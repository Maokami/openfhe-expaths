<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijn@haverbeke.berlin> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report.events;
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report.events;
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setChecker(report.checker);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.fileId]);
    this.drawBugPath();

    this.jumpTo(event.line, 0);
    this.highlightBugEvent(idx);
  },

  highlightBugEvent : function (idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setChecker : function (checker) {
    var content = checker.name;
    if (checker.url) {
      content = '<a href="' + checker.url + '" target="_blank">' +
        checker.name + '</a>';
    }

    this._checkerName.innerHTML = content;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.filePath;
    let e = document.createElement('div');
    e.innerHTML = file.content;
    this._codeMirror.doc.setValue(e.innerText);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.fileId !== that._currentBugEvent.fileId) {
        return;
      }

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.fileId !== that._currentBugEvent.fileId)
        return;

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Control for encryption operations\n */\n\n#include &quot;cryptocontext.h&quot;\n\n#include &quot;key/privatekey.h&quot;\n#include &quot;key/publickey.h&quot;\n#include &quot;math/chebyshev.h&quot;\n#include &quot;schemerns/rns-scheme.h&quot;\n#include &quot;scheme/ckksrns/ckksrns-cryptoparameters.h&quot;\n\nnamespace lbcrypto {\n\ntemplate &lt;typename Element&gt;\nstd::map&lt;std::string, std::vector&lt;EvalKey&lt;Element&gt;&gt;&gt;&amp; CryptoContextImpl&lt;Element&gt;::evalMultKeyMap() {\n    return s_evalMultKeyMap;\n}\ntemplate &lt;typename Element&gt;\nstd::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt;&amp; CryptoContextImpl&lt;Element&gt;::evalSumKeyMap() {\n    return s_evalSumKeyMap;\n}\ntemplate &lt;typename Element&gt;\nstd::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt;&amp;\nCryptoContextImpl&lt;Element&gt;::evalAutomorphismKeyMap() {\n    return s_evalAutomorphismKeyMap;\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::SetKSTechniqueInScheme() {\n    // check if the scheme is an RNS scheme\n    auto schemeRNSPtr = dynamic_cast&lt;SchemeRNS*&gt;(&amp;(*scheme));\n    if (schemeRNSPtr != nullptr) {\n        // check if the parameter object is RNS-based\n        auto elPtr = dynamic_cast&lt;const CryptoParametersRNS*&gt;(&amp;(*params));\n        if (elPtr != nullptr) {\n            schemeRNSPtr-&gt;SetKeySwitchingTechnique(elPtr-&gt;GetKeySwitchTechnique());\n            return;\n        }\n        &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Cannot set KeySwitchingTechnique as the parameter object is not RNS-based&quot;);\n    }\n}\n\n/////////////////////////////////////////\n// SHE MULTIPLICATION\n/////////////////////////////////////////\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::InsertEvalMultKey(const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; vectorToInsert) {\n    GetAllEvalMultKeys()[vectorToInsert[0]-&gt;GetKeyTag()] = vectorToInsert;\n}\n\n/////////////////////////////////////////\n// ADVANCED SHE\n/////////////////////////////////////////\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::EvalSumKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                               const PublicKey&lt;Element&gt; publicKey) {\n    if (privateKey == nullptr || Mismatched(privateKey-&gt;GetCryptoContext())) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Private key passed to EvalSumKeyGen were not generated &quot;\n                      &quot;with this crypto context&quot;);\n    }\n\n    if (publicKey != nullptr &amp;&amp; privateKey-&gt;GetKeyTag() != publicKey-&gt;GetKeyTag()) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Public key passed to EvalSumKeyGen does not match private key&quot;);\n    }\n\n    auto evalKeys = GetScheme()-&gt;EvalSumKeyGen(privateKey, publicKey);\n\n    GetAllEvalSumKeys()[privateKey-&gt;GetKeyTag()] = evalKeys;\n}\n\ntemplate &lt;typename Element&gt;\nstd::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; CryptoContextImpl&lt;Element&gt;::EvalSumRowsKeyGen(\n    const PrivateKey&lt;Element&gt; privateKey, const PublicKey&lt;Element&gt; publicKey, usint rowSize, usint subringDim) {\n    if (privateKey == nullptr || Mismatched(privateKey-&gt;GetCryptoContext())) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Private key passed to EvalSumKeyGen were not generated &quot;\n                      &quot;with this crypto context&quot;);\n    }\n\n    if (publicKey != nullptr &amp;&amp; privateKey-&gt;GetKeyTag() != publicKey-&gt;GetKeyTag()) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Public key passed to EvalSumKeyGen does not match private key&quot;);\n    }\n\n    auto evalKeys = GetScheme()-&gt;EvalSumRowsKeyGen(privateKey, publicKey, rowSize, subringDim);\n\n    return evalKeys;\n}\n\ntemplate &lt;typename Element&gt;\nstd::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; CryptoContextImpl&lt;Element&gt;::EvalSumColsKeyGen(\n    const PrivateKey&lt;Element&gt; privateKey, const PublicKey&lt;Element&gt; publicKey) {\n    if (privateKey == nullptr || Mismatched(privateKey-&gt;GetCryptoContext())) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Private key passed to EvalSumKeyGen were not generated &quot;\n                      &quot;with this crypto context&quot;);\n    }\n\n    if (publicKey != nullptr &amp;&amp; privateKey-&gt;GetKeyTag() != publicKey-&gt;GetKeyTag()) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Public key passed to EvalSumKeyGen does not match private key&quot;);\n    }\n\n    auto evalKeys = GetScheme()-&gt;EvalSumColsKeyGen(privateKey, publicKey);\n\n    return evalKeys;\n}\n\ntemplate &lt;typename Element&gt;\nconst std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; CryptoContextImpl&lt;Element&gt;::GetEvalSumKeyMap(const std::string&amp; keyID) {\n    auto ekv = GetAllEvalSumKeys().find(keyID);\n    if (ekv == GetAllEvalSumKeys().end())\n        &quot;hey&quot;; OPENFHE_THROW(not_available_error,\n                      &quot;You need to use EvalSumKeyGen so that you have EvalSumKeys &quot;\n                      &quot;available for this ID&quot;);\n    return *ekv-&gt;second;\n}\n\ntemplate &lt;typename Element&gt;\nstd::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt;&amp;\nCryptoContextImpl&lt;Element&gt;::GetAllEvalSumKeys() {\n    return evalSumKeyMap();\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::ClearEvalSumKeys() {\n    GetAllEvalSumKeys().clear();\n}\n\n/**\n * ClearEvalMultKeys - flush EvalMultKey cache for a given id\n * @param id\n */\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::ClearEvalSumKeys(const std::string&amp; id) {\n    auto kd = GetAllEvalSumKeys().find(id);\n    if (kd != GetAllEvalSumKeys().end())\n        GetAllEvalSumKeys().erase(kd);\n}\n\n/**\n * ClearEvalMultKeys - flush EvalMultKey cache for a given context\n * @param cc\n */\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::ClearEvalSumKeys(const CryptoContext&lt;Element&gt; cc) {\n    for (auto it = GetAllEvalSumKeys().begin(); it != GetAllEvalSumKeys().end();) {\n        if (it-&gt;second-&gt;begin()-&gt;second-&gt;GetCryptoContext() == cc) {\n            it = GetAllEvalSumKeys().erase(it);\n        }\n        else {\n            ++it;\n        }\n    }\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::InsertEvalSumKey(\n    const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; mapToInsert) {\n    // find the tag\n    if (!mapToInsert-&gt;empty()) {\n        auto onekey                                      = mapToInsert-&gt;begin();\n        GetAllEvalSumKeys()[onekey-&gt;second-&gt;GetKeyTag()] = mapToInsert;\n    }\n}\n\n/////////////////////////////////////////\n// SHE AUTOMORPHISM\n/////////////////////////////////////////\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::EvalAtIndexKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                                   const std::vector&lt;int32_t&gt;&amp; indexList,\n                                                   const PublicKey&lt;Element&gt; publicKey) {\n    if (privateKey == nullptr || Mismatched(privateKey-&gt;GetCryptoContext())) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Private key passed to EvalAtIndexKeyGen were not generated &quot;\n                      &quot;with this crypto context&quot;);\n    }\n\n    if (publicKey != nullptr &amp;&amp; privateKey-&gt;GetKeyTag() != publicKey-&gt;GetKeyTag()) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Public key passed to EvalAtIndexKeyGen does not match private key&quot;);\n    }\n\n    auto evalKeys = GetScheme()-&gt;EvalAtIndexKeyGen(publicKey, privateKey, indexList);\n\n    auto ekv = GetAllEvalAutomorphismKeys().find(privateKey-&gt;GetKeyTag());\n    if (ekv == GetAllEvalAutomorphismKeys().end()) {\n        GetAllEvalAutomorphismKeys()[privateKey-&gt;GetKeyTag()] = evalKeys;\n    }\n    else {\n        auto&amp; currRotMap = GetEvalAutomorphismKeyMap(privateKey-&gt;GetKeyTag());\n        auto iterRowKeys = evalKeys-&gt;begin();\n        while (iterRowKeys != evalKeys-&gt;end()) {\n            auto idx = iterRowKeys-&gt;first;\n            // Search current rotation key map and add key\n            // only if it doesn&#x27;t exist\n            if (currRotMap.find(idx) == currRotMap.end()) {\n                currRotMap.insert(*iterRowKeys);\n            }\n            iterRowKeys++;\n        }\n    }\n\n    //  evalAutomorphismKeyMap()[privateKey-&gt;GetKeyTag()] = evalKeys;\n}\n\ntemplate &lt;typename Element&gt;\nstd::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; CryptoContextImpl&lt;Element&gt;::GetEvalAutomorphismKeyMap(const std::string&amp; keyID) {\n    auto ekv = evalAutomorphismKeyMap().find(keyID);\n    if (ekv == evalAutomorphismKeyMap().end())\n        &quot;hey&quot;; OPENFHE_THROW(not_available_error,\n                      &quot;You need to use EvalAutomorphismKeyGen so that you have &quot;\n                      &quot;EvalAutomorphismKeys available for this ID&quot;);\n    return *ekv-&gt;second;\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::ClearEvalAutomorphismKeys() {\n    evalAutomorphismKeyMap().clear();\n}\n\n/**\n * ClearEvalAutomorphismKeys - flush EvalAutomorphismKey cache for a given id\n * @param id\n */\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::ClearEvalAutomorphismKeys(const std::string&amp; id) {\n    auto kd = evalAutomorphismKeyMap().find(id);\n    if (kd != evalAutomorphismKeyMap().end())\n        evalAutomorphismKeyMap().erase(kd);\n}\n\n/**\n * ClearEvalAutomorphismKeys - flush EvalAutomorphismKey cache for a given\n * context\n * @param cc\n */\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::ClearEvalAutomorphismKeys(const CryptoContext&lt;Element&gt; cc) {\n    for (auto it = evalAutomorphismKeyMap().begin(); it != evalAutomorphismKeyMap().end();) {\n        if (it-&gt;second-&gt;begin()-&gt;second-&gt;GetCryptoContext() == cc) {\n            it = evalAutomorphismKeyMap().erase(it);\n        }\n        else {\n            ++it;\n        }\n    }\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::InsertEvalAutomorphismKey(\n    const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; mapToInsert) {\n    // find the tag\n    auto onekey                                           = mapToInsert-&gt;begin();\n    evalAutomorphismKeyMap()[onekey-&gt;second-&gt;GetKeyTag()] = mapToInsert;\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalSum(ConstCiphertext&lt;Element&gt; ciphertext, usint batchSize) const {\n    if (ciphertext == nullptr || Mismatched(ciphertext-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Information passed to EvalSum was not generated with this &quot;\n                      &quot;crypto context&quot;);\n\n    auto evalSumKeys = CryptoContextImpl&lt;Element&gt;::GetEvalSumKeyMap(ciphertext-&gt;GetKeyTag());\n    auto rv          = GetScheme()-&gt;EvalSum(ciphertext, batchSize, evalSumKeys);\n    return rv;\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalSumRows(ConstCiphertext&lt;Element&gt; ciphertext, usint rowSize,\n                                                            const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalSumKeys,\n                                                            usint subringDim) const {\n    if (ciphertext == nullptr || Mismatched(ciphertext-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Information passed to EvalSum was not generated with this &quot;\n                      &quot;crypto context&quot;);\n\n    auto rv = GetScheme()-&gt;EvalSumRows(ciphertext, rowSize, evalSumKeys, subringDim);\n    return rv;\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalSumCols(\n    ConstCiphertext&lt;Element&gt; ciphertext, usint rowSize,\n    const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalSumKeysRight) const {\n    if (ciphertext == nullptr || Mismatched(ciphertext-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Information passed to EvalSum was not generated with this &quot;\n                      &quot;crypto context&quot;);\n\n    auto evalSumKeys = CryptoContextImpl&lt;Element&gt;::GetEvalSumKeyMap(ciphertext-&gt;GetKeyTag());\n\n    auto rv = GetScheme()-&gt;EvalSumCols(ciphertext, rowSize, evalSumKeys, evalSumKeysRight);\n    return rv;\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalAtIndex(ConstCiphertext&lt;Element&gt; ciphertext, int32_t index) const {\n    if (ciphertext == nullptr || Mismatched(ciphertext-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Information passed to EvalAtIndex was not generated with &quot;\n                      &quot;this crypto context&quot;);\n\n    // If the index is zero, no rotation is needed, copy the ciphertext and return\n    // This is done after the keyMap so that it is protected if there&#x27;s not a\n    // valid key.\n    if (0 == index) {\n        auto rv = ciphertext-&gt;Clone();\n        return rv;\n    }\n\n    auto evalAutomorphismKeys = CryptoContextImpl&lt;Element&gt;::GetEvalAutomorphismKeyMap(ciphertext-&gt;GetKeyTag());\n\n    auto rv = GetScheme()-&gt;EvalAtIndex(ciphertext, index, evalAutomorphismKeys);\n    return rv;\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalMerge(\n    const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVector) const {\n    if (ciphertextVector[0] == nullptr || Mismatched(ciphertextVector[0]-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Information passed to EvalMerge was not generated with &quot;\n                      &quot;this crypto context&quot;);\n\n    auto evalAutomorphismKeys = CryptoContextImpl&lt;Element&gt;::GetEvalAutomorphismKeyMap(ciphertextVector[0]-&gt;GetKeyTag());\n\n    auto rv = GetScheme()-&gt;EvalMerge(ciphertextVector, evalAutomorphismKeys);\n\n    return rv;\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalInnerProduct(ConstCiphertext&lt;Element&gt; ct1,\n                                                                 ConstCiphertext&lt;Element&gt; ct2, usint batchSize) const {\n    if (ct1 == nullptr || ct2 == nullptr || ct1-&gt;GetKeyTag() != ct2-&gt;GetKeyTag() || Mismatched(ct1-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Information passed to EvalInnerProduct was not generated &quot;\n                      &quot;with this crypto context&quot;);\n\n    auto evalSumKeys = CryptoContextImpl&lt;Element&gt;::GetEvalSumKeyMap(ct1-&gt;GetKeyTag());\n    auto ek          = GetEvalMultKeyVector(ct1-&gt;GetKeyTag());\n\n    auto rv = GetScheme()-&gt;EvalInnerProduct(ct1, ct2, batchSize, evalSumKeys, ek[0]);\n    return rv;\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalInnerProduct(ConstCiphertext&lt;Element&gt; ct1, ConstPlaintext ct2,\n                                                                 usint batchSize) const {\n    if (ct1 == nullptr || ct2 == nullptr || Mismatched(ct1-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Information passed to EvalInnerProduct was not generated &quot;\n                      &quot;with this crypto context&quot;);\n\n    auto evalSumKeys = CryptoContextImpl&lt;Element&gt;::GetEvalSumKeyMap(ct1-&gt;GetKeyTag());\n\n    auto rv = GetScheme()-&gt;EvalInnerProduct(ct1, ct2, batchSize, evalSumKeys);\n    return rv;\n}\n\ntemplate &lt;typename Element&gt;\nPlaintext CryptoContextImpl&lt;Element&gt;::GetPlaintextForDecrypt(PlaintextEncodings pte, std::shared_ptr&lt;ParmType&gt; evp,\n                                                             EncodingParams ep) {\n    auto vp = std::make_shared&lt;typename NativePoly::Params&gt;(evp-&gt;GetCyclotomicOrder(), ep-&gt;GetPlaintextModulus(), 1);\n\n    if (pte == CKKS_PACKED_ENCODING)\n        return PlaintextFactory::MakePlaintext(pte, evp, ep);\n\n    return PlaintextFactory::MakePlaintext(pte, vp, ep);\n}\n\ntemplate &lt;typename Element&gt;\nDecryptResult CryptoContextImpl&lt;Element&gt;::Decrypt(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                  const PrivateKey&lt;Element&gt; privateKey, Plaintext* plaintext) {\n    if (ciphertext == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ciphertext passed to Decrypt is empty&quot;);\n    if (plaintext == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;plaintext passed to Decrypt is empty&quot;);\n    if (privateKey == nullptr || Mismatched(privateKey-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Information passed to Decrypt was not generated with &quot;\n                      &quot;this crypto context&quot;);\n\n    // determine which type of plaintext that you need to decrypt into\n    // Plaintext decrypted =\n    // GetPlaintextForDecrypt(ciphertext-&gt;GetEncodingType(),\n    // this-&gt;GetElementParams(), this-&gt;GetEncodingParams());\n    Plaintext decrypted = GetPlaintextForDecrypt(ciphertext-&gt;GetEncodingType(),\n                                                 ciphertext-&gt;GetElements()[0].GetParams(), this-&gt;GetEncodingParams());\n\n    DecryptResult result;\n\n    if ((ciphertext-&gt;GetEncodingType() == CKKS_PACKED_ENCODING) &amp;&amp; (typeid(Element) != typeid(NativePoly))) {\n        result = GetScheme()-&gt;Decrypt(ciphertext, privateKey, &amp;decrypted-&gt;GetElement&lt;Poly&gt;());\n    }\n    else {\n        result = GetScheme()-&gt;Decrypt(ciphertext, privateKey, &amp;decrypted-&gt;GetElement&lt;NativePoly&gt;());\n    }\n\n    if (result.isValid == false)  // TODO (dsuponit): why don&#x27;t we throw an exception here?\n        return result;\n\n    decrypted-&gt;SetScalingFactorInt(result.scalingFactorInt);\n\n    if (ciphertext-&gt;GetEncodingType() == CKKS_PACKED_ENCODING) {\n        auto decryptedCKKS = std::dynamic_pointer_cast&lt;CKKSPackedEncoding&gt;(decrypted);\n        decryptedCKKS-&gt;SetNoiseScaleDeg(ciphertext-&gt;GetNoiseScaleDeg());\n        decryptedCKKS-&gt;SetLevel(ciphertext-&gt;GetLevel());\n        decryptedCKKS-&gt;SetScalingFactor(ciphertext-&gt;GetScalingFactor());\n        decryptedCKKS-&gt;SetSlots(ciphertext-&gt;GetSlots());\n\n        const auto cryptoParamsCKKS = std::dynamic_pointer_cast&lt;CryptoParametersRNS&gt;(this-&gt;GetCryptoParameters());\n\n        decryptedCKKS-&gt;Decode(ciphertext-&gt;GetNoiseScaleDeg(), ciphertext-&gt;GetScalingFactor(),\n                              cryptoParamsCKKS-&gt;GetScalingTechnique(), cryptoParamsCKKS-&gt;GetExecutionMode());\n    }\n    else {\n        decrypted-&gt;Decode();\n    }\n\n    *plaintext = std::move(decrypted);\n    return result;\n}\n\n//------------------------------------------------------------------------------\n// Advanced SHE CHEBYSHEV SERIES EXAMPLES\n//------------------------------------------------------------------------------\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalChebyshevFunction(std::function&lt;double(double)&gt; func,\n                                                                      ConstCiphertext&lt;Element&gt; ciphertext, double a,\n                                                                      double b, uint32_t degree) const {\n    std::vector&lt;double&gt; coefficients = EvalChebyshevCoefficients(func, a, b, degree);\n    return EvalChebyshevSeries(ciphertext, coefficients, a, b);\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalSin(ConstCiphertext&lt;Element&gt; ciphertext, double a, double b,\n                                                        uint32_t degree) const {\n    return EvalChebyshevFunction([](double x) -&gt; double { return std::sin(x); }, ciphertext, a, b, degree);\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalCos(ConstCiphertext&lt;Element&gt; ciphertext, double a, double b,\n                                                        uint32_t degree) const {\n    return EvalChebyshevFunction([](double x) -&gt; double { return std::cos(x); }, ciphertext, a, b, degree);\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalLogistic(ConstCiphertext&lt;Element&gt; ciphertext, double a, double b,\n                                                             uint32_t degree) const {\n    return EvalChebyshevFunction([](double x) -&gt; double { return 1 / (1 + std::exp(-x)); }, ciphertext, a, b, degree);\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalDivide(ConstCiphertext&lt;Element&gt; ciphertext, double a, double b,\n                                                           uint32_t degree) const {\n    return EvalChebyshevFunction([](double x) -&gt; double { return 1 / x; }, ciphertext, a, b, degree);\n}\n\n//------------------------------------------------------------------------------\n// SCHEMESWITCHING Methods\n//------------------------------------------------------------------------------\n\ntemplate &lt;typename Element&gt;\nstd::pair&lt;BinFHEContext, LWEPrivateKey&gt; CryptoContextImpl&lt;Element&gt;::EvalCKKStoFHEWSetup(\n    SecurityLevel sl, BINFHE_PARAMSET slBin, bool arbFunc, uint32_t logQ, bool dynamic, uint32_t numSlotsCKKS,\n    uint32_t logQswitch) {\n    return GetScheme()-&gt;EvalCKKStoFHEWSetup(*this, sl, slBin, arbFunc, logQ, dynamic, numSlotsCKKS, logQswitch);\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::EvalCKKStoFHEWKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk,\n                                                      uint32_t dim1, uint32_t L) {\n    if (keyPair.secretKey == nullptr || this-&gt;Mismatched(keyPair.secretKey-&gt;GetCryptoContext())) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;CKKS private key passed to EvalCKKStoFHEWKeyGen was not generated with this crypto context&quot;);\n    }\n    if (!lwesk) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;FHEW private key passed to EvalCKKStoFHEWKeyGen is null&quot;);\n    }\n    auto evalKeys = GetScheme()-&gt;EvalCKKStoFHEWKeyGen(keyPair, lwesk, dim1, L);\n\n    auto ekv = GetAllEvalAutomorphismKeys().find(keyPair.secretKey-&gt;GetKeyTag());\n    if (ekv == GetAllEvalAutomorphismKeys().end()) {\n        GetAllEvalAutomorphismKeys()[keyPair.secretKey-&gt;GetKeyTag()] = evalKeys;\n    }\n    else {\n        auto&amp; currRotMap = GetEvalAutomorphismKeyMap(keyPair.secretKey-&gt;GetKeyTag());\n        auto iterRowKeys = evalKeys-&gt;begin();\n        while (iterRowKeys != evalKeys-&gt;end()) {\n            auto idx = iterRowKeys-&gt;first;\n            // Search current rotation key map and add key\n            // only if it doesn&#x27;t exist\n            if (currRotMap.find(idx) == currRotMap.end()) {\n                currRotMap.insert(*iterRowKeys);\n            }\n            iterRowKeys++;\n        }\n    }\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::EvalCKKStoFHEWPrecompute(double scale) {\n    GetScheme()-&gt;EvalCKKStoFHEWPrecompute(*this, scale);\n}\n\ntemplate &lt;typename Element&gt;\nstd::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt; CryptoContextImpl&lt;Element&gt;::EvalCKKStoFHEW(\n    ConstCiphertext&lt;Element&gt; ciphertext, uint32_t numCtxts) {\n    if (ciphertext == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ciphertext passed to EvalCKKStoFHEW is empty&quot;);\n    return GetScheme()-&gt;EvalCKKStoFHEW(ciphertext, numCtxts);\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::EvalFHEWtoCKKSSetup(const BinFHEContext&amp; ccLWE, uint32_t numSlotsCKKS, uint32_t logQ) {\n    GetScheme()-&gt;EvalFHEWtoCKKSSetup(*this, ccLWE, numSlotsCKKS, logQ);\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::EvalFHEWtoCKKSKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk,\n                                                      uint32_t numSlots, uint32_t dim1, uint32_t L) {\n    if (keyPair.secretKey == nullptr || this-&gt;Mismatched(keyPair.secretKey-&gt;GetCryptoContext())) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Private key passed to EvalFHEWtoCKKSKeyGen was not generated with this crypto context&quot;);\n    }\n    auto evalKeys = GetScheme()-&gt;EvalFHEWtoCKKSKeyGen(keyPair, lwesk, numSlots, dim1, L);\n\n    auto ekv = GetAllEvalAutomorphismKeys().find(keyPair.secretKey-&gt;GetKeyTag());\n    if (ekv == GetAllEvalAutomorphismKeys().end()) {\n        GetAllEvalAutomorphismKeys()[keyPair.secretKey-&gt;GetKeyTag()] = evalKeys;\n    }\n    else {\n        auto&amp; currRotMap = GetEvalAutomorphismKeyMap(keyPair.secretKey-&gt;GetKeyTag());\n        auto iterRowKeys = evalKeys-&gt;begin();\n        while (iterRowKeys != evalKeys-&gt;end()) {\n            auto idx = iterRowKeys-&gt;first;\n            // Search current rotation key map and add key\n            // only if it doesn&#x27;t exist\n            if (currRotMap.find(idx) == currRotMap.end()) {\n                currRotMap.insert(*iterRowKeys);\n            }\n            iterRowKeys++;\n        }\n    }\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalFHEWtoCKKS(\n    std::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt;&amp; LWECiphertexts, uint32_t numCtxts, uint32_t numSlots, uint32_t p,\n    double pmin, double pmax) const {\n    return GetScheme()-&gt;EvalFHEWtoCKKS(LWECiphertexts, numCtxts, numSlots, p, pmin, pmax);\n}\n\ntemplate &lt;typename Element&gt;\nstd::pair&lt;BinFHEContext, LWEPrivateKey&gt; CryptoContextImpl&lt;Element&gt;::EvalSchemeSwitchingSetup(\n    SecurityLevel sl, BINFHE_PARAMSET slBin, bool arbFunc, uint32_t logQ, bool dynamic, uint32_t numSlotsCKKS,\n    uint32_t logQswitch) {\n    return GetScheme()-&gt;EvalSchemeSwitchingSetup(*this, sl, slBin, arbFunc, logQ, dynamic, numSlotsCKKS, logQswitch);\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::EvalSchemeSwitchingKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk,\n                                                           uint32_t numValues, bool oneHot, bool alt, uint32_t dim1CF,\n                                                           uint32_t dim1FC, uint32_t LCF, uint32_t LFC) {\n    if (keyPair.secretKey == nullptr || this-&gt;Mismatched(keyPair.secretKey-&gt;GetCryptoContext())) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Private key passed to EvalSchemeSwitchingKeyGen was not generated with this crypto context&quot;);\n    }\n    auto evalKeys =\n        GetScheme()-&gt;EvalSchemeSwitchingKeyGen(keyPair, lwesk, numValues, oneHot, alt, dim1CF, dim1FC, LCF, LFC);\n\n    auto ekv = GetAllEvalAutomorphismKeys().find(keyPair.secretKey-&gt;GetKeyTag());\n    if (ekv == GetAllEvalAutomorphismKeys().end()) {\n        GetAllEvalAutomorphismKeys()[keyPair.secretKey-&gt;GetKeyTag()] = evalKeys;\n    }\n    else {\n        auto&amp; currRotMap = GetEvalAutomorphismKeyMap(keyPair.secretKey-&gt;GetKeyTag());\n        auto iterRowKeys = evalKeys-&gt;begin();\n        while (iterRowKeys != evalKeys-&gt;end()) {\n            auto idx = iterRowKeys-&gt;first;\n            // Search current rotation key map and add key\n            // only if it doesn&#x27;t exist\n            if (currRotMap.find(idx) == currRotMap.end()) {\n                currRotMap.insert(*iterRowKeys);\n            }\n            iterRowKeys++;\n        }\n    }\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::EvalCompareSwitchPrecompute(uint32_t pLWE, uint32_t initLevel, double scaleSign,\n                                                             bool unit) {\n    GetScheme()-&gt;EvalCompareSwitchPrecompute(*this, pLWE, initLevel, scaleSign, unit);\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalCompareSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                                           ConstCiphertext&lt;Element&gt; ciphertext2,\n                                                                           uint32_t numCtxts, uint32_t numSlots,\n                                                                           uint32_t pLWE, double scaleSign, bool unit) {\n    if (ciphertext1 == nullptr || ciphertext2 == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ciphertexts passed to EvalCompareSchemeSwitching are empty&quot;);\n    if (Mismatched(ciphertext1-&gt;GetCryptoContext()) || Mismatched(ciphertext2-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;A ciphertext passed to EvalCompareSchemeSwitching was not &quot;\n                      &quot;generated with this crypto context&quot;);\n    return GetScheme()-&gt;EvalCompareSchemeSwitching(ciphertext1, ciphertext2, numCtxts, numSlots, pLWE, scaleSign, unit);\n}\n\ntemplate &lt;typename Element&gt;\nstd::vector&lt;Ciphertext&lt;Element&gt;&gt; CryptoContextImpl&lt;Element&gt;::EvalMinSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                                    PublicKey&lt;Element&gt; publicKey,\n                                                                                    uint32_t numValues,\n                                                                                    uint32_t numSlots, bool oneHot,\n                                                                                    uint32_t pLWE, double scaleSign) {\n    if (!ciphertext)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ciphertexts passed to EvalMinSchemeSwitching are empty&quot;);\n    if (Mismatched(ciphertext-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;The ciphertext passed to EvalMinSchemeSwitching was not &quot;\n                      &quot;generated with this crypto context&quot;);\n    return GetScheme()-&gt;EvalMinSchemeSwitching(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE, scaleSign);\n}\n\ntemplate &lt;typename Element&gt;\nstd::vector&lt;Ciphertext&lt;Element&gt;&gt; CryptoContextImpl&lt;Element&gt;::EvalMinSchemeSwitchingAlt(\n    ConstCiphertext&lt;Element&gt; ciphertext, PublicKey&lt;Element&gt; publicKey, uint32_t numValues, uint32_t numSlots,\n    bool oneHot, uint32_t pLWE, double scaleSign) {\n    if (ciphertext == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ciphertexts passed to EvalMinSchemeSwitching are empty&quot;);\n    if (Mismatched(ciphertext-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;The ciphertext passed to EvalMinSchemeSwitchingAlt was not &quot;\n                      &quot;generated with this crypto context&quot;);\n    return GetScheme()-&gt;EvalMinSchemeSwitchingAlt(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE, scaleSign);\n}\n\ntemplate &lt;typename Element&gt;\nstd::vector&lt;Ciphertext&lt;Element&gt;&gt; CryptoContextImpl&lt;Element&gt;::EvalMaxSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                                    PublicKey&lt;Element&gt; publicKey,\n                                                                                    uint32_t numValues,\n                                                                                    uint32_t numSlots, bool oneHot,\n                                                                                    uint32_t pLWE, double scaleSign) {\n    if (ciphertext == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ciphertexts passed to EvalMaxSchemeSwitching are empty&quot;);\n    if (Mismatched(ciphertext-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;The ciphertext passed to EvalMinSchemeSwitching was not &quot;\n                      &quot;generated with this crypto context&quot;);\n    return GetScheme()-&gt;EvalMaxSchemeSwitching(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE, scaleSign);\n}\n\ntemplate &lt;typename Element&gt;\nstd::vector&lt;Ciphertext&lt;Element&gt;&gt; CryptoContextImpl&lt;Element&gt;::EvalMaxSchemeSwitchingAlt(\n    ConstCiphertext&lt;Element&gt; ciphertext, PublicKey&lt;Element&gt; publicKey, uint32_t numValues, uint32_t numSlots,\n    bool oneHot, uint32_t pLWE, double scaleSign) {\n    if (ciphertext == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ciphertexts passed to EvalMaxSchemeSwitching are empty&quot;);\n    if (Mismatched(ciphertext-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;The ciphertext passed to EvalMinSchemeSwitchingAlt was not &quot;\n                      &quot;generated with this crypto context&quot;);\n    return GetScheme()-&gt;EvalMaxSchemeSwitchingAlt(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE, scaleSign);\n}\n\n}  // namespace lbcrypto\n\n// the code below is from cryptocontext-impl.cpp\nnamespace lbcrypto {\n\ntemplate &lt;&gt;\nPlaintext CryptoContextImpl&lt;DCRTPoly&gt;::GetPlaintextForDecrypt(PlaintextEncodings pte, std::shared_ptr&lt;ParmType&gt; evp,\n                                                              EncodingParams ep) {\n    if ((pte == CKKS_PACKED_ENCODING) &amp;&amp; (evp-&gt;GetParams().size() &gt; 1)) {\n        auto vp = std::make_shared&lt;typename Poly::Params&gt;(evp-&gt;GetCyclotomicOrder(), ep-&gt;GetPlaintextModulus(), 1);\n        return PlaintextFactory::MakePlaintext(pte, vp, ep);\n    }\n    else {\n        auto vp =\n            std::make_shared&lt;typename NativePoly::Params&gt;(evp-&gt;GetCyclotomicOrder(), ep-&gt;GetPlaintextModulus(), 1);\n        return PlaintextFactory::MakePlaintext(pte, vp, ep);\n    }\n}\n\ntemplate &lt;&gt;\nDecryptResult CryptoContextImpl&lt;DCRTPoly&gt;::Decrypt(ConstCiphertext&lt;DCRTPoly&gt; ciphertext,\n                                                   const PrivateKey&lt;DCRTPoly&gt; privateKey, Plaintext* plaintext) {\n    if (ciphertext == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ciphertext passed to Decrypt is empty&quot;);\n    if (plaintext == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;plaintext passed to Decrypt is empty&quot;);\n    if (privateKey == nullptr || Mismatched(privateKey-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Information passed to Decrypt was not generated with &quot;\n                      &quot;this crypto context&quot;);\n\n    // determine which type of plaintext that you need to decrypt into\n    // Plaintext decrypted =\n    // GetPlaintextForDecrypt(ciphertext-&gt;GetEncodingType(),\n    // this-&gt;GetElementParams(), this-&gt;GetEncodingParams());\n    Plaintext decrypted = GetPlaintextForDecrypt(ciphertext-&gt;GetEncodingType(),\n                                                 ciphertext-&gt;GetElements()[0].GetParams(), this-&gt;GetEncodingParams());\n\n    DecryptResult result;\n\n    if ((ciphertext-&gt;GetEncodingType() == CKKS_PACKED_ENCODING) &amp;&amp;\n        (ciphertext-&gt;GetElements()[0].GetParams()-&gt;GetParams().size() &gt; 1))  // more than one tower in DCRTPoly\n        result = GetScheme()-&gt;Decrypt(ciphertext, privateKey, &amp;decrypted-&gt;GetElement&lt;Poly&gt;());\n    else\n        result = GetScheme()-&gt;Decrypt(ciphertext, privateKey, &amp;decrypted-&gt;GetElement&lt;NativePoly&gt;());\n\n    if (result.isValid == false)\n        return result;\n\n    decrypted-&gt;SetScalingFactorInt(result.scalingFactorInt);\n\n    if (ciphertext-&gt;GetEncodingType() == CKKS_PACKED_ENCODING) {\n        auto decryptedCKKS = std::dynamic_pointer_cast&lt;CKKSPackedEncoding&gt;(decrypted);\n        decryptedCKKS-&gt;SetNoiseScaleDeg(ciphertext-&gt;GetNoiseScaleDeg());\n        decryptedCKKS-&gt;SetLevel(ciphertext-&gt;GetLevel());\n        decryptedCKKS-&gt;SetScalingFactor(ciphertext-&gt;GetScalingFactor());\n        decryptedCKKS-&gt;SetSlots(ciphertext-&gt;GetSlots());\n\n        const auto cryptoParamsCKKS = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(this-&gt;GetCryptoParameters());\n\n        decryptedCKKS-&gt;Decode(ciphertext-&gt;GetNoiseScaleDeg(), ciphertext-&gt;GetScalingFactor(),\n                              cryptoParamsCKKS-&gt;GetScalingTechnique(), cryptoParamsCKKS-&gt;GetExecutionMode());\n    }\n    else {\n        decrypted-&gt;Decode();\n    }\n\n    *plaintext = std::move(decrypted);\n    return result;\n}\n\ntemplate &lt;&gt;\nDecryptResult CryptoContextImpl&lt;DCRTPoly&gt;::MultipartyDecryptFusion(\n    const std::vector&lt;Ciphertext&lt;DCRTPoly&gt;&gt;&amp; partialCiphertextVec, Plaintext* plaintext) const {\n    DecryptResult result;\n\n    // Make sure we&#x27;re processing ciphertexts.\n    size_t last_ciphertext = partialCiphertextVec.size();\n    if (last_ciphertext &lt; 1)\n        return result;\n\n    for (size_t i = 0; i &lt; last_ciphertext; i++) {\n        if (partialCiphertextVec[i] == nullptr || Mismatched(partialCiphertextVec[i]-&gt;GetCryptoContext()))\n            &quot;hey&quot;; OPENFHE_THROW(config_error,\n                          &quot;A ciphertext passed to MultipartyDecryptFusion was not &quot;\n                          &quot;generated with this crypto context&quot;);\n        if (partialCiphertextVec[i]-&gt;GetEncodingType() != partialCiphertextVec[0]-&gt;GetEncodingType())\n            &quot;hey&quot;; OPENFHE_THROW(type_error,\n                          &quot;Ciphertexts passed to MultipartyDecryptFusion have &quot;\n                          &quot;mismatched encoding types&quot;);\n    }\n\n    // determine which type of plaintext that you need to decrypt into\n    Plaintext decrypted =\n        GetPlaintextForDecrypt(partialCiphertextVec[0]-&gt;GetEncodingType(),\n                               partialCiphertextVec[0]-&gt;GetElements()[0].GetParams(), this-&gt;GetEncodingParams());\n\n    if ((partialCiphertextVec[0]-&gt;GetEncodingType() == CKKS_PACKED_ENCODING) &amp;&amp;\n        (partialCiphertextVec[0]-&gt;GetElements()[0].GetParams()-&gt;GetParams().size() &gt; 1))\n        result = GetScheme()-&gt;MultipartyDecryptFusion(partialCiphertextVec, &amp;decrypted-&gt;GetElement&lt;Poly&gt;());\n    else\n        result = GetScheme()-&gt;MultipartyDecryptFusion(partialCiphertextVec, &amp;decrypted-&gt;GetElement&lt;NativePoly&gt;());\n\n    if (result.isValid == false)\n        return result;\n\n    decrypted-&gt;SetScalingFactorInt(result.scalingFactorInt);\n\n    if (partialCiphertextVec[0]-&gt;GetEncodingType() == CKKS_PACKED_ENCODING) {\n        auto decryptedCKKS = std::dynamic_pointer_cast&lt;CKKSPackedEncoding&gt;(decrypted);\n        decryptedCKKS-&gt;SetSlots(partialCiphertextVec[0]-&gt;GetSlots());\n        const auto cryptoParamsCKKS = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(this-&gt;GetCryptoParameters());\n        decryptedCKKS-&gt;Decode(partialCiphertextVec[0]-&gt;GetNoiseScaleDeg(), partialCiphertextVec[0]-&gt;GetScalingFactor(),\n                              cryptoParamsCKKS-&gt;GetScalingTechnique(), cryptoParamsCKKS-&gt;GetExecutionMode());\n    }\n    else {\n        decrypted-&gt;Decode();\n    }\n\n    *plaintext = std::move(decrypted);\n\n    return result;\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::IntMPBootAdjustScale(ConstCiphertext&lt;Element&gt; ciphertext) const {\n    return GetScheme()-&gt;IntMPBootAdjustScale(ciphertext);\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::IntMPBootRandomElementGen(const PublicKey&lt;Element&gt; publicKey) const {\n    const auto cryptoParamsCKKS = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(this-&gt;GetCryptoParameters());\n    return GetScheme()-&gt;IntMPBootRandomElementGen(cryptoParamsCKKS, publicKey);\n}\n\ntemplate &lt;typename Element&gt;\nstd::vector&lt;Ciphertext&lt;Element&gt;&gt; CryptoContextImpl&lt;Element&gt;::IntMPBootDecrypt(const PrivateKey&lt;Element&gt; privateKey,\n                                                                              ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                              ConstCiphertext&lt;Element&gt; a) const {\n    return GetScheme()-&gt;IntMPBootDecrypt(privateKey, ciphertext, a);\n}\n\ntemplate &lt;typename Element&gt;\nstd::vector&lt;Ciphertext&lt;Element&gt;&gt; CryptoContextImpl&lt;Element&gt;::IntMPBootAdd(\n    std::vector&lt;std::vector&lt;Ciphertext&lt;Element&gt;&gt;&gt;&amp; sharesPairVec) const {\n    return GetScheme()-&gt;IntMPBootAdd(sharesPairVec);\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::IntMPBootEncrypt(const PublicKey&lt;Element&gt; publicKey,\n                                                                 const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; sharesPair,\n                                                                 ConstCiphertext&lt;Element&gt; a,\n                                                                 ConstCiphertext&lt;Element&gt; ciphertext) const {\n    return GetScheme()-&gt;IntMPBootEncrypt(publicKey, sharesPair, a, ciphertext);\n}\n\n// Function for sharing and recovery of secret for Threshold FHE with aborts\ntemplate &lt;&gt;\nstd::unordered_map&lt;uint32_t, DCRTPoly&gt; CryptoContextImpl&lt;DCRTPoly&gt;::ShareKeys(const PrivateKey&lt;DCRTPoly&gt;&amp; sk, usint N,\n                                                                              usint threshold, usint index,\n                                                                              const std::string&amp; shareType) const {\n    // conditions on N and threshold for security with aborts\n    if (N &lt; 2)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Number of parties needs to be at least 3 for aborts&quot;);\n\n    if (threshold &lt;= N / 2)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Threshold required to be majority (more than N/2)&quot;);\n\n    const auto cryptoParams = sk-&gt;GetCryptoContext()-&gt;GetCryptoParameters();\n    auto elementParams      = cryptoParams-&gt;GetElementParams();\n    auto vecSize            = elementParams-&gt;GetParams().size();\n    auto ring_dimension     = elementParams-&gt;GetRingDimension();\n\n    // condition for inverse in lagrange coeff to exist.\n    for (usint k = 0; k &lt; vecSize; k++) {\n        auto modq_k = elementParams-&gt;GetParams()[k]-&gt;GetModulus();\n        if (N &gt;= modq_k)\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Number of parties N needs to be less than DCRTPoly moduli&quot;);\n    }\n\n    // secret sharing\n    const usint num_of_shares = N - 1;\n    std::unordered_map&lt;uint32_t, DCRTPoly&gt; SecretShares;\n\n    if (shareType == &quot;additive&quot;) {\n        // generate a random share of N-2 elements and create the last share as sk - (sk_1 + ... + sk_N-2)\n        typename DCRTPoly::DugType dug;\n        DCRTPoly rsum(dug, elementParams, Format::EVALUATION);\n\n        std::vector&lt;DCRTPoly&gt; SecretSharesVec;\n        SecretSharesVec.reserve(num_of_shares);\n        SecretSharesVec.push_back(rsum);\n        for (size_t i = 1; i &lt; num_of_shares - 1; ++i) {\n            DCRTPoly r(dug, elementParams, Format::EVALUATION);  // should re-generate uniform r for each share\n            rsum += r;\n            SecretSharesVec.push_back(std::move(r));\n        }\n        SecretSharesVec.push_back(sk-&gt;GetPrivateElement() - rsum);\n\n        usint ctr = 0;\n        for (size_t i = 1; i &lt;= N; i++) {\n            if (i != index) {\n                SecretShares[i] = SecretSharesVec[ctr];\n                ctr++;\n            }\n        }\n    }\n    else if (shareType == &quot;shamir&quot;) {\n        // vector to store columnwise randomly generated coefficients for polynomial f from Z_q for every secret key entry\n        std::vector&lt;DCRTPoly&gt; fs;\n        fs.reserve(threshold);\n\n        // set constant term of polynomial f_i to s_i\n        DCRTPoly ske = sk-&gt;GetPrivateElement();\n        // set the secret element in coefficient format\n        ske.SetFormat(Format::COEFFICIENT);\n\n        fs.push_back(std::move(ske));\n        // generate random coefficients\n        typename DCRTPoly::DugType dug;\n        for (size_t i = 1; i &lt; threshold; i++) {\n            fs.push_back(DCRTPoly(dug, elementParams, Format::COEFFICIENT));\n        }\n\n        // evaluate the polynomial at the index of the parties 1 to N\n\n        for (size_t i = 1; i &lt;= N; i++) {\n            if (i != index) {\n                DCRTPoly feval(elementParams, Format::COEFFICIENT, true);\n                for (size_t k = 0; k &lt; vecSize; k++) {\n                    auto modq_k = elementParams-&gt;GetParams()[k]-&gt;GetModulus();\n\n                    NativeVector powtempvec(ring_dimension, modq_k);\n                    NativePoly powtemppoly(elementParams-&gt;GetParams()[k], Format::COEFFICIENT);\n                    NativePoly fevalpoly(elementParams-&gt;GetParams()[k], Format::COEFFICIENT, true);\n\n                    NativeInteger powtemp(1);\n                    for (size_t t = 1; t &lt; threshold; t++) {\n                        powtemp = powtemp.ModMul(i, modq_k);\n\n                        for (size_t d = 0; d &lt; ring_dimension; d++) {\n                            powtempvec.at(d) = powtemp;\n                        }\n\n                        powtemppoly.SetValues(powtempvec, Format::COEFFICIENT);\n\n                        auto fst = fs[t].GetElementAtIndex(k);\n\n                        for (size_t l = 0; l &lt; ring_dimension; l++) {\n                            fevalpoly.at(l) += powtemppoly.at(l).ModMul(fst.at(l), modq_k);\n                        }\n                    }\n                    fevalpoly += fs[0].GetElementAtIndex(k);\n\n                    fevalpoly.SetFormat(Format::COEFFICIENT);\n                    feval.SetElementAtIndex(k, fevalpoly);\n                }\n                // assign fi\n                SecretShares[i] = feval;\n            }\n        }\n    }\n    return SecretShares;\n}\n\ntemplate &lt;&gt;\nvoid CryptoContextImpl&lt;DCRTPoly&gt;::RecoverSharedKey(PrivateKey&lt;DCRTPoly&gt;&amp; sk,\n                                                   std::unordered_map&lt;uint32_t, DCRTPoly&gt;&amp; sk_shares, usint N,\n                                                   usint threshold, const std::string&amp; shareType) const {\n    if (sk_shares.size() &lt; threshold)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Number of shares available less than threshold of the sharing scheme&quot;);\n\n    // conditions on N and threshold for security with aborts\n    if (N &lt; 2)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Number of parties needs to be at least 3 for aborts&quot;);\n\n    if (threshold &lt;= N / 2)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Threshold required to be majority (more than N/2)&quot;);\n\n    const auto&amp; cryptoParams  = sk-&gt;GetCryptoContext()-&gt;GetCryptoParameters();\n    const auto&amp; elementParams = cryptoParams-&gt;GetElementParams();\n    size_t ring_dimension     = elementParams-&gt;GetRingDimension();\n    size_t vecSize            = elementParams-&gt;GetParams().size();\n\n    // condition for inverse in lagrange coeff to exist.\n    for (size_t k = 0; k &lt; vecSize; k++) {\n        auto modq_k = elementParams-&gt;GetParams()[k]-&gt;GetModulus();\n        if (N &gt;= modq_k)\n            &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;Number of parties N needs to be less than DCRTPoly moduli&quot;);\n    }\n\n    // vector of indexes of the clients\n    std::vector&lt;uint32_t&gt; client_indexes;\n    for (uint32_t i = 1; i &lt;= N; ++i) {\n        if (sk_shares.find(i) != sk_shares.end())\n            client_indexes.push_back(i);\n    }\n    const uint32_t client_indexes_size = client_indexes.size();\n\n    if (client_indexes_size &lt; threshold)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Not enough shares to recover the secret&quot;);\n\n    if (shareType == &quot;additive&quot;) {\n        DCRTPoly sum_of_elems(elementParams, Format::EVALUATION, true);\n        for (uint32_t i = 0; i &lt; threshold; ++i) {\n            sum_of_elems += sk_shares[client_indexes[i]];\n        }\n        sk-&gt;SetPrivateElement(sum_of_elems);\n    }\n    else if (shareType == &quot;shamir&quot;) {\n        // use lagrange interpolation to recover the secret\n        // vector of lagrange coefficients L_j = Pdt_i ne j (i (i-j)^-1)\n        std::vector&lt;DCRTPoly&gt; Lagrange_coeffs(client_indexes_size, DCRTPoly(elementParams, Format::EVALUATION));\n\n        // recovery of the secret with lagrange coefficients and the secret shares\n        for (uint32_t j = 0; j &lt; client_indexes_size; j++) {\n            auto cj = client_indexes[j];\n            for (size_t k = 0; k &lt; vecSize; k++) {\n                auto modq_k = elementParams-&gt;GetParams()[k]-&gt;GetModulus();\n                NativePoly multpoly(elementParams-&gt;GetParams()[k], Format::COEFFICIENT, true);\n                multpoly.AddILElementOne();\n                for (uint32_t i = 0; i &lt; client_indexes_size; i++) {\n                    auto ci = client_indexes[i];\n                    if (ci != cj) {\n                        auto&amp;&amp; denominator = (cj &lt; ci) ? NativeInteger(ci - cj) : modq_k - NativeInteger(cj - ci);\n                        auto denom_inv{denominator.ModInverse(modq_k)};\n                        for (size_t d = 0; d &lt; ring_dimension; ++d)\n                            multpoly[d].ModMulFastEq(NativeInteger(ci).ModMul(denom_inv, modq_k), modq_k);\n                    }\n                }\n                multpoly.SetFormat(Format::EVALUATION);\n                Lagrange_coeffs[j].SetElementAtIndex(k, multpoly);\n            }\n            Lagrange_coeffs[j].SetFormat(Format::COEFFICIENT);\n        }\n\n        DCRTPoly lagrange_sum_of_elems(elementParams, Format::COEFFICIENT, true);\n        for (size_t k = 0; k &lt; vecSize; ++k) {\n            NativePoly lagrange_sum_of_elems_poly(elementParams-&gt;GetParams()[k], Format::COEFFICIENT, true);\n            for (uint32_t i = 0; i &lt; client_indexes_size; ++i) {\n                const auto&amp; coeff = Lagrange_coeffs[i].GetAllElements()[k];\n                const auto&amp; share = sk_shares[client_indexes[i]].GetAllElements()[k];\n                lagrange_sum_of_elems_poly += coeff.TimesNoCheck(share);\n            }\n            lagrange_sum_of_elems.SetElementAtIndex(k, lagrange_sum_of_elems_poly);\n        }\n        lagrange_sum_of_elems.SetFormat(Format::EVALUATION);\n        sk-&gt;SetPrivateElement(lagrange_sum_of_elems);\n    }\n}\n\ntemplate class CryptoContextImpl&lt;DCRTPoly&gt;;\n\n}  // namespace lbcrypto\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Control for encryption operations\n */\n\n#ifndef SRC_PKE_CRYPTOCONTEXT_H_\n#define SRC_PKE_CRYPTOCONTEXT_H_\n\n#include &quot;cryptocontextfactory.h&quot;\n#include &quot;cryptocontext-fwd.h&quot;\n#include &quot;ciphertext.h&quot;\n\n#include &quot;encoding/plaintextfactory.h&quot;\n\n#include &quot;key/evalkey.h&quot;\n#include &quot;key/keypair.h&quot;\n\n#include &quot;schemebase/base-pke.h&quot;\n#include &quot;schemebase/base-scheme.h&quot;\n#include &quot;schemerns/rns-cryptoparameters.h&quot;\n\n#include &quot;utils/caller_info.h&quot;\n#include &quot;utils/serial.h&quot;\n#include &quot;utils/type_name.h&quot;\n\n#include &quot;binfhecontext.h&quot;\n\n#include &lt;functional&gt;\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;unordered_map&gt;\n\nnamespace lbcrypto {\n\n/**\n * @brief CryptoContextImpl\n *\n * A CryptoContextImpl is the object used to access the OpenFHE library\n *\n * All OpenFHE functionality is accessed by way of an instance of a\n * CryptoContextImpl; we say that various objects are &quot;created in&quot; a context,\n * and can only be used in the context in which they were created\n *\n * All OpenFHE methods are accessed through CryptoContextImpl methods. Guards\n * are implemented to make certain that only valid objects that have been\n * created in the context are used\n *\n * Contexts are created using GenCryptoContext(), and can be serialized\n * and recovered from a serialization\n */\ntemplate &lt;typename Element&gt;\nclass CryptoContextImpl : public Serializable {\n    using IntType  = typename Element::Integer;\n    using ParmType = typename Element::Params;\n\n    void SetKSTechniqueInScheme();\n\n    const CryptoContext&lt;Element&gt; GetContextForPointer(const CryptoContextImpl&lt;Element&gt;* cc) const {\n        const auto&amp; contexts = CryptoContextFactory&lt;Element&gt;::GetAllContexts();\n        for (const auto&amp; ctx : contexts) {\n            if (cc == ctx.get())\n                return ctx;\n        }\n        &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Cannot find context for the given pointer to CryptoContextImpl&quot;);\n    }\n\n    virtual Plaintext MakeCKKSPackedPlaintextInternal(const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; value,\n                                                      size_t noiseScaleDeg, uint32_t level,\n                                                      const std::shared_ptr&lt;ParmType&gt; params, usint slots) const {\n        const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersRNS&gt;(GetCryptoParameters());\n        if (level &gt; 0) {\n            // validation of level: We need to compare it to multiplicativeDepth, but multiplicativeDepth is not\n            // readily available. so, what we get is numModuli and use it for calculations\n            size_t numModuli = cryptoParams-&gt;GetElementParams()-&gt;GetParams().size();\n            uint32_t multiplicativeDepth =\n                (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT) ? (numModuli - 2) : (numModuli - 1);\n            // we throw an exception if level &gt;= numModuli. however, we use multiplicativeDepth in the error message,\n            // so the user can understand the error more easily.\n            if (level &gt;= numModuli) {\n                std::string errorMsg;\n                if (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT)\n                    errorMsg = &quot;The level value should be less than or equal to (multiplicativeDepth + 1).&quot;;\n                else\n                    errorMsg = &quot;The level value should be less than or equal to multiplicativeDepth.&quot;;\n\n                errorMsg += &quot; Currently: level is [&quot; + std::to_string(level) + &quot;] and multiplicativeDepth is [&quot; +\n                            std::to_string(multiplicativeDepth) + &quot;]&quot;;\n                &quot;hey&quot;; OPENFHE_THROW(config_error, errorMsg);\n            }\n        }\n\n        double scFact = 0;\n        if (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT &amp;&amp; level == 0) {\n            scFact = cryptoParams-&gt;GetScalingFactorRealBig(level);\n            // In FLEXIBLEAUTOEXT mode at level 0, we don&#x27;t use the noiseScaleDeg\n            // in our encoding function, so we set it to 1 to make sure it\n            // has no effect on the encoding.\n            noiseScaleDeg = 1;\n        }\n        else {\n            scFact = cryptoParams-&gt;GetScalingFactorReal(level);\n        }\n\n        Plaintext p;\n        if (params == nullptr) {\n            std::shared_ptr&lt;ILDCRTParams&lt;DCRTPoly::Integer&gt;&gt; elemParamsPtr;\n            if (level != 0) {\n                ILDCRTParams&lt;DCRTPoly::Integer&gt; elemParams = *(cryptoParams-&gt;GetElementParams());\n                for (uint32_t i = 0; i &lt; level; i++) {\n                    elemParams.PopLastParam();\n                }\n                elemParamsPtr = std::make_shared&lt;ILDCRTParams&lt;DCRTPoly::Integer&gt;&gt;(elemParams);\n            }\n            else {\n                elemParamsPtr = cryptoParams-&gt;GetElementParams();\n            }\n            // Check if plaintext has got enough slots for data (value)\n            usint ringDim    = elemParamsPtr-&gt;GetRingDimension();\n            size_t valueSize = value.size();\n            if (valueSize &gt; ringDim / 2) {\n                &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The size [&quot; + std::to_string(valueSize) +\n                                                &quot;] of the vector with values should not be greater than ringDim/2 [&quot; +\n                                                std::to_string(ringDim / 2) + &quot;] if the scheme is CKKS&quot;);\n            }\n            // TODO (dsuponit): we should call a version of MakePlaintext instead of calling Plaintext() directly here\n            p = Plaintext(std::make_shared&lt;CKKSPackedEncoding&gt;(elemParamsPtr, this-&gt;GetEncodingParams(), value,\n                                                               noiseScaleDeg, level, scFact, slots));\n        }\n        else {\n            // Check if plaintext has got enough slots for data (value)\n            usint ringDim    = params-&gt;GetRingDimension();\n            size_t valueSize = value.size();\n            if (valueSize &gt; ringDim / 2) {\n                &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The size [&quot; + std::to_string(valueSize) +\n                                                &quot;] of the vector with values should not be greater than ringDim/2 [&quot; +\n                                                std::to_string(ringDim / 2) + &quot;] if the scheme is CKKS&quot;);\n            }\n            // TODO (dsuponit): we should call a version of MakePlaintext instead of calling Plaintext() directly here\n            p = Plaintext(std::make_shared&lt;CKKSPackedEncoding&gt;(params, this-&gt;GetEncodingParams(), value, noiseScaleDeg,\n                                                               level, scFact, slots));\n        }\n        p-&gt;Encode();\n\n        // In FLEXIBLEAUTOEXT mode, a fresh plaintext at level 0 always has noiseScaleDeg 2.\n        if (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT &amp;&amp; level == 0) {\n            p-&gt;SetNoiseScaleDeg(2);\n        }\n        return p;\n    }\n\n    /**\n    * MakePlaintext constructs a CoefPackedEncoding or PackedEncoding in this context\n    * @param encoding is PACKED_ENCODING or COEF_PACKED_ENCODING\n    * @param value is the value to encode\n    * @param depth is the multiplicative depth to encode the plaintext at\n    * @param level is the level to encode the plaintext at\n    * @return plaintext\n    */\n    Plaintext MakePlaintext(const PlaintextEncodings encoding, const std::vector&lt;int64_t&gt;&amp; value, size_t depth,\n                            uint32_t level) const {\n        const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersRNS&gt;(GetCryptoParameters());\n        if (level &gt; 0) {\n            if (getSchemeId() == SCHEME::BFVRNS_SCHEME) {\n                std::string errorMsg(&quot;The level value should be zero for BFVRNS_SCHEME. Currently: level is [&quot; +\n                                     std::to_string(level) + &quot;]&quot;);\n                &quot;hey&quot;; OPENFHE_THROW(config_error, errorMsg);\n            }\n            // validation of level: We need to compare it to multiplicativeDepth, but multiplicativeDepth is not\n            // readily available. so, what we get is numModuli and use it for calculations\n            size_t numModuli = cryptoParams-&gt;GetElementParams()-&gt;GetParams().size();\n            uint32_t multiplicativeDepth =\n                (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT) ? (numModuli - 2) : (numModuli - 1);\n            // we throw an exception if level &gt;= numModuli. however, we use multiplicativeDepth in the error message,\n            // so the user can understand the error more easily.\n            if (level &gt;= numModuli) {\n                std::string errorMsg;\n                if (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT)\n                    errorMsg = &quot;The level value should be less than or equal to (multiplicativeDepth + 1).&quot;;\n                else\n                    errorMsg = &quot;The level value should be less than or equal to multiplicativeDepth.&quot;;\n\n                errorMsg += &quot; Currently: level is [&quot; + std::to_string(level) + &quot;] and multiplicativeDepth is [&quot; +\n                            std::to_string(multiplicativeDepth) + &quot;]&quot;;\n                &quot;hey&quot;; OPENFHE_THROW(config_error, errorMsg);\n            }\n        }\n\n        Plaintext p;\n        if (getSchemeId() == SCHEME::BGVRNS_SCHEME &amp;&amp; (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTO ||\n                                                       cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT)) {\n            NativeInteger scf;\n            if (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT &amp;&amp; level == 0) {\n                scf = cryptoParams-&gt;GetScalingFactorIntBig(level);\n                p   = PlaintextFactory::MakePlaintext(value, encoding, this-&gt;GetElementParams(),\n                                                      this-&gt;GetEncodingParams(), getSchemeId(), 1, level, scf);\n                p-&gt;SetNoiseScaleDeg(2);\n            }\n            else {\n                scf = cryptoParams-&gt;GetScalingFactorInt(level);\n                p   = PlaintextFactory::MakePlaintext(value, encoding, this-&gt;GetElementParams(),\n                                                      this-&gt;GetEncodingParams(), getSchemeId(), depth, level, scf);\n            }\n        }\n        else {\n            auto elementParams = this-&gt;GetElementParams();\n            p = PlaintextFactory::MakePlaintext(value, encoding, elementParams, this-&gt;GetEncodingParams(),\n                                                getSchemeId());\n        }\n\n        return p;\n    }\n\n    /**\n    * MakePlaintext static that takes a cc and calls the Plaintext Factory\n    * @param encoding\n    * @param cc\n    * @param value\n    * @return\n    */\n    template &lt;typename Value1&gt;\n    static Plaintext MakePlaintext(PlaintextEncodings encoding, CryptoContext&lt;Element&gt; cc, const Value1&amp; value) {\n        return PlaintextFactory::MakePlaintext(value, encoding, cc-&gt;GetElementParams(), cc-&gt;GetEncodingParams());\n    }\n\n    template &lt;typename Value1, typename Value2&gt;\n    static Plaintext MakePlaintext(PlaintextEncodings encoding, CryptoContext&lt;Element&gt; cc, const Value1&amp; value,\n                                   const Value2&amp; value2) {\n        return PlaintextFactory::MakePlaintext(encoding, cc-&gt;GetElementParams(), cc-&gt;GetEncodingParams(), value,\n                                               value2);\n    }\n\nprivate:\n    // cached evalmult keys, by secret key UID\n    static inline std::map&lt;std::string, std::vector&lt;EvalKey&lt;Element&gt;&gt;&gt; s_evalMultKeyMap{};\n    // cached evalsum keys, by secret key UID\n    static inline std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt; s_evalSumKeyMap{};\n    // cached evalautomorphism keys, by secret key UID\n    static inline std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt; s_evalAutomorphismKeyMap{};\n\nprotected:\n    // crypto parameters used for this context\n    std::shared_ptr&lt;CryptoParametersBase&lt;Element&gt;&gt; params;\n    // algorithm used; accesses all crypto methods\n    std::shared_ptr&lt;SchemeBase&lt;Element&gt;&gt; scheme;\n\n    static std::map&lt;std::string, std::vector&lt;EvalKey&lt;Element&gt;&gt;&gt;&amp; evalMultKeyMap();\n    static std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt;&amp; evalSumKeyMap();\n    static std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt;&amp; evalAutomorphismKeyMap();\n\n    SCHEME m_schemeId = SCHEME::INVALID_SCHEME;\n\n    uint32_t m_keyGenLevel;\n\n    /**\n   * TypeCheck makes sure that an operation between two ciphertexts is permitted\n   * @param a\n   * @param b\n   */\n    void TypeCheck(const ConstCiphertext&lt;Element&gt; a, const ConstCiphertext&lt;Element&gt; b, CALLER_INFO_ARGS_HDR) const {\n        if (a == nullptr || b == nullptr) {\n            std::string errorMsg(std::string(&quot;Null Ciphertext&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(type_error, errorMsg);\n        }\n        if (a-&gt;GetCryptoContext().get() != this) {\n            std::string errorMsg(std::string(&quot;Ciphertext was not created in this CryptoContext&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(type_error, errorMsg);\n        }\n        if (a-&gt;GetCryptoContext() != b-&gt;GetCryptoContext()) {\n            std::string errorMsg(std::string(&quot;Ciphertexts were not created in the same CryptoContext&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(type_error, errorMsg);\n        }\n        if (a-&gt;GetKeyTag() != b-&gt;GetKeyTag()) {\n            std::string errorMsg(std::string(&quot;Ciphertexts were not encrypted with same keys&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(type_error, errorMsg);\n        }\n        if (a-&gt;GetEncodingType() != b-&gt;GetEncodingType()) {\n            std::stringstream ss;\n            ss &lt;&lt; &quot;Ciphertext encoding types &quot; &lt;&lt; a-&gt;GetEncodingType();\n            ss &lt;&lt; &quot; and &quot; &lt;&lt; b-&gt;GetEncodingType();\n            ss &lt;&lt; &quot; do not match&quot;;\n            ss &lt;&lt; CALLER_INFO;\n            &quot;hey&quot;; OPENFHE_THROW(type_error, ss.str());\n        }\n    }\n\n    /**\n   * TypeCheck makes sure that an operation between a ciphertext and a plaintext\n   * is permitted\n   * @param a\n   * @param b\n   */\n    void TypeCheck(const ConstCiphertext&lt;Element&gt; a, const ConstPlaintext&amp; b, CALLER_INFO_ARGS_HDR) const {\n        if (a == nullptr) {\n            std::string errorMsg(std::string(&quot;Null Ciphertext&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(type_error, errorMsg);\n        }\n        if (b == nullptr) {\n            std::string errorMsg(std::string(&quot;Null Plaintext&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(type_error, errorMsg);\n        }\n        if (a-&gt;GetCryptoContext().get() != this) {\n            std::string errorMsg(std::string(&quot;Ciphertext was not created in this CryptoContext&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(type_error, errorMsg);\n        }\n        if (a-&gt;GetEncodingType() != b-&gt;GetEncodingType()) {\n            std::stringstream ss;\n            ss &lt;&lt; &quot;Ciphertext encoding type &quot; &lt;&lt; a-&gt;GetEncodingType();\n            ss &lt;&lt; &quot; and Plaintext encoding type &quot; &lt;&lt; b-&gt;GetEncodingType();\n            ss &lt;&lt; &quot; do not match&quot;;\n            ss &lt;&lt; CALLER_INFO;\n            &quot;hey&quot;; OPENFHE_THROW(type_error, ss.str());\n        }\n    }\n\n    bool Mismatched(const CryptoContext&lt;Element&gt; a) const {\n        if (a.get() != this) {\n            return true;\n        }\n        return false;\n    }\n\n    template &lt;typename T&gt;\n    void CheckKey(const T&amp; key, CALLER_INFO_ARGS_HDR) const {\n        if (key == nullptr) {\n            std::string errorMsg(std::string(&quot;Key is nullptr&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errorMsg);\n        }\n        if (Mismatched(key-&gt;GetCryptoContext())) {\n            std::string errorMsg(std::string(&quot;Key was not generated with the same crypto context&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errorMsg);\n        }\n    }\n\n    void CheckCiphertext(const ConstCiphertext&lt;Element&gt;&amp; ciphertext, CALLER_INFO_ARGS_HDR) const {\n        if (ciphertext == nullptr) {\n            std::string errorMsg(std::string(&quot;Ciphertext is nullptr&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errorMsg);\n        }\n        if (Mismatched(ciphertext-&gt;GetCryptoContext())) {\n            std::string errorMsg(std::string(&quot;Ciphertext was not generated with the same crypto context&quot;) +\n                                 CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errorMsg);\n        }\n    }\n\n    PrivateKey&lt;Element&gt; privateKey;\n\npublic:\n    /**\n   * This stores the private key in the crypto context.\n   * This is only intended for debugging and should not be\n   * used in production systems. Please define DEBUG_KEY in\n   * openfhe.h to enable this.\n   *\n   * If used, one can create a key pair and store the secret\n   * key in th crypto context like this:\n   *\n   * auto keys = cc-&gt;KeyGen();\n   * cc-&gt;SetPrivateKey(keys.secretKey);\n   *\n   * After that, anyone in the code, one can access the\n   * secret key by getting the crypto context and doing the\n   * following:\n   *\n   * auto sk = cc-&gt;GetPrivateKey();\n   *\n   * This key can be used for decrypting any intermediate\n   * ciphertexts for debugging purposes.\n   *\n   * @param sk the secret key\n   *\n   */\n    void SetPrivateKey(const PrivateKey&lt;Element&gt; privateKey) {\n#ifdef DEBUG_KEY\n        std::cerr &lt;&lt; &quot;Warning - SetPrivateKey is only intended to be used for debugging &quot;\n                     &quot;purposes - not for production systems.&quot;\n                  &lt;&lt; std::endl;\n        this-&gt;privateKey = privateKey;\n#else\n        &quot;hey&quot;; OPENFHE_THROW(not_available_error, &quot;SetPrivateKey is only allowed if DEBUG_KEY is set in openfhe.h&quot;);\n#endif\n    }\n\n    /**\n   * This gets the private key from the crypto context.\n   * This is only intended for debugging and should not be\n   * used in production systems. Please define DEBUG_KEY in\n   * openfhe.h to enable this.\n   *\n   * If used, one can create a key pair and store the secret\n   * key in th crypto context like this:\n   *\n   * auto keys = cc-&gt;KeyGen();\n   * cc-&gt;SetPrivateKey(keys.secretKey);\n   *\n   * After that, anyone in the code, one can access the\n   * secret key by getting the crypto context and doing the\n   * following:\n   *\n   * auto sk = cc-&gt;GetPrivateKey();\n   *\n   * This key can be used for decrypting any intermediate\n   * ciphertexts for debugging purposes.\n   *\n   * @return the secret key\n   *\n   */\n    const PrivateKey&lt;Element&gt; GetPrivateKey() {\n#ifdef DEBUG_KEY\n        return this-&gt;privateKey;\n#else\n        &quot;hey&quot;; OPENFHE_THROW(not_available_error, &quot;GetPrivateKey is only allowed if DEBUG_KEY is set in openfhe.h&quot;);\n#endif\n    }\n\n    void setSchemeId(SCHEME schemeTag) {\n        this-&gt;m_schemeId = schemeTag;\n    }\n\n    SCHEME getSchemeId() const {\n        return this-&gt;m_schemeId;\n    }\n\n    /**\n   * CryptoContextImpl constructor from pointers to parameters and scheme\n   * @param params pointer to CryptoParameters\n   * @param scheme pointer to Crypto Scheme object\n   * @param schemeId scheme identifier\n   */\n    // TODO (dsuponit): investigate if we really need 2 constructors for CryptoContextImpl as one of them take regular pointer\n    // and the other one takes shared_ptr\n    CryptoContextImpl(CryptoParametersBase&lt;Element&gt;* params = nullptr, SchemeBase&lt;Element&gt;* scheme = nullptr,\n                      SCHEME schemeId = SCHEME::INVALID_SCHEME) {\n        this-&gt;params.reset(params);\n        this-&gt;scheme.reset(scheme);\n        this-&gt;m_keyGenLevel = 0;\n        this-&gt;m_schemeId    = schemeId;\n    }\n\n    /**\n   * CryptoContextImpl constructor from shared pointers to parameters and scheme\n   * @param params shared pointer to CryptoParameters\n   * @param scheme sharedpointer to Crypto Scheme object\n   * @param schemeId scheme identifier\n   */\n    CryptoContextImpl(std::shared_ptr&lt;CryptoParametersBase&lt;Element&gt;&gt; params,\n                      std::shared_ptr&lt;SchemeBase&lt;Element&gt;&gt; scheme, SCHEME schemeId = SCHEME::INVALID_SCHEME) {\n        this-&gt;params        = params;\n        this-&gt;scheme        = scheme;\n        this-&gt;m_keyGenLevel = 0;\n        this-&gt;m_schemeId    = schemeId;\n    }\n\n    /**\n   * Copy constructor\n   * @param c - source\n   */\n    CryptoContextImpl(const CryptoContextImpl&lt;Element&gt;&amp; c) {\n        params              = c.params;\n        scheme              = c.scheme;\n        this-&gt;m_keyGenLevel = 0;\n        this-&gt;m_schemeId    = c.m_schemeId;\n    }\n\n    /**\n   * Assignment\n   * @param rhs - assigning from\n   * @return this\n   */\n    CryptoContextImpl&lt;Element&gt;&amp; operator=(const CryptoContextImpl&lt;Element&gt;&amp; rhs) {\n        params        = rhs.params;\n        scheme        = rhs.scheme;\n        m_keyGenLevel = rhs.m_keyGenLevel;\n        m_schemeId    = rhs.m_schemeId;\n        return *this;\n    }\n\n    /**\n   * A CryptoContextImpl is only valid if the shared pointers are both valid\n   */\n    operator bool() const {\n        return params &amp;&amp; scheme;\n    }\n\n    /**\n   * Private method to compare two contexts; this is only used internally and\n   * is not generally available\n   * @param a - operand 1\n   * @param b - operand 2\n   * @return true if the implementations have identical parms and scheme\n   */\n    friend bool operator==(const CryptoContextImpl&lt;Element&gt;&amp; a, const CryptoContextImpl&lt;Element&gt;&amp; b) {\n        // Identical if the parameters and the schemes are identical... the exact\n        // same object, OR the same type and the same values\n        if (a.params.get() == b.params.get()) {\n            return true;\n        }\n        else {\n            if (typeid(*a.params.get()) != typeid(*b.params.get())) {\n                return false;\n            }\n            if (*a.params.get() != *b.params.get())\n                return false;\n        }\n\n        if (a.scheme.get() == b.scheme.get()) {\n            return true;\n        }\n        else {\n            if (typeid(*a.scheme.get()) != typeid(*b.scheme.get())) {\n                return false;\n            }\n            if (*a.scheme.get() != *b.scheme.get())\n                return false;\n        }\n\n        return true;\n    }\n\n    /**\n   * Private method to compare two contexts; this is only used internally and\n   * is not generally available\n   * */\n    friend bool operator!=(const CryptoContextImpl&lt;Element&gt;&amp; a, const CryptoContextImpl&lt;Element&gt;&amp; b) {\n        return !(a == b);\n    }\n\n    /**\n   * SerializeEvalMultKey for a single EvalMult key or all EvalMult keys\n   *\n   * @param ser - stream to serialize to\n   * @param sertype - type of serialization\n   * @param id for key to serialize - if empty std::string, serialize them all\n   * @return true on success\n   */\n    template &lt;typename ST&gt;\n    static bool SerializeEvalMultKey(std::ostream&amp; ser, const ST&amp; sertype, std::string id = &quot;&quot;) {\n        std::map&lt;std::string, std::vector&lt;EvalKey&lt;Element&gt;&gt;&gt;* smap;\n        std::map&lt;std::string, std::vector&lt;EvalKey&lt;Element&gt;&gt;&gt; omap;\n\n        if (id.length() == 0) {\n            smap = &amp;GetAllEvalMultKeys();\n        }\n        else {\n            const auto k = GetAllEvalMultKeys().find(id);\n\n            if (k == GetAllEvalMultKeys().end())\n                return false;  // no such id\n\n            smap           = &amp;omap;\n            omap[k-&gt;first] = k-&gt;second;\n        }\n\n        Serial::Serialize(*smap, ser, sertype);\n        return true;\n    }\n\n    /**\n   * SerializeEvalMultKey for all EvalMultKeys made in a given context\n   *\n   * @param ser stream to serialize to\n   * @param sertype type of serialization\n   * @param cc whose keys should be serialized\n   * @return true on success (false on failure or no keys found)\n   */\n    template &lt;typename ST&gt;\n    static bool SerializeEvalMultKey(std::ostream&amp; ser, const ST&amp; sertype, const CryptoContext&lt;Element&gt; cc) {\n        std::map&lt;std::string, std::vector&lt;EvalKey&lt;Element&gt;&gt;&gt; omap;\n        for (const auto&amp; k : GetAllEvalMultKeys()) {\n            if (k.second[0]-&gt;GetCryptoContext() == cc) {\n                omap[k.first] = k.second;\n            }\n        }\n\n        if (omap.size() == 0)\n            return false;\n\n        Serial::Serialize(omap, ser, sertype);\n        return true;\n    }\n\n    /**\n   * DeserializeEvalMultKey deserialize all keys in the serialization\n   * deserialized keys silently replace any existing matching keys\n   * deserialization will create CryptoContextImpl if necessary\n   *\n   * @param serObj - stream with a serialization\n   * @param sertype type of serialization\n   * @return true on success\n   */\n    template &lt;typename ST&gt;\n    static bool DeserializeEvalMultKey(std::istream&amp; ser, const ST&amp; sertype) {\n        std::map&lt;std::string, std::vector&lt;EvalKey&lt;Element&gt;&gt;&gt; evalMultKeyMap;\n\n        Serial::Deserialize(GetAllEvalMultKeys(), ser, sertype);\n\n        // The deserialize call created any contexts that needed to be created....\n        // so all we need to do is put the keys into the maps for their context\n\n        for (auto k : GetAllEvalMultKeys()) {\n            GetAllEvalMultKeys()[k.first] = k.second;\n        }\n\n        return true;\n    }\n\n    /**\n   * ClearEvalMultKeys - flush EvalMultKey cache\n   */\n    static void ClearEvalMultKeys() {\n        GetAllEvalMultKeys().clear();\n    }\n\n    /**\n   * ClearEvalMultKeys - flush EvalMultKey cache for a given id\n   * @param id the correponding key id\n   */\n    static void ClearEvalMultKeys(const std::string&amp; id) {\n        auto kd = GetAllEvalMultKeys().find(id);\n        if (kd != GetAllEvalMultKeys().end())\n            GetAllEvalMultKeys().erase(kd);\n    }\n\n    /**\n   * ClearEvalMultKeys - flush EvalMultKey cache for a given context\n   * @param cc crypto context\n   */\n    static void ClearEvalMultKeys(const CryptoContext&lt;Element&gt; cc) {\n        for (auto it = GetAllEvalMultKeys().begin(); it != GetAllEvalMultKeys().end();) {\n            if (it-&gt;second[0]-&gt;GetCryptoContext() == cc) {\n                it = GetAllEvalMultKeys().erase(it);\n            }\n            else {\n                ++it;\n            }\n        }\n    }\n\n    /**\n   * InsertEvalMultKey - add the given vector of keys to the map, replacing the\n   * existing vector if there\n   * @param evalKeyVec vector of keys\n   */\n    static void InsertEvalMultKey(const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec);\n\n    /**\n   * SerializeEvalSumKey for a single EvalSum key or all of the EvalSum keys\n   *\n   * @param ser - stream to serialize to\n   * @param sertype - type of serialization\n   * @param id - key to serialize; empty std::string means all keys\n   * @return true on success\n   */\n    template &lt;typename ST&gt;\n    static bool SerializeEvalSumKey(std::ostream&amp; ser, const ST&amp; sertype, std::string id = &quot;&quot;) {\n        std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt;* smap;\n        std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt; omap;\n\n        if (id.length() == 0) {\n            smap = &amp;GetAllEvalSumKeys();\n        }\n        else {\n            auto k = GetAllEvalSumKeys().find(id);\n\n            if (k == GetAllEvalSumKeys().end())\n                return false;  // no such id\n\n            smap           = &amp;omap;\n            omap[k-&gt;first] = k-&gt;second;\n        }\n        Serial::Serialize(*smap, ser, sertype);\n        return true;\n    }\n\n    /**\n   * SerializeEvalSumKey for all of the EvalSum keys for a context\n   *\n   * @param ser - stream to serialize to\n   * @param sertype - type of serialization\n   * @param cc - context\n   * @return true on success\n   */\n    template &lt;typename ST&gt;\n    static bool SerializeEvalSumKey(std::ostream&amp; ser, const ST&amp; sertype, const CryptoContext&lt;Element&gt; cc) {\n        std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt; omap;\n        for (const auto&amp; k : GetAllEvalSumKeys()) {\n            if (k.second-&gt;begin()-&gt;second-&gt;GetCryptoContext() == cc) {\n                omap[k.first] = k.second;\n            }\n        }\n\n        if (omap.size() == 0)\n            return false;\n\n        Serial::Serialize(omap, ser, sertype);\n\n        return true;\n    }\n\n    /**\n   * DeserializeEvalSumKey deserialize all keys in the serialization\n   * deserialized keys silently replace any existing matching keys\n   * deserialization will create CryptoContextImpl if necessary\n   *\n   * @param ser - stream to serialize from\n   * @param sertype - type of serialization\n   * @return true on success\n   */\n    template &lt;typename ST&gt;\n    static bool DeserializeEvalSumKey(std::istream&amp; ser, const ST&amp; sertype) {\n        std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt; evalSumKeyMap;\n\n        Serial::Deserialize(evalSumKeyMap, ser, sertype);\n\n        // The deserialize call created any contexts that needed to be created....\n        // so all we need to do is put the keys into the maps for their context\n\n        for (auto k : evalSumKeyMap) {\n            GetAllEvalSumKeys()[k.first] = k.second;\n        }\n\n        return true;\n    }\n\n    /**\n   * ClearEvalSumKeys - flush EvalSumKey cache\n   */\n    static void ClearEvalSumKeys();\n\n    /**\n   * ClearEvalSumKeys - flush EvalSumKey cache for a given id\n   * @param id key id\n   */\n    static void ClearEvalSumKeys(const std::string&amp; id);\n\n    /**\n   * ClearEvalSumKeys - flush EvalSumKey cache for a given context\n   * @param cc crypto context\n   */\n    static void ClearEvalSumKeys(const CryptoContext&lt;Element&gt; cc);\n\n    /**\n   * InsertEvalSumKey - add the given map of keys to the map, replacing the\n   * existing map if there\n   * @param evalKeyMap key map\n   */\n    static void InsertEvalSumKey(const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap);\n\n    /**\n   * SerializeEvalAutomorphismKey for a single EvalAuto key or all of the\n   * EvalAuto keys\n   *\n   * @param ser - stream to serialize to\n   * @param sertype - type of serialization\n   * @param id - key to serialize; empty std::string means all keys\n   * @return true on success\n   */\n    template &lt;typename ST&gt;\n    static bool SerializeEvalAutomorphismKey(std::ostream&amp; ser, const ST&amp; sertype, std::string id = &quot;&quot;) {\n        std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt;* smap;\n        std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt; omap;\n        if (id.length() == 0) {\n            smap = &amp;GetAllEvalAutomorphismKeys();\n        }\n        else {\n            auto k = GetAllEvalAutomorphismKeys().find(id);\n\n            if (k == GetAllEvalAutomorphismKeys().end())\n                return false;  // no such id\n\n            smap           = &amp;omap;\n            omap[k-&gt;first] = k-&gt;second;\n        }\n        Serial::Serialize(*smap, ser, sertype);\n        return true;\n    }\n\n    /**\n   * SerializeEvalAutomorphismKey for all of the EvalAuto keys for a context\n   *\n   * @param ser - stream to serialize to\n   * @param sertype - type of serialization\n   * @param cc - context\n   * @return true on success\n   */\n    template &lt;typename ST&gt;\n    static bool SerializeEvalAutomorphismKey(std::ostream&amp; ser, const ST&amp; sertype, const CryptoContext&lt;Element&gt; cc) {\n        std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt; omap;\n        for (const auto&amp; k : GetAllEvalAutomorphismKeys()) {\n            if (k.second-&gt;begin()-&gt;second-&gt;GetCryptoContext() == cc) {\n                omap[k.first] = k.second;\n            }\n        }\n\n        if (omap.size() == 0)\n            return false;\n\n        Serial::Serialize(omap, ser, sertype);\n        return true;\n    }\n\n    /**\n   * DeserializeEvalAutomorphismKey deserialize all keys in the serialization\n   * deserialized keys silently replace any existing matching keys\n   * deserialization will create CryptoContextImpl if necessary\n   *\n   * @param ser - stream to serialize from\n   * @param sertype - type of serialization\n   * @return true on success\n   */\n    template &lt;typename ST&gt;\n    static bool DeserializeEvalAutomorphismKey(std::istream&amp; ser, const ST&amp; sertype) {\n        std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt; evalSumKeyMap;\n\n        Serial::Deserialize(evalSumKeyMap, ser, sertype);\n\n        // The deserialize call created any contexts that needed to be created....\n        // so all we need to do is put the keys into the maps for their context\n\n        for (auto k : evalSumKeyMap) {\n            GetAllEvalAutomorphismKeys()[k.first] = k.second;\n        }\n\n        return true;\n    }\n\n    /**\n   * ClearEvalAutomorphismKeys - flush EvalAutomorphismKey cache\n   */\n    static void ClearEvalAutomorphismKeys();\n\n    /**\n   * ClearEvalAutomorphismKeys - flush EvalAutomorphismKey cache for a given id\n   * @param id\n   */\n    static void ClearEvalAutomorphismKeys(const std::string&amp; id);\n\n    /**\n   * ClearEvalAutomorphismKeys - flush EvalAutomorphismKey cache for a given\n   * context\n   * @param cc\n   */\n    static void ClearEvalAutomorphismKeys(const CryptoContext&lt;Element&gt; cc);\n\n    /**\n   * InsertEvalAutomorphismKey - add the given map of keys to the map, replacing\n   * the existing map if there\n   * @param mapToInsert\n   */\n    static void InsertEvalAutomorphismKey(const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap);\n\n    //------------------------------------------------------------------------------\n    // TURN FEATURES ON\n    //------------------------------------------------------------------------------\n\n    /**\n   * Enable a particular feature for use with this CryptoContextImpl\n   * @param feature - the feature that should be enabled\n   */\n    void Enable(PKESchemeFeature feature) {\n        scheme-&gt;Enable(feature);\n    }\n\n    /**\n   * Enable several features at once\n   * @param featureMask - bitwise or of several PKESchemeFeatures\n   */\n    void Enable(usint featureMask) {\n        scheme-&gt;Enable(featureMask);\n    }\n\n    // GETTERS\n    /**\n   * Getter for Scheme\n   * @return scheme\n   */\n    const std::shared_ptr&lt;SchemeBase&lt;Element&gt;&gt; GetScheme() const {\n        return scheme;\n    }\n\n    /**\n   * Getter for CryptoParams\n   * @return params\n   */\n    const std::shared_ptr&lt;CryptoParametersBase&lt;Element&gt;&gt; GetCryptoParameters() const {\n        return params;\n    }\n\n    /**\n   * For future use: getter for the level at which evaluation keys should be generated\n   */\n    size_t GetKeyGenLevel() const {\n        return m_keyGenLevel;\n    }\n\n    /**\n   * For future use: setter for the level at which evaluation keys should be generated\n   */\n    void SetKeyGenLevel(size_t level) {\n        m_keyGenLevel = level;\n    }\n\n    /**\n   * Getter for element params\n   * @return\n   */\n    const std::shared_ptr&lt;ParmType&gt; GetElementParams() const {\n        return params-&gt;GetElementParams();\n    }\n\n    /**\n   * Getter for encoding params\n   * @return\n   */\n    const EncodingParams GetEncodingParams() const {\n        return params-&gt;GetEncodingParams();\n    }\n\n    /**\n   * Get the cyclotomic order used for this context\n   *\n   * @return\n   */\n    usint GetCyclotomicOrder() const {\n        return params-&gt;GetElementParams()-&gt;GetCyclotomicOrder();\n    }\n\n    /**\n   * Get the ring dimension used for this context\n   *\n   * @return\n   */\n    usint GetRingDimension() const {\n        return params-&gt;GetElementParams()-&gt;GetRingDimension();\n    }\n\n    /**\n   * Get the ciphertext modulus used for this context\n   *\n   * @return\n   */\n    const IntType&amp; GetModulus() const {\n        return params-&gt;GetElementParams()-&gt;GetModulus();\n    }\n\n    /**\n   * Get the ciphertext modulus used for this context\n   *\n   * @return\n   */\n    const IntType&amp; GetRootOfUnity() const {\n        return params-&gt;GetElementParams()-&gt;GetRootOfUnity();\n    }\n\n    //------------------------------------------------------------------------------\n    // KEYS GETTERS\n    //------------------------------------------------------------------------------\n\n    /**\n   * Get a map of relinearization keys for all secret keys\n   */\n    static std::map&lt;std::string, std::vector&lt;EvalKey&lt;Element&gt;&gt;&gt;&amp; GetAllEvalMultKeys() {\n        return evalMultKeyMap();\n    }\n\n    /**\n   * Get relinearization keys for a specific secret key tag\n   */\n    static const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; GetEvalMultKeyVector(const std::string&amp; keyID) {\n        auto ekv = GetAllEvalMultKeys().find(keyID);\n        if (ekv == GetAllEvalMultKeys().end()) {\n            &quot;hey&quot;; OPENFHE_THROW(not_available_error,\n                          &quot;You need to use EvalMultKeyGen so that you have an &quot;\n                          &quot;EvalMultKey available for this ID&quot;);\n        }\n        return ekv-&gt;second;\n    }\n\n    /**\n   * Get a map of automorphism keys for all secret keys\n   */\n    static std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt;&amp; GetAllEvalAutomorphismKeys() {\n        return evalAutomorphismKeyMap();\n    }\n\n    /**\n   * Get automorphism keys for a specific secret key tag\n   */\n    static std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; GetEvalAutomorphismKeyMap(const std::string&amp; id);\n\n    /**\n   * Get a map of summation keys (each is composed of several automorphism keys) for all secret keys\n   */\n    static std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt;&amp; GetAllEvalSumKeys();\n\n    /**\n   * Get a map of summation keys (each is composed of several automorphism keys) for a specific secret key tag\n   */\n    static const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; GetEvalSumKeyMap(const std::string&amp; id);\n\n    //------------------------------------------------------------------------------\n    // PLAINTEXT FACTORY METHODS\n    //------------------------------------------------------------------------------\n\n    // TODO to be deprecated in 2.0\n    /**\n   * MakeStringPlaintext constructs a StringEncoding in this context\n   * @param str string to be encoded\n   * @return plaintext\n   */\n    Plaintext MakeStringPlaintext(const std::string&amp; str) const {\n        return PlaintextFactory::MakePlaintext(str, STRING_ENCODING, this-&gt;GetElementParams(),\n                                               this-&gt;GetEncodingParams());\n    }\n\n    /**\n   * MakeCoefPackedPlaintext constructs a CoefPackedEncoding in this context\n   * @param value vector of signed integers mod t\n   * @param noiseScaleDeg is degree of the scaling factor to encode the plaintext at\n   * @param level is the level to encode the plaintext at\n   * @return plaintext\n   */\n    Plaintext MakeCoefPackedPlaintext(const std::vector&lt;int64_t&gt;&amp; value, size_t noiseScaleDeg = 1,\n                                      uint32_t level = 0) const {\n        if (!value.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Cannot encode an empty value vector&quot;);\n\n        return MakePlaintext(COEF_PACKED_ENCODING, value, noiseScaleDeg, level);\n    }\n\n    /**\n   * MakePackedPlaintext constructs a PackedEncoding in this context\n   * @param value vector of signed integers mod t\n   * @param noiseScaleDeg is degree of the scaling factor to encode the plaintext at\n   * @param level is the level to encode the plaintext at\n   * @return plaintext\n   */\n    Plaintext MakePackedPlaintext(const std::vector&lt;int64_t&gt;&amp; value, size_t noiseScaleDeg = 1,\n                                  uint32_t level = 0) const {\n        if (!value.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Cannot encode an empty value vector&quot;);\n\n        return MakePlaintext(PACKED_ENCODING, value, noiseScaleDeg, level);\n    }\n\n    /**\n   * COMPLEX ARITHMETIC IS NOT AVAILABLE,\n   * AND THIS METHOD BE DEPRECATED. USE THE REAL-NUMBER METHOD INSTEAD.\n   * MakeCKKSPackedPlaintext constructs a CKKSPackedEncoding in this context\n   * from a vector of complex numbers\n   * @param value - input vector of complex number\n   * @param scaleDeg - degree of scaling factor used to encode the vector\n   * @param level - level at each the vector will get encrypted\n   * @param params - parameters to be usef for the ciphertext\n   * @return plaintext\n   */\n    Plaintext MakeCKKSPackedPlaintext(const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; value, size_t scaleDeg = 1,\n                                      uint32_t level = 0, const std::shared_ptr&lt;ParmType&gt; params = nullptr,\n                                      usint slots = 0) const {\n        if (!value.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Cannot encode an empty value vector&quot;);\n\n        return MakeCKKSPackedPlaintextInternal(value, scaleDeg, level, params, slots);\n    }\n\n    /**\n   * MakeCKKSPackedPlaintext constructs a CKKSPackedEncoding in this context\n   * from a vector of real numbers\n   * @param value - input vector of real numbers\n   * @param scaleDeg - degree of scaling factor used to encode the vector\n   * @param level - level at each the vector will get encrypted\n   * @param params - parameters to be usef for the ciphertext\n   * @return plaintext\n   */\n    Plaintext MakeCKKSPackedPlaintext(const std::vector&lt;double&gt;&amp; value, size_t scaleDeg = 1, uint32_t level = 0,\n                                      const std::shared_ptr&lt;ParmType&gt; params = nullptr, usint slots = 0) const {\n        if (!value.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Cannot encode an empty value vector&quot;);\n\n        std::vector&lt;std::complex&lt;double&gt;&gt; complexValue(value.size());\n        std::transform(value.begin(), value.end(), complexValue.begin(),\n                       [](double da) { return std::complex&lt;double&gt;(da); });\n\n        return MakeCKKSPackedPlaintextInternal(complexValue, scaleDeg, level, params, slots);\n    }\n\n    /**\n   * GetPlaintextForDecrypt returns a new Plaintext to be used in decryption.\n   *\n   * @param pte Type of plaintext we want to return\n   * @param evp Element parameters\n   * @param ep Encoding parameters\n   * @return plaintext\n   */\n    static Plaintext GetPlaintextForDecrypt(PlaintextEncodings pte, std::shared_ptr&lt;ParmType&gt; evp, EncodingParams ep);\n\n    //------------------------------------------------------------------------------\n    // PKE Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * KeyGen generates a key pair using this algorithm&#x27;s KeyGen method\n   * @return a public/secret key pair\n   */\n    KeyPair&lt;Element&gt; KeyGen() {\n        return GetScheme()-&gt;KeyGen(GetContextForPointer(this), false);\n    }\n\n    /**\n   * NOT SUPPORTED BY ANY CRYPTO SCHEME NOW\n   * SparseKeyGen generates a key pair with special structure, and without full\n   * entropy, for use in special cases like Ring Reduction\n   * @return a public/secret key pair\n   */\n    KeyPair&lt;Element&gt; SparseKeyGen() {\n        return GetScheme()-&gt;KeyGen(GetContextForPointer(this), true);\n    }\n\n    /**\n   * Encrypt a plaintext using a given public key\n   * @param plaintext plaintext\n   * @param publicKey public key\n   * @return ciphertext (or null on failure)\n   */\n    Ciphertext&lt;Element&gt; Encrypt(const Plaintext&amp; plaintext, const PublicKey&lt;Element&gt; publicKey) const {\n        if (plaintext == nullptr)\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Input plaintext is nullptr&quot;);\n        CheckKey(publicKey);\n\n        Ciphertext&lt;Element&gt; ciphertext = GetScheme()-&gt;Encrypt(plaintext-&gt;GetElement&lt;Element&gt;(), publicKey);\n\n        if (ciphertext) {\n            ciphertext-&gt;SetEncodingType(plaintext-&gt;GetEncodingType());\n            ciphertext-&gt;SetScalingFactor(plaintext-&gt;GetScalingFactor());\n            ciphertext-&gt;SetScalingFactorInt(plaintext-&gt;GetScalingFactorInt());\n            ciphertext-&gt;SetNoiseScaleDeg(plaintext-&gt;GetNoiseScaleDeg());\n            ciphertext-&gt;SetLevel(plaintext-&gt;GetLevel());\n            ciphertext-&gt;SetSlots(plaintext-&gt;GetSlots());\n        }\n\n        return ciphertext;\n    }\n\n    /**\n   * Encrypt a plaintext using a given public key\n   * @param publicKey public key\n   * @param plaintext plaintext\n   * @return ciphertext (or null on failure)\n   */\n    Ciphertext&lt;Element&gt; Encrypt(const PublicKey&lt;Element&gt; publicKey, Plaintext plaintext) const {\n        return Encrypt(plaintext, publicKey);\n    }\n\n    /**\n   * Encrypt a plaintext using a given private key\n   * @param plaintext input plaintext\n   * @param privateKey private key\n   * @return ciphertext (or null on failure)\n   */\n    Ciphertext&lt;Element&gt; Encrypt(const Plaintext&amp; plaintext, const PrivateKey&lt;Element&gt; privateKey) const {\n        //    if (plaintext == nullptr)\n        //      &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Input plaintext is nullptr&quot;);\n        CheckKey(privateKey);\n\n        Ciphertext&lt;Element&gt; ciphertext = GetScheme()-&gt;Encrypt(plaintext-&gt;GetElement&lt;Element&gt;(), privateKey);\n\n        if (ciphertext) {\n            ciphertext-&gt;SetEncodingType(plaintext-&gt;GetEncodingType());\n            ciphertext-&gt;SetScalingFactor(plaintext-&gt;GetScalingFactor());\n            ciphertext-&gt;SetScalingFactorInt(plaintext-&gt;GetScalingFactorInt());\n            ciphertext-&gt;SetNoiseScaleDeg(plaintext-&gt;GetNoiseScaleDeg());\n            ciphertext-&gt;SetLevel(plaintext-&gt;GetLevel());\n            ciphertext-&gt;SetSlots(plaintext-&gt;GetSlots());\n        }\n\n        return ciphertext;\n    }\n\n    /**\n   * Encrypt a plaintext using a given private key\n   * @param privateKey private key\n   * @param plaintext input plaintext\n   * @return ciphertext (or null on failure)\n   */\n    Ciphertext&lt;Element&gt; Encrypt(const PrivateKey&lt;Element&gt; privateKey, Plaintext plaintext) const {\n        return Encrypt(plaintext, privateKey);\n    }\n\n    /**\n   * Decrypt a single ciphertext into the appropriate plaintext\n   *\n   * @param ciphertext - ciphertext to decrypt\n   * @param privateKey - decryption key\n   * @param plaintext - resulting plaintext object pointer is here\n   * @return\n   */\n    DecryptResult Decrypt(ConstCiphertext&lt;Element&gt; ciphertext, const PrivateKey&lt;Element&gt; privateKey,\n                          Plaintext* plaintext);\n\n    /**\n   * Decrypt a single ciphertext into the appropriate plaintext\n   *\n   * @param privateKey - decryption key\n   * @param ciphertext - ciphertext to decrypt\n   * @param plaintext - resulting plaintext object pointer is here\n   * @return\n   */\n    inline DecryptResult Decrypt(const PrivateKey&lt;Element&gt; privateKey, ConstCiphertext&lt;Element&gt; ciphertext,\n                                 Plaintext* plaintext) {\n        return Decrypt(ciphertext, privateKey, plaintext);\n    }\n\n    //------------------------------------------------------------------------------\n    // KeySwitch Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * KeySwitchGen creates a key that can be used with the OpenFHE KeySwitch\n   * operation\n   * @param oldPrivateKey input secrey key\n   * @param newPrivateKey output secret key\n   * @return new evaluation key\n   */\n    EvalKey&lt;Element&gt; KeySwitchGen(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                  const PrivateKey&lt;Element&gt; newPrivateKey) const {\n        CheckKey(oldPrivateKey);\n        CheckKey(newPrivateKey);\n\n        return GetScheme()-&gt;KeySwitchGen(oldPrivateKey, newPrivateKey);\n    }\n\n    /**\n   * KeySwitch - OpenFHE KeySwitch method\n   * @param ciphertext - ciphertext\n   * @param evalKey - evaluation key used for key switching\n   * @return new CiphertextImpl after applying key switch\n   */\n    Ciphertext&lt;Element&gt; KeySwitch(ConstCiphertext&lt;Element&gt; ciphertext, const EvalKey&lt;Element&gt; evalKey) const {\n        CheckCiphertext(ciphertext);\n        CheckKey(evalKey);\n\n        return GetScheme()-&gt;KeySwitch(ciphertext, evalKey);\n    }\n\n    /**\n   * KeySwitchInPlace - OpenFHE KeySwitchInPlace method\n   * @param ciphertext - ciphertext\n   * @param evalKey - evaluation key used for key switching\n   */\n    void KeySwitchInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const EvalKey&lt;Element&gt; evalKey) const {\n        CheckCiphertext(ciphertext);\n        CheckKey(evalKey);\n\n        GetScheme()-&gt;KeySwitchInPlace(ciphertext, evalKey);\n    }\n\n    //------------------------------------------------------------------------------\n    // SHE NEGATION Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * Negates a ciphertext\n   * @param ciphertext input ciphertext\n   * @return new ciphertext -ct\n   */\n    Ciphertext&lt;Element&gt; EvalNegate(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;EvalNegate(ciphertext);\n    }\n\n    /**\n   * In-place negation of a ciphertext\n   * @param ciphertext input ciphertext\n   */\n    void EvalNegateInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        CheckCiphertext(ciphertext);\n\n        GetScheme()-&gt;EvalNegateInPlace(ciphertext);\n    }\n\n    //------------------------------------------------------------------------------\n    // SHE ADDITION Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * Homomorphic addition of two ciphertexts\n   * @param ciphertext1 first addend\n   * @param ciphertext2 second addend\n   * @return the result as a new ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n        return GetScheme()-&gt;EvalAdd(ciphertext1, ciphertext2);\n    }\n\n    /**\n   * In-place homomorphic addition of two ciphertexts\n   * @param ciphertext1 first addend\n   * @param ciphertext2 second addend\n   * @return \\p ciphertext1 contains \\p ciphertext1 + \\p ciphertext2\n   */\n    void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n        GetScheme()-&gt;EvalAddInPlace(ciphertext1, ciphertext2);\n    }\n\n    /**\n   * Homomorphic addition of two mutable ciphertexts (they can be changed during the operation)\n   * @param ciphertext1 first addend\n   * @param ciphertext2 second addend\n   * @return the result as a new ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalAddMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n        return GetScheme()-&gt;EvalAddMutable(ciphertext1, ciphertext2);\n    }\n\n    /**\n   * In-place homomorphic addition of two mutable ciphertexts (they can be changed during the operation)\n   * @param ciphertext1 first addend\n   * @param ciphertext2 second addend\n   * @return \\p ciphertext1 contains \\p ciphertext1 + \\p ciphertext2\n   */\n    void EvalAddMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n        GetScheme()-&gt;EvalAddMutableInPlace(ciphertext1, ciphertext2);\n    }\n\n    /**\n   * EvalAdd - OpenFHE EvalAdd method for a ciphertext and plaintext\n   * @param ciphertext input ciphertext\n   * @param plaintext input plaintext\n   * @return new ciphertext for ciphertext + plaintext\n   */\n    Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const {\n        TypeCheck(ciphertext, plaintext);\n        plaintext-&gt;SetFormat(EVALUATION);\n        return GetScheme()-&gt;EvalAdd(ciphertext, plaintext);\n    }\n\n    /**\n   * EvalAdd - OpenFHE EvalAdd method for a ciphertext and plaintext\n   * @param plaintext input plaintext\n   * @param ciphertext input ciphertext\n   * @return new ciphertext for ciphertext + plaintext\n   */\n    Ciphertext&lt;Element&gt; EvalAdd(ConstPlaintext plaintext, ConstCiphertext&lt;Element&gt; ciphertext) const {\n        return EvalAdd(ciphertext, plaintext);\n    }\n\n    /**\n   * In-place addition for a ciphertext and plaintext\n   * @param ciphertext input ciphertext\n   * @param plaintext input plaintext\n   */\n    void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, ConstPlaintext plaintext) const {\n        TypeCheck(ciphertext, plaintext);\n        plaintext-&gt;SetFormat(EVALUATION);\n        GetScheme()-&gt;EvalAddInPlace(ciphertext, plaintext);\n    }\n\n    /**\n   * In-place addition for a ciphertext and plaintext\n   * @param plaintext input plaintext\n   * @param ciphertext input ciphertext\n   */\n    void EvalAddInPlace(ConstPlaintext plaintext, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        EvalAddInPlace(ciphertext, plaintext);\n    }\n\n    /**\n   * Homomorphic addition a mutable ciphertext and plaintext\n   * @param ciphertext input ciphertext\n   * @param plaintext input plaintext\n   * @return new ciphertext for ciphertext + plaintext\n   */\n    Ciphertext&lt;Element&gt; EvalAddMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        TypeCheck((ConstCiphertext&lt;Element&gt;)ciphertext, (ConstPlaintext)plaintext);\n        plaintext-&gt;SetFormat(EVALUATION);\n        return GetScheme()-&gt;EvalAddMutable(ciphertext, plaintext);\n    }\n\n    /**\n   * Homomorphic addition a mutable ciphertext and plaintext\n   * @param plaintext input plaintext\n   * @param ciphertext input ciphertext\n   * @return new ciphertext for ciphertext + plaintext\n   */\n    Ciphertext&lt;Element&gt; EvalAddMutable(Plaintext plaintext, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        return EvalAddMutable(ciphertext, plaintext);\n    }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, const NativeInteger&amp; constant) const {\n    //  return GetScheme()-&gt;EvalAdd(ciphertext, constant);\n    // }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // Ciphertext&lt;Element&gt; EvalAdd(const NativeInteger&amp; constant, ConstCiphertext&lt;Element&gt; ciphertext) const {\n    //  return EvalAdd(ciphertext, constant);\n    // }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const NativeInteger&amp; constant) const {\n    //  GetScheme()-&gt;EvalAddInPlace(ciphertext, constant);\n    // }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // void EvalAddInPlace(const NativeInteger&amp; constant, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n    //  EvalAddInPlace(ciphertext, constant);\n    // }\n\n    /**\n   * EvalAdd - OpenFHE EvalAdd method for a ciphertext and a real number.  Supported only in CKKS.\n   * @param ciphertext input ciphertext\n   * @param constant a real number\n   * @return new ciphertext for ciphertext + constant\n   */\n    Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        Ciphertext&lt;Element&gt; result =\n            constant &gt;= 0 ? GetScheme()-&gt;EvalAdd(ciphertext, constant) : GetScheme()-&gt;EvalSub(ciphertext, -constant);\n        return result;\n    }\n\n    /**\n   * EvalAdd - OpenFHE EvalAdd method for a ciphertext and a real number.  Supported only in CKKS.\n   * @param constant a real number\n   * @param ciphertext input ciphertext\n   * @return new ciphertext for ciphertext + constant\n   */\n    Ciphertext&lt;Element&gt; EvalAdd(double constant, ConstCiphertext&lt;Element&gt; ciphertext) const {\n        return EvalAdd(ciphertext, constant);\n    }\n\n    /**\n   * In-place addition of a ciphertext and a real number. Supported only in CKKS.\n   * @param ciphertext input ciphertext\n   * @param constant a real number\n   */\n    void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        if (constant == 0)\n            return;\n        if (constant &gt; 0) {\n            GetScheme()-&gt;EvalAddInPlace(ciphertext, constant);\n        }\n        else {\n            GetScheme()-&gt;EvalSubInPlace(ciphertext, std::fabs(constant));\n        }\n    }\n\n    /**\n   * In-place addition of a ciphertext and a real number.  Supported only in CKKS.\n   * @param constant a real number\n   * @param ciphertext input ciphertext\n   */\n    void EvalAddInPlace(double constant, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        EvalAddInPlace(ciphertext, constant);\n    }\n\n    //------------------------------------------------------------------------------\n    // SHE SUBTRACTION Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * Homomorphic subtraction of two ciphertexts\n   * @param ciphertext1 minuend\n   * @param ciphertext2 subtrahend\n   * @return the result as a new ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n        return GetScheme()-&gt;EvalSub(ciphertext1, ciphertext2);\n    }\n\n    /**\n   * In-place homomorphic subtraction of two ciphertexts\n   * @param ciphertext1 minuend\n   * @param ciphertext2 subtrahend\n   * @return the result as a new ciphertext\n   */\n    void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n        GetScheme()-&gt;EvalSubInPlace(ciphertext1, ciphertext2);\n    }\n\n    /**\n   * Homomorphic subtraction of two mutable ciphertexts\n   * @param ciphertext1 minuend\n   * @param ciphertext2 subtrahend\n   * @return the result as a new ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSubMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n        return GetScheme()-&gt;EvalSubMutable(ciphertext1, ciphertext2);\n    }\n\n    /**\n   * In-place homomorphic subtraction of two mutable ciphertexts\n   * @param ciphertext1 minuend\n   * @param ciphertext2 subtrahend\n   * @return the updated minuend\n   */\n    void EvalSubMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n        GetScheme()-&gt;EvalSubMutableInPlace(ciphertext1, ciphertext2);\n    }\n\n    /**\n   * Homomorphic subtraction of a ciphertext and plaintext\n   * @param ciphertext minuend\n   * @param plaintext subtrahend\n   * @return new ciphertext for ciphertext - plaintext\n   */\n    Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const {\n        TypeCheck(ciphertext, plaintext);\n        return GetScheme()-&gt;EvalSub(ciphertext, plaintext);\n    }\n\n    /**\n   * Homomorphic subtraction of a ciphertext and plaintext\n   * @param plaintext minuend\n   * @param ciphertext subtrahend\n   * @return new ciphertext for plaintext - ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSub(ConstPlaintext plaintext, ConstCiphertext&lt;Element&gt; ciphertext) const {\n        return EvalAdd(EvalNegate(ciphertext), plaintext);\n    }\n\n    /**\n   * Homomorphic subtraction of mutable ciphertext and plaintext\n   * @param ciphertext minuend\n   * @param plaintext subtrahend\n   * @return new ciphertext for ciphertext - plaintext\n   */\n    Ciphertext&lt;Element&gt; EvalSubMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        TypeCheck((ConstCiphertext&lt;Element&gt;)ciphertext, (ConstPlaintext)plaintext);\n        return GetScheme()-&gt;EvalSubMutable(ciphertext, plaintext);\n    }\n\n    /**\n   * Homomorphic subtraction of mutable ciphertext and plaintext\n   * @param plaintext minuend\n   * @param ciphertext subtrahend\n   * @return new ciphertext for plaintext - ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSubMutable(Plaintext plaintext, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        Ciphertext&lt;Element&gt; negated = EvalNegate(ciphertext);\n        Ciphertext&lt;Element&gt; result  = EvalAddMutable(negated, plaintext);\n        ciphertext                  = EvalNegate(negated);\n        return result;\n    }\n\n    /**\n   * Subtraction of a ciphertext and a real number. Supported only in CKKS.\n   * @param ciphertext input ciphertext\n   * @param constant a real number\n   * @return new ciphertext for ciphertext - constant\n   */\n    Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        Ciphertext&lt;Element&gt; result =\n            constant &gt;= 0 ? GetScheme()-&gt;EvalSub(ciphertext, constant) : GetScheme()-&gt;EvalAdd(ciphertext, -constant);\n        return result;\n    }\n\n    /**\n   * Subtraction of a ciphertext and a real number.  Supported only in CKKS.\n   * @param constant a real number\n   * @param ciphertext input ciphertext\n   * @return new ciphertext for constant - ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSub(double constant, ConstCiphertext&lt;Element&gt; ciphertext) const {\n        return EvalAdd(EvalNegate(ciphertext), constant);\n    }\n\n    /**\n   * In-place subtraction of a ciphertext and a real number.  Supported only in CKKS.\n   * @param ciphertext input ciphertext\n   * @param constant a real number\n   */\n    void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        if (constant &gt;= 0) {\n            GetScheme()-&gt;EvalSubInPlace(ciphertext, constant);\n        }\n        else {\n            GetScheme()-&gt;EvalAddInPlace(ciphertext, -constant);\n        }\n    }\n\n    /**\n   * In-placve subtraction of ciphertext from a real number.  Supported only in CKKS.\n   * @param constant a real number\n   * @param ciphertext input ciphertext\n   */\n    void EvalSubInPlace(double constant, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        EvalNegateInPlace(ciphertext);\n        EvalAddInPlace(ciphertext, constant);\n    }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, const NativeInteger&amp; constant) const {\n    //  return GetScheme()-&gt;EvalSub(ciphertext, constant);\n    // }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // Ciphertext&lt;Element&gt; EvalSub(const NativeInteger&amp; constant, ConstCiphertext&lt;Element&gt; ciphertext) const {\n    //  return EvalAdd(EvalNegate(ciphertext), constant);\n    // }\n\n    //  void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const NativeInteger&amp; constant) const {\n    //    GetScheme()-&gt;EvalSubInPlace(ciphertext, constant);\n    //  }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // void EvalSubInPlace(const NativeInteger&amp; constant, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n    //  EvalNegateInPlace(ciphertext);\n    //  EvalAddInPlace(ciphertext, constant);\n    // }\n\n    //------------------------------------------------------------------------------\n    // SHE MULTIPLICATION Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * EvalMultKeyGen creates a relinearization key (for s^2) that can be used with the OpenFHE EvalMult\n   * operator\n   * the new evaluation key is stored in cryptocontext\n   * @param key secret key\n   */\n    void EvalMultKeyGen(const PrivateKey&lt;Element&gt; key) {\n        if (key == nullptr || Mismatched(key-&gt;GetCryptoContext()))\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Key passed to EvalMultKeyGen were not generated with this crypto context&quot;);\n\n        EvalKey&lt;Element&gt; k = GetScheme()-&gt;EvalMultKeyGen(key);\n\n        GetAllEvalMultKeys()[k-&gt;GetKeyTag()] = {k};\n    }\n\n    /**\n   * EvalMultsKeyGen creates a vector evalmult keys that can be used with the\n   * OpenFHE EvalMult operator 1st key (for s^2) is used for multiplication of\n   * ciphertexts of depth 1 2nd key (for s^3) is used for multiplication of\n   * ciphertexts of depth 2, etc.\n   * a vector of new evaluation keys is stored in crytpocontext\n   *\n   * @param key secret key\n   */\n    void EvalMultKeysGen(const PrivateKey&lt;Element&gt; key) {\n        if (key == nullptr || Mismatched(key-&gt;GetCryptoContext()))\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Key passed to EvalMultsKeyGen were not generated with this crypto context&quot;);\n\n        const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeys = GetScheme()-&gt;EvalMultKeysGen(key);\n\n        GetAllEvalMultKeys()[evalKeys[0]-&gt;GetKeyTag()] = evalKeys;\n    }\n\n    /**\n   * EvalMult - OpenFHE EvalMult method for a pair of ciphertexts (uses a relinearization key from the crypto context)\n   * @param ciphertext1 multiplier\n   * @param ciphertext2 multiplicand\n   * @return new ciphertext for ciphertext1 * ciphertext2\n   */\n    Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertext1-&gt;GetKeyTag());\n        if (!evalKeyVec.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Evaluation key has not been generated for EvalMult&quot;);\n        }\n\n        return GetScheme()-&gt;EvalMult(ciphertext1, ciphertext2, evalKeyVec[0]);\n    }\n\n    /**\n   * EvalMult - OpenFHE EvalMult method for a pair of mutable ciphertexts (uses a relinearization key from the crypto context)\n   * @param ciphertext1 multiplier\n   * @param ciphertext2 multiplicand\n   * @return new ciphertext for ciphertext1 * ciphertext2\n   */\n    Ciphertext&lt;Element&gt; EvalMultMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertext1-&gt;GetKeyTag());\n        if (!evalKeyVec.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Evaluation key has not been generated for EvalMultMutable&quot;);\n        }\n\n        return GetScheme()-&gt;EvalMultMutable(ciphertext1, ciphertext2, evalKeyVec[0]);\n    }\n\n    /**\n   * In-place EvalMult method for a pair of mutable ciphertexts (uses a relinearization key from the crypto context)\n   * @param ciphertext1 multiplier\n   * @param ciphertext2 multiplicand\n   */\n    void EvalMultMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertext1-&gt;GetKeyTag());\n        if (!evalKeyVec.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Evaluation key has not been generated for EvalMultMutable&quot;);\n        }\n\n        GetScheme()-&gt;EvalMultMutableInPlace(ciphertext1, ciphertext2, evalKeyVec[0]);\n    }\n\n    /**\n   * Efficient homomorphic squaring of a ciphertext - uses a relinearization key stored in the crypto context\n   * @param ciphertext input ciphertext\n   * @return squared ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSquare(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        CheckCiphertext(ciphertext);\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertext-&gt;GetKeyTag());\n        if (!evalKeyVec.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Evaluation key has not been generated for EvalMult&quot;);\n        }\n\n        return GetScheme()-&gt;EvalSquare(ciphertext, evalKeyVec[0]);\n    }\n\n    /**\n   * Efficient homomorphic squaring of a mutable ciphertext - uses a relinearization key stored in the crypto context\n   * @param ciphertext input ciphertext\n   * @return squared ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSquareMutable(Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        CheckCiphertext(ciphertext);\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertext-&gt;GetKeyTag());\n        if (!evalKeyVec.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Evaluation key has not been generated for EvalMultMutable&quot;);\n        }\n\n        return GetScheme()-&gt;EvalSquareMutable(ciphertext, evalKeyVec[0]);\n    }\n\n    /**\n   * In-place homomorphic squaring of a mutable ciphertext - uses a relinearization key stored in the crypto context\n   * @param ciphertext input ciphertext\n   * @return squared ciphertext\n   */\n    void EvalSquareInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        CheckCiphertext(ciphertext);\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertext-&gt;GetKeyTag());\n        if (!evalKeyVec.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Evaluation key has not been generated for EvalMultMutable&quot;);\n        }\n\n        GetScheme()-&gt;EvalSquareInPlace(ciphertext, evalKeyVec[0]);\n    }\n\n    /**\n   * Homomorphic multiplication of two ciphertexts withour relinearization\n   * @param ciphertext1 multiplier\n   * @param ciphertext2 multiplicand\n   * @return new ciphertext for ciphertext1 * ciphertext2\n   */\n    Ciphertext&lt;Element&gt; EvalMultNoRelin(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                        ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n        return GetScheme()-&gt;EvalMult(ciphertext1, ciphertext2);\n    }\n\n    /**\n   * Function for relinearization of a ciphertext to the lowest level (with 2 polynomials per ciphertext).\n   * @param ciphertext input ciphertext.\n   * @return relinearized ciphertext\n   */\n    Ciphertext&lt;Element&gt; Relinearize(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        // input parameter check\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Input ciphertext is nullptr&quot;);\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertext-&gt;GetKeyTag());\n\n        if (evalKeyVec.size() &lt; (ciphertext-&gt;GetElements().size() - 2)) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error,\n                          &quot;Insufficient value was used for maxRelinSkDeg to generate &quot;\n                          &quot;keys for EvalMult&quot;);\n        }\n\n        return GetScheme()-&gt;Relinearize(ciphertext, evalKeyVec);\n    }\n\n    /**\n   * In-place relinearization of a ciphertext to the lowest level (with 2 polynomials per ciphertext).\n   * @param ciphertext input ciphertext.\n   */\n    void RelinearizeInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        // input parameter check\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Input ciphertext is nullptr&quot;);\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertext-&gt;GetKeyTag());\n        if (evalKeyVec.size() &lt; (ciphertext-&gt;GetElements().size() - 2)) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error,\n                          &quot;Insufficient value was used for maxRelinSkDeg to generate &quot;\n                          &quot;keys for EvalMult&quot;);\n        }\n\n        GetScheme()-&gt;RelinearizeInPlace(ciphertext, evalKeyVec);\n    }\n\n    /**\n   * Homomorphic multiplication of two ciphertexts followed by relinearization to the lowest level\n   * @param ciphertext1 first input ciphertext.\n   * @param ciphertext2 second input ciphertext.\n   * @return new ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalMultAndRelinearize(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                               ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        // input parameter check\n        if (!ciphertext1 || !ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Input ciphertext is nullptr&quot;);\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertext1-&gt;GetKeyTag());\n\n        if (evalKeyVec.size() &lt; (ciphertext1-&gt;GetElements().size() + ciphertext2-&gt;GetElements().size() - 3)) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error,\n                          &quot;Insufficient value was used for maxRelinSkDeg to generate &quot;\n                          &quot;keys for EvalMult&quot;);\n        }\n\n        return GetScheme()-&gt;EvalMultAndRelinearize(ciphertext1, ciphertext2, evalKeyVec);\n    }\n\n    /**\n   * Multiplication of a ciphertext by a plaintext\n   * @param ciphertext multiplier\n   * @param plaintext multiplicand\n   * @return the result of multiplication\n   */\n    Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const {\n        TypeCheck(ciphertext, plaintext);\n        return GetScheme()-&gt;EvalMult(ciphertext, plaintext);\n    }\n\n    /**\n   * Multiplication of a plaintext by a ciphertext\n   * @param plaintext multiplier\n   * @param ciphertext multiplicand\n   * @return the result of multiplication\n   */\n    Ciphertext&lt;Element&gt; EvalMult(ConstPlaintext plaintext, ConstCiphertext&lt;Element&gt; ciphertext) const {\n        return EvalMult(ciphertext, plaintext);\n    }\n\n    /**\n   * Multiplication of mutable ciphertext and plaintext\n   * @param ciphertext multiplier\n   * @param plaintext multiplicand\n   * @return the result of multiplication\n   */\n    Ciphertext&lt;Element&gt; EvalMultMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        TypeCheck(ciphertext, plaintext);\n        return GetScheme()-&gt;EvalMultMutable(ciphertext, plaintext);\n    }\n\n    /**\n   * Multiplication of mutable plaintext and ciphertext\n   * @param plaintext multiplier\n   * @param ciphertext multiplicand\n   * @return the result of multiplication\n   */\n    Ciphertext&lt;Element&gt; EvalMultMutable(Plaintext plaintext, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        return EvalMultMutable(ciphertext, plaintext);\n    }\n\n    // template &lt;typename T = const NativeInteger,\n    //    typename std::enable_if &lt;!std::is_same&lt;ConstCiphertext&lt;Element&gt;, T&gt;::value, bool&gt;::type = true&gt;\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext, const NativeInteger&amp; constant) const {\n    //  if (!ciphertext) {\n    //    &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Input ciphertext is nullptr&quot;);\n    //  }\n    //  return GetScheme()-&gt;EvalMult(ciphertext, constant);\n    // }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // Ciphertext&lt;Element&gt; EvalMult(const NativeInteger&amp; constant, ConstCiphertext&lt;Element&gt; ciphertext) const {\n    //  return EvalMult(ciphertext, constant);\n    // }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const NativeInteger&amp; constant) const {\n    //  if (!ciphertext) {\n    //    &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Input ciphertext is nullptr&quot;);\n    //  }\n\n    //  GetScheme()-&gt;EvalMultInPlace(ciphertext, constant);\n    // }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // void EvalMultInPlace(const NativeInteger&amp; constant, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n    //  EvalMultInPlace(ciphertext, constant);\n    // }\n\n    /**\n   * Multiplication of a ciphertext by a real number.  Supported only in CKKS.\n   * @param ciphertext multiplier\n   * @param constant multiplicand\n   * @return the result of multiplication\n   */\n    Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        if (!ciphertext) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Input ciphertext is nullptr&quot;);\n        }\n        return GetScheme()-&gt;EvalMult(ciphertext, constant);\n    }\n\n    /**\n   * Multiplication of a ciphertext by a real number.  Supported only in CKKS.\n   * @param constant multiplier\n   * @param ciphertext multiplicand\n   * @return the result of multiplication\n   */\n    inline Ciphertext&lt;Element&gt; EvalMult(double constant, ConstCiphertext&lt;Element&gt; ciphertext) const {\n        return EvalMult(ciphertext, constant);\n    }\n\n    /**\n   * In-place multiplication of a ciphertext by a real number. Supported only in CKKS.\n   * @param ciphertext multiplier\n   * @param constant multiplicand\n   */\n    void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        if (!ciphertext) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Input ciphertext is nullptr&quot;);\n        }\n\n        GetScheme()-&gt;EvalMultInPlace(ciphertext, constant);\n    }\n\n    /**\n   * In-place multiplication of a ciphertext by a real number. Supported only in CKKS.\n   * @param constant multiplier (real number)\n   * @param ciphertext multiplicand\n   */\n    inline void EvalMultInPlace(double constant, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        EvalMultInPlace(ciphertext, constant);\n    }\n\n    //------------------------------------------------------------------------------\n    // SHE AUTOMORPHISM Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * Generate automophism keys for a given private key; Uses the private key for\n   * encryption\n   *\n   * @param privateKey private key.\n   * @param indexList list of automorphism indices to be computed\n   * @return returns the evaluation keys\n   */\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalAutomorphismKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::vector&lt;usint&gt;&amp; indexList) const {\n        CheckKey(privateKey);\n        if (!indexList.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input index vector is empty&quot;);\n\n        return GetScheme()-&gt;EvalAutomorphismKeyGen(privateKey, indexList);\n    }\n\n    /**\n   * NOT USED BY ANY CRYPTO SCHEME: Generate automophism keys for a public and private key\n   */\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalAutomorphismKeyGen(\n        const PublicKey&lt;Element&gt; publicKey, const PrivateKey&lt;Element&gt; privateKey,\n        const std::vector&lt;usint&gt;&amp; indexList) const {\n        CheckKey(publicKey);\n        CheckKey(privateKey);\n        if (!indexList.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input index vector is empty&quot;);\n\n        return GetScheme()-&gt;EvalAutomorphismKeyGen(publicKey, privateKey, indexList);\n    }\n\n    /**\n   * Function for evaluating automorphism of ciphertext at index i\n   *\n   * @param ciphertext the input ciphertext.\n   * @param i automorphism index\n   * @param &amp;evalKeys - reference to the vector of evaluation keys generated by\n   * EvalAutomorphismKeyGen.\n   * @return resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalAutomorphism(ConstCiphertext&lt;Element&gt; ciphertext, usint i,\n                                         const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap,\n                                         CALLER_INFO_ARGS_HDR) const {\n        CheckCiphertext(ciphertext);\n\n        if (evalKeyMap.empty()) {\n            std::string errorMsg(std::string(&quot;Empty input key map&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(type_error, errorMsg);\n        }\n\n        auto key = evalKeyMap.find(i);\n\n        if (key == evalKeyMap.end()) {\n            std::string errorMsg(std::string(&quot;Could not find an EvalKey for index &quot;) + std::to_string(i) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(type_error, errorMsg);\n        }\n\n        auto evalKey = key-&gt;second;\n\n        CheckKey(evalKey);\n\n        return GetScheme()-&gt;EvalAutomorphism(ciphertext, i, evalKeyMap);\n    }\n\n    /**\n   * Finds an automorphism index for a given vector index using a scheme-specific algorithm\n   * @param idx regular vector index\n   * @return the automorphism index\n   */\n    usint FindAutomorphismIndex(const usint idx) const {\n        const auto cryptoParams  = GetCryptoParameters();\n        const auto elementParams = cryptoParams-&gt;GetElementParams();\n        uint32_t m               = elementParams-&gt;GetCyclotomicOrder();\n        return GetScheme()-&gt;FindAutomorphismIndex(idx, m);\n    }\n\n    /**\n   * Finds automorphism indices for a given list of vector indices using a scheme-specific algorithm\n   * @param idxList vector of indices\n   * @return a vector of automorphism indices\n   */\n    std::vector&lt;usint&gt; FindAutomorphismIndices(const std::vector&lt;usint&gt;&amp; idxList) const {\n        std::vector&lt;usint&gt; newIndices;\n        newIndices.reserve(idxList.size());\n        for (const auto idx : idxList) {\n            newIndices.emplace_back(FindAutomorphismIndex(idx));\n        }\n        return newIndices;\n    }\n\n    /**\n   * Rotates a ciphertext by an index (positive index is a left shift, negative index is a right shift).\n   * Uses a rotation key stored in a crypto context.\n   * Calls EvalAtIndex under the hood.\n   * @param ciphertext input ciphertext\n   * @param index rotation index\n   * @return a rotated ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalRotate(ConstCiphertext&lt;Element&gt; ciphertext, int32_t index) const {\n        CheckCiphertext(ciphertext);\n\n        auto evalKeyMap = GetEvalAutomorphismKeyMap(ciphertext-&gt;GetKeyTag());\n        return GetScheme()-&gt;EvalAtIndex(ciphertext, index, evalKeyMap);\n    }\n\n    /**\n   * EvalFastRotationPrecompute implements the precomputation step of\n   * hoisted automorphisms.\n   *\n   * Please refer to Section 5 of Halevi and Shoup, &quot;Faster Homomorphic\n   * linear transformations in HELib.&quot; for more details, link:\n   * https://eprint.iacr.org/2018/244.\n   *\n   * Generally, automorphisms are performed with three steps: (1) the\n   * automorphism is applied on the ciphertext, (2) the automorphed values are\n   * decomposed into digits, and (3) key switching is applied to make it\n   * possible to further compute on the ciphertext.\n   *\n   * Hoisted automorphisms is a technique that performs the digit decomposition\n   * for the original ciphertext first, and then performs the automorphism and\n   * the key switching on the decomposed digits. The benefit of this is that the\n   * digit decomposition is independent of the automorphism rotation index, so\n   * it can be reused for multiple different indices. This can greatly improve\n   * performance when we have to compute many automorphisms on the same\n   * ciphertext. This routinely happens when we do permutations (EvalPermute).\n   *\n   * EvalFastRotationPrecompute implements the digit decomposition step of\n   * hoisted automorphisms.\n   *\n   * @param ciphertext the input ciphertext on which to do the precomputation (digit\n   * decomposition)\n   */\n    std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EvalFastRotationPrecompute(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        return GetScheme()-&gt;EvalFastRotationPrecompute(ciphertext);\n    }\n\n    /**\n   * EvalFastRotation implements the automorphism and key switching step of\n   * hoisted automorphisms.\n   *\n   * Please refer to Section 5 of Halevi and Shoup, &quot;Faster Homomorphic\n   * linear transformations in HELib.&quot; for more details, link:\n   * https://eprint.iacr.org/2018/244.\n   *\n   * Generally, automorphisms are performed with three steps: (1) the\n   * automorphism is applied on the ciphertext, (2) the automorphed values are\n   * decomposed into digits, and (3) key switching is applied to make it\n   * possible to further compute on the ciphertext.\n   *\n   * Hoisted automorphisms is a technique that performs the digit decomposition\n   * for the original ciphertext first, and then performs the automorphism and\n   * the key switching on the decomposed digits. The benefit of this is that the\n   * digit decomposition is independent of the automorphism rotation index, so\n   * it can be reused for multiple different indices. This can greatly improve\n   * performance when we have to compute many automorphisms on the same\n   * ciphertext. This routinely happens when we do permutations (EvalPermute).\n   *\n   * EvalFastRotation implements the automorphism and key swithcing step of\n   * hoisted automorphisms.\n   *\n   * This method assumes that all required rotation keys exist. This may not be\n   * true if we are using baby-step/giant-step key switching. Please refer to\n   * Section 5.1 of the above reference and EvalPermuteBGStepHoisted to see how\n   * to deal with this issue.\n   *\n   * @param ciphertext the input ciphertext to perform the automorphism on\n   * @param index the index of the rotation. Positive indices correspond to left\n   * rotations and negative indices correspond to right rotations.\n   * @param m is the cyclotomic order\n   * @param digits the digit decomposition created by EvalFastRotationPrecompute\n   * at the precomputation step.\n   */\n    Ciphertext&lt;Element&gt; EvalFastRotation(ConstCiphertext&lt;Element&gt; ciphertext, const usint index, const usint m,\n                                         const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits) const {\n        return GetScheme()-&gt;EvalFastRotation(ciphertext, index, m, digits);\n    }\n\n    /**\n   * Only supported for hybrid key switching.\n   * Performs fast (hoisted) rotation and returns the results\n   * in the extended CRT basis P*Q\n   *\n   * @param ciphertext input ciphertext\n   * @param index the rotation index.\n   * @param digits the precomputed digits for the ciphertext\n   * @param addFirst if true, the the first element c0 is also computed (otherwise ignored)\n   * @return resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalFastRotationExt(ConstCiphertext&lt;Element&gt; ciphertext, usint index,\n                                            const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits, bool addFirst) const {\n        auto evalKeyMap = GetEvalAutomorphismKeyMap(ciphertext-&gt;GetKeyTag());\n\n        return GetScheme()-&gt;EvalFastRotationExt(ciphertext, index, digits, addFirst, evalKeyMap);\n    }\n\n    /**\n   * Only supported for hybrid key switching.\n   * Takes a ciphertext in the extended basis P*Q\n   * and scales down to Q.\n   *\n   * @param ciphertext input ciphertext in the extended basis\n   * @return resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; KeySwitchDown(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        return GetScheme()-&gt;KeySwitchDown(ciphertext);\n    }\n\n    /**\n   * Only supported for hybrid key switching.\n   * Scales down the polynomial c0 from extended basis P*Q to Q.\n   *\n   * @param ciphertext input ciphertext in the extended basis\n   * @return resulting polynomial\n   */\n    Element KeySwitchDownFirstElement(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        return GetScheme()-&gt;KeySwitchDownFirstElement(ciphertext);\n    }\n\n    /**\n   * Only supported for hybrid key switching.\n   * Takes a ciphertext in the normal basis Q\n   * and extends it to extended basis P*Q.\n   *\n   * @param ciphertext input ciphertext in basis Q\n   * @return resulting ciphertext in basis P*Q\n   */\n    Ciphertext&lt;Element&gt; KeySwitchExt(ConstCiphertext&lt;Element&gt; ciphertext, bool addFirst) const {\n        return GetScheme()-&gt;KeySwitchExt(ciphertext, addFirst);\n    }\n\n    /**\n   * EvalAtIndexKeyGen generates evaluation keys for a list of rotation indices\n   *\n   * @param privateKey private key.\n   * @param indexList list of indices.\n   * @param publicKey public key (used in NTRU schemes). Not used anymore.\n   */\n    void EvalAtIndexKeyGen(const PrivateKey&lt;Element&gt; privateKey, const std::vector&lt;int32_t&gt;&amp; indexList,\n                           const PublicKey&lt;Element&gt; publicKey = nullptr);\n\n    /**\n   * EvalRotateKeyGen generates evaluation keys for a list of rotation indices.\n   * Calls EvalAtIndexKeyGen under the hood.\n   *\n   * @param privateKey private key.\n   * @param indexList list of indices.\n   * @param publicKey public key (used in NTRU schemes).\n   */\n    void EvalRotateKeyGen(const PrivateKey&lt;Element&gt; privateKey, const std::vector&lt;int32_t&gt;&amp; indexList,\n                          const PublicKey&lt;Element&gt; publicKey = nullptr) {\n        EvalAtIndexKeyGen(privateKey, indexList, publicKey);\n    };\n\n    /**\n   * Rotates a ciphertext by an index (positive index is a left shift, negative index is a right shift).\n   * Uses a rotation key stored in a crypto context.\n   * @param ciphertext input ciphertext\n   * @param index rotation index\n   * @return a rotated ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalAtIndex(ConstCiphertext&lt;Element&gt; ciphertext, int32_t index) const;\n\n    //------------------------------------------------------------------------------\n    // SHE Leveled Methods Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * ComposedEvalMult - calls multiplication, relinearization, and then modulus switching/rescaling.\n   * Uses a relinearization key stored in the crypto context.\n   * @param ciphertext1 - first ciphertext\n   * @param ciphertext2 - second ciphertext\n   */\n    Ciphertext&lt;Element&gt; ComposedEvalMult(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                         ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        CheckCiphertext(ciphertext1);\n        CheckCiphertext(ciphertext2);\n\n        auto evalKeyVec = GetEvalMultKeyVector(ciphertext1-&gt;GetKeyTag());\n        if (!evalKeyVec.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Evaluation key has not been generated for EvalMult&quot;);\n        }\n\n        return GetScheme()-&gt;ComposedEvalMult(ciphertext1, ciphertext2, evalKeyVec[0]);\n    }\n\n    /**\n   * Rescale - An alias for OpenFHE ModReduce method.\n   * This is because ModReduce is called Rescale in CKKS.\n   *\n   * @param ciphertext - ciphertext\n   * @return rescaled ciphertext\n   */\n    Ciphertext&lt;Element&gt; Rescale(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;ModReduce(ciphertext, BASE_NUM_LEVELS_TO_DROP);\n    }\n\n    /**\n   * Rescale - An alias for OpenFHE ModReduceInPlace method.\n   * This is because ModReduceInPlace is called RescaleInPlace in CKKS.\n   *\n   * @param ciphertext - ciphertext to be rescaled in-place\n   */\n    void RescaleInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        CheckCiphertext(ciphertext);\n\n        GetScheme()-&gt;ModReduceInPlace(ciphertext, BASE_NUM_LEVELS_TO_DROP);\n    }\n\n    /**\n   * ModReduce - OpenFHE ModReduce method used only for BGV/CKKS.\n   * @param ciphertext - ciphertext\n   * @return mod reduced ciphertext\n   */\n    Ciphertext&lt;Element&gt; ModReduce(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;ModReduce(ciphertext, BASE_NUM_LEVELS_TO_DROP);\n    }\n\n    /**\n   * ModReduce - OpenFHE ModReduceInPlace method used only for BGV/CKKS.\n   * @param ciphertext - ciphertext to be mod-reduced in-place\n   */\n    void ModReduceInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        CheckCiphertext(ciphertext);\n\n        GetScheme()-&gt;ModReduceInPlace(ciphertext, BASE_NUM_LEVELS_TO_DROP);\n    }\n\n    /**\n   * LevelReduce - drops unnecessary RNS limbs (levels) from the ciphertext and evaluation key\n   * @param ciphertext input ciphertext. Supported only in BGV/CKKS.\n   * @param evalKey input evaluation key (modified in place)\n   * @returns the ciphertext with reduced number opf RNS limbs\n   */\n    Ciphertext&lt;Element&gt; LevelReduce(ConstCiphertext&lt;Element&gt; ciphertext, const EvalKey&lt;Element&gt; evalKey,\n                                    size_t levels = 1) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;LevelReduce(ciphertext, evalKey, levels);\n    }\n\n    /**\n   * LevelReduceInPlace - drops unnecessary RNS limbs (levels) from the ciphertext and evaluation key. Supported only in BGV/CKKS.\n   * @param ciphertext input ciphertext (modified in place)\n   * @param evalKey input evaluation key (modified in place)\n   */\n    void LevelReduceInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const EvalKey&lt;Element&gt; evalKey, size_t levels = 1) const {\n        CheckCiphertext(ciphertext);\n        if (levels &lt;= 0) {\n            return;\n        }\n        GetScheme()-&gt;LevelReduceInPlace(ciphertext, evalKey, levels);\n    }\n    /**\n   * Compress - Reduces the size of ciphertext modulus to minimize the\n   * communication cost before sending the encrypted result for decryption.\n   * Similar to ModReduce but for BFV where ModReduce is not exposed directly.\n   * @param ciphertext - input ciphertext\n   * @param numTowers - number of RNS limbs after compressing (default is 1)\n   * @return compressed ciphertext\n   */\n    Ciphertext&lt;Element&gt; Compress(ConstCiphertext&lt;Element&gt; ciphertext, uint32_t towersLeft = 1) const {\n        if (ciphertext == nullptr)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;input ciphertext is invalid (has no data)&quot;);\n\n        return GetScheme()-&gt;Compress(ciphertext, towersLeft);\n    }\n\n    //------------------------------------------------------------------------------\n    // Advanced SHE Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * EvalAddMany - Evaluate addition on a vector of ciphertexts.\n   * It computes the addition in a binary tree manner.\n   *\n   * @param ctList is the list of ciphertexts.\n   * @return new ciphertext.\n   */\n    Ciphertext&lt;Element&gt; EvalAddMany(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const {\n        // input parameter check\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Empty input ciphertext vector&quot;);\n\n        if (ciphertextVec.size() == 1) {\n            return ciphertextVec[0];\n        }\n\n        return GetScheme()-&gt;EvalAddMany(ciphertextVec);\n    }\n\n    /**\n   * EvalAddManyInPlace - Evaluate addition on a vector of ciphertexts.\n   * Addition is computed in a binary tree manner. Difference with EvalAddMany\n   * is that EvalAddManyInPlace uses the input ciphertext vector to store\n   * intermediate results, to avoid the overhead of using extra tepmorary\n   * space.\n   *\n   * @param ctList is the list of ciphertexts.\n   * @return new ciphertext.\n   */\n    Ciphertext&lt;Element&gt; EvalAddManyInPlace(std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const {\n        // input parameter check\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Empty input ciphertext vector&quot;);\n\n        return GetScheme()-&gt;EvalAddManyInPlace(ciphertextVec);\n    }\n\n    /**\n   * EvalMultMany - OpenFHE function for evaluating multiplication on\n   * ciphertext followed by relinearization operation (at the end). It computes\n   * the multiplication in a binary tree manner. Also, it reduces the number of\n   * elements in the ciphertext to two after each multiplication.\n   * Currently it assumes that the consecutive two input arguments have\n   * total number of ring elements smaller than the supported one (for the secret key degree used by EvalMultsKeyGen). Otherwise, it throws an\n   * error.\n   *\n   * @param ciphertextVec  is the ciphertext list.\n   * @return new ciphertext.\n   */\n    Ciphertext&lt;Element&gt; EvalMultMany(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const {\n        // input parameter check\n        if (!ciphertextVec.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Empty input ciphertext vector&quot;);\n        }\n\n        if (ciphertextVec.size() == 1) {\n            return ciphertextVec[0];\n        }\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertextVec[0]-&gt;GetKeyTag());\n        if (evalKeyVec.size() &lt; (ciphertextVec[0]-&gt;GetElements().size() - 2)) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Insufficient value was used for maxRelinSkDeg to generate keys&quot;);\n        }\n\n        return GetScheme()-&gt;EvalMultMany(ciphertextVec, evalKeyVec);\n    }\n\n    //------------------------------------------------------------------------------\n    // Advanced SHE LINEAR WEIGHTED SUM\n    //------------------------------------------------------------------------------\n\n    /**\n   * EvalLinearWSum - OpenFHE EvalLinearWSum method to compute a linear\n   * weighted sum. Supported only in CKKS.\n   *\n   * @param ciphertextVec&amp; a list of ciphertexts\n   * @param constantVec&amp; a list of weights\n   * @return new ciphertext containing the weighted sum\n   */\n    Ciphertext&lt;Element&gt; EvalLinearWSum(std::vector&lt;ConstCiphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                       const std::vector&lt;double&gt;&amp; constantVec) const {\n        return GetScheme()-&gt;EvalLinearWSum(ciphertextVec, constantVec);\n    }\n\n    /**\n   * EvalLinearWSum - OpenFHE EvalLinearWSum method to compute a linear\n   * weighted sum. Supported only in CKKS.\n   *\n   * @param constantVec&amp; a list of weights\n   * @param ciphertextVec&amp; a list of ciphertexts\n   * @return new ciphertext containing the weighted sum\n   */\n    Ciphertext&lt;Element&gt; EvalLinearWSum(const std::vector&lt;double&gt;&amp; constantsVec,\n                                       std::vector&lt;ConstCiphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const {\n        return EvalLinearWSum(ciphertextVec, constantsVec);\n    }\n\n    /**\n   * EvalLinearWSum - OpenFHE EvalLinearWSum method to compute a linear\n   * weighted sum (mutable version). Supported only in CKKS.\n   *\n   * @param ciphertextVec&amp; ciphertexts a list of mutable ciphertexts\n   * @param constantVec&amp; constants a list of weights\n   * @return new ciphertext containing the weighted sum\n   */\n    Ciphertext&lt;Element&gt; EvalLinearWSumMutable(std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                              const std::vector&lt;double&gt;&amp; constantsVec) const {\n        return GetScheme()-&gt;EvalLinearWSumMutable(ciphertextVec, constantsVec);\n    }\n\n    /**\n   * EvalLinearWSum - OpenFHE EvalLinearWSum method to compute a linear\n   * weighted sum (mutable version). Supported only in CKKS.\n   *\n   * @param constantVec&amp; constants a list of weights\n   * @param ciphertextVec&amp; ciphertexts a list of mutable ciphertexts\n   * @return new ciphertext containing the weighted sum\n   */\n    Ciphertext&lt;Element&gt; EvalLinearWSumMutable(const std::vector&lt;double&gt;&amp; constantsVec,\n                                              std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const {\n        return EvalLinearWSumMutable(ciphertextVec, constantsVec);\n    }\n\n    //------------------------------------------------------------------------------\n    // Advanced SHE EVAL POLYNOMIAL\n    //------------------------------------------------------------------------------\n\n    /**\n   * Method for evaluation for polynomials represented as power series. Supported only in CKKS.\n   * If the degree of the polynomial is less than 5, use\n   * EvalPolyLinear (naive linear method), otherwise, use EvalPolyPS (Paterson-Stockmeyer method).\n   *\n   * @param ciphertext input ciphertext\n   * @param &amp;coefficients is the vector of coefficients in the polynomial; the\n   * size of the vector is the degree of the polynomial + 1\n   * @return the result of polynomial evaluation.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalPoly(ConstCiphertext&lt;Element&gt; ciphertext,\n                                         const std::vector&lt;double&gt;&amp; coefficients) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;EvalPoly(ciphertext, coefficients);\n    }\n\n    /**\n   * Naive method for polynomial evaluation for polynomials represented in the power\n   * series (fast only for small-degree polynomials; less than 10). Uses a binary tree computation of\n   * the polynomial powers. Supported only in CKKS.\n   *\n   * @param cipherText input ciphertext\n   * @param &amp;coefficients is the vector of coefficients in the polynomial; the\n   * size of the vector is the degree of the polynomial\n   * @return the result of polynomial evaluation.\n   */\n    Ciphertext&lt;Element&gt; EvalPolyLinear(ConstCiphertext&lt;Element&gt; ciphertext,\n                                       const std::vector&lt;double&gt;&amp; coefficients) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;EvalPolyLinear(ciphertext, coefficients);\n    }\n\n    /**\n   * Paterson-Stockmeyer method for evaluation for polynomials represented in the power\n   * series. Supported only in CKKS.\n   *\n   * @param cipherText input ciphertext\n   * @param &amp;coefficients is the vector of coefficients in the polynomial; the\n   * size of the vector is the degree of the polynomial\n   * @return the result of polynomial evaluation.\n   */\n    Ciphertext&lt;Element&gt; EvalPolyPS(ConstCiphertext&lt;Element&gt; ciphertext, const std::vector&lt;double&gt;&amp; coefficients) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;EvalPolyPS(ciphertext, coefficients);\n    }\n\n    //------------------------------------------------------------------------------\n    // Advanced SHE EVAL CHEBYSHEV SERIES\n    //------------------------------------------------------------------------------\n\n    /**\n   * Method for evaluating Chebyshev polynomial interpolation;\n   * first the range [a,b] is mapped to [-1,1] using linear transformation 1 + 2\n   * (x-a)/(b-a) If the degree of the polynomial is less than 5, use\n   * EvalChebyshevSeriesLinear (naive linear method), otherwise, use EvalChebyshevSeriesPS (Paterson-Stockmeyer method).\n   * Supported only in CKKS.\n   *\n   * @param cipherText input ciphertext\n   * @param &amp;coefficients is the vector of coefficients in Chebyshev expansion\n   * @param a - lower bound of argument for which the coefficients were found\n   * @param b - upper bound of argument for which the coefficients were found\n   * @return the result of polynomial evaluation.\n   */\n    Ciphertext&lt;Element&gt; EvalChebyshevSeries(ConstCiphertext&lt;Element&gt; ciphertext,\n                                            const std::vector&lt;double&gt;&amp; coefficients, double a, double b) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;EvalChebyshevSeries(ciphertext, coefficients, a, b);\n    }\n\n    /**\n   * Naive linear method for evaluating Chebyshev polynomial interpolation;\n   * first the range [a,b] is mapped to [-1,1] using linear transformation 1 + 2\n   * (x-a)/(b-a). Supported only in CKKS.\n   *\n   * @param cipherText input ciphertext\n   * @param &amp;coefficients is the vector of coefficients in Chebyshev expansion\n   * @param a - lower bound of argument for which the coefficients were found\n   * @param b - upper bound of argument for which the coefficients were found\n   * @return the result of polynomial evaluation.\n   */\n    Ciphertext&lt;Element&gt; EvalChebyshevSeriesLinear(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                  const std::vector&lt;double&gt;&amp; coefficients, double a, double b) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;EvalChebyshevSeriesLinear(ciphertext, coefficients, a, b);\n    }\n\n    /**\n   * Paterson-Stockmeyer method for evaluating Chebyshev polynomial interpolation;\n   * first the range [a,b] is mapped to [-1,1] using linear transformation 1 + 2\n   * (x-a)/(b-a). Supported only in CKKS.\n   *\n   * @param cipherText input ciphertext\n   * @param &amp;coefficients is the vector of coefficients in Chebyshev expansion\n   * @param a - lower bound of argument for which the coefficients were found\n   * @param b - upper bound of argument for which the coefficients were found\n   * @return the result of polynomial evaluation.\n   */\n    Ciphertext&lt;Element&gt; EvalChebyshevSeriesPS(ConstCiphertext&lt;Element&gt; ciphertext,\n                                              const std::vector&lt;double&gt;&amp; coefficients, double a, double b) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;EvalChebyshevSeriesPS(ciphertext, coefficients, a, b);\n    }\n\n    /**\n   * Method for calculating Chebyshev evaluation on a ciphertext for a smooth input\n   * function over the range [a,b]. Supported only in CKKS.\n   *\n   * @param func is the function to be approximated\n   * @param ciphertext input ciphertext\n   * @param a - lower bound of argument for which the coefficients were found\n   * @param b - upper bound of argument for which the coefficients were found\n   * @param degree Desired degree of approximation\n   * @return the coefficients of the Chebyshev approximation.\n   */\n    Ciphertext&lt;Element&gt; EvalChebyshevFunction(std::function&lt;double(double)&gt; func, ConstCiphertext&lt;Element&gt; ciphertext,\n                                              double a, double b, uint32_t degree) const;\n\n    /**\n   * Evaluate approximate sine function on a ciphertext using the Chebyshev approximation.\n   * Supported only in CKKS.\n   *\n   * @param ciphertext input ciphertext\n   * @param a - lower bound of argument for which the coefficients were found\n   * @param b - upper bound of argument for which the coefficients were found\n   * @param degree Desired degree of approximation\n   * @return the result of polynomial evaluation.\n   */\n    Ciphertext&lt;Element&gt; EvalSin(ConstCiphertext&lt;Element&gt; ciphertext, double a, double b, uint32_t degree) const;\n\n    /**\n   * Evaluate approximate cosine function on a ciphertext using the Chebyshev approximation.\n   * Supported only in CKKS.\n   *\n   * @param ciphertext input ciphertext\n   * @param a - lower bound of argument for which the coefficients were found\n   * @param b - upper bound of argument for which the coefficients were found\n   * @param degree Desired degree of approximation\n   * @return the result of polynomial evaluation.\n   */\n    Ciphertext&lt;Element&gt; EvalCos(ConstCiphertext&lt;Element&gt; ciphertext, double a, double b, uint32_t degree) const;\n\n    /**\n   * Evaluate approximate logistic function 1/(1 + exp(-x)) on a ciphertext using the Chebyshev approximation.\n   * Supported only in CKKS.\n   *\n   * @param ciphertext input ciphertext\n   * @param a - lower bound of argument for which the coefficients were found\n   * @param b - upper bound of argument for which the coefficients were found\n   * @param degree Desired degree of approximation\n   * @return the result of polynomial evaluation.\n   */\n    Ciphertext&lt;Element&gt; EvalLogistic(ConstCiphertext&lt;Element&gt; ciphertext, double a, double b, uint32_t degree) const;\n\n    /**\n   * Evaluate approximate division function 1/x where x &gt;= 1 on a ciphertext using the Chebyshev approximation.\n   * Supported only in CKKS.\n   *\n   * @param ciphertext input ciphertext\n   * @param a - lower bound of argument for which the coefficients were found\n   * @param b - upper bound of argument for which the coefficients were found\n   * @param degree Desired degree of approximation\n   * @return the result of polynomial evaluation.\n   */\n    Ciphertext&lt;Element&gt; EvalDivide(ConstCiphertext&lt;Element&gt; ciphertext, double a, double b, uint32_t degree) const;\n\n    //------------------------------------------------------------------------------\n    // Advanced SHE EVAL SUM\n    //------------------------------------------------------------------------------\n\n    /**\n   * EvalSumKeyGen Generates the key map to be used by EvalSum\n   *\n   * @param privateKey private key.\n   * @param publicKey public key (used in NTRU schemes).\n   */\n    void EvalSumKeyGen(const PrivateKey&lt;Element&gt; privateKey, const PublicKey&lt;Element&gt; publicKey = nullptr);\n\n    /**\n   * Generate the automorphism keys for EvalSumRows; works\n   * only for packed encoding\n   *\n   * @param privateKey private key.\n   * @param publicKey public key.\n   * @param rowSize size of rows in the matrix\n   * @param subringDim subring dimension (set to cyclotomic order if set to 0)\n   * @return returns the evaluation keys\n   */\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSumRowsKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                                                         const PublicKey&lt;Element&gt; publicKey = nullptr,\n                                                                         usint rowSize = 0, usint subringDim = 0);\n    /**\n   * Generates the automorphism keys for EvalSumCols; works\n   * only for packed encoding\n   *\n   * @param privateKey private key.\n   * @param publicKey public key.\n   * @return returns the evaluation keys\n   */\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSumColsKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                                                         const PublicKey&lt;Element&gt; publicKey = nullptr);\n\n    /**\n   * Function for evaluating a sum of all components in a vector.\n   *\n   * @param ciphertext the input ciphertext.\n   * @param batchSize size of the batch\n   * @return resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSum(ConstCiphertext&lt;Element&gt; ciphertext, usint batchSize) const;\n\n    /**\n   * Sums all elements over row-vectors in a matrix - works only with packed\n   * encoding\n   *\n   * @param ciphertext the input ciphertext.\n   * @param rowSize size of rows in the matrix\n   * @param &amp;evalSumKeyMap - reference to the map of evaluation keys generated by\n   * @param subringDim the current cyclotomic order/subring dimension. If set to\n   * 0, we use the full cyclotomic order.\n   * @return resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSumRows(ConstCiphertext&lt;Element&gt; ciphertext, usint rowSize,\n                                    const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalSumKeyMap, usint subringDim = 0) const;\n\n    /**\n   * Sums all elements over column-vectors in a matrix - works only with packed\n   * encoding\n   *\n   * @param ciphertext the input ciphertext.\n   * @param rowSize size of rows in the matrix\n   * @param &amp;evalSumKeyMap - reference to the map of evaluation keys generated by\n   * @return resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSumCols(ConstCiphertext&lt;Element&gt; ciphertext, usint rowSize,\n                                    const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalSumKeyMap) const;\n\n    //------------------------------------------------------------------------------\n    // Advanced SHE EVAL INNER PRODUCT\n    //------------------------------------------------------------------------------\n\n    /**\n   * Evaluates inner product in packed encoding (uses EvalSum)\n   *\n   * @param ciphertext1 first vector.\n   * @param ciphertext2 second vector.\n   * @param batchSize size of the batch to be summed up\n   * @return resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalInnerProduct(ConstCiphertext&lt;Element&gt; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2,\n                                         usint batchSize) const;\n\n    /**\n   * Evaluates inner product in packed encoding (uses EvalSum)\n   *\n   * @param ciphertext1 first vector - ciphertext.\n   * @param plaintext second vector - plaintext.\n   * @param batchSize size of the batch to be summed up\n   * @return resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalInnerProduct(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext,\n                                         usint batchSize) const;\n\n    /**\n   * Merges multiple ciphertexts with encrypted results in slot 0 into a single\n   * ciphertext. The slot assignment is done based on the order of ciphertexts in\n   * the vector. Requires the generation of rotation keys for the indices that are needed.\n   *\n   * @param ciphertextVector vector of ciphertexts to be merged.\n   * @return resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalMerge(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const;\n\n    //------------------------------------------------------------------------------\n    // PRE Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * ReKeyGen produces an Eval Key that OpenFHE can use for Proxy Re-Encryption\n   * @param oldPrivateKey original secret key\n   * @param newPublicKey public key for the new secret key\n   * @return new evaluation key\n   */\n    EvalKey&lt;Element&gt; ReKeyGen(const PrivateKey&lt;Element&gt; oldPrivateKey, const PublicKey&lt;Element&gt; newPublicKey) const {\n        CheckKey(oldPrivateKey);\n        CheckKey(newPublicKey);\n\n        return GetScheme()-&gt;ReKeyGen(oldPrivateKey, newPublicKey);\n    }\n\n    /**\n   * ReKeyGen produces an Eval Key that OpenFHE can use for Proxy Re-Encryption\n   * NOTE this functionality has been completely removed from OpenFHE\n   * @param oldPrivateKey original secret key\n   * @param newPrivateKey new secret key\n   * @return new evaluation key\n   */\n    EvalKey&lt;Element&gt; ReKeyGen(const PrivateKey&lt;Element&gt; originalPrivateKey,\n                              const PrivateKey&lt;Element&gt; newPrivateKey) const\n        __attribute__((deprecated(&quot;functionality removed from OpenFHE&quot;)));\n\n    /**\n   * ReEncrypt - Proxy Re-Encryption mechanism for OpenFHE\n   * @param ciphertext - input ciphertext\n   * @param evalKey - evaluation key from the PRE keygen method\n   * @param publicKey the public key of the recipient of the re-encrypted\n   * ciphertext.\n   * @return the resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; ReEncrypt(ConstCiphertext&lt;Element&gt; ciphertext, EvalKey&lt;Element&gt; evalKey,\n                                  const PublicKey&lt;Element&gt; publicKey = nullptr) const {\n        CheckCiphertext(ciphertext);\n        CheckKey(evalKey);\n\n        return GetScheme()-&gt;ReEncrypt(ciphertext, evalKey, publicKey);\n    }\n\n    //------------------------------------------------------------------------------\n    // Multiparty Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * Threshold FHE: Generates a public key from a vector of secret shares.\n   * ONLY FOR DEBUGGIN PURPOSES. SHOULD NOT BE USED IN PRODUCTION.\n   *\n   * @param &amp;privateKeyVec secrete key shares.\n   * @return key pair including the private for the current party and joined\n   * public key\n   */\n    KeyPair&lt;Element&gt; MultipartyKeyGen(const std::vector&lt;PrivateKey&lt;Element&gt;&gt;&amp; privateKeyVec) {\n        if (!privateKeyVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key vector is empty&quot;);\n        return GetScheme()-&gt;MultipartyKeyGen(GetContextForPointer(this), privateKeyVec, false);\n    }\n\n    /**\n   * Threshold FHE: Generation of a public key derived\n   * from a previous joined public key (for prior secret shares) and the secret\n   * key share of the current party.\n   *\n   * @param publicKey joined public key from prior parties.\n   * @param makeSparse set to true if ring reduce by a factor of 2 is to be\n   * used. NOT SUPPORTED BY ANY SCHEME ANYMORE.\n   * @param fresh set to true if proxy re-encryption is used in the multi-party\n   * protocol or star topology is used\n   * @return key pair including the secret share for the current party and\n   * joined public key\n   */\n    KeyPair&lt;Element&gt; MultipartyKeyGen(const PublicKey&lt;Element&gt; publicKey, bool makeSparse = false, bool fresh = false) {\n        if (!publicKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input public key is empty&quot;);\n        return GetScheme()-&gt;MultipartyKeyGen(GetContextForPointer(this), publicKey, makeSparse, fresh);\n    }\n\n    /**\n   * Threshold FHE: Method for decryption operation run by the lead decryption\n   * client\n   *\n   * @param &amp;ciphertextVec a vector of ciphertexts\n   * @param privateKey secret key share used for decryption.\n   * @returm vector of partially decrypted ciphertexts.\n   */\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; MultipartyDecryptLead(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                                           const PrivateKey&lt;Element&gt; privateKey) const {\n        CheckKey(privateKey);\n\n        std::vector&lt;Ciphertext&lt;Element&gt;&gt; newCiphertextVec;\n\n        for (size_t i = 0; i &lt; ciphertextVec.size(); i++) {\n            CheckCiphertext(ciphertextVec[i]);\n            newCiphertextVec.push_back(GetScheme()-&gt;MultipartyDecryptLead(ciphertextVec[i], privateKey));\n        }\n\n        return newCiphertextVec;\n    }\n\n    /**\n   * Threshold FHE: &quot;Partial&quot; decryption computed by all parties except for the\n   * lead one\n   *\n   * @param &amp;ciphertextVec a vector of ciphertexts\n   * @param privateKey secret key share used for decryption.\n   * @returm vector of partially decrypted ciphertexts.\n   */\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; MultipartyDecryptMain(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                                           const PrivateKey&lt;Element&gt; privateKey) const {\n        CheckKey(privateKey);\n\n        std::vector&lt;Ciphertext&lt;Element&gt;&gt; newCiphertextVec;\n        for (size_t i = 0; i &lt; ciphertextVec.size(); i++) {\n            CheckCiphertext(ciphertextVec[i]);\n            newCiphertextVec.push_back(GetScheme()-&gt;MultipartyDecryptMain(ciphertextVec[i], privateKey));\n        }\n\n        return newCiphertextVec;\n    }\n\n    /**\n   * Threshold FHE: Method for combining the partially decrypted ciphertexts\n   * and getting the final decryption in the clear.\n   *\n   * @param &amp;partialCiphertextVec vector of &quot;partial&quot; decryptions.\n   * @param *plaintext the plaintext output.\n   * @return the decoding result.\n   */\n    DecryptResult MultipartyDecryptFusion(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; partialCiphertextVec,\n                                          Plaintext* plaintext) const {\n        std::string datatype = demangle(typeid(Element).name());\n        &quot;hey&quot;; OPENFHE_THROW(config_error, std::string(__func__) + &quot; is not implemented for &quot; + datatype);\n    }\n\n    /**\n   * Threshold FHE: Generates a joined evaluation key\n   * from the current secret share and a prior joined\n   * evaluation key\n   *\n   * @param originalPrivateKey secret key transformed from.\n   * @param newPrivateKey secret key transformed to.\n   * @param ek the prior joined evaluation key.\n   * @return the new joined evaluation key.\n   */\n    EvalKey&lt;Element&gt; MultiKeySwitchGen(const PrivateKey&lt;Element&gt; originalPrivateKey,\n                                       const PrivateKey&lt;Element&gt; newPrivateKey, const EvalKey&lt;Element&gt; evalKey) const {\n        if (!originalPrivateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first private key is nullptr&quot;);\n        if (!newPrivateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second private key is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n\n        return GetScheme()-&gt;MultiKeySwitchGen(originalPrivateKey, newPrivateKey, evalKey);\n    }\n\n    /**\n   * Threshold FHE: Generates joined automorphism keys\n   * from the current secret share and prior joined\n   * automorphism keys\n   *\n   * @param privateKey secret key share.\n   * @param evalKeyMap a dictionary with prior joined automorphism keys.\n   * @param &amp;indexList a vector of automorphism indices.\n   * @param keyId - new key identifier used for the resulting evaluation key\n   * @return a dictionary with new joined automorphism keys.\n   */\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiEvalAutomorphismKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap,\n        const std::vector&lt;usint&gt;&amp; indexList, const std::string&amp; keyId = &quot;&quot;) {\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        if (!evalKeyMap)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is nullptr&quot;);\n        if (!indexList.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input index vector is empty&quot;);\n\n        return GetScheme()-&gt;MultiEvalAutomorphismKeyGen(privateKey, evalKeyMap, indexList, keyId);\n    }\n\n    /**\n   * Threshold FHE: Generates joined rotation keys\n   * from the current secret share and prior joined\n   * rotation keys\n   *\n   * @param privateKey secret key share.\n   * @param evalKeyMap a dictionary with prior joined rotation keys.\n   * @param &amp;indexList a vector of rotation indices.\n   * @param keyId - new key identifier used for the resulting evaluation key\n   * @return a dictionary with new joined rotation keys.\n   */\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiEvalAtIndexKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap,\n        const std::vector&lt;int32_t&gt;&amp; indexList, const std::string&amp; keyId = &quot;&quot;) {\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        if (!evalKeyMap)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is nullptr&quot;);\n        if (!indexList.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input index vector is empty&quot;);\n\n        return GetScheme()-&gt;MultiEvalAtIndexKeyGen(privateKey, evalKeyMap, indexList, keyId);\n    }\n\n    /**\n   * Threshold FHE: Generates joined summation evaluation keys\n   * from the current secret share and prior joined\n   * summation keys\n   *\n   * @param privateKey secret key share.\n   * @param evalKeyMap a dictionary with prior joined summation keys.\n   * @param keyId - new key identifier used for the resulting evaluation key\n   * @return new joined summation keys.\n   */\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiEvalSumKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap,\n        const std::string&amp; keyId = &quot;&quot;) {\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        if (!evalKeyMap)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is nullptr&quot;);\n        return GetScheme()-&gt;MultiEvalSumKeyGen(privateKey, evalKeyMap, keyId);\n    }\n\n    /**\n   * Threshold FHE: Adds two prior evaluation keys\n   *\n   * @param evalKey1 first evaluation key.\n   * @param evalKey2 second evaluation key.\n   * @param keyId - new key identifier used for the resulting evaluation key\n   * @return the new joined key.\n   */\n    EvalKey&lt;Element&gt; MultiAddEvalKeys(EvalKey&lt;Element&gt; evalKey1, EvalKey&lt;Element&gt; evalKey2,\n                                      const std::string&amp; keyId = &quot;&quot;) {\n        if (!evalKey1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first evaluation key is nullptr&quot;);\n        if (!evalKey2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second evaluation key is nullptr&quot;);\n\n        return GetScheme()-&gt;MultiAddEvalKeys(evalKey1, evalKey2, keyId);\n    }\n\n    /**\n   * Threshold FHE: Generates a partial evaluation key for homomorphic\n   * multiplication based on the current secret share and an existing partial\n   * evaluation key\n   *\n   * @param privateKey current secret share.\n   * @param evalKey prior evaluation key.\n   * @param keyId - new key identifier used for the resulting evaluation key\n   * @return the new joined key.\n   */\n    EvalKey&lt;Element&gt; MultiMultEvalKey(PrivateKey&lt;Element&gt; privateKey, EvalKey&lt;Element&gt; evalKey,\n                                      const std::string&amp; keyId = &quot;&quot;) {\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n\n        return GetScheme()-&gt;MultiMultEvalKey(privateKey, evalKey, keyId);\n    }\n\n    /**\n   * Threshold FHE: Adds two prior evaluation key sets for summation\n   *\n   * @param evalKeyMap1 first summation key set.\n   * @param evalKeyMap2 second summation key set.\n   * @param keyId - new key identifier used for the resulting evaluation key\n   * @return the new joined key set for summation.\n   */\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiAddEvalSumKeys(\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap1,\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap2, const std::string&amp; keyId = &quot;&quot;) {\n        if (!evalKeyMap1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first evaluation key map is nullptr&quot;);\n        if (!evalKeyMap2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second evaluation key map is nullptr&quot;);\n\n        return GetScheme()-&gt;MultiAddEvalSumKeys(evalKeyMap1, evalKeyMap2, keyId);\n    }\n\n    /**\n   * Threshold FHE: Adds two prior evaluation key sets for automorphisms\n   *\n   * @param evalKeyMap1 first automorphism key set.\n   * @param evalKeyMap2 second automorphism key set.\n   * @param keyId - new key identifier used for the resulting evaluation key.\n   * @return the new joined key set for summation.\n   */\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiAddEvalAutomorphismKeys(\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap1,\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap2, const std::string&amp; keyId = &quot;&quot;) {\n        if (!evalKeyMap1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first evaluation key map is nullptr&quot;);\n        if (!evalKeyMap2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second evaluation key map is nullptr&quot;);\n\n        return GetScheme()-&gt;MultiAddEvalAutomorphismKeys(evalKeyMap1, evalKeyMap2, keyId);\n    }\n\n    /**\n   * Threshold FHE: Adds two  partial public keys\n   *\n   * @param publicKey1 first public key.\n   * @param publicKey2 second public key.\n   * @param keyId - new key identifier used for the resulting evaluation key.\n   * @return the new joined key.\n   */\n    PublicKey&lt;Element&gt; MultiAddPubKeys(PublicKey&lt;Element&gt; publicKey1, PublicKey&lt;Element&gt; publicKey2,\n                                       const std::string&amp; keyId = &quot;&quot;) {\n        if (!publicKey1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first public key is nullptr&quot;);\n        if (!publicKey2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second public key is nullptr&quot;);\n\n        return GetScheme()-&gt;MultiAddPubKeys(publicKey1, publicKey2, keyId);\n    }\n\n    /**\n    * Threshold FHE: Adds two  partial evaluation keys for multiplication\n    *\n    * @param evalKey1 first evaluation key.\n    * @param evalKey2 second evaluation key.\n    * @param keyId - new key identifier used for the resulting evaluation key.\n    * @return the new joined key.\n    */\n    EvalKey&lt;Element&gt; MultiAddEvalMultKeys(EvalKey&lt;Element&gt; evalKey1, EvalKey&lt;Element&gt; evalKey2,\n                                          const std::string&amp; keyId = &quot;&quot;) {\n        if (!evalKey1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first evaluation key is nullptr&quot;);\n        if (!evalKey2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second evaluation key is nullptr&quot;);\n\n        return GetScheme()-&gt;MultiAddEvalMultKeys(evalKey1, evalKey2, keyId);\n    }\n\n    /**\n    * Threshold FHE: Prepare a ciphertext for Multi-Party Interactive Bootstrapping.\n    *\n    * @param ciphertext: Input Ciphertext\n    * @return: Resulting Ciphertext\n    */\n    Ciphertext&lt;Element&gt; IntMPBootAdjustScale(ConstCiphertext&lt;Element&gt; ciphertext) const;\n\n    /**\n    * Threshold FHE: Generate a common random polynomial for Multi-Party Interactive Bootstrapping\n    *\n    * @param publicKey: the scheme public key (you can also provide the lead party&#x27;s public-key)\n    * @return: Resulting ring element\n    */\n    Ciphertext&lt;Element&gt; IntMPBootRandomElementGen(const PublicKey&lt;Element&gt; publicKey) const;\n\n    /**\n    * Threshold FHE: Does masked decryption as part of Multi-Party Interactive Bootstrapping.\n    * Each party calls this function as part of the protocol\n    *\n    * @param privateKey: secret key share for party i\n    * @param ciphertext: input ciphertext\n    * @param a: input common random polynomial\n    * @return: Resulting masked decryption\n    */\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; IntMPBootDecrypt(const PrivateKey&lt;Element&gt; privateKey,\n                                                      ConstCiphertext&lt;Element&gt; ciphertext,\n                                                      ConstCiphertext&lt;Element&gt; a) const;\n\n    /**\n    * Threshold FHE: Aggregates a vector of masked decryptions and re-encryotion shares,\n    * which is the second step of the interactive multiparty bootstrapping procedure.\n    *\n    * @param sharesPairVec: vector of pair of ciphertexts, each element of this vector contains\n    * (h_0i, h_1i) - the masked-decryption and encryption shares ofparty i\n    * @return: aggregated pair of shares ((h_0, h_1)\n    */\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; IntMPBootAdd(std::vector&lt;std::vector&lt;Ciphertext&lt;Element&gt;&gt;&gt;&amp; sharesPairVec) const;\n\n    /**\n    *  Threshold FHE: Does public key encryption of lead party&#x27;s masked decryption\n    * as part of interactive multi-party bootstrapping, which increases\n    * the ciphertext modulus and enables future computations.\n    * This operation is done by the lead party as the final step\n    * of interactive multi-party bootstrapping.\n    *\n    * @param publicKey: the lead party&#x27;s public key\n    * @param sharesPair: aggregated decryption and re-encryption shares\n    * @param a: common random ring element\n    * @param ciphertext: input ciphertext\n    * @return: Resulting encryption\n    */\n    Ciphertext&lt;Element&gt; IntMPBootEncrypt(const PublicKey&lt;Element&gt; publicKey,\n                                         const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; sharesPair, ConstCiphertext&lt;Element&gt; a,\n                                         ConstCiphertext&lt;Element&gt; ciphertext) const;\n\n    /**\n   * Threshold FHE with aborts: secret sharing of secret key for aborts\n   *\n   * @param &amp;sk secret key to be shared.\n   * @param N total number of parties.\n   * @param threshold - threshold number of parties.\n   * @param index - index of the party invoking the function.\n   * @param shareType - Type of secret sharing to be used - additive or shamir sharing.\n   * @return the secret shares of the secret key sk.\n   */\n    std::unordered_map&lt;uint32_t, Element&gt; ShareKeys(const PrivateKey&lt;Element&gt;&amp; sk, usint N, usint threshold,\n                                                    usint index, const std::string&amp; shareType) const {\n        std::string datatype = demangle(typeid(Element).name());\n        &quot;hey&quot;; OPENFHE_THROW(config_error, std::string(__func__) + &quot; is not implemented for &quot; + datatype);\n    }\n\n    /**\n   * Threshold FHE with aborts: Recovers a secret key share from other existing secret shares.\n   *\n   * @param &amp;sk secret recovered from the secret shares.\n   * @param &amp;sk_shares secret shares.\n   * @param N total number of parties.\n   * @param threshold - threshold number of parties.\n   * @param shareType - Type of secret sharing to be used - additive or shamir sharing\n   * @return the recovered key from the secret shares assigned to sk.\n   */\n    void RecoverSharedKey(PrivateKey&lt;Element&gt;&amp; sk, std::unordered_map&lt;uint32_t, Element&gt;&amp; sk_shares, usint N,\n                          usint threshold, const std::string&amp; shareType) const;\n\n    //------------------------------------------------------------------------------\n    // FHE Bootstrap Methods\n    //------------------------------------------------------------------------------\n\n    /**\n   * Bootstrap functionality:\n   * There are three methods that have to be called in this specific order:\n   * 1. EvalBootstrapSetup: computes and encodes the coefficients for encoding and\n   * decoding and stores the necessary parameters\n   * 2. EvalBootstrapKeyGen: computes and stores the keys for rotations and conjugation\n   * 3. EvalBootstrap: refreshes the given ciphertext\n   */\n\n    /**\n   * Sets all parameters for both linear  and FFT-like methods. Supported in CKKS only.\n   *\n   * @param levelBudget - vector of budgets for the amount of levels in encoding\n   * and decoding\n   * @param dim1 - vector of inner dimension in the baby-step giant-step routine\n   * for encoding and decoding\n   * @param slots - number of slots to be bootstrapped\n   * @param correctionFactor - value to internally rescale message by to improve precision of bootstrapping. If set to 0, we use the default logic. This value is only used when NATIVE_SIZE=64.\n   */\n    void EvalBootstrapSetup(std::vector&lt;uint32_t&gt; levelBudget = {5, 4}, std::vector&lt;uint32_t&gt; dim1 = {0, 0},\n                            uint32_t slots = 0, uint32_t correctionFactor = 0) {\n        GetScheme()-&gt;EvalBootstrapSetup(*this, levelBudget, dim1, slots, correctionFactor);\n    }\n    /**\n   * Generates all automorphism keys for EvalBootstrap. Supported in CKKS only.\n   * EvalBootstrapKeyGen uses the baby-step/giant-step strategy.\n   *\n   * @param privateKey private key.\n   * @param slots number of slots to support permutations on\n   */\n    void EvalBootstrapKeyGen(const PrivateKey&lt;Element&gt; privateKey, uint32_t slots) {\n        if (privateKey == NULL || this-&gt;Mismatched(privateKey-&gt;GetCryptoContext())) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Private key passed to &quot; + std::string(__func__) +\n                                            &quot; was not generated with this cryptocontext&quot;);\n        }\n\n        auto evalKeys = GetScheme()-&gt;EvalBootstrapKeyGen(privateKey, slots);\n\n        auto ekv = GetAllEvalAutomorphismKeys().find(privateKey-&gt;GetKeyTag());\n        if (ekv == GetAllEvalAutomorphismKeys().end()) {\n            GetAllEvalAutomorphismKeys()[privateKey-&gt;GetKeyTag()] = evalKeys;\n        }\n        else {\n            auto&amp; currRotMap = GetEvalAutomorphismKeyMap(privateKey-&gt;GetKeyTag());\n            auto iterRowKeys = evalKeys-&gt;begin();\n            while (iterRowKeys != evalKeys-&gt;end()) {\n                auto idx = iterRowKeys-&gt;first;\n                // Search current rotation key map and add key\n                // only if it doesn&#x27;t exist\n                if (currRotMap.find(idx) == currRotMap.end()) {\n                    currRotMap.insert(*iterRowKeys);\n                }\n                iterRowKeys++;\n            }\n        }\n    }\n    /**\n   * Defines the bootstrapping evaluation of ciphertext using either the\n   * FFT-like method or the linear method\n   *\n   * @param ciphertext the input ciphertext.\n   * @param numIterations number of iterations to run iterative bootstrapping (Meta-BTS). Increasing the iterations increases the precision of bootstrapping.\n   * @param precision precision of initial bootstrapping algorithm. This value is\n   * determined by the user experimentally by first running EvalBootstrap with numIterations = 1 and precision = 0 (unused).\n   * @return the refreshed ciphertext.\n   */\n    Ciphertext&lt;Element&gt; EvalBootstrap(ConstCiphertext&lt;Element&gt; ciphertext, uint32_t numIterations = 1,\n                                      uint32_t precision = 0) const {\n        return GetScheme()-&gt;EvalBootstrap(ciphertext, numIterations, precision);\n    }\n\n    //------------------------------------------------------------------------------\n    // Scheme switching Methods\n    //------------------------------------------------------------------------------\n\n    /**\n   * Scheme switching between CKKS and FHEW functionality\n   * There are three methods that have to be called in this specific order:\n   * 1. EvalCKKStoFHEWSetup: generates a FHEW cryptocontext and returns the key, computes and encodes\n   * the coefficients for encoding and decoding and stores the necessary parameters\n   * 2. EvalCKKStoFHEWKeyGen: computes and stores the keys for rotations and conjugation\n   * 3. EvalCKKStoFHEW: returns the FHEW/CGGI ciphertext\n   * 1&#x27;. EvalFHEWtoCKKSwitchetup: takes in the CKKS cryptocontext and sets the parameters\n   * 2&#x27;. EvalFHEWtoCKKSKeyGen: computes and stores the switching key and the keys for rotations and conjugation\n   * 3&#x27;. EvalFHEWtoCKKS: returns the CKKS ciphertext\n   * 1&#x27;&#x27;. EvalSchemeSwitchingSetup: generates a FHEW cryptocontext and returns the key, computes and encodes\n   * the coefficients for encoding and decoding and stores the necessary parameters\n   * 2&#x27;&#x27;. EvalSchemeSwitchingKeyGen: computes and stores the switching key and the keys for rotations and conjugation\n   * 3&#x27;&#x27;. EvalCompareSchemeSwitching/EvalFuncSchemeSwitching: returns the CKKS ciphertext of the function specified\n   */\n\n    /**\n   * Sets all parameters for switching from CKKS to FHEW\n   *\n   * @param sl security level for CKKS cryptocontext\n   * @param slBin security level for FHEW cryptocontext (only STD128 and TOY are currently supported)\n   * @param arbFunc whether the binfhecontext should be created for arbitrary function evaluation or not\n   * @param logQ size of ciphertext modulus in FHEW for large-precision evaluation\n   * @param dynamic whether to use dynamic mode for FHEW\n   * @param numSlotsCKKS number of slots in CKKS encryption\n   * @param logQswitch size of ciphertext modulus in intermediate switch for security with the FHEW ring dimension\n   * @return the FHEW cryptocontext and its secret key (if a method from extracting the binfhecontext\n   * from the secret key is created, then we can only return the secret key)\n   * TODO: add an overload for when BinFHEContext is already generated and fed as a parameter\n   */\n    std::pair&lt;BinFHEContext, LWEPrivateKey&gt; EvalCKKStoFHEWSetup(SecurityLevel sl      = HEStd_128_classic,\n                                                                BINFHE_PARAMSET slBin = STD128, bool arbFunc = false,\n                                                                uint32_t logQ = 25, bool dynamic = false,\n                                                                uint32_t numSlotsCKKS = 0, uint32_t logQswitch = 27);\n\n    /**\n   * Generates all keys for scheme switching: the rotation keys for the baby-step/giant-step strategy\n   * for the linear transform in the homomorphic decoding, conjugation keys, switching key from CKKS to FHEW\n   *\n   * @param keypair CKKS key pair\n   * @param lwesk FHEW secret key\n   * @param dim1 baby-step for the linear transform\n   * @param L level on which the hom. decoding matrix should be. We want the hom. decoded ciphertext to be on the last level\n   */\n    void EvalCKKStoFHEWKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk, uint32_t dim1 = 0,\n                              uint32_t L = 1);\n\n    /**\n   * Performs precomputations for the homomorphic decoding in CKKS. Given as a separate method than EvalCKKStoFHEWSetup\n   * to allow the user to specify a scale that depends on the CKKS and FHEW cryptocontexts\n   *\n   * @param scale factor with which to scale the matrix in the linear transform\n   */\n    void EvalCKKStoFHEWPrecompute(double scale = 1.0);\n\n    /**\n   * Performs the scheme switching on a CKKS ciphertext\n   *\n   * @param ciphertext CKKS ciphertext to switch\n   * @param numCtxts number of coefficients to extract from the CKKS ciphertext. If it is zero, it defaults to number of slots\n   * @return a vector of LWE ciphertexts of length the numCtxts\n   */\n    std::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt; EvalCKKStoFHEW(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                   uint32_t numCtxts = 0);\n\n    /**\n   * Sets all parameters for switching from FHEW to CKKS. The CKKS cryptocontext to switch to is\n   * already generated.\n   *\n   * @param ccLWE the FHEW cryptocontext from which to switch\n   * @param numSlotsCKKS number of FHEW ciphertexts that becomes the number of slots in CKKS encryption\n   * @param logQ size of ciphertext modulus in FHEW for large-precision evaluation\n   */\n    void EvalFHEWtoCKKSSetup(const BinFHEContext&amp; ccLWE, uint32_t numSlotsCKKS = 0, uint32_t logQ = 25);\n\n    /**\n   * Generates all keys for scheme switching: the rotation keys for the baby-step/giant-step strategy\n   * in the linear transform for the partial decryption, the switching key from FHEW to CKKS\n   *\n   * @param keypair CKKS key pair\n   * @param lwesk FHEW secret key\n   * @param numSlots number of slots for the CKKS encryption of the FHEW secret key\n   * @param dim1 baby-step for the linear transform\n   * @param L level on which the hom. decoding matrix should be. We want the hom. decoded ciphertext to be on the last level\n   */\n    void EvalFHEWtoCKKSKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk, uint32_t numSlots = 0,\n                              uint32_t dim1 = 0, uint32_t L = 0);\n\n    /**\n   * Performs the scheme switching on a vector of FHEW ciphertexts\n   *\n   * @param LWECiphertexts FHEW/LWE ciphertexts to switch\n   * @param numCtxts number of values to encrypt from the LWE ciphertexts in the new CKKS ciphertext\n   * @param numSlots number of slots to use in the encoding in the new CKKS/RLWE ciphertext\n   * @param p plaintext modulus to use to decide postscaling, by default p = 4\n   * @param pmin, pmax plaintext space of the resulting messages (by default [0,2] assuming\n   * the LWE ciphertext had plaintext modulus p = 4 and only bits were encrypted)\n   * @return a CKKS ciphertext encrypting in its slots the messages in the LWE ciphertexts\n   */\n    Ciphertext&lt;Element&gt; EvalFHEWtoCKKS(std::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt;&amp; LWECiphertexts,\n                                       uint32_t numCtxts = 0, uint32_t numSlots = 0, uint32_t p = 4, double pmin = 0.0,\n                                       double pmax = 2.0) const;\n\n    /**\n   * Sets all parameters for switching from CKKS to FHEW and back\n   *\n   * @param sl security level for CKKS cryptocontext\n   * @param slBin security level for FHEW cryptocontext\n   * @param arbFunc whether the binfhecontext should be created for arbitrary function evaluation or not\n   * @param logQ size of ciphertext modulus in FHEW for large-precision evaluation\n   * @param dynamic whether to use dynamic mode for FHEW\n   * @param numSlotsCKKS number of slots in CKKS encryption\n   * @param logQswitch size of ciphertext modulus in intermediate switch for security with the FHEW ring dimension\n   * @return the FHEW cryptocontext and its secret key (if a method from extracting the binfhecontext\n   * from the secret key is created, then we can only return the secret key)\n   * TODO: add an overload for when BinFHEContext is already generated and fed as a parameter\n   */\n    std::pair&lt;BinFHEContext, LWEPrivateKey&gt; EvalSchemeSwitchingSetup(SecurityLevel sl      = HEStd_128_classic,\n                                                                     BINFHE_PARAMSET slBin = STD128,\n                                                                     bool arbFunc = false, uint32_t logQ = 25,\n                                                                     bool dynamic = false, uint32_t numSlotsCKKS = 0,\n                                                                     uint32_t logQswitch = 27);\n\n    /**\n   * Generates all keys for scheme switching: the rotation keys for the baby-step/giant-step strategy\n   * in the linear transform for the homomorphic encoding and partial decryption, the switching key from\n   * FHEW to CKKS\n   *\n   * @param keypair CKKS key pair\n   * @param lwesk FHEW secret key\n   * @param numValues parameter of argmin computation, set to zero if not needed\n   * @param oneHot flag that indicates whether the argmin result should have one hot encoding or not\n   * @param alt flag that indicates whether to use the alternative version of argmin which requires fewer automorphism keys\n   * @param dim1CF baby-step for the linear transform in CKKS to FHEW\n   * @param dim1FC baby-step for the linear transform in FHEW to CKKS\n   * @param LCF level on which to do the linear transform in CKKS to FHEW\n   * @param LFC level on which to do the linear transform in FHEW to CKKS\n   */\n    void EvalSchemeSwitchingKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk, uint32_t numValues = 0,\n                                   bool oneHot = true, bool alt = false, uint32_t dim1CF = 0, uint32_t dim1FC = 0,\n                                   uint32_t LCF = 1, uint32_t LFC = 0);\n\n    /**\n   * Performs precomputations for the homomorphic decoding in CKKS. Given as a separate method than EvalSchemeSwitchingSetup\n   * to allow the user to specify a scale that depends on the CKKS and FHEW cryptocontexts\n   *\n   * @param pLWE the desired plaintext modulus for the new FHEW ciphertexts\n   * @param initLevel the level of the ciphertext that will be switched\n   * @param scaleSign factor to multiply the CKKS ciphertext when switching to FHEW in case the messages are too small;\n   * the resulting FHEW ciphertexts will encrypt values modulo pLWE, so scaleSign should account for this\n   * @param unit whether the input messages are normalized to the unit circle\n   */\n    void EvalCompareSwitchPrecompute(uint32_t pLWE = 0, uint32_t initLevel = 0, double scaleSign = 1.0,\n                                     bool unit = false);\n\n    /**\n   * Performs the scheme switching on the difference of two CKKS ciphertexts to compare, evaluates the sign function\n   * over the resulting FHEW ciphertexts, then performs the scheme switching back to a CKKS ciphertext\n   *\n   * @param ciphertext1, ciphertext2 CKKS ciphertexts of messages that need to be compared\n   * @param numCtxts number of coefficients to extract from the CKKS ciphertext\n   * @param numSlots number of slots to encode the new CKKS ciphertext with\n   * @param pLWE the desired plaintext modulus for the new FHEW ciphertexts\n   * @param scaleSign factor to multiply the CKKS ciphertext when switching to FHEW in case the messages are too small;\n   * the resulting FHEW ciphertexts will encrypt values modulo pLWE, so scaleSign should account for this\n   * pLWE and scaleSign are given here only if the homomorphic decoding matrix is not scaled with the desired values\n   * @param unit whether the input messages are normalized to the unit circle\n   * @return a CKKS ciphertext encrypting in its slots the sign of  messages in the LWE ciphertexts\n   */\n    Ciphertext&lt;Element&gt; EvalCompareSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                   ConstCiphertext&lt;Element&gt; ciphertext2, uint32_t numCtxts = 0,\n                                                   uint32_t numSlots = 0, uint32_t pLWE = 0, double scaleSign = 1.0,\n                                                   bool unit = false);\n\n    /**\n   * Computes the minimum and argument of the first numValues packed in a CKKS ciphertext via repeated\n   * scheme switchings to FHEW and back.\n   *\n   * @param ciphertext CKKS ciphertexts of values that need to be compared\n   * @param publicKey public key of the CKKS cryptocontext\n   * @param numValues number of values to extract from the CKKS ciphertext. We always assume for the moment numValues is a power of two\n   * @param numSlots number of slots to encode the new CKKS ciphertext with\n   * @param oneHot whether the argmin result is given as a one hot/elementary vector or as the index\n   * @param pLWE the desired plaintext modulus for the new FHEW ciphertexts\n   * @param scaleSign factor to multiply the CKKS ciphertext when switching to FHEW in case the messages are too small;\n   * the resulting FHEW ciphertexts will encrypt values modulo pLWE, so scaleSign should account for this\n   * pLWE and scaleSign are given here only if the homomorphic decoding matrix is not scaled with the desired values\n   * @return a vector of two CKKS ciphertexts where the first encrypts the minimum value and the second encrypts the\n   * index (in the representation specified by oneHot). The ciphertexts have junk after the first slot in the first ciphertext\n   * and after numValues in the second ciphertext if oneHot=true and after the first slot if oneHot=false.\n   */\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMinSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                            PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                            uint32_t numSlots = 0, bool oneHot = true,\n                                                            uint32_t pLWE = 0, double scaleSign = 1.0);\n\n    /**\n     * Same as EvalMinSchemeSwitching but performs more operations in FHEW than in CKKS. Slightly better precision but slower.\n    */\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMinSchemeSwitchingAlt(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                               PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                               uint32_t numSlots = 0, bool oneHot = true,\n                                                               uint32_t pLWE = 0, double scaleSign = 1.0);\n\n    /**\n   * Computes the maximum and argument of the first numValues packed in a CKKS ciphertext via repeated\n   * scheme switchings to FHEW and back.\n   *\n   * @param ciphertext CKKS ciphertexts of values that need to be compared\n   * @param publicKey public key of the CKKS cryptocontext\n   * @param numValues number of values to extract from the CKKS ciphertext. We always assume for the moment numValues is a power of two\n   * @param numSlots number of slots to encode the new CKKS ciphertext with\n   * @param oneHot whether the argmax result is given as a one hot/elementary vector or as the index\n   * @param pLWE the desired plaintext modulus for the new FHEW ciphertexts\n   * @param scaleSign factor to multiply the CKKS ciphertext when switching to FHEW in case the messages are too small;\n   * the resulting FHEW ciphertexts will encrypt values modulo pLWE, so scaleSign should account for this\n   * pLWE and scaleSign are given here only if the homomorphic decoding matrix is not scaled with the desired values\n   * @return a vector of two CKKS ciphertexts where the first encrypts the maximum value and the second encrypts the\n   * index (in the representation specified by oneHot). The ciphertexts have junk after the first slot in the first ciphertext\n   * and after numValues in the second ciphertext if oneHot=true and after the first slot if oneHot=false.\n   */\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMaxSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                            PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                            uint32_t numSlots = 0, bool oneHot = true,\n                                                            uint32_t pLWE = 0, double scaleSign = 1.0);\n\n    /**\n     * Same as EvalMaxSchemeSwitching but performs more operations in FHEW than in CKKS. Slightly better precision but slower.\n    */\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMaxSchemeSwitchingAlt(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                               PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                               uint32_t numSlots = 0, bool oneHot = true,\n                                                               uint32_t pLWE = 0, double scaleSign = 1.0);\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(cereal::make_nvp(&quot;cc&quot;, params));\n        ar(cereal::make_nvp(&quot;kt&quot;, scheme));\n        ar(cereal::make_nvp(&quot;si&quot;, m_schemeId));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                 &quot; is from a later version of the library&quot;);\n        }\n        ar(cereal::make_nvp(&quot;cc&quot;, params));\n        ar(cereal::make_nvp(&quot;kt&quot;, scheme));\n        ar(cereal::make_nvp(&quot;si&quot;, m_schemeId));\n        SetKSTechniqueInScheme();\n\n        // NOTE: a pointer to this object will be wrapped in a shared_ptr, and is a\n        // &quot;CryptoContext&quot;. OpenFHE relies on the notion that identical\n        // CryptoContextImpls are not duplicated in memory Once we deserialize this\n        // object, we must check to see if there is a matching object for this\n        // object that&#x27;s already existing in memory if it DOES exist, use it. If it\n        // does NOT exist, add this to the cache of all contexts\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;CryptoContext&quot;;\n    }\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n};\n\n// Member function specializations. Their implementations are in cryptocontext.cpp\ntemplate &lt;&gt;\nDecryptResult CryptoContextImpl&lt;DCRTPoly&gt;::MultipartyDecryptFusion(\n    const std::vector&lt;Ciphertext&lt;DCRTPoly&gt;&gt;&amp; partialCiphertextVec, Plaintext* plaintext) const;\ntemplate &lt;&gt;\nstd::unordered_map&lt;uint32_t, DCRTPoly&gt; CryptoContextImpl&lt;DCRTPoly&gt;::ShareKeys(const PrivateKey&lt;DCRTPoly&gt;&amp; sk, usint N,\n                                                                              usint threshold, usint index,\n                                                                              const std::string&amp; shareType) const;\n}  // namespace lbcrypto\n\n#endif /* SRC_PKE_CRYPTOCONTEXT_H_ */\n"}, "/home/zero0000/static-analyze-openfhe/src/binfhe/lib/binfhe-base-scheme.cpp": {"id": "/home/zero0000/static-analyze-openfhe/src/binfhe/lib/binfhe-base-scheme.cpp", "filePath": "/home/zero0000/static-analyze-openfhe/src/binfhe/lib/binfhe-base-scheme.cpp", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#include &quot;binfhe-base-scheme.h&quot;\n\n#include &lt;string&gt;\n\nnamespace lbcrypto {\n\n// wrapper for KeyGen methods\nRingGSWBTKey BinFHEScheme::KeyGen(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params, ConstLWEPrivateKey&amp; LWEsk,\n                                  KEYGEN_MODE keygenMode = SYM_ENCRYPT) const {\n    const auto&amp; LWEParams = params-&gt;GetLWEParams();\n\n    RingGSWBTKey ek;\n    LWEPrivateKey skN;\n    if (keygenMode == SYM_ENCRYPT) {\n        skN = LWEscheme-&gt;KeyGen(LWEParams-&gt;GetN(), LWEParams-&gt;GetQ());\n    }\n    else if (keygenMode == PUB_ENCRYPT) {\n        ConstLWEKeyPair kpN = LWEscheme-&gt;KeyGenPair(LWEParams);\n        skN                 = kpN-&gt;secretKey;\n        ek.Pkey             = kpN-&gt;publicKey;\n    }\n    else {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Invalid KeyGen mode&quot;);\n    }\n\n    ek.KSkey = LWEscheme-&gt;KeySwitchGen(LWEParams, LWEsk, skN);\n\n    const auto&amp; RGSWParams = params-&gt;GetRingGSWParams();\n    const auto&amp; polyParams = RGSWParams-&gt;GetPolyParams();\n    NativePoly skNPoly(polyParams);\n    skNPoly.SetValues(skN-&gt;GetElement(), Format::COEFFICIENT);\n    skNPoly.SetFormat(Format::EVALUATION);\n\n    ek.BSkey = ACCscheme-&gt;KeyGenAcc(RGSWParams, skNPoly, LWEsk);\n\n    return ek;\n}\n\n// Full evaluation as described in https://eprint.iacr.org/2020/086\nLWECiphertext BinFHEScheme::EvalBinGate(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params, BINGATE gate,\n                                        const RingGSWBTKey&amp; EK, ConstLWECiphertext&amp; ct1,\n                                        ConstLWECiphertext&amp; ct2) const {\n    if (ct1 == ct2)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertexts should be independant&quot;);\n\n    // By default, we compute XOR/XNOR using a combination of AND, OR, and NOT gates\n    if ((gate == XOR) || (gate == XNOR)) {\n        const auto&amp; ctAND1 = EvalBinGate(params, AND, EK, ct1, EvalNOT(params, ct2));\n        const auto&amp; ctAND2 = EvalBinGate(params, AND, EK, EvalNOT(params, ct1), ct2);\n        const auto&amp; ctOR   = EvalBinGate(params, OR, EK, ctAND1, ctAND2);\n\n        // NOT is free so there is not cost to do it an extra time for XNOR\n        return (gate == XOR) ? ctOR : EvalNOT(params, ctOR);\n    }\n\n    LWECiphertext ctprep = std::make_shared&lt;LWECiphertextImpl&gt;(*ct1);\n    // the additive homomorphic operation for XOR/NXOR is different from the other gates we compute\n    // 2*(ct1 - ct2) mod 4 for XOR, me map 1,2 -&gt; 1 and 3,0 -&gt; 0\n    if ((gate == XOR_FAST) || (gate == XNOR_FAST)) {\n        LWEscheme-&gt;EvalSubEq(ctprep, ct2);\n        LWEscheme-&gt;EvalAddEq(ctprep, ctprep);\n    }\n    else {\n        // for all other gates, we simply compute (ct1 + ct2) mod 4\n        // for AND: 0,1 -&gt; 0 and 2,3 -&gt; 1\n        // for OR: 1,2 -&gt; 1 and 3,0 -&gt; 0\n        LWEscheme-&gt;EvalAddEq(ctprep, ct2);\n    }\n\n    auto acc{BootstrapGateCore(params, gate, EK.BSkey, ctprep)};\n\n    // the accumulator result is encrypted w.r.t. the transposed secret key\n    // we can transpose &quot;a&quot; to get an encryption under the original secret key\n    std::vector&lt;NativePoly&gt;&amp; accVec{acc-&gt;GetElements()};\n    accVec[0] = accVec[0].Transpose();\n    accVec[0].SetFormat(Format::COEFFICIENT);\n    accVec[1].SetFormat(Format::COEFFICIENT);\n\n    // we add Q/8 to &quot;b&quot; to to map back to Q/4 (i.e., mod 2) arithmetic.\n    const auto&amp; LWEParams = params-&gt;GetLWEParams();\n    NativeInteger Q{LWEParams-&gt;GetQ()};\n    NativeInteger b{(Q &gt;&gt; 3) + 1};\n    b.ModAddFastEq(accVec[1][0], Q);\n\n    auto ctExt = std::make_shared&lt;LWECiphertextImpl&gt;(std::move(accVec[0].GetValues()), std::move(b));\n    // Modulus switching to a middle step Q&#x27;\n    auto ctMS = LWEscheme-&gt;ModSwitch(LWEParams-&gt;GetqKS(), ctExt);\n    // Key switching\n    auto ctKS = LWEscheme-&gt;KeySwitch(LWEParams, EK.KSkey, ctMS);\n    // Modulus switching\n    return LWEscheme-&gt;ModSwitch(ct1-&gt;GetModulus(), ctKS);\n}\n\n// Full evaluation as described in https://eprint.iacr.org/2020/086\nLWECiphertext BinFHEScheme::EvalBinGate(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params, BINGATE gate,\n                                        const RingGSWBTKey&amp; EK, const std::vector&lt;LWECiphertext&gt;&amp; ctvector) const {\n    // check if the ciphertexts are all independent\n    for (size_t i = 0; i &lt; ctvector.size(); i++) {\n        for (size_t j = i + 1; j &lt; ctvector.size(); j++) {\n            if (ctvector[j] == ctvector[i]) {\n                &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertexts should be independent&quot;);\n            }\n        }\n    }\n\n    NativeInteger p = ctvector[0]-&gt;GetptModulus();\n\n    LWECiphertext ctprep = std::make_shared&lt;LWECiphertextImpl&gt;(*ctvector[0]);\n    ctprep-&gt;SetptModulus(p);\n    if ((gate == MAJORITY) || (gate == AND3) || (gate == OR3) || (gate == AND4) || (gate == OR4)) {\n        // we simply compute sum(ctvector[i]) mod p\n        for (size_t i = 1; i &lt; ctvector.size(); i++) {\n            LWEscheme-&gt;EvalAddEq(ctprep, ctvector[i]);\n        }\n        auto acc = BootstrapGateCore(params, gate, EK.BSkey, ctprep);\n\n        std::vector&lt;NativePoly&gt;&amp; accVec = acc-&gt;GetElements();\n        // the accumulator result is encrypted w.r.t. the transposed secret key\n        // we can transpose &quot;a&quot; to get an encryption under the original secret key\n        accVec[0] = accVec[0].Transpose();\n        accVec[0].SetFormat(Format::COEFFICIENT);\n        accVec[1].SetFormat(Format::COEFFICIENT);\n\n        // we add Q/8 to &quot;b&quot; to to map back to Q/4 (i.e., mod 2) arithmetic.\n        auto&amp; LWEParams = params-&gt;GetLWEParams();\n        NativeInteger Q = LWEParams-&gt;GetQ();\n        NativeInteger b = Q / NativeInteger(2 * p) + 1;\n        b.ModAddFastEq(accVec[1][0], Q);\n\n        auto ctExt = std::make_shared&lt;LWECiphertextImpl&gt;(std::move(accVec[0].GetValues()), std::move(b));\n        // Modulus switching to a middle step Q&#x27;\n        auto ctMS = LWEscheme-&gt;ModSwitch(LWEParams-&gt;GetqKS(), ctExt);\n        // Key switching\n        auto ctKS = LWEscheme-&gt;KeySwitch(LWEParams, EK.KSkey, ctMS);\n        // Modulus switching\n        return LWEscheme-&gt;ModSwitch(ctvector[0]-&gt;GetModulus(), ctKS);\n    }\n    else if (gate == CMUX) {\n        if (ctvector.size() != 3)\n            &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;CMUX gate implemented for ciphertext vectors of size 3&quot;);\n\n        auto ccNOT   = EvalNOT(params, ctvector[2]);\n        auto ctNAND1 = EvalBinGate(params, NAND, EK, ctvector[0], ccNOT);\n        auto ctNAND2 = EvalBinGate(params, NAND, EK, ctvector[1], ctvector[2]);\n        auto ctCMUX  = EvalBinGate(params, NAND, EK, ctNAND1, ctNAND2);\n        return ctCMUX;\n    }\n    else {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;This gate is not implemented for vector of ciphertexts at this time&quot;);\n    }\n}\n// Full evaluation as described in https://eprint.iacr.org/2020/086\nLWECiphertext BinFHEScheme::Bootstrap(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params, const RingGSWBTKey&amp; EK,\n                                      ConstLWECiphertext&amp; ct) const {\n    NativeInteger p = ct-&gt;GetptModulus();\n    LWECiphertext ctprep{std::make_shared&lt;LWECiphertextImpl&gt;(*ct)};\n    // ctprep = ct + q/4\n    LWEscheme-&gt;EvalAddConstEq(ctprep, (ct-&gt;GetModulus() &gt;&gt; 2));\n\n    auto acc{BootstrapGateCore(params, AND, EK.BSkey, ctprep)};\n\n    // the accumulator result is encrypted w.r.t. the transposed secret key\n    // we can transpose &quot;a&quot; to get an encryption under the original secret key\n    std::vector&lt;NativePoly&gt;&amp; accVec{acc-&gt;GetElements()};\n    accVec[0] = accVec[0].Transpose();\n    accVec[0].SetFormat(Format::COEFFICIENT);\n    accVec[1].SetFormat(Format::COEFFICIENT);\n\n    // we add Q/8 to &quot;b&quot; to to map back to Q/4 (i.e., mod 2) arithmetic.\n    const auto&amp; LWEParams = params-&gt;GetLWEParams();\n    NativeInteger Q{LWEParams-&gt;GetQ()};\n    NativeInteger b = Q / NativeInteger(2 * p) + 1;\n    b.ModAddFastEq(accVec[1][0], Q);\n\n    auto ctExt = std::make_shared&lt;LWECiphertextImpl&gt;(std::move(accVec[0].GetValues()), std::move(b));\n    // Modulus switching to a middle step Q&#x27;\n    auto ctMS = LWEscheme-&gt;ModSwitch(LWEParams-&gt;GetqKS(), ctExt);\n    // Key switching\n    auto ctKS = LWEscheme-&gt;KeySwitch(LWEParams, EK.KSkey, ctMS);\n    // Modulus switching\n    return LWEscheme-&gt;ModSwitch(ct-&gt;GetModulus(), ctKS);\n}\n\n// Evaluation of the NOT operation; no key material is needed\nLWECiphertext BinFHEScheme::EvalNOT(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params, ConstLWECiphertext&amp; ct) const {\n    NativeInteger q{ct-&gt;GetModulus()};\n    uint32_t n{ct-&gt;GetLength()};\n\n    NativeVector a(n, q);\n    for (uint32_t i = 0; i &lt; n; ++i)\n        a[i] = ct-&gt;GetA(i) == 0 ? 0 : q - ct-&gt;GetA(i);\n\n    return std::make_shared&lt;LWECiphertextImpl&gt;(std::move(a), (q &gt;&gt; 2).ModSubFast(ct-&gt;GetB(), q));\n}\n\n// Evaluate Arbitrary Function homomorphically\n// Modulus of ct is q | 2N\nLWECiphertext BinFHEScheme::EvalFunc(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params, const RingGSWBTKey&amp; EK,\n                                     ConstLWECiphertext&amp; ct, const std::vector&lt;NativeInteger&gt;&amp; LUT,\n                                     const NativeInteger&amp; beta) const {\n    auto ct1 = std::make_shared&lt;LWECiphertextImpl&gt;(*ct);\n    NativeInteger q{ct-&gt;GetModulus()};\n    uint32_t functionProperty{this-&gt;checkInputFunction(LUT, q)};\n\n    if (functionProperty == 0) {  // negacyclic function only needs one bootstrap\n        auto fLUT = [LUT](NativeInteger x, NativeInteger q, NativeInteger Q) -&gt; NativeInteger {\n            return LUT[x.ConvertToInt()];\n        };\n        LWEscheme-&gt;EvalAddConstEq(ct1, beta);\n        return BootstrapFunc(params, EK, ct1, fLUT, q);\n    }\n\n    if (functionProperty == 2) {  // arbitary funciton\n        const auto&amp; LWEParams = params-&gt;GetLWEParams();\n        uint32_t N{LWEParams-&gt;GetN()};\n        if (q.ConvertToInt() &gt; N) {  // need q to be at most = N for arbitary function\n            std::string errMsg =\n                &quot;ERROR: ciphertext modulus q needs to be &lt;= ring dimension for arbitrary function evaluation&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, errMsg);\n        }\n\n        // TODO: figure out a way to not do this :(\n\n        // repeat the LUT to make it periodic\n        std::vector&lt;NativeInteger&gt; LUT2 = LUT;\n        LUT2.insert(LUT2.end(), LUT.begin(), LUT.end());\n\n        NativeInteger dq{q &lt;&lt; 1};\n        // raise the modulus of ct1 : q -&gt; 2q\n        ct1-&gt;GetA().SetModulus(dq);\n\n        auto ct2 = std::make_shared&lt;LWECiphertextImpl&gt;(*ct1);\n        LWEscheme-&gt;EvalAddConstEq(ct2, beta);\n        // this is 1/4q_small or -1/4q_small mod q\n        auto f0 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -&gt; NativeInteger {\n            if (x &lt; (q &gt;&gt; 1))\n                return Q - (q &gt;&gt; 2);\n            else\n                return (q &gt;&gt; 2);\n        };\n        auto ct3 = BootstrapFunc(params, EK, ct2, f0, dq);\n        LWEscheme-&gt;EvalSubEq2(ct1, ct3);\n        LWEscheme-&gt;EvalAddConstEq(ct3, beta);\n        LWEscheme-&gt;EvalSubConstEq(ct3, q &gt;&gt; 1);\n\n        // Now the input is within the range [0, q/2).\n        // Note that for non-periodic function, the input q is boosted up to 2q\n        auto fLUT2 = [LUT2](NativeInteger x, NativeInteger q, NativeInteger Q) -&gt; NativeInteger {\n            if (x &lt; (q &gt;&gt; 1))\n                return LUT2[x.ConvertToInt()];\n            else\n                return Q - LUT2[x.ConvertToInt() - q.ConvertToInt() / 2];\n        };\n        auto ct4 = BootstrapFunc(params, EK, ct3, fLUT2, dq);\n        ct4-&gt;SetModulus(q);\n        return ct4;\n    }\n\n    // Else it&#x27;s periodic function so we evaluate directly\n    LWEscheme-&gt;EvalAddConstEq(ct1, beta);\n    // this is 1/4q_small or -1/4q_small mod q\n    auto f0 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -&gt; NativeInteger {\n        if (x &lt; (q &gt;&gt; 1))\n            return Q - (q &gt;&gt; 2);\n        else\n            return (q &gt;&gt; 2);\n    };\n    auto ct2 = BootstrapFunc(params, EK, ct1, f0, q);\n    LWEscheme-&gt;EvalSubEq2(ct, ct2);\n    LWEscheme-&gt;EvalAddConstEq(ct2, beta);\n    LWEscheme-&gt;EvalSubConstEq(ct2, q &gt;&gt; 2);\n\n    // Now the input is within the range [0, q/2).\n    // Note that for non-periodic function, the input q is boosted up to 2q\n    auto fLUT1 = [LUT](NativeInteger x, NativeInteger q, NativeInteger Q) -&gt; NativeInteger {\n        if (x &lt; (q &gt;&gt; 1))\n            return LUT[x.ConvertToInt()];\n        else\n            return Q - LUT[x.ConvertToInt() - q.ConvertToInt() / 2];\n    };\n    return BootstrapFunc(params, EK, ct2, fLUT1, q);\n}\n\n// Evaluate Homomorphic Flooring\nLWECiphertext BinFHEScheme::EvalFloor(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params, const RingGSWBTKey&amp; EK,\n                                      ConstLWECiphertext&amp; ct, const NativeInteger&amp; beta, uint32_t roundbits) const {\n    const auto&amp; LWEParams = params-&gt;GetLWEParams();\n    NativeInteger q{roundbits == 0 ? LWEParams-&gt;Getq() : beta * (1 &lt;&lt; roundbits + 1)};\n    NativeInteger mod{ct-&gt;GetModulus()};\n\n    auto ct1 = std::make_shared&lt;LWECiphertextImpl&gt;(*ct);\n    LWEscheme-&gt;EvalAddConstEq(ct1, beta);\n\n    auto ct1Modq = std::make_shared&lt;LWECiphertextImpl&gt;(*ct1);\n    ct1Modq-&gt;SetModulus(q);\n    // this is 1/4q_small or -1/4q_small mod q\n    auto f1 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -&gt; NativeInteger {\n        if (x &lt; (q &gt;&gt; 1))\n            return Q - (q &gt;&gt; 2);\n        else\n            return (q &gt;&gt; 2);\n    };\n    auto ct2 = BootstrapFunc(params, EK, ct1Modq, f1, mod);\n    LWEscheme-&gt;EvalSubEq(ct1, ct2);\n\n    auto ct2Modq = std::make_shared&lt;LWECiphertextImpl&gt;(*ct1);\n    ct2Modq-&gt;SetModulus(q);\n\n    // now the input is only within the range [0, q/2)\n    auto f2 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -&gt; NativeInteger {\n        if (x &lt; (q &gt;&gt; 2))\n            return Q - (q &gt;&gt; 1) - x;\n        else if (((q &gt;&gt; 2) &lt;= x) &amp;&amp; (x &lt; 3 * (q &gt;&gt; 2)))\n            return x;\n        else\n            return Q + (q &gt;&gt; 1) - x;\n    };\n    auto ct3 = BootstrapFunc(params, EK, ct2Modq, f2, mod);\n    LWEscheme-&gt;EvalSubEq(ct1, ct3);\n\n    return ct1;\n}\n\n// Evaluate large-precision sign\nLWECiphertext BinFHEScheme::EvalSign(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params,\n                                     const std::map&lt;uint32_t, RingGSWBTKey&gt;&amp; EKs, ConstLWECiphertext&amp; ct,\n                                     const NativeInteger&amp; beta, bool schemeSwitch) const {\n    auto mod{ct-&gt;GetModulus()};\n    const auto&amp; LWEParams = params-&gt;GetLWEParams();\n    auto q{LWEParams-&gt;Getq()};\n    if (mod &lt;= q) {\n        std::string errMsg =\n            &quot;ERROR: EvalSign is only for large precision. For small precision, please use bootstrapping directly&quot;;\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, errMsg);\n    }\n\n    const auto&amp; RGSWParams = params-&gt;GetRingGSWParams();\n    const auto curBase     = RGSWParams-&gt;GetBaseG();\n    auto search            = EKs.find(curBase);\n    if (search == EKs.end()) {\n        std::string errMsg(&quot;ERROR: No key [&quot; + std::to_string(curBase) + &quot;] found in the map&quot;);\n        &quot;hey&quot;; OPENFHE_THROW(openfhe_error, errMsg);\n    }\n    RingGSWBTKey curEK(search-&gt;second);\n\n    auto cttmp = std::make_shared&lt;LWECiphertextImpl&gt;(*ct);\n    while (mod &gt; q) {\n        cttmp = EvalFloor(params, curEK, cttmp, beta);\n        // round Q to 2betaQ/q\n        //  mod   = mod / q * 2 * beta;\n        mod   = (mod &lt;&lt; 1) * beta / q;\n        cttmp = LWEscheme-&gt;ModSwitch(mod, cttmp);\n\n        // if dynamic\n        if (EKs.size() == 3) {\n            // TODO: use GetMSB()?\n            uint32_t binLog = static_cast&lt;uint32_t&gt;(ceil(GetMSB(mod.ConvertToInt()) - 1));\n            uint32_t base{0};\n            if (binLog &lt;= static_cast&lt;uint32_t&gt;(17))\n                base = static_cast&lt;uint32_t&gt;(1) &lt;&lt; 27;\n            else if (binLog &lt;= static_cast&lt;uint32_t&gt;(26))\n                base = static_cast&lt;uint32_t&gt;(1) &lt;&lt; 18;\n\n            if (0 != base) {  // if base is to change ...\n                RGSWParams-&gt;Change_BaseG(base);\n\n                auto search = EKs.find(base);\n                if (search == EKs.end()) {\n                    std::string errMsg(&quot;ERROR: No key [&quot; + std::to_string(curBase) + &quot;] found in the map&quot;);\n                    &quot;hey&quot;; OPENFHE_THROW(openfhe_error, errMsg);\n                }\n                curEK = search-&gt;second;\n            }\n        }\n    }\n    LWEscheme-&gt;EvalAddConstEq(cttmp, beta);\n\n    if (!schemeSwitch) {\n        // if the ended q is smaller than q, we need to change the param for the final boostrapping\n        auto f3 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -&gt; NativeInteger {\n            return (x &lt; q / 2) ? (Q / 4) : (Q - Q / 4);\n        };\n        cttmp = BootstrapFunc(params, curEK, cttmp, f3, q);  // this is 1/4q_small or -1/4q_small mod q\n        LWEscheme-&gt;EvalSubConstEq(cttmp, q &gt;&gt; 2);\n    }\n    else {  // return the negated f3 and do not subtract q/4 for a more natural encoding in scheme switching\n        // if the ended q is smaller than q, we need to change the param for the final boostrapping\n        auto f3 = [](NativeInteger x, NativeInteger q, NativeInteger Q) -&gt; NativeInteger {\n            return (x &lt; q / 2) ? (Q - Q / 4) : (Q / 4);\n        };\n        cttmp = BootstrapFunc(params, curEK, cttmp, f3, q);  // this is 1/4q_small or -1/4q_small mod q\n    }\n    RGSWParams-&gt;Change_BaseG(curBase);\n    return cttmp;\n}\n\n//////\n\n// Evaluate Ciphertext Decomposition\nstd::vector&lt;LWECiphertext&gt; BinFHEScheme::EvalDecomp(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params,\n                                                    const std::map&lt;uint32_t, RingGSWBTKey&gt;&amp; EKs, ConstLWECiphertext&amp; ct,\n                                                    const NativeInteger&amp; beta) const {\n    auto mod         = ct-&gt;GetModulus();\n    auto&amp; LWEParams  = params-&gt;GetLWEParams();\n    auto&amp; RGSWParams = params-&gt;GetRingGSWParams();\n\n    NativeInteger q = LWEParams-&gt;Getq();\n    if (mod &lt;= q) {\n        std::string errMsg =\n            &quot;ERROR: EvalDecomp is only for large precision. For small precision, please use bootstrapping directly&quot;;\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, errMsg);\n    }\n\n    const auto curBase = RGSWParams-&gt;GetBaseG();\n    auto search        = EKs.find(curBase);\n    if (search == EKs.end()) {\n        std::string errMsg(&quot;ERROR: No key [&quot; + std::to_string(curBase) + &quot;] found in the map&quot;);\n        &quot;hey&quot;; OPENFHE_THROW(openfhe_error, errMsg);\n    }\n    RingGSWBTKey curEK(search-&gt;second);\n\n    auto cttmp = std::make_shared&lt;LWECiphertextImpl&gt;(*ct);\n    std::vector&lt;LWECiphertext&gt; ret;\n    while (mod &gt; q) {\n        auto ctq = std::make_shared&lt;LWECiphertextImpl&gt;(*cttmp);\n        ctq-&gt;SetModulus(q);\n        ret.push_back(std::move(ctq));\n\n        // Floor the input sequentially to obtain the most significant bit\n        cttmp = EvalFloor(params, curEK, cttmp, beta);\n        mod   = mod / q * 2 * beta;\n        // round Q to 2betaQ/q\n        cttmp = LWEscheme-&gt;ModSwitch(mod, cttmp);\n\n        if (EKs.size() == 3) {  // if dynamic\n            uint32_t binLog = static_cast&lt;uint32_t&gt;(ceil(log2(mod.ConvertToInt())));\n            uint32_t base   = 0;\n            if (binLog &lt;= static_cast&lt;uint32_t&gt;(17))\n                base = static_cast&lt;uint32_t&gt;(1) &lt;&lt; 27;\n            else if (binLog &lt;= static_cast&lt;uint32_t&gt;(26))\n                base = static_cast&lt;uint32_t&gt;(1) &lt;&lt; 18;\n\n            if (0 != base) {  // if base is to change ...\n                RGSWParams-&gt;Change_BaseG(base);\n\n                auto search = EKs.find(base);\n                if (search == EKs.end()) {\n                    std::string errMsg(&quot;ERROR: No key [&quot; + std::to_string(curBase) + &quot;] found in the map&quot;);\n                    &quot;hey&quot;; OPENFHE_THROW(openfhe_error, errMsg);\n                }\n                curEK = search-&gt;second;\n            }\n        }\n    }\n    RGSWParams-&gt;Change_BaseG(curBase);\n    ret.push_back(std::move(cttmp));\n    return ret;\n}\n\n// private:\n\nRLWECiphertext BinFHEScheme::BootstrapGateCore(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params, BINGATE gate,\n                                               ConstRingGSWACCKey&amp; ek, ConstLWECiphertext&amp; ct) const {\n    if (ek == nullptr) {\n        std::string errMsg =\n            &quot;Bootstrapping keys have not been generated. Please call BTKeyGen &quot;\n            &quot;before calling bootstrapping.&quot;;\n        &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n    }\n\n    auto&amp; LWEParams  = params-&gt;GetLWEParams();\n    auto&amp; RGSWParams = params-&gt;GetRingGSWParams();\n    auto polyParams  = RGSWParams-&gt;GetPolyParams();\n\n    // Specifies the range [q1,q2) that will be used for mapping\n    NativeInteger p  = ct-&gt;GetptModulus();\n    NativeInteger q  = ct-&gt;GetModulus();\n    uint32_t qHalf   = q.ConvertToInt() &gt;&gt; 1;\n    NativeInteger q1 = RGSWParams-&gt;GetGateConst()[static_cast&lt;size_t&gt;(gate)];\n    NativeInteger q2 = q1.ModAddFast(NativeInteger(qHalf), q);\n\n    // depending on whether the value is the range, it will be set\n    // to either Q/8 or -Q/8 to match binary arithmetic\n    NativeInteger Q      = LWEParams-&gt;GetQ();\n    NativeInteger Q2p    = Q / NativeInteger(2 * p) + 1;\n    NativeInteger Q2pNeg = Q - Q2p;\n\n    uint32_t N = LWEParams-&gt;GetN();\n    NativeVector m(N, Q);\n    // Since q | (2*N), we deal with a sparse embedding of Z_Q[x]/(X^{q/2}+1) to\n    // Z_Q[x]/(X^N+1)\n    uint32_t factor = (2 * N / q.ConvertToInt());\n\n    const NativeInteger&amp; b = ct-&gt;GetB();\n    for (size_t j = 0; j &lt; qHalf; ++j) {\n        NativeInteger temp = b.ModSub(j, q);\n        if (q1 &lt; q2)\n            m[j * factor] = ((temp &gt;= q1) &amp;&amp; (temp &lt; q2)) ? Q2pNeg : Q2p;\n        else\n            m[j * factor] = ((temp &gt;= q2) &amp;&amp; (temp &lt; q1)) ? Q2p : Q2pNeg;\n    }\n    std::vector&lt;NativePoly&gt; res(2);\n    // no need to do NTT as all coefficients of this poly are zero\n    res[0] = NativePoly(polyParams, Format::EVALUATION, true);\n    res[1] = NativePoly(polyParams, Format::COEFFICIENT, false);\n    res[1].SetValues(std::move(m), Format::COEFFICIENT);\n    res[1].SetFormat(Format::EVALUATION);\n\n    // main accumulation computation\n    // the following loop is the bottleneck of bootstrapping/binary gate\n    // evaluation\n    auto acc = std::make_shared&lt;RLWECiphertextImpl&gt;(std::move(res));\n    ACCscheme-&gt;EvalAcc(RGSWParams, ek, acc, ct-&gt;GetA());\n    return acc;\n}\n\n// Functions below are for large-precision sign evaluation,\n// flooring, homomorphic digit decomposition, and arbitrary\n// funciton evaluation, from https://eprint.iacr.org/2021/1337\ntemplate &lt;typename Func&gt;\nRLWECiphertext BinFHEScheme::BootstrapFuncCore(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params,\n                                               ConstRingGSWACCKey&amp; ek, ConstLWECiphertext&amp; ct, const Func f,\n                                               const NativeInteger&amp; fmod) const {\n    if (ek == nullptr) {\n        std::string errMsg =\n            &quot;Bootstrapping keys have not been generated. Please call BTKeyGen before calling bootstrapping.&quot;;\n        &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n    }\n\n    auto&amp; LWEParams  = params-&gt;GetLWEParams();\n    auto&amp; RGSWParams = params-&gt;GetRingGSWParams();\n    auto polyParams  = RGSWParams-&gt;GetPolyParams();\n\n    NativeInteger Q = LWEParams-&gt;GetQ();\n    uint32_t N      = LWEParams-&gt;GetN();\n    NativeVector m(N, Q);\n    // For specific function evaluation instead of general bootstrapping\n    NativeInteger ctMod    = ct-&gt;GetModulus();\n    uint32_t factor        = (2 * N / ctMod.ConvertToInt());\n    const NativeInteger&amp; b = ct-&gt;GetB();\n    for (size_t j = 0; j &lt; (ctMod &gt;&gt; 1); ++j) {\n        NativeInteger temp = b.ModSub(j, ctMod);\n        m[j * factor]      = Q.ConvertToInt() / fmod.ConvertToInt() * f(temp, ctMod, fmod);\n    }\n    std::vector&lt;NativePoly&gt; res(2);\n    // no need to do NTT as all coefficients of this poly are zero\n    res[0] = NativePoly(polyParams, Format::EVALUATION, true);\n    res[1] = NativePoly(polyParams, Format::COEFFICIENT, false);\n    res[1].SetValues(std::move(m), Format::COEFFICIENT);\n    res[1].SetFormat(Format::EVALUATION);\n\n    // main accumulation computation\n    // the following loop is the bottleneck of bootstrapping/binary gate\n    // evaluation\n    auto acc = std::make_shared&lt;RLWECiphertextImpl&gt;(std::move(res));\n    ACCscheme-&gt;EvalAcc(RGSWParams, ek, acc, ct-&gt;GetA());\n    return acc;\n}\n\n// Full evaluation as described in https://eprint.iacr.org/2020/086\ntemplate &lt;typename Func&gt;\nLWECiphertext BinFHEScheme::BootstrapFunc(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params, const RingGSWBTKey&amp; EK,\n                                          ConstLWECiphertext&amp; ct, const Func f, const NativeInteger&amp; fmod) const {\n    auto acc = BootstrapFuncCore(params, EK.BSkey, ct, f, fmod);\n\n    std::vector&lt;NativePoly&gt;&amp; accVec = acc-&gt;GetElements();\n    // the accumulator result is encrypted w.r.t. the transposed secret key\n    // we can transpose &quot;a&quot; to get an encryption under the original secret key\n    accVec[0] = accVec[0].Transpose();\n    accVec[0].SetFormat(Format::COEFFICIENT);\n    accVec[1].SetFormat(Format::COEFFICIENT);\n\n    auto ctExt      = std::make_shared&lt;LWECiphertextImpl&gt;(std::move(accVec[0].GetValues()), std::move(accVec[1][0]));\n    auto&amp; LWEParams = params-&gt;GetLWEParams();\n    // Modulus switching to a middle step Q&#x27;\n    auto ctMS = LWEscheme-&gt;ModSwitch(LWEParams-&gt;GetqKS(), ctExt);\n    // Key switching\n    auto ctKS = LWEscheme-&gt;KeySwitch(LWEParams, EK.KSkey, ctMS);\n    // Modulus switching\n    return LWEscheme-&gt;ModSwitch(fmod, ctKS);\n}\n\n};  // namespace lbcrypto\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n\tCKKS to FHEW scheme switching implementation.\n */\n\n#define PROFILE\n\n#include &quot;scheme/ckksrns/ckksrns-schemeswitching.h&quot;\n\n#include &quot;cryptocontext.h&quot;\n#include &quot;gen-cryptocontext.h&quot;\n\n#include &quot;scheme/ckksrns/ckksrns-cryptoparameters.h&quot;\n#include &quot;scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h&quot;\n#include &quot;scheme/ckksrns/cryptocontext-ckksrns.h&quot;\n#include &quot;scheme/ckksrns/cryptocontextparams-ckksrns.h&quot;\n\n#include &quot;scheme/ckksrns/ckksrns-scheme.h&quot;\n#include &quot;cryptocontextfactory.h&quot;\n#include &quot;schemebase/base-scheme.h&quot;\n#include &quot;math/dftransform.h&quot;\n\nnamespace lbcrypto {\n\n//------------------------------------------------------------------------------\n// Complex Plaintext Functions, copied from ckksrns-fhe. TODO: fix this\n//------------------------------------------------------------------------------\n\n#if NATIVEINT == 128 &amp;&amp; !defined(__EMSCRIPTEN__)\nPlaintext SWITCHCKKSRNS::MakeAuxPlaintext(const CryptoContextImpl&lt;DCRTPoly&gt;&amp; cc, const std::shared_ptr&lt;ParmType&gt; params,\n                                          const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; value, size_t noiseScaleDeg,\n                                          uint32_t level, usint slots) const {\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(cc.GetCryptoParameters());\n\n    double scFact = cryptoParams-&gt;GetScalingFactorReal(level);\n\n    Plaintext p = Plaintext(std::make_shared&lt;CKKSPackedEncoding&gt;(params, cc.GetEncodingParams(), value, noiseScaleDeg,\n                                                                 level, scFact, slots));\n\n    DCRTPoly&amp; plainElement = p-&gt;GetElement&lt;DCRTPoly&gt;();\n\n    usint N = cc.GetRingDimension();\n\n    std::vector&lt;std::complex&lt;double&gt;&gt; inverse = value;\n\n    inverse.resize(slots);\n\n    DiscreteFourierTransform::FFTSpecialInv(inverse, N * 2);\n    uint64_t pBits = cc.GetEncodingParams()-&gt;GetPlaintextModulus();\n\n    double powP      = std::pow(2.0, MAX_DOUBLE_PRECISION);\n    int32_t pCurrent = pBits - MAX_DOUBLE_PRECISION;\n\n    std::vector&lt;int128_t&gt; temp(2 * slots);\n    for (size_t i = 0; i &lt; slots; ++i) {\n        // extract the mantissa of real part and multiply it by 2^52\n        int32_t n1 = 0;\n        double dre = std::frexp(inverse[i].real(), &amp;n1) * powP;\n        // extract the mantissa of imaginary part and multiply it by 2^52\n        int32_t n2 = 0;\n        double dim = std::frexp(inverse[i].imag(), &amp;n2) * powP;\n\n        // Check for possible overflow\n        if (is128BitOverflow(dre) || is128BitOverflow(dim)) {\n            DiscreteFourierTransform::FFTSpecial(inverse, N * 2);\n\n            double invLen = static_cast&lt;double&gt;(inverse.size());\n            double factor = 2 * M_PI * i;\n\n            double realMax = -1, imagMax = -1;\n            uint32_t realMaxIdx = -1, imagMaxIdx = -1;\n\n            for (uint32_t idx = 0; idx &lt; inverse.size(); idx++) {\n                // exp( j*2*pi*n*k/N )\n                std::complex&lt;double&gt; expFactor = {cos((factor * idx) / invLen), sin((factor * idx) / invLen)};\n\n                // X[k] * exp( j*2*pi*n*k/N )\n                std::complex&lt;double&gt; prodFactor = inverse[idx] * expFactor;\n\n                double realVal = prodFactor.real();\n                double imagVal = prodFactor.imag();\n\n                if (realVal &gt; realMax) {\n                    realMax    = realVal;\n                    realMaxIdx = idx;\n                }\n                if (imagVal &gt; imagMax) {\n                    imagMax    = imagVal;\n                    imagMaxIdx = idx;\n                }\n            }\n\n            auto scaledInputSize = ceil(log2(dre));\n\n            std::stringstream buffer;\n            buffer &lt;&lt; std::endl\n                   &lt;&lt; &quot;Overflow in data encoding - scaled input is too large to fit &quot;\n                      &quot;into a NativeInteger (60 bits). Try decreasing scaling factor.&quot;\n                   &lt;&lt; std::endl;\n            buffer &lt;&lt; &quot;Overflow at slot number &quot; &lt;&lt; i &lt;&lt; std::endl;\n            buffer &lt;&lt; &quot;- Max real part contribution from input[&quot; &lt;&lt; realMaxIdx &lt;&lt; &quot;]: &quot; &lt;&lt; realMax &lt;&lt; std::endl;\n            buffer &lt;&lt; &quot;- Max imaginary part contribution from input[&quot; &lt;&lt; imagMaxIdx &lt;&lt; &quot;]: &quot; &lt;&lt; imagMax &lt;&lt; std::endl;\n            buffer &lt;&lt; &quot;Scaling factor is &quot; &lt;&lt; ceil(log2(powP)) &lt;&lt; &quot; bits &quot; &lt;&lt; std::endl;\n            buffer &lt;&lt; &quot;Scaled input is &quot; &lt;&lt; scaledInputSize &lt;&lt; &quot; bits &quot; &lt;&lt; std::endl;\n            &quot;hey&quot;; OPENFHE_THROW(math_error, buffer.str());\n        }\n\n        int64_t re64       = std::llround(dre);\n        int32_t pRemaining = pCurrent + n1;\n        __int128 re        = 0;\n        if (pRemaining &lt; 0) {\n            re = re64 &gt;&gt; (-pRemaining);\n        }\n        else {\n            __int128 pPowRemaining = ((__int128)1) &lt;&lt; pRemaining;\n            re                     = pPowRemaining * re64;\n        }\n\n        int64_t im64 = std::llround(dim);\n        pRemaining   = pCurrent + n2;\n        __int128 im  = 0;\n        if (pRemaining &lt; 0) {\n            im = im64 &gt;&gt; (-pRemaining);\n        }\n        else {\n            __int128 pPowRemaining = ((int64_t)1) &lt;&lt; pRemaining;\n            im                     = pPowRemaining * im64;\n        }\n\n        temp[i]         = (re &lt; 0) ? Max128BitValue() + re : re;\n        temp[i + slots] = (im &lt; 0) ? Max128BitValue() + im : im;\n\n        if (is128BitOverflow(temp[i]) || is128BitOverflow(temp[i + slots])) {\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Overflow, try to decrease scaling factor&quot;);\n        }\n    }\n\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; bigParams        = plainElement.GetParams();\n    const std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt;&amp; nativeParams = bigParams-&gt;GetParams();\n\n    for (size_t i = 0; i &lt; nativeParams.size(); i++) {\n        NativeVector nativeVec(N, nativeParams[i]-&gt;GetModulus());\n        FitToNativeVector(N, temp, Max128BitValue(), &amp;nativeVec);\n        NativePoly element = plainElement.GetElementAtIndex(i);\n        element.SetValues(nativeVec, Format::COEFFICIENT);\n        plainElement.SetElementAtIndex(i, element);\n    }\n\n    usint numTowers = nativeParams.size();\n    std::vector&lt;DCRTPoly::Integer&gt; moduli(numTowers);\n    for (usint i = 0; i &lt; numTowers; i++) {\n        moduli[i] = nativeParams[i]-&gt;GetModulus();\n    }\n\n    DCRTPoly::Integer intPowP = NativeInteger(1) &lt;&lt; pBits;\n    std::vector&lt;DCRTPoly::Integer&gt; crtPowP(numTowers, intPowP);\n\n    auto currPowP = crtPowP;\n\n    // We want to scale temp by 2^(pd), and the loop starts from j=2\n    // because temp is already scaled by 2^p in the re/im loop above,\n    // and currPowP already is 2^p.\n    for (size_t i = 2; i &lt; noiseScaleDeg; i++) {\n        currPowP = CKKSPackedEncoding::CRTMult(currPowP, crtPowP, moduli);\n    }\n\n    if (noiseScaleDeg &gt; 1) {\n        plainElement = plainElement.Times(currPowP);\n    }\n\n    p-&gt;SetFormat(Format::EVALUATION);\n    p-&gt;SetScalingFactor(pow(p-&gt;GetScalingFactor(), noiseScaleDeg));\n\n    return p;\n}\n#else\nPlaintext SWITCHCKKSRNS::MakeAuxPlaintext(const CryptoContextImpl&lt;DCRTPoly&gt;&amp; cc, const std::shared_ptr&lt;ParmType&gt; params,\n                                          const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; value, size_t noiseScaleDeg,\n                                          uint32_t level, usint slots) const {\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(cc.GetCryptoParameters());\n\n    double scFact = cryptoParams-&gt;GetScalingFactorReal(level);\n\n    Plaintext p = Plaintext(std::make_shared&lt;CKKSPackedEncoding&gt;(params, cc.GetEncodingParams(), value, noiseScaleDeg,\n                                                                 level, scFact, slots));\n\n    DCRTPoly&amp; plainElement = p-&gt;GetElement&lt;DCRTPoly&gt;();\n\n    usint N = cc.GetRingDimension();\n\n    std::vector&lt;std::complex&lt;double&gt;&gt; inverse = value;\n\n    inverse.resize(slots);\n\n    DiscreteFourierTransform::FFTSpecialInv(inverse, N * 2);\n    double powP = scFact;\n\n    // Compute approxFactor, a value to scale down by, in case the value exceeds a 64-bit integer.\n    constexpr int32_t MAX_BITS_IN_WORD = 61;\n\n    int32_t logc = 0;\n    for (size_t i = 0; i &lt; slots; ++i) {\n        inverse[i] *= powP;\n        if (inverse[i].real() != 0) {\n            int32_t logci = static_cast&lt;int32_t&gt;(ceil(log2(std::abs(inverse[i].real()))));\n            if (logc &lt; logci)\n                logc = logci;\n        }\n        if (inverse[i].imag() != 0) {\n            int32_t logci = static_cast&lt;int32_t&gt;(ceil(log2(std::abs(inverse[i].imag()))));\n            if (logc &lt; logci)\n                logc = logci;\n        }\n    }\n    if (logc &lt; 0) {\n        &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Too small scaling factor&quot;);\n    }\n    int32_t logValid    = (logc &lt;= MAX_BITS_IN_WORD) ? logc : MAX_BITS_IN_WORD;\n    int32_t logApprox   = logc - logValid;\n    double approxFactor = pow(2, logApprox);\n\n    std::vector&lt;int64_t&gt; temp(2 * slots);\n    for (size_t i = 0; i &lt; slots; ++i) {\n        // Scale down by approxFactor in case the value exceeds a 64-bit integer.\n        double dre = inverse[i].real() / approxFactor;\n        double dim = inverse[i].imag() / approxFactor;\n\n        // Check for possible overflow\n        if (is64BitOverflow(dre) || is64BitOverflow(dim)) {\n            DiscreteFourierTransform::FFTSpecial(inverse, N * 2);\n\n            double invLen = static_cast&lt;double&gt;(inverse.size());\n            double factor = 2 * M_PI * i;\n\n            double realMax = -1, imagMax = -1;\n            uint32_t realMaxIdx = -1, imagMaxIdx = -1;\n\n            for (uint32_t idx = 0; idx &lt; inverse.size(); idx++) {\n                // exp( j*2*pi*n*k/N )\n                std::complex&lt;double&gt; expFactor = {cos((factor * idx) / invLen), sin((factor * idx) / invLen)};\n\n                // X[k] * exp( j*2*pi*n*k/N )\n                std::complex&lt;double&gt; prodFactor = inverse[idx] * expFactor;\n\n                double realVal = prodFactor.real();\n                double imagVal = prodFactor.imag();\n\n                if (realVal &gt; realMax) {\n                    realMax    = realVal;\n                    realMaxIdx = idx;\n                }\n                if (imagVal &gt; imagMax) {\n                    imagMax    = imagVal;\n                    imagMaxIdx = idx;\n                }\n            }\n\n            auto scaledInputSize = ceil(log2(dre));\n\n            std::stringstream buffer;\n            buffer &lt;&lt; std::endl\n                   &lt;&lt; &quot;Overflow in data encoding - scaled input is too large to fit &quot;\n                      &quot;into a NativeInteger (60 bits). Try decreasing scaling factor.&quot;\n                   &lt;&lt; std::endl;\n            buffer &lt;&lt; &quot;Overflow at slot number &quot; &lt;&lt; i &lt;&lt; std::endl;\n            buffer &lt;&lt; &quot;- Max real part contribution from input[&quot; &lt;&lt; realMaxIdx &lt;&lt; &quot;]: &quot; &lt;&lt; realMax &lt;&lt; std::endl;\n            buffer &lt;&lt; &quot;- Max imaginary part contribution from input[&quot; &lt;&lt; imagMaxIdx &lt;&lt; &quot;]: &quot; &lt;&lt; imagMax &lt;&lt; std::endl;\n            buffer &lt;&lt; &quot;Scaling factor is &quot; &lt;&lt; ceil(log2(powP)) &lt;&lt; &quot; bits &quot; &lt;&lt; std::endl;\n            buffer &lt;&lt; &quot;Scaled input is &quot; &lt;&lt; scaledInputSize &lt;&lt; &quot; bits &quot; &lt;&lt; std::endl;\n            &quot;hey&quot;; OPENFHE_THROW(math_error, buffer.str());\n        }\n\n        int64_t re = std::llround(dre);\n        int64_t im = std::llround(dim);\n\n        temp[i]         = (re &lt; 0) ? Max64BitValue() + re : re;\n        temp[i + slots] = (im &lt; 0) ? Max64BitValue() + im : im;\n    }\n\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; bigParams        = plainElement.GetParams();\n    const std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt;&amp; nativeParams = bigParams-&gt;GetParams();\n\n    for (size_t i = 0; i &lt; nativeParams.size(); i++) {\n        NativeVector nativeVec(N, nativeParams[i]-&gt;GetModulus());\n        FitToNativeVector(N, temp, Max64BitValue(), &amp;nativeVec);\n        NativePoly element = plainElement.GetElementAtIndex(i);\n        element.SetValues(nativeVec, Format::COEFFICIENT);\n        plainElement.SetElementAtIndex(i, element);\n    }\n\n    usint numTowers = nativeParams.size();\n    std::vector&lt;DCRTPoly::Integer&gt; moduli(numTowers);\n    for (usint i = 0; i &lt; numTowers; i++) {\n        moduli[i] = nativeParams[i]-&gt;GetModulus();\n    }\n\n    DCRTPoly::Integer intPowP = std::llround(powP);\n    std::vector&lt;DCRTPoly::Integer&gt; crtPowP(numTowers, intPowP);\n\n    auto currPowP = crtPowP;\n\n    // We want to scale temp by 2^(pd), and the loop starts from j=2\n    // because temp is already scaled by 2^p in the re/im loop above,\n    // and currPowP already is 2^p.\n    for (size_t i = 2; i &lt; noiseScaleDeg; i++) {\n        currPowP = CKKSPackedEncoding::CRTMult(currPowP, crtPowP, moduli);\n    }\n\n    if (noiseScaleDeg &gt; 1) {\n        plainElement = plainElement.Times(currPowP);\n    }\n\n    // Scale back up by the approxFactor to get the correct encoding.\n    if (logApprox &gt; 0) {\n        int32_t logStep = (logApprox &lt;= MAX_LOG_STEP) ? logApprox : MAX_LOG_STEP;\n        auto intStep    = DCRTPoly::Integer(uint64_t(1) &lt;&lt; logStep);\n        std::vector&lt;DCRTPoly::Integer&gt; crtApprox(numTowers, intStep);\n        logApprox -= logStep;\n\n        while (logApprox &gt; 0) {\n            logStep = (logApprox &lt;= MAX_LOG_STEP) ? logApprox : MAX_LOG_STEP;\n            intStep = DCRTPoly::Integer(uint64_t(1) &lt;&lt; logStep);\n            std::vector&lt;DCRTPoly::Integer&gt; crtSF(numTowers, intStep);\n            crtApprox = CKKSPackedEncoding::CRTMult(crtApprox, crtSF, moduli);\n            logApprox -= logStep;\n        }\n        plainElement = plainElement.Times(crtApprox);\n    }\n\n    p-&gt;SetFormat(Format::EVALUATION);\n    p-&gt;SetScalingFactor(pow(p-&gt;GetScalingFactor(), noiseScaleDeg));\n\n    return p;\n}\n#endif\n\nCiphertext&lt;DCRTPoly&gt; SWITCHCKKSRNS::EvalMultExt(ConstCiphertext&lt;DCRTPoly&gt; ciphertext, ConstPlaintext plaintext) const {\n    Ciphertext&lt;DCRTPoly&gt; result = ciphertext-&gt;Clone();\n    std::vector&lt;DCRTPoly&gt;&amp; cv   = result-&gt;GetElements();\n\n    DCRTPoly pt = plaintext-&gt;GetElement&lt;DCRTPoly&gt;();\n    pt.SetFormat(Format::EVALUATION);\n\n    for (auto&amp; c : cv) {\n        c *= pt;\n    }\n    result-&gt;SetNoiseScaleDeg(result-&gt;GetNoiseScaleDeg() + plaintext-&gt;GetNoiseScaleDeg());\n    result-&gt;SetScalingFactor(result-&gt;GetScalingFactor() * plaintext-&gt;GetScalingFactor());\n    return result;\n}\n\nvoid SWITCHCKKSRNS::EvalAddExtInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1, ConstCiphertext&lt;DCRTPoly&gt; ciphertext2) const {\n    std::vector&lt;DCRTPoly&gt;&amp; cv1       = ciphertext1-&gt;GetElements();\n    const std::vector&lt;DCRTPoly&gt;&amp; cv2 = ciphertext2-&gt;GetElements();\n\n    for (size_t i = 0; i &lt; cv1.size(); ++i) {\n        cv1[i] += cv2[i];\n    }\n}\n\nCiphertext&lt;DCRTPoly&gt; SWITCHCKKSRNS::EvalAddExt(ConstCiphertext&lt;DCRTPoly&gt; ciphertext1,\n                                               ConstCiphertext&lt;DCRTPoly&gt; ciphertext2) const {\n    Ciphertext&lt;DCRTPoly&gt; result = ciphertext1-&gt;Clone();\n    EvalAddExtInPlace(result, ciphertext2);\n    return result;\n}\n\nEvalKey&lt;DCRTPoly&gt; SWITCHCKKSRNS::ConjugateKeyGen(const PrivateKey&lt;DCRTPoly&gt; privateKey) const {\n    const auto cc = privateKey-&gt;GetCryptoContext();\n    auto algo     = cc-&gt;GetScheme();\n\n    const DCRTPoly&amp; s = privateKey-&gt;GetPrivateElement();\n    usint N           = s.GetRingDimension();\n\n    PrivateKey&lt;DCRTPoly&gt; privateKeyPermuted = std::make_shared&lt;PrivateKeyImpl&lt;DCRTPoly&gt;&gt;(cc);\n\n    usint index = 2 * N - 1;\n    std::vector&lt;usint&gt; vec(N);\n    PrecomputeAutoMap(N, index, &amp;vec);\n\n    DCRTPoly sPermuted = s.AutomorphismTransform(index, vec);\n\n    privateKeyPermuted-&gt;SetPrivateElement(sPermuted);\n    privateKeyPermuted-&gt;SetKeyTag(privateKey-&gt;GetKeyTag());\n\n    return algo-&gt;KeySwitchGen(privateKey, privateKeyPermuted);\n}\n\nCiphertext&lt;DCRTPoly&gt; SWITCHCKKSRNS::Conjugate(ConstCiphertext&lt;DCRTPoly&gt; ciphertext,\n                                              const std::map&lt;usint, EvalKey&lt;DCRTPoly&gt;&gt;&amp; evalKeyMap) const {\n    const std::vector&lt;DCRTPoly&gt;&amp; cv = ciphertext-&gt;GetElements();\n    usint N                         = cv[0].GetRingDimension();\n\n    std::vector&lt;usint&gt; vec(N);\n    PrecomputeAutoMap(N, 2 * N - 1, &amp;vec);\n\n    auto algo = ciphertext-&gt;GetCryptoContext()-&gt;GetScheme();\n\n    Ciphertext&lt;DCRTPoly&gt; result = ciphertext-&gt;Clone();\n\n    algo-&gt;KeySwitchInPlace(result, evalKeyMap.at(2 * N - 1));\n\n    std::vector&lt;DCRTPoly&gt;&amp; rcv = result-&gt;GetElements();\n\n    rcv[0] = rcv[0].AutomorphismTransform(2 * N - 1, vec);\n    rcv[1] = rcv[1].AutomorphismTransform(2 * N - 1, vec);\n\n    return result;\n}\n\n#if NATIVEINT == 128 &amp;&amp; !defined(__EMSCRIPTEN__)\nvoid SWITCHCKKSRNS::FitToNativeVector(uint32_t ringDim, const std::vector&lt;__int128&gt;&amp; vec, __int128 bigBound,\n                                      NativeVector* nativeVec) const {\n    if (nativeVec == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The passed native vector is empty.&quot;);\n    NativeInteger bigValueHf((unsigned __int128)bigBound &gt;&gt; 1);\n    NativeInteger modulus(nativeVec-&gt;GetModulus());\n    NativeInteger diff = NativeInteger((unsigned __int128)bigBound) - modulus;\n    uint32_t dslots    = vec.size();\n    uint32_t gap       = ringDim / dslots;\n    for (usint i = 0; i &lt; vec.size(); i++) {\n        NativeInteger n((unsigned __int128)vec[i]);\n        if (n &gt; bigValueHf) {\n            (*nativeVec)[gap * i] = n.ModSub(diff, modulus);\n        }\n        else {\n            (*nativeVec)[gap * i] = n.Mod(modulus);\n        }\n    }\n}\n#else  // NATIVEINT == 64\nvoid SWITCHCKKSRNS::FitToNativeVector(uint32_t ringDim, const std::vector&lt;int64_t&gt;&amp; vec, int64_t bigBound,\n                                      NativeVector* nativeVec) const {\n    if (nativeVec == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The passed native vector is empty.&quot;);\n    NativeInteger bigValueHf(bigBound &gt;&gt; 1);\n    NativeInteger modulus(nativeVec-&gt;GetModulus());\n    NativeInteger diff = bigBound - modulus;\n    uint32_t dslots    = vec.size();\n    uint32_t gap       = ringDim / dslots;\n    for (usint i = 0; i &lt; vec.size(); i++) {\n        NativeInteger n(vec[i]);\n        if (n &gt; bigValueHf) {\n            (*nativeVec)[gap * i] = n.ModSub(diff, modulus);\n        }\n        else {\n            (*nativeVec)[gap * i] = n.Mod(modulus);\n        }\n    }\n}\n#endif\n\n//------------------------------------------------------------------------------\n// Key and modulus switch and extraction methods\n//------------------------------------------------------------------------------\n\nNativeInteger RoundqQAlter(const NativeInteger&amp; v, const NativeInteger&amp; q, const NativeInteger&amp; Q) {\n    return NativeInteger(\n               (BasicInteger)std::floor(0.5 + v.ConvertToDouble() * q.ConvertToDouble() / Q.ConvertToDouble()))\n        .Mod(q);\n}\n\nNativeInteger RoundqScale(const NativeInteger&amp; v, const NativeInteger&amp; q, const double&amp; Q) {\n    return NativeInteger((BasicInteger)std::floor(0.5 + v.ConvertToDouble() / Q * q.ConvertToDouble())).Mod(q);\n}\n\nNativeInteger RoundqScaleAlter(const NativeInteger&amp; v, const NativeInteger&amp; q, const double&amp; scFactor,\n                               const NativeInteger&amp; p) {\n    return NativeInteger((BasicInteger)std::floor(0.5 + v.ConvertToDouble() / scFactor *\n                                                            (q.ConvertToDouble() / p.ConvertToDouble())))\n        .Mod(q);\n}\n\nEvalKey&lt;DCRTPoly&gt; switchingKeyGenRLWE(\n    const PrivateKey&lt;DCRTPoly&gt;&amp; ckksSK,\n    ConstLWEPrivateKey&amp; LWEsk) {  // This function is without the intermediate ModSwitch\n    // Extract CKKS params: method which populates the first n elements of a new RLWE key with the n elements of the target LWE key\n    auto skelements = ckksSK-&gt;GetPrivateElement();\n    skelements.SetFormat(Format::COEFFICIENT);\n    auto lweskElements = LWEsk-&gt;GetElement();\n    for (size_t i = 0; i &lt; skelements.GetNumOfElements(); i++) {\n        auto skelementsPlain = skelements.GetElementAtIndex(i);\n        for (size_t j = 0; j &lt; skelementsPlain.GetLength(); j++) {\n            if (j &gt;= lweskElements.GetLength()) {\n                skelementsPlain[j] = 0;\n            }\n            else {\n                if (lweskElements[j] == 0) {\n                    skelementsPlain[j] = 0;\n                }\n                else if (lweskElements[j].ConvertToInt() == 1) {\n                    skelementsPlain[j] = 1;\n                }\n                else\n                    skelementsPlain[j] = skelementsPlain.GetModulus() - 1;\n            }\n        }\n        skelements.SetElementAtIndex(i, skelementsPlain);\n    }\n\n    skelements.SetFormat(Format::EVALUATION);\n\n    auto ccCKKS    = ckksSK-&gt;GetCryptoContext();\n    auto RLWELWEsk = ccCKKS-&gt;KeyGen().secretKey;\n    RLWELWEsk-&gt;SetPrivateElement(std::move(skelements));\n\n    return ccCKKS-&gt;KeySwitchGen(ckksSK, RLWELWEsk);\n}\n\nvoid ModSwitch(ConstCiphertext&lt;DCRTPoly&gt; ctxt, Ciphertext&lt;DCRTPoly&gt;&amp; ctxtKS, NativeInteger modulus_CKKS_to) {\n    if (ctxt-&gt;GetElements()[0].GetRingDimension() != ctxtKS-&gt;GetElements()[0].GetRingDimension()) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;ModSwitch is implemented only for the same ring dimension.&quot;);\n    }\n\n    auto Q = ctxt-&gt;GetElements()[0].GetModulus();\n\n    const std::vector&lt;DCRTPoly&gt; cv = ctxt-&gt;GetElements();\n\n    if (cv[0].GetNumOfElements() != 1 || ctxtKS-&gt;GetElements()[0].GetNumOfElements() != 1) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;ModSwitch is implemented only for ciphertext with one tower.&quot;);\n    }\n\n    const auto&amp; paramsQlP = ctxtKS-&gt;GetElements()[0].GetParams();\n    std::vector&lt;DCRTPoly&gt; resultElements(cv.size());\n\n    for (uint32_t i = 0; i &lt; cv.size(); i++) {\n        resultElements[i] = DCRTPoly(paramsQlP, Format::COEFFICIENT, true);\n        resultElements[i].SetValuesModSwitch(cv[i], modulus_CKKS_to);\n        resultElements[i].SetFormat(Format::EVALUATION);\n    }\n\n    ctxtKS-&gt;SetElements(resultElements);\n}\n\nEvalKey&lt;DCRTPoly&gt; switchingKeyGen(const PrivateKey&lt;DCRTPoly&gt;&amp; ckksSKto, const PrivateKey&lt;DCRTPoly&gt;&amp; ckksSKfrom) {\n    auto skElements = ckksSKto-&gt;GetPrivateElement();\n    skElements.SetFormat(Format::COEFFICIENT);\n    auto skElementsFrom = ckksSKfrom-&gt;GetPrivateElement();\n    skElementsFrom.SetFormat(Format::COEFFICIENT);\n\n    for (size_t i = 0; i &lt; skElements.GetNumOfElements(); i++) {\n        auto skElementsPlain     = skElements.GetElementAtIndex(i);\n        auto skElementsFromPlain = skElementsFrom.GetElementAtIndex(i);\n        for (size_t j = 0; j &lt; skElementsPlain.GetLength(); j++) {\n            if (skElementsFromPlain[j] == 0) {\n                skElementsPlain[j] = 0;\n            }\n            else if (skElementsFromPlain[j] == 1) {\n                skElementsPlain[j] = 1;\n            }\n            else\n                skElementsPlain[j] = skElementsPlain.GetModulus() - 1;\n        }\n        skElements.SetElementAtIndex(i, skElementsPlain);\n    }\n\n    skElements.SetFormat(Format::EVALUATION);\n\n    auto ccCKKSto        = ckksSKto-&gt;GetCryptoContext();\n    auto oldTranformedSK = ccCKKSto-&gt;KeyGen().secretKey;\n    oldTranformedSK-&gt;SetPrivateElement(std::move(skElements));\n\n    return ccCKKSto-&gt;KeySwitchGen(oldTranformedSK, ckksSKto);\n}\n\nEvalKey&lt;DCRTPoly&gt; switchingKeyGenRLWEcc(const PrivateKey&lt;DCRTPoly&gt;&amp; ckksSKto, const PrivateKey&lt;DCRTPoly&gt;&amp; ckksSKfrom,\n                                        ConstLWEPrivateKey&amp; LWEsk) {\n    auto skElements = ckksSKto-&gt;GetPrivateElement();\n    skElements.SetFormat(Format::COEFFICIENT);\n    auto skElementsFrom = ckksSKfrom-&gt;GetPrivateElement();\n    skElementsFrom.SetFormat(Format::COEFFICIENT);\n    auto skElements2 = ckksSKto-&gt;GetPrivateElement();\n    skElements2.SetFormat(Format::COEFFICIENT);\n    auto lweskElements = LWEsk-&gt;GetElement();\n\n    for (size_t i = 0; i &lt; skElements.GetNumOfElements(); i++) {\n        auto skElementsPlain     = skElements.GetElementAtIndex(i);\n        auto skElementsFromPlain = skElementsFrom.GetElementAtIndex(i);\n        auto skElementsPlainLWE  = skElements2.GetElementAtIndex(i);\n        for (size_t j = 0; j &lt; skElementsPlain.GetLength(); j++) {\n            if (skElementsFromPlain[j] == 0) {\n                skElementsPlain[j] = 0;\n            }\n            else if (skElementsFromPlain[j] == 1) {\n                skElementsPlain[j] = 1;\n            }\n            else\n                skElementsPlain[j] = skElementsPlain.GetModulus() - 1;\n\n            if (j &gt;= lweskElements.GetLength()) {\n                skElementsPlainLWE[j] = 0;\n            }\n            else {\n                if (lweskElements[j] == 0) {\n                    skElementsPlainLWE[j] = 0;\n                }\n                else if (lweskElements[j].ConvertToInt() == 1) {\n                    skElementsPlainLWE[j] = 1;\n                }\n                else\n                    skElementsPlainLWE[j] = skElementsPlain.GetModulus() - 1;\n            }\n        }\n        skElements.SetElementAtIndex(i, skElementsPlain);\n        skElements2.SetElementAtIndex(i, skElementsPlainLWE);\n    }\n\n    skElements.SetFormat(Format::EVALUATION);\n    skElements2.SetFormat(Format::EVALUATION);\n\n    auto ccCKKSto        = ckksSKto-&gt;GetCryptoContext();\n    auto oldTranformedSK = ccCKKSto-&gt;KeyGen().secretKey;\n    oldTranformedSK-&gt;SetPrivateElement(std::move(skElements));\n    auto RLWELWEsk = ccCKKSto-&gt;KeyGen().secretKey;\n    RLWELWEsk-&gt;SetPrivateElement(std::move(skElements2));\n\n    return ccCKKSto-&gt;KeySwitchGen(oldTranformedSK, RLWELWEsk);\n}\n\nstd::vector&lt;std::vector&lt;NativeInteger&gt;&gt; ExtractLWEpacked(const Ciphertext&lt;DCRTPoly&gt;&amp; ct) {\n    auto originalA{(ct-&gt;GetElements()[1]).GetElementAtIndex(0)};\n    auto originalB{(ct-&gt;GetElements()[0]).GetElementAtIndex(0)};\n    originalA.SetFormat(Format::COEFFICIENT);\n    originalB.SetFormat(Format::COEFFICIENT);\n    auto N = originalB.GetLength();\n\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; extracted(2);\n    extracted[0].reserve(N);\n    extracted[1].reserve(N);\n\n    auto&amp; originalAVals = originalA.GetValues();\n    auto&amp; originalBVals = originalB.GetValues();\n\n    extracted[1].insert(extracted[1].end(), &amp;originalAVals[0], &amp;originalAVals[N]);\n    extracted[0].insert(extracted[0].end(), &amp;originalBVals[0], &amp;originalBVals[N]);\n\n    return extracted;\n}\n\nstd::shared_ptr&lt;LWECiphertextImpl&gt; ExtractLWECiphertext(const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; aANDb,\n                                                        NativeInteger modulus, uint32_t n, uint32_t index = 0) {\n    auto N = aANDb[0].size();\n    NativeVector a(n, modulus);\n    NativeInteger b;\n\n    for (size_t i = 0; i &lt; n &amp;&amp; i &lt;= index; ++i) {\n        a[i] = modulus - aANDb[1][index - i];\n    }\n    if (n &gt; index) {\n        for (size_t i = index + 1; i &lt; n; ++i) {\n            a[i] = aANDb[1][N + index - i];\n        }\n    }\n\n    b           = aANDb[0][index];\n    auto result = std::make_shared&lt;LWECiphertextImpl&gt;(std::move(a), std::move(b));\n    return result;\n}\n\n//------------------------------------------------------------------------------\n// Linear transformation methods.\n// Currently mostly copied from ckksrns-fhe, because there an internal bootstrapping global structure is used.\n// TODO: fix this.\n//------------------------------------------------------------------------------\n\nstd::vector&lt;ConstPlaintext&gt; SWITCHCKKSRNS::EvalLTPrecomputeSwitch(\n    const CryptoContextImpl&lt;DCRTPoly&gt;&amp; cc, const std::vector&lt;std::vector&lt;std::complex&lt;double&gt;&gt;&gt;&amp; A,\n    const std::vector&lt;std::vector&lt;std::complex&lt;double&gt;&gt;&gt;&amp; B, uint32_t dim1, uint32_t L, double scale = 1) const {\n    uint32_t slots = A.size();\n    uint32_t M     = cc.GetCyclotomicOrder();\n\n    // Computing the baby-step bStep and the giant-step gStep\n    uint32_t bStep = (dim1 == 0) ? getRatioBSGSLT(slots) : dim1;\n    uint32_t gStep = ceil(static_cast&lt;double&gt;(slots) / bStep);\n\n    const auto cryptoParamsCKKS = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(cc.GetCryptoParameters());\n\n    ILDCRTParams&lt;DCRTPoly::Integer&gt; elementParams = *(cryptoParamsCKKS-&gt;GetElementParams());\n    uint32_t towersToDrop                         = 0;\n    if (L != 0) {\n        towersToDrop = elementParams.GetParams().size() - L - 1;\n        for (uint32_t i = 0; i &lt; towersToDrop; i++)\n            elementParams.PopLastParam();\n    }\n\n    auto paramsQ = elementParams.GetParams();\n    usint sizeQ  = paramsQ.size();\n    auto paramsP = cryptoParamsCKKS-&gt;GetParamsP()-&gt;GetParams();\n    usint sizeP  = paramsP.size();\n\n    std::vector&lt;NativeInteger&gt; moduli(sizeQ + sizeP);\n    std::vector&lt;NativeInteger&gt; roots(sizeQ + sizeP);\n    for (size_t i = 0; i &lt; sizeQ; i++) {\n        moduli[i] = paramsQ[i]-&gt;GetModulus();\n        roots[i]  = paramsQ[i]-&gt;GetRootOfUnity();\n    }\n\n    for (size_t i = 0; i &lt; sizeP; i++) {\n        moduli[sizeQ + i] = paramsP[i]-&gt;GetModulus();\n        roots[sizeQ + i]  = paramsP[i]-&gt;GetRootOfUnity();\n    }\n\n    auto elementParamsPtr = std::make_shared&lt;ILDCRTParams&lt;DCRTPoly::Integer&gt;&gt;(M, moduli, roots);\n\n    std::vector&lt;std::vector&lt;std::complex&lt;double&gt;&gt;&gt; newA(slots);\n    std::vector&lt;ConstPlaintext&gt; result(slots);\n\n    //  A and B are concatenated horizontally\n    for (uint32_t i = 0; i &lt; A.size(); i++) {\n        auto vecA        = A[i];\n        const auto&amp; vecB = B[i];\n        vecA.insert(vecA.end(), vecB.begin(), vecB.end());\n        newA[i] = std::move(vecA);\n    }\n\n#pragma omp parallel for\n    for (uint32_t j = 0; j &lt; gStep; j++) {\n        int32_t offset = -static_cast&lt;int32_t&gt;(bStep * j);\n        for (uint32_t i = 0; i &lt; bStep; i++) {\n            if (bStep * j + i &lt; slots) {\n                // shifted diagonal is computed for rectangular map newA of dimension slots x 2*slots\n                auto vec = ExtractShiftedDiagonal(newA, bStep * j + i);\n                std::transform(vec.begin(), vec.end(), vec.begin(),\n                               [&amp;](const std::complex&lt;double&gt;&amp; elem) { return elem * scale; });\n\n                result[bStep * j + i] =\n                    MakeAuxPlaintext(cc, elementParamsPtr, Rotate(Fill(vec, M / 4), offset), 1, towersToDrop, M / 4);\n            }\n        }\n    }\n    return result;\n}\n\nstd::vector&lt;ConstPlaintext&gt; SWITCHCKKSRNS::EvalLTPrecomputeSwitch(\n    const CryptoContextImpl&lt;DCRTPoly&gt;&amp; cc, const std::vector&lt;std::vector&lt;std::complex&lt;double&gt;&gt;&gt;&amp; A, uint32_t dim1,\n    uint32_t L, double scale = 1) const {\n    if (A[0].size() != A.size()) {\n        &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;The matrix passed to EvalLTPrecomputeSwitch is not square&quot;);\n    }\n\n    uint32_t slots = A.size();\n\n    uint32_t M     = cc.GetCyclotomicOrder();\n    uint32_t bStep = (dim1 == 0) ? getRatioBSGSLT(slots) : dim1;\n    uint32_t gStep = ceil(static_cast&lt;double&gt;(slots) / bStep);\n\n    // Make sure the plaintext is created only with the necessary amount of moduli\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(cc.GetCryptoParameters());\n\n    ILDCRTParams&lt;DCRTPoly::Integer&gt; elementParams = *(cryptoParams-&gt;GetElementParams());\n\n    uint32_t towersToDrop = 0;\n    if (L != 0) {\n        towersToDrop = elementParams.GetParams().size() - L - 1;\n        for (uint32_t i = 0; i &lt; towersToDrop; i++)\n            elementParams.PopLastParam();\n    }\n\n    auto paramsQ = elementParams.GetParams();\n    usint sizeQ  = paramsQ.size();\n    auto paramsP = cryptoParams-&gt;GetParamsP()-&gt;GetParams();\n    usint sizeP  = paramsP.size();\n\n    std::vector&lt;NativeInteger&gt; moduli(sizeQ + sizeP);\n    std::vector&lt;NativeInteger&gt; roots(sizeQ + sizeP);\n\n    for (size_t i = 0; i &lt; sizeQ; i++) {\n        moduli[i] = paramsQ[i]-&gt;GetModulus();\n        roots[i]  = paramsQ[i]-&gt;GetRootOfUnity();\n    }\n\n    for (size_t i = 0; i &lt; sizeP; i++) {\n        moduli[sizeQ + i] = paramsP[i]-&gt;GetModulus();\n        roots[sizeQ + i]  = paramsP[i]-&gt;GetRootOfUnity();\n    }\n\n    auto elementParamsPtr = std::make_shared&lt;ILDCRTParams&lt;DCRTPoly::Integer&gt;&gt;(M, moduli, roots);\n\n    std::vector&lt;ConstPlaintext&gt; result(slots);\n#pragma omp parallel for\n    for (uint32_t j = 0; j &lt; gStep; j++) {\n        int32_t offset = -static_cast&lt;int32_t&gt;(bStep * j);\n        for (uint32_t i = 0; i &lt; bStep; i++) {\n            if (bStep * j + i &lt; slots) {\n                auto diag = ExtractShiftedDiagonal(A, bStep * j + i);\n                std::transform(diag.begin(), diag.end(), diag.begin(),\n                               [&amp;](const std::complex&lt;double&gt;&amp; elem) { return elem * scale; });\n                result[bStep * j + i] =\n                    MakeAuxPlaintext(cc, elementParamsPtr, Rotate(Fill(diag, M / 4), offset), 1, towersToDrop, M / 4);\n            }\n        }\n    }\n\n    return result;\n}\n\nstd::vector&lt;std::vector&lt;std::complex&lt;double&gt;&gt;&gt; EvalLTRectPrecomputeSwitch(\n    const std::vector&lt;std::vector&lt;std::complex&lt;double&gt;&gt;&gt;&amp; A, uint32_t dim1, double scale) {\n    if ((A.size() / A[0].size()) * A[0].size() != A.size()) {\n        &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;The matrix passed to EvalLTPrecompute is not in proper rectangular shape&quot;);\n    }\n    uint32_t n     = A[0].size();  //\n    uint32_t bStep = (dim1 == 0) ? getRatioBSGSLT(n) : dim1;\n    uint32_t gStep = ceil(static_cast&lt;double&gt;(n) / bStep);\n\n    auto num_slices = A.size() / A[0].size();\n    std::vector&lt;std::vector&lt;std::vector&lt;std::complex&lt;double&gt;&gt;&gt;&gt; A_slices(num_slices);\n    for (size_t i = 0; i &lt; num_slices; i++) {\n        A_slices[i] = std::vector&lt;std::vector&lt;std::complex&lt;double&gt;&gt;&gt;(A.begin() + i * A[0].size(),\n                                                                     A.begin() + (i + 1) * A[0].size());\n    }\n    std::vector&lt;std::vector&lt;std::complex&lt;double&gt;&gt;&gt; diags(n);\n#pragma omp parallel for\n    for (uint32_t j = 0; j &lt; gStep; j++) {\n        for (uint32_t i = 0; i &lt; bStep; i++) {\n            if (bStep * j + i &lt; n) {\n                std::vector&lt;std::complex&lt;double&gt;&gt; diag(0);\n                for (uint32_t k = 0; k &lt; num_slices; k++) {\n                    auto tmp = ExtractShiftedDiagonal(A_slices[k], bStep * j + i);\n                    diag.insert(diag.end(), tmp.begin(), tmp.end());\n                }\n                std::transform(diag.begin(), diag.end(), diag.begin(),\n                               [&amp;](const std::complex&lt;double&gt;&amp; elem) { return elem * scale; });\n                diags[bStep * j + i] = diag;\n            }\n        }\n    }\n\n    return diags;\n}\n\nCiphertext&lt;DCRTPoly&gt; SWITCHCKKSRNS::EvalLTWithPrecomputeSwitch(const CryptoContextImpl&lt;DCRTPoly&gt;&amp; cc,\n                                                               ConstCiphertext&lt;DCRTPoly&gt; ctxt,\n                                                               const std::vector&lt;ConstPlaintext&gt;&amp; A,\n                                                               uint32_t dim1) const {\n    uint32_t slots = A.size();\n\n    // Computing the baby-step bStep and the giant-step gStep\n    uint32_t bStep = dim1;\n    uint32_t gStep = ceil(static_cast&lt;double&gt;(slots) / bStep);\n\n    uint32_t M = cc.GetCyclotomicOrder();\n    uint32_t N = cc.GetRingDimension();\n\n    // Computes the NTTs for each CRT limb (for the hoisted automorphisms used later on)\n    auto digits = cc.EvalFastRotationPrecompute(ctxt);\n\n    std::vector&lt;Ciphertext&lt;DCRTPoly&gt;&gt; fastRotation(bStep - 1);\n\n    // Hoisted automorphisms\n#pragma omp parallel for\n    for (uint32_t j = 1; j &lt; bStep; j++)\n        fastRotation[j - 1] = cc.EvalFastRotationExt(ctxt, j, digits, true);\n\n    Ciphertext&lt;DCRTPoly&gt; result;\n    DCRTPoly first;\n\n    for (uint32_t j = 0; j &lt; gStep; j++) {\n        Ciphertext&lt;DCRTPoly&gt; inner = EvalMultExt(cc.KeySwitchExt(ctxt, true), A[bStep * j]);\n\n        for (uint32_t i = 1; i &lt; bStep; i++) {\n            if (bStep * j + i &lt; slots) {\n                EvalAddExtInPlace(inner, EvalMultExt(fastRotation[i - 1], A[bStep * j + i]));\n            }\n        }\n\n        if (j == 0) {\n            first         = cc.KeySwitchDownFirstElement(inner);\n            auto elements = inner-&gt;GetElements();\n            elements[0].SetValuesToZero();\n            inner-&gt;SetElements(elements);\n            result = inner;\n        }\n        else {\n            inner = cc.KeySwitchDown(inner);\n            // Find the automorphism index that corresponds to the rotation index.\n            usint autoIndex = FindAutomorphismIndex2nComplex(bStep * j, M);\n            std::vector&lt;usint&gt; map(N);\n            PrecomputeAutoMap(N, autoIndex, &amp;map);\n            DCRTPoly firstCurrent = inner-&gt;GetElements()[0].AutomorphismTransform(autoIndex, map);\n            first += firstCurrent;\n\n            auto innerDigits = cc.EvalFastRotationPrecompute(inner);\n            EvalAddExtInPlace(result, cc.EvalFastRotationExt(inner, bStep * j, innerDigits, false));\n        }\n    }\n\n    result        = cc.KeySwitchDown(result);\n    auto elements = result-&gt;GetElements();\n    elements[0] += first;\n    result-&gt;SetElements(elements);\n\n    return result;\n}\n\nCiphertext&lt;DCRTPoly&gt; SWITCHCKKSRNS::EvalLTRectWithPrecomputeSwitch(\n    const CryptoContextImpl&lt;DCRTPoly&gt;&amp; cc, const std::vector&lt;std::vector&lt;std::complex&lt;double&gt;&gt;&gt;&amp; A,\n    ConstCiphertext&lt;DCRTPoly&gt; ct, uint32_t dim1, uint32_t L) const {\n    uint32_t n = A.size();\n\n    // Computing the baby-step bStep and the giant-step gStep\n    uint32_t bStep = (dim1 == 0) ? getRatioBSGSLT(n) : dim1;\n    uint32_t gStep = ceil(static_cast&lt;double&gt;(n) / bStep);\n\n    uint32_t M = cc.GetCyclotomicOrder();\n    uint32_t N = cc.GetRingDimension();\n\n    // Computes the NTTs for each CRT limb (for the hoisted automorphisms used later on)\n    auto digits = cc.EvalFastRotationPrecompute(ct);\n\n    std::vector&lt;Ciphertext&lt;DCRTPoly&gt;&gt; fastRotation(bStep - 1);\n\n    // Make sure the plaintext is created only with the necessary amount of moduli\n    const auto cryptoParamsCKKS = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(ct-&gt;GetCryptoParameters());\n\n    ILDCRTParams&lt;DCRTPoly::Integer&gt; elementParams = *(cryptoParamsCKKS-&gt;GetElementParams());\n    uint32_t towersToDrop                         = 0;\n\n    // For FLEXIBLEAUTOEXT we do not need extra modulus in auxiliary plaintexts\n    if (L != 0) {\n        towersToDrop = elementParams.GetParams().size() - L - 1;\n        for (uint32_t i = 0; i &lt; towersToDrop; i++)\n            elementParams.PopLastParam();\n    }\n    if (cryptoParamsCKKS-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT) {\n        towersToDrop += 1;\n        elementParams.PopLastParam();\n    }\n\n    auto paramsQ = elementParams.GetParams();\n    usint sizeQ  = paramsQ.size();\n    auto paramsP = cryptoParamsCKKS-&gt;GetParamsP()-&gt;GetParams();\n    usint sizeP  = paramsP.size();\n\n    std::vector&lt;NativeInteger&gt; moduli(sizeQ + sizeP);\n    std::vector&lt;NativeInteger&gt; roots(sizeQ + sizeP);\n\n    for (size_t i = 0; i &lt; sizeQ; i++) {\n        moduli[i] = paramsQ[i]-&gt;GetModulus();\n        roots[i]  = paramsQ[i]-&gt;GetRootOfUnity();\n    }\n\n    for (size_t i = 0; i &lt; sizeP; i++) {\n        moduli[sizeQ + i] = paramsP[i]-&gt;GetModulus();\n        roots[sizeQ + i]  = paramsP[i]-&gt;GetRootOfUnity();\n    }\n\n    auto elementParamsPtr  = std::make_shared&lt;ILDCRTParams&lt;DCRTPoly::Integer&gt;&gt;(M, moduli, roots);\n    auto elementParamsPtr2 = std::dynamic_pointer_cast&lt;typename DCRTPoly::Params&gt;(elementParamsPtr);\n\n// Hoisted automorphisms\n#pragma omp parallel for\n    for (uint32_t j = 1; j &lt; bStep; j++) {\n        fastRotation[j - 1] = cc.EvalFastRotationExt(ct, j, digits, true);\n    }\n\n    Ciphertext&lt;DCRTPoly&gt; result;\n    DCRTPoly first;\n\n    for (uint32_t j = 0; j &lt; gStep; j++) {\n        int32_t offset = (j == 0) ? 0 : -static_cast&lt;int32_t&gt;(bStep * j);\n        auto temp      = cc.MakeCKKSPackedPlaintext(Rotate(Fill(A[bStep * j], N / 2), offset), 1, towersToDrop,\n                                                    elementParamsPtr2, N / 2);\n        Ciphertext&lt;DCRTPoly&gt; inner = EvalMultExt(cc.KeySwitchExt(ct, true), temp);\n\n        for (uint32_t i = 1; i &lt; bStep; i++) {\n            if (bStep * j + i &lt; n) {\n                auto tempi = cc.MakeCKKSPackedPlaintext(Rotate(Fill(A[bStep * j + i], N / 2), offset), 1, towersToDrop,\n                                                        elementParamsPtr2, N / 2);\n                EvalAddExtInPlace(inner, EvalMultExt(fastRotation[i - 1], tempi));\n            }\n        }\n\n        if (j == 0) {\n            first         = cc.KeySwitchDownFirstElement(inner);\n            auto elements = inner-&gt;GetElements();\n            elements[0].SetValuesToZero();\n            inner-&gt;SetElements(elements);\n            result = inner;\n        }\n        else {\n            inner = cc.KeySwitchDown(inner);\n            // Find the automorphism index that corresponds to rotation index index.\n            usint autoIndex = FindAutomorphismIndex2nComplex(bStep * j, M);\n            std::vector&lt;usint&gt; map(N);\n            PrecomputeAutoMap(N, autoIndex, &amp;map);\n            DCRTPoly firstCurrent = inner-&gt;GetElements()[0].AutomorphismTransform(autoIndex, map);\n            first += firstCurrent;\n\n            auto innerDigits = cc.EvalFastRotationPrecompute(inner);\n            EvalAddExtInPlace(result, cc.EvalFastRotationExt(inner, bStep * j, innerDigits, false));\n        }\n    }\n    result        = cc.KeySwitchDown(result);\n    auto elements = result-&gt;GetElements();\n    elements[0] += first;\n    result-&gt;SetElements(elements);\n\n    return result;\n}\n\nCiphertext&lt;DCRTPoly&gt; SWITCHCKKSRNS::EvalSlotsToCoeffsSwitch(const CryptoContextImpl&lt;DCRTPoly&gt;&amp; cc,\n                                                            ConstCiphertext&lt;DCRTPoly&gt; ctxt) const {\n    uint32_t slots = m_numSlotsCKKS;\n    uint32_t m     = 4 * slots;\n    uint32_t M     = cc.GetCyclotomicOrder();\n    bool isSparse  = (M != m) ? true : false;\n\n    auto ctxtToDecode = ctxt-&gt;Clone();\n    ctxtToDecode      = cc.Compress(ctxtToDecode, 2);\n\n    Ciphertext&lt;DCRTPoly&gt; ctxtDecoded;\n\n    if (slots != m_numSlotsCKKS || m_U0Pre.size() == 0) {\n        std::string errorMsg(std::string(&quot;Precomputations for &quot;) + std::to_string(slots) +\n                             std::string(&quot; slots were not generated&quot;) +\n                             std::string(&quot; Need to call EvalCKKSToFHEWPrecompute to proceed&quot;));\n        &quot;hey&quot;; OPENFHE_THROW(type_error, errorMsg);\n    }\n\n    if (!isSparse) {  // fully packed\n        // ctxtToDecode = cc.EvalAdd(ctxtToDecode, cc.GetScheme()-&gt;MultByMonomial(ctxtToDecode, M / 4));\n        ctxtDecoded = EvalLTWithPrecomputeSwitch(cc, ctxtToDecode, m_U0Pre, m_dim1CF);\n    }\n    else {  // sparsely packed\n        ctxtDecoded = EvalLTWithPrecomputeSwitch(cc, ctxtToDecode, m_U0Pre, m_dim1CF);\n        ctxtDecoded = cc.EvalAdd(ctxtDecoded, cc.EvalAtIndex(ctxtDecoded, slots));\n    }\n\n    return ctxtDecoded;\n}\n\nCiphertext&lt;DCRTPoly&gt; SWITCHCKKSRNS::EvalPartialHomDecryption(const CryptoContextImpl&lt;DCRTPoly&gt;&amp; cc,\n                                                             const std::vector&lt;std::vector&lt;std::complex&lt;double&gt;&gt;&gt;&amp; A,\n                                                             ConstCiphertext&lt;DCRTPoly&gt; ct, uint32_t dim1, double scale,\n                                                             uint32_t L) const {\n    // Ensure the # rows (# of LWE ciphertext to switch) is a multiple of # columns (the lattice parameter n)\n    std::vector&lt;std::vector&lt;std::complex&lt;double&gt;&gt;&gt; Acopy(A);\n    if ((A.size() % A[0].size()) != 0) {\n        std::vector&lt;std::vector&lt;std::complex&lt;double&gt;&gt;&gt; padding(A[0].size() - (A.size() % A[0].size()));\n        for (size_t i = 0; i &lt; padding.size(); i++) {\n            padding[i] = std::vector&lt;std::complex&lt;double&gt;&gt;(A[0].size());\n        }\n        Acopy.insert(Acopy.end(), padding.begin(), padding.end());\n    }\n\n    auto Apre = EvalLTRectPrecomputeSwitch(Acopy, dim1, scale);\n    auto res =\n        EvalLTRectWithPrecomputeSwitch(cc, Apre, ct, dim1, L);  // The result is repeated every Acopy.size() slots\n\n    return res;\n}\n\n//------------------------------------------------------------------------------\n// Scheme switching Wrapper\n//------------------------------------------------------------------------------\nstd::pair&lt;BinFHEContext, LWEPrivateKey&gt; SWITCHCKKSRNS::EvalCKKStoFHEWSetup(const CryptoContextImpl&lt;DCRTPoly&gt;&amp; cc,\n                                                                           SecurityLevel sl, BINFHE_PARAMSET slBin,\n                                                                           bool arbFunc, uint32_t logQ, bool dynamic,\n                                                                           uint32_t numSlotsCKKS, uint32_t logQswitch) {\n    m_ccLWE = BinFHEContext();\n    if (slBin != TOY &amp;&amp; slBin != STD128)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Only STD128 or TOY are currently supported.&quot;);\n    m_ccLWE.BinFHEContext::GenerateBinFHEContext(slBin, arbFunc, logQ, 0, GINX, dynamic);\n\n    // For arbitrary functions, the LWE ciphertext needs to be at most the ring dimension in FHEW bootstrapping\n    m_modulus_LWE = (arbFunc == false) ? 1 &lt;&lt; logQ : m_ccLWE.GetParams()-&gt;GetLWEParams()-&gt;Getq().ConvertToInt();\n\n    // LWE private key\n    LWEPrivateKey lwesk;\n    lwesk = m_ccLWE.KeyGen();\n\n    std::pair&lt;BinFHEContext, LWEPrivateKey&gt; FHEWcc;\n    FHEWcc.first  = m_ccLWE;\n    FHEWcc.second = lwesk;\n\n    uint32_t M = cc.GetCyclotomicOrder();\n    if (numSlotsCKKS == 0 || numSlotsCKKS == M / 4)  // fully-packed\n        m_numSlotsCKKS = M / 4;\n    else  // sparsely-packed\n        m_numSlotsCKKS = numSlotsCKKS;\n\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(cc.GetCryptoParameters());\n    ILDCRTParams&lt;DCRTPoly::Integer&gt; elementParams = *(cryptoParams-&gt;GetElementParams());\n    auto paramsQ                                  = elementParams.GetParams();\n    m_modulus_CKKS_initial                        = paramsQ[0]-&gt;GetModulus().ConvertToInt();\n    // Modulus to switch to in order to have secure RLWE samples with ring dimension n.\n    // We can select any Qswitch less than 27 bits corresponding to 128 bits of security for lattice parameter n=1024 &lt; 1305\n    // according to https://homomorphicencryption.org/wp-content/uploads/2018/11/HomomorphicEncryptionStandardv1.1.pdf\n    // or any Qswitch for TOY security.\n    // Ensure that Qswitch is larger than Q_FHEW and smaller than Q_CKKS.\n    if (logQ &gt;= logQswitch || logQswitch &gt; GetMSB(m_modulus_CKKS_initial.ConvertToInt()) - 1)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Qswitch should be larger than QFHEW and smaller than QCKKS.&quot;);\n\n    // Intermediate cryptocontext\n    uint32_t multDepth    = 0;\n    uint32_t scaleModSize = cc.GetEncodingParams()-&gt;GetPlaintextModulus();\n\n    CCParams&lt;CryptoContextCKKSRNS&gt; parameters;\n    parameters.SetMultiplicativeDepth(multDepth);\n    parameters.SetFirstModSize(logQswitch);\n    parameters.SetScalingModSize(scaleModSize);\n    parameters.SetScalingTechnique(\n        FIXEDMANUAL);  // This doesn&#x27;t need this to be the same scaling technique as the outer cryptocontext, since we only do a key switch\n    parameters.SetSecurityLevel(sl);\n    parameters.SetRingDim(cc.GetRingDimension());\n    parameters.SetBatchSize(cc.GetEncodingParams()-&gt;GetBatchSize());\n\n    m_ccKS = GenCryptoContext(parameters);\n\n    // Enable the features that you wish to use\n    m_ccKS-&gt;Enable(PKE);\n    m_ccKS-&gt;Enable(KEYSWITCH);\n    m_ccKS-&gt;Enable(LEVELEDSHE);\n    m_ccKS-&gt;Enable(ADVANCEDSHE);\n    m_ccKS-&gt;Enable(SCHEMESWITCH);\n    m_ccKS-&gt;Enable(FHE);\n\n    // Get the ciphertext modulus\n    const auto cryptoParams2 = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(m_ccKS-&gt;GetCryptoParameters());\n    ILDCRTParams&lt;DCRTPoly::Integer&gt; elementParams2 = *(cryptoParams2-&gt;GetElementParams());\n    auto paramsQ2                                  = elementParams2.GetParams();\n    m_modulus_CKKS_from                            = paramsQ2[0]-&gt;GetModulus().ConvertToInt();\n\n    return FHEWcc;\n}\n\nstd::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;DCRTPoly&gt;&gt;&gt; SWITCHCKKSRNS::EvalCKKStoFHEWKeyGen(\n    const KeyPair&lt;DCRTPoly&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk, uint32_t dim1, uint32_t L) {\n    auto privateKey = keyPair.secretKey;\n    auto publicKey  = keyPair.publicKey;\n\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(privateKey-&gt;GetCryptoParameters());\n\n    if (cryptoParams-&gt;GetKeySwitchTechnique() != HYBRID)\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;CKKS to FHEW scheme switching is only supported for the Hybrid key switching method.&quot;);\n#if NATIVEINT == 128 &amp;&amp; !defined(__EMSCRIPTEN__)\n    if (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTO || cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT)\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;128-bit CKKS to FHEW scheme switching is supported for FIXEDMANUAL and FIXEDAUTO methods only.&quot;);\n#endif\n\n    auto ccCKKS = privateKey-&gt;GetCryptoContext();\n\n    // Intermediate cryptocontext for CKKS to FHEW\n    auto keys2 = m_ccKS-&gt;KeyGen();\n\n    Plaintext ptxtZeroKS = m_ccKS-&gt;MakeCKKSPackedPlaintext(std::vector&lt;double&gt;{0.0});\n    m_ctxtKS             = m_ccKS-&gt;Encrypt(keys2.publicKey, ptxtZeroKS);\n\n    // Compute switching key between RLWE and LWE via the intermediate cryptocontext, keep it in RLWE form\n    m_CKKStoFHEWswk = switchingKeyGenRLWEcc(keys2.secretKey, privateKey, lwesk);\n\n    // Compute automorphism keys\n    uint32_t M     = ccCKKS-&gt;GetCyclotomicOrder();\n    uint32_t slots = m_numSlotsCKKS;\n    // Computing the baby-step\n    if (dim1 == 0)\n        dim1 = getRatioBSGSLT(slots);\n    m_dim1CF = dim1;\n    m_LCF    = L;\n\n    // Compute indices for rotations for slotToCoeff transform\n    std::vector&lt;int32_t&gt; indexRotationS2C = FindLTRotationIndicesSwitch(m_dim1CF, M, slots);\n    indexRotationS2C.emplace_back(static_cast&lt;int32_t&gt;(slots));\n\n    // Remove possible duplicates\n    sort(indexRotationS2C.begin(), indexRotationS2C.end());\n    indexRotationS2C.erase(unique(indexRotationS2C.begin(), indexRotationS2C.end()), indexRotationS2C.end());\n\n    auto algo     = ccCKKS-&gt;GetScheme();\n    auto evalKeys = algo-&gt;EvalAtIndexKeyGen(publicKey, privateKey, indexRotationS2C);\n\n    const DCRTPoly&amp; s                       = privateKey-&gt;GetPrivateElement();\n    usint N                                 = s.GetRingDimension();\n    PrivateKey&lt;DCRTPoly&gt; privateKeyPermuted = std::make_shared&lt;PrivateKeyImpl&lt;DCRTPoly&gt;&gt;(ccCKKS);\n    usint index                             = 2 * N - 1;\n    std::vector&lt;usint&gt; vec(N);\n    PrecomputeAutoMap(N, index, &amp;vec);\n    DCRTPoly sPermuted = s.AutomorphismTransform(index, vec);\n    privateKeyPermuted-&gt;SetPrivateElement(sPermuted);\n    privateKeyPermuted-&gt;SetKeyTag(privateKey-&gt;GetKeyTag());\n    auto conjKey       = algo-&gt;KeySwitchGen(privateKey, privateKeyPermuted);\n    (*evalKeys)[M - 1] = conjKey;\n\n    // Compute multiplication key\n    algo-&gt;EvalMultKeyGen(privateKey);\n\n    return evalKeys;\n}\n\nvoid SWITCHCKKSRNS::EvalCKKStoFHEWPrecompute(const CryptoContextImpl&lt;DCRTPoly&gt;&amp; cc, double scale) {\n    uint32_t M     = cc.GetCyclotomicOrder();\n    uint32_t slots = m_numSlotsCKKS;\n\n    uint32_t m    = 4 * m_numSlotsCKKS;\n    bool isSparse = (M != m) ? true : false;\n\n    // Computes indices for all primitive roots of unity\n    std::vector&lt;uint32_t&gt; rotGroup(slots);\n    uint32_t fivePows = 1;\n    for (uint32_t i = 0; i &lt; slots; ++i) {\n        rotGroup[i] = fivePows;\n        fivePows *= 5;\n        fivePows %= m;\n    }\n    // Computes all powers of a primitive root of unity exp(2*M_PI/m)\n    std::vector&lt;std::complex&lt;double&gt;&gt; ksiPows(m + 1);\n    for (uint32_t j = 0; j &lt; m; ++j) {\n        double angle = 2.0 * M_PI * j / m;\n        ksiPows[j].real(cos(angle));\n        ksiPows[j].imag(sin(angle));\n    }\n    ksiPows[m] = ksiPows[0];\n\n    // Matrices for decoding\n    std::vector&lt;std::vector&lt;std::complex&lt;double&gt;&gt;&gt; U0(slots, std::vector&lt;std::complex&lt;double&gt;&gt;(slots));\n    std::vector&lt;std::vector&lt;std::complex&lt;double&gt;&gt;&gt; U1(slots, std::vector&lt;std::complex&lt;double&gt;&gt;(slots));\n\n    for (size_t i = 0; i &lt; slots; i++) {\n        for (size_t j = 0; j &lt; slots; j++) {\n            U0[i][j] = ksiPows[(j * rotGroup[i]) % m];\n            U1[i][j] = std::complex&lt;double&gt;(0, 1) * U0[i][j];\n        }\n    }\n\n    if (!isSparse) {  // fully packed\n        m_U0Pre = EvalLTPrecomputeSwitch(cc, U0, m_dim1CF, m_LCF, scale);\n    }\n    else {  // sparsely packed\n        m_U0Pre = EvalLTPrecomputeSwitch(cc, U0, U1, m_dim1CF, m_LCF, scale);\n    }\n}\n\nstd::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt; SWITCHCKKSRNS::EvalCKKStoFHEW(ConstCiphertext&lt;DCRTPoly&gt; ciphertext,\n                                                                              uint32_t numCtxts) {\n    auto ccCKKS    = ciphertext-&gt;GetCryptoContext();\n    uint32_t slots = m_numSlotsCKKS;\n\n    // Step 1. Homomorphic decoding\n    auto ctxtDecoded = EvalSlotsToCoeffsSwitch(*ccCKKS, ciphertext);\n    ctxtDecoded      = ccCKKS-&gt;Compress(ctxtDecoded);\n\n    // Step 2. Modulus switch to Q&#x27;, such that CKKS is secure for (Q&#x27;,n)\n    auto ctxtKS = m_ctxtKS-&gt;Clone();\n    ModSwitch(ctxtDecoded, ctxtKS, m_modulus_CKKS_from);\n\n    // Step 3: Key switch from the CKKS key with the new modulus Q&#x27; to the RLWE version of the FHEW key with the new modulus Q&#x27;\n    auto ctSwitched = m_ccKS-&gt;KeySwitch(ctxtKS, m_CKKStoFHEWswk);\n\n    // Step 4. Extract LWE ciphertexts with the modulus Q&#x27;\n    uint32_t n = m_ccLWE.GetParams()-&gt;GetLWEParams()-&gt;Getn();  // lattice parameter for additive LWE\n    std::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt; LWEciphertexts;\n    auto AandB = ExtractLWEpacked(ctSwitched);\n\n    if (numCtxts == 0 || numCtxts &gt; slots) {\n        numCtxts = slots;\n    }\n\n    uint32_t gap = m_ccKS-&gt;GetRingDimension() / (2 * slots);\n\n    for (uint32_t i = 0, idx = 0; i &lt; numCtxts; ++i, idx += gap) {\n        auto temp = ExtractLWECiphertext(AandB, m_modulus_CKKS_from, n, idx);\n        LWEciphertexts.emplace_back(temp);\n    }\n\n    // Step 5. Modulus switch to q in FHEW\n    if (m_modulus_LWE != m_modulus_CKKS_from) {\n#pragma omp parallel for\n        for (uint32_t i = 0; i &lt; numCtxts; i++) {\n            auto original_a = LWEciphertexts[i]-&gt;GetA();\n            auto original_b = LWEciphertexts[i]-&gt;GetB();\n            // multiply by Q_LWE/Q&#x27; and round to Q_LWE\n            NativeVector a_round(n, m_modulus_LWE);\n            for (uint32_t j = 0; j &lt; n; ++j) {\n                a_round[j] = RoundqQAlter(original_a[j], m_modulus_LWE, m_modulus_CKKS_from);\n            }\n            NativeInteger b_round = RoundqQAlter(original_b, m_modulus_LWE, m_modulus_CKKS_from);\n            LWEciphertexts[i]     = std::make_shared&lt;LWECiphertextImpl&gt;(std::move(a_round), std::move(b_round));\n        }\n    }\n\n    return LWEciphertexts;\n}\n\n//------------------------------------------------------------------------------\n// Scheme switching Wrapper\n//------------------------------------------------------------------------------\nvoid SWITCHCKKSRNS::EvalFHEWtoCKKSSetup(const CryptoContextImpl&lt;DCRTPoly&gt;&amp; ccCKKS, const BinFHEContext&amp; ccLWE,\n                                        uint32_t numSlotsCKKS, uint32_t logQ) {\n    m_ccLWE = ccLWE;\n\n    if (m_ccLWE.GetParams()-&gt;GetLWEParams()-&gt;Getn() * 2 &gt; ccCKKS.GetRingDimension())\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The lattice parameter in LWE cannot be larger than half the RLWE ring dimension.&quot;);\n\n    if (numSlotsCKKS == 0) {\n        if (ccCKKS.GetEncodingParams()-&gt;GetBatchSize() != 0)\n            m_numSlotsCKKS = ccCKKS.GetEncodingParams()-&gt;GetBatchSize();\n        else\n            m_numSlotsCKKS = ccCKKS.GetRingDimension() / 2;\n    }\n    else {\n        m_numSlotsCKKS = numSlotsCKKS;\n    }\n\n    m_modulus_LWE = (logQ != 0) ? 1 &lt;&lt; logQ : m_ccLWE.GetParams()-&gt;GetLWEParams()-&gt;Getq().ConvertToInt();\n}\n\nstd::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;DCRTPoly&gt;&gt;&gt; SWITCHCKKSRNS::EvalFHEWtoCKKSKeyGen(\n    const KeyPair&lt;DCRTPoly&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk, uint32_t numSlots, uint32_t dim1, uint32_t L) {\n    auto privateKey = keyPair.secretKey;\n    auto publicKey  = keyPair.publicKey;\n\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(privateKey-&gt;GetCryptoParameters());\n    auto ccCKKS             = privateKey-&gt;GetCryptoContext();\n\n    uint32_t n       = lwesk-&gt;GetElement().GetLength();\n    uint32_t ringDim = ccCKKS-&gt;GetRingDimension();\n\n    // Generate FHEW to CKKS switching key, i.e., CKKS encryption of FHEW secret key\n    auto skLWEElements = lwesk-&gt;GetElement();\n    std::vector&lt;std::complex&lt;double&gt;&gt; skLWEDouble(n);\n    for (uint32_t i = 0; i &lt; n; i++) {\n        auto tmp = skLWEElements[i].ConvertToDouble();\n        if (tmp == lwesk-&gt;GetModulus().ConvertToInt() - 1)\n            tmp = -1;\n        skLWEDouble[i] = std::complex&lt;double&gt;(tmp, 0);\n    }\n\n    // Check encoding and specify the number of slots, otherwise, if batchsize is set and is smaller, it will throw an error.\n    Plaintext skLWEPlainswk;\n    if (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT)\n        skLWEPlainswk = ccCKKS-&gt;MakeCKKSPackedPlaintext(Fill(skLWEDouble, ringDim / 2), 1, BASE_NUM_LEVELS_TO_DROP,\n                                                        nullptr, ringDim / 2);\n    else\n        skLWEPlainswk = ccCKKS-&gt;MakeCKKSPackedPlaintext(Fill(skLWEDouble, ringDim / 2), 1, 0, nullptr, ringDim / 2);\n\n    m_FHEWtoCKKSswk = ccCKKS-&gt;Encrypt(publicKey, skLWEPlainswk);\n\n    // Compute automorphism keys for CKKS for baby-step giant-step\n    uint32_t M = ccCKKS-&gt;GetCyclotomicOrder();\n    if (dim1 == 0)\n        dim1 = getRatioBSGSLT(n);\n    m_dim1FC = dim1;\n    m_LFC    = L;\n\n    // Compute indices for rotations for homomorphic decryption in CKKS\n    std::vector&lt;int32_t&gt; indexRotationHomDec = FindLTRotationIndicesSwitch(dim1, M, n);\n\n    uint32_t slots = (numSlots == 0) ? m_numSlotsCKKS : numSlots;\n    // Compute indices for rotations to bring back the final CKKS ciphertext encoding to slots\n    if (ringDim &gt; 2 * slots) {  // if the encoding is full, this does not execute\n        indexRotationHomDec.reserve(indexRotationHomDec.size() + GetMSB(ringDim) - 2);\n        for (uint32_t j = 1; j &lt; ringDim / (2 * slots); j &lt;&lt;= 1) {\n            indexRotationHomDec.emplace_back(j * slots);\n        }\n    }\n\n    // Remove possible duplicates\n    sort(indexRotationHomDec.begin(), indexRotationHomDec.end());\n    indexRotationHomDec.erase(unique(indexRotationHomDec.begin(), indexRotationHomDec.end()),\n                              indexRotationHomDec.end());\n\n    auto algo     = ccCKKS-&gt;GetScheme();\n    auto evalKeys = algo-&gt;EvalAtIndexKeyGen(publicKey, privateKey, indexRotationHomDec);\n\n    // Compute multiplication key\n    ccCKKS-&gt;EvalMultKeyGen(privateKey);\n\n    return evalKeys;\n}\n\nCiphertext&lt;DCRTPoly&gt; SWITCHCKKSRNS::EvalFHEWtoCKKS(std::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt;&amp; LWECiphertexts,\n                                                   uint32_t numCtxts, uint32_t numSlots, uint32_t p, double pmin,\n                                                   double pmax) const {\n    if (!LWECiphertexts.size())\n        &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Empty input FHEW ciphertext vector&quot;);\n    uint32_t numLWECtxts = LWECiphertexts.size();\n\n    uint32_t slots =\n        (numSlots == 0) ? m_numSlotsCKKS : numSlots;  // This is the number of CKKS slots to use in encoding\n\n    uint32_t numValues = (numCtxts == 0) ? numLWECtxts : std::min(numCtxts, numLWECtxts);\n    numValues = std::min(numValues, slots);  // This is the number of LWE ciphertexts to pack into the CKKS ciphertext\n\n    uint32_t n = LWECiphertexts[0]-&gt;GetA().GetLength();\n\n    auto ccCKKS                 = m_FHEWtoCKKSswk-&gt;GetCryptoContext();\n    const auto cryptoParamsCKKS = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(ccCKKS-&gt;GetCryptoParameters());\n\n    uint32_t m    = 4 * slots;\n    uint32_t M    = ccCKKS-&gt;GetCyclotomicOrder();\n    uint32_t N    = ccCKKS-&gt;GetRingDimension();\n    bool isSparse = (M != m) ? true : false;\n\n    double K = 1.0;\n    std::vector&lt;double&gt; coefficientsFHEW;  // EvalFHEWtoCKKS assumes lattice parameter n is at most 2048.\n    if (n == 32) {\n        K = 16.0;\n        coefficientsFHEW.insert(coefficientsFHEW.end(), &amp;g_coefficientsFHEW16[0], &amp;g_coefficientsFHEW16[LEN_16]);\n    }\n    else {\n        K = 128.0;  // Failure probability of 2^{-49}\n        if (p &lt;= 4) {\n            coefficientsFHEW.insert(\n                coefficientsFHEW.end(), &amp;g_coefficientsFHEW128_8[0],\n                &amp;g_coefficientsFHEW128_8\n                    [LEN_128_8]);  // If the output messages are bits, we could use a lower degree polynomial\n        }\n        else {\n            coefficientsFHEW.insert(coefficientsFHEW.end(), &amp;g_coefficientsFHEW128_9[0],\n                                    &amp;g_coefficientsFHEW128_9[LEN_128_9]);\n        }\n    }\n\n    // Step 1. Form matrix A and vector b from the LWE ciphertexts, but only extract the first necessary number of them\n    std::vector&lt;std::vector&lt;std::complex&lt;double&gt;&gt;&gt; A(numValues);\n\n    // To have the same encoding as A*s, create b with the appropriate number of elements\n    uint32_t b_size = numValues;\n    if ((numValues % n) != 0) {\n        b_size = numValues + n - (numValues % n);\n    }\n    std::vector&lt;std::complex&lt;double&gt;&gt; b(b_size);\n\n    // Combine the scale with the division by K to consume fewer levels, but careful since the value might be too small\n    double prescale = (1.0 / LWECiphertexts[0]-&gt;GetModulus().ConvertToDouble()) / K;\n\n#pragma omp parallel for\n    for (uint32_t i = 0; i &lt; numValues; i++) {\n        auto a = LWECiphertexts[i]-&gt;GetA();\n        A[i]   = std::vector&lt;std::complex&lt;double&gt;&gt;(a.GetLength());\n        for (uint32_t j = 0; j &lt; a.GetLength(); j++) {\n            A[i][j] = std::complex&lt;double&gt;(a[j].ConvertToDouble(), 0);\n        }\n        b[i] = std::complex&lt;double&gt;(LWECiphertexts[i]-&gt;GetB().ConvertToDouble(), 0);\n    }\n\n    // Step 2. Perform the homomorphic linear transformation of A*skLWE\n    Ciphertext&lt;DCRTPoly&gt; AdotS = EvalPartialHomDecryption(*ccCKKS, A, m_FHEWtoCKKSswk, m_dim1FC, prescale, 0);\n\n    // Step 3. Get the ciphertext of B - A*s\n    for (uint32_t i = 0; i &lt; numValues; i++) {\n        b[i] *= prescale;\n    }\n    Plaintext BPlain = ccCKKS-&gt;MakeCKKSPackedPlaintext(b, AdotS-&gt;GetNoiseScaleDeg(), AdotS-&gt;GetLevel(), nullptr, N / 2);\n\n    auto BminusAdotS = ccCKKS-&gt;EvalAdd(ccCKKS-&gt;EvalNegate(AdotS), BPlain);\n\n    if (cryptoParamsCKKS-&gt;GetScalingTechnique() == FIXEDMANUAL) {\n        ccCKKS-&gt;ModReduceInPlace(BminusAdotS);\n    }\n    else {\n        if (BminusAdotS-&gt;GetNoiseScaleDeg() == 2)\n            ccCKKS-&gt;GetScheme()-&gt;ModReduceInternalInPlace(BminusAdotS, BASE_NUM_LEVELS_TO_DROP);\n    }\n\n    // Step 4. Do the modulus reduction: homomorphically evaluate modular function. We do it by using sine approximation.\n    auto BminusAdotS2 = BminusAdotS;  // Instead of zeroing out slots which are not of interest as done above\n\n    double a_cheby = -1;\n    double b_cheby = 1;  // The division by K was performed before\n\n    // double a_cheby = -K; double b_cheby = K; // Alternatively, do this separately to not lose precision when scaling with everything at once\n    // auto BminusAdotS2 = BminusAdotS;\n\n    auto BminusAdotS3 = ccCKKS-&gt;EvalChebyshevSeries(BminusAdotS2, coefficientsFHEW, a_cheby, b_cheby);\n\n    if (cryptoParamsCKKS-&gt;GetScalingTechnique() != FIXEDMANUAL) {\n        ccCKKS-&gt;GetScheme()-&gt;ModReduceInternalInPlace(BminusAdotS3, BASE_NUM_LEVELS_TO_DROP);\n    }\n\n    enum { BT_ITER = 3 };\n    for (int32_t j = 1; j &lt; BT_ITER + 1; j++) {\n        BminusAdotS3  = ccCKKS-&gt;EvalMult(BminusAdotS3, BminusAdotS3);\n        BminusAdotS3  = ccCKKS-&gt;EvalAdd(BminusAdotS3, BminusAdotS3);\n        double scalar = 1.0 / std::pow((2.0 * Pi), std::pow(2.0, j - BT_ITER));\n        BminusAdotS3  = ccCKKS-&gt;EvalSub(BminusAdotS3, scalar);\n        if (cryptoParamsCKKS-&gt;GetScalingTechnique() == FIXEDMANUAL) {\n            ccCKKS-&gt;ModReduceInPlace(BminusAdotS3);\n        }\n        else {\n            ccCKKS-&gt;GetScheme()-&gt;ModReduceInternalInPlace(BminusAdotS3, BASE_NUM_LEVELS_TO_DROP);\n        }\n    }\n\n    /* For p &lt;= 4 and when we only encrypt bits, we don&#x27;t need sin(2pi*x)/2pi to approximate x,\n     * we can directly use sin(0) for 0 and sin(pi/2) for 1.\n     * Here pmax is actually the plaintext modulus, not the maximum value of the messages that we\n     * consider. For plaintext modulus &gt; 4, even if we only care about encrypting bits, 2pi is not\n     * the correct post-scaling factor.\n     * Moreover, we have to account for the different encoding the end ciphertext should have.\n     */\n\n    double postScale = 1.0;\n    double postBias  = 0.0;\n    if (p == 1 || p == 2 || p == 3 || p == 4) {\n        postScale = 2 * Pi;\n    }\n    else {\n        postScale = static_cast&lt;double&gt;(p);\n    }\n\n    if (pmin != 0) {\n        postScale *= (pmax - pmin) / 4.0;\n        postBias = (pmax - pmin) / 4.0;\n    }\n\n    // numValues are set; the rest of values up to N/2 are made zero when creating the plaintext\n    std::vector&lt;std::complex&lt;double&gt;&gt; postScaleVec(numValues, std::complex&lt;double&gt;(postScale, 0));\n    std::vector&lt;std::complex&lt;double&gt;&gt; postBiasVec(numValues, std::complex&lt;double&gt;(postBias, 0));\n\n    ILDCRTParams&lt;DCRTPoly::Integer&gt; elementParams = *(cryptoParamsCKKS-&gt;GetElementParams());\n\n    uint32_t towersToDrop = BminusAdotS3-&gt;GetLevel() + BminusAdotS3-&gt;GetNoiseScaleDeg() - 1;\n    for (uint32_t i = 0; i &lt; towersToDrop; i++)\n        elementParams.PopLastParam();\n\n    auto paramsQ = elementParams.GetParams();\n    usint sizeQ  = paramsQ.size();\n    auto paramsP = cryptoParamsCKKS-&gt;GetParamsP()-&gt;GetParams();\n    usint sizeP  = paramsP.size();\n\n    std::vector&lt;NativeInteger&gt; moduli(sizeQ + sizeP);\n    std::vector&lt;NativeInteger&gt; roots(sizeQ + sizeP);\n    for (size_t i = 0; i &lt; sizeQ; i++) {\n        moduli[i] = paramsQ[i]-&gt;GetModulus();\n        roots[i]  = paramsQ[i]-&gt;GetRootOfUnity();\n    }\n\n    for (size_t i = 0; i &lt; sizeP; i++) {\n        moduli[sizeQ + i] = paramsP[i]-&gt;GetModulus();\n        roots[sizeQ + i]  = paramsP[i]-&gt;GetRootOfUnity();\n    }\n\n    auto elementParamsPtr  = std::make_shared&lt;ILDCRTParams&lt;DCRTPoly::Integer&gt;&gt;(M, moduli, roots);\n    auto elementParamsPtr2 = std::dynamic_pointer_cast&lt;typename DCRTPoly::Params&gt;(elementParamsPtr);\n\n    // Use full packing here to clear up the junk in the slots after numValues\n    auto postScalePlain = ccCKKS-&gt;MakeCKKSPackedPlaintext(postScaleVec, 1, towersToDrop, elementParamsPtr2, N / 2);\n    auto BminusAdotSres = ccCKKS-&gt;EvalMult(BminusAdotS3, postScalePlain);\n\n    // Add the plaintext for bias at the correct level and depth\n    auto postBiasPlain = ccCKKS-&gt;MakeCKKSPackedPlaintext(postBiasVec, BminusAdotSres-&gt;GetNoiseScaleDeg(),\n                                                         BminusAdotSres-&gt;GetLevel(), nullptr, N / 2);\n\n    BminusAdotSres = ccCKKS-&gt;EvalAdd(postBiasPlain, BminusAdotSres);\n\n    // Go back to the sparse encoding if needed\n    if (isSparse) {\n        for (uint32_t j = 1; j &lt; N / (2 * slots); j &lt;&lt;= 1) {\n            auto temp = ccCKKS-&gt;EvalRotate(BminusAdotSres, j * slots);\n            ccCKKS-&gt;EvalAddInPlace(BminusAdotSres, temp);\n        }\n        BminusAdotSres-&gt;SetSlots(slots);\n    }\n\n    if (cryptoParamsCKKS-&gt;GetScalingTechnique() == FIXEDMANUAL) {\n        ccCKKS-&gt;ModReduceInPlace(BminusAdotSres);\n    }\n\n    return BminusAdotSres;\n}\n\nstd::pair&lt;BinFHEContext, LWEPrivateKey&gt; SWITCHCKKSRNS::EvalSchemeSwitchingSetup(\n    const CryptoContextImpl&lt;DCRTPoly&gt;&amp; ccCKKS, SecurityLevel sl, BINFHE_PARAMSET slBin, bool arbFunc, uint32_t logQ,\n    bool dynamic, uint32_t numSlotsCKKS, uint32_t logQswitch) {\n    auto FHEWcc = EvalCKKStoFHEWSetup(ccCKKS, sl, slBin, arbFunc, logQ, dynamic, numSlotsCKKS, logQswitch);\n\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(ccCKKS.GetCryptoParameters());\n\n    // Get the last ciphertext modulus; this assumes the LWE mod switch will be performed on the ciphertext at the last level\n    ILDCRTParams&lt;DCRTPoly::Integer&gt; elementParams = *(cryptoParams-&gt;GetElementParams());\n    auto paramsQ                                  = elementParams.GetParams();\n    m_modulus_CKKS_initial                        = paramsQ[0]-&gt;GetModulus().ConvertToInt();\n\n    return FHEWcc;\n}\n\nstd::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;DCRTPoly&gt;&gt;&gt; SWITCHCKKSRNS::EvalSchemeSwitchingKeyGen(\n    const KeyPair&lt;DCRTPoly&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk, uint32_t numValues, bool oneHot, bool alt,\n    uint32_t dim1CF, uint32_t dim1FC, uint32_t LCF, uint32_t LFC) {\n    auto privateKey = keyPair.secretKey;\n    auto publicKey  = keyPair.publicKey;\n\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(privateKey-&gt;GetCryptoParameters());\n\n    if (cryptoParams-&gt;GetKeySwitchTechnique() != HYBRID)\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;CKKS to FHEW scheme switching is only supported for the Hybrid key switching method.&quot;);\n#if NATIVEINT == 128 &amp;&amp; !defined(__EMSCRIPTEN__)\n    if (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTO || cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT)\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;128-bit CKKS to FHEW scheme switching is supported for FIXEDMANUAL and FIXEDAUTO methods only.&quot;);\n#endif\n\n    auto ccCKKS = privateKey-&gt;GetCryptoContext();\n\n    uint32_t M       = ccCKKS-&gt;GetCyclotomicOrder();\n    uint32_t slots   = m_numSlotsCKKS;\n    uint32_t n       = lwesk-&gt;GetElement().GetLength();\n    uint32_t ringDim = ccCKKS-&gt;GetRingDimension();\n\n    // Intermediate cryptocontext for CKKS to FHEW\n    auto keys2 = m_ccKS-&gt;KeyGen();\n\n    Plaintext ptxtZeroKS = m_ccKS-&gt;MakeCKKSPackedPlaintext(std::vector&lt;double&gt;{0.0}, 1, 0, nullptr, slots);\n    m_ctxtKS             = m_ccKS-&gt;Encrypt(keys2.publicKey, ptxtZeroKS);\n\n    // Compute switching key between RLWE and LWE via the intermediate cryptocontext, keep it in RLWE form\n    m_CKKStoFHEWswk = switchingKeyGenRLWEcc(keys2.secretKey, privateKey, lwesk);\n\n    auto skLWEElements = lwesk-&gt;GetElement();\n    std::vector&lt;std::complex&lt;double&gt;&gt; skLWEDouble(n);\n    for (uint32_t i = 0; i &lt; n; i++) {\n        auto tmp = skLWEElements[i].ConvertToDouble();\n        if (tmp == lwesk-&gt;GetModulus().ConvertToInt() - 1)\n            tmp = -1;\n        skLWEDouble[i] = std::complex&lt;double&gt;(tmp, 0);\n    }\n\n    // Check encoding and specify the number of slots, otherwise, if batchsize is set and is smaller, it will throw an error.\n    Plaintext skLWEPlainswk;\n    if (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT)\n        skLWEPlainswk = ccCKKS-&gt;MakeCKKSPackedPlaintext(Fill(skLWEDouble, ringDim / 2), 1, BASE_NUM_LEVELS_TO_DROP,\n                                                        nullptr, ringDim / 2);\n    else\n        skLWEPlainswk = ccCKKS-&gt;MakeCKKSPackedPlaintext(Fill(skLWEDouble, ringDim / 2), 1, 0, nullptr, ringDim / 2);\n\n    m_FHEWtoCKKSswk = ccCKKS-&gt;Encrypt(publicKey, skLWEPlainswk);\n\n    // Compute automorphism keys\n    /* CKKS to FHEW */\n    if (dim1CF == 0)\n        dim1CF = getRatioBSGSLT(slots);\n    m_dim1CF = dim1CF;\n    m_LCF    = LCF;\n\n    // Compute indices for rotations for slotToCoeff transform\n    std::vector&lt;int32_t&gt; indexRotationS2C = FindLTRotationIndicesSwitch(m_dim1CF, M, slots);\n    indexRotationS2C.emplace_back(static_cast&lt;int32_t&gt;(slots));\n\n    // Compute indices for rotations for sparse packing\n    if (ringDim &gt; 2 * slots) {  // if the encoding is full, this does not execute\n        indexRotationS2C.reserve(indexRotationS2C.size() + GetMSB(ringDim) - 2 + GetMSB(slots) - 1);\n        for (uint32_t i = 1; i &lt; ringDim / 2; i &lt;&lt;= 1) {\n            indexRotationS2C.emplace_back(static_cast&lt;int32_t&gt;(i));\n            if (i &lt;= slots)\n                indexRotationS2C.emplace_back(-static_cast&lt;int32_t&gt;(i));\n        }\n    }\n\n    /* FHEW to CKKS */\n    if (dim1FC == 0)\n        dim1FC = getRatioBSGSLT(n);  // This picks the ratio for baby-step giant-step\n    m_dim1FC = dim1FC;\n    m_LFC    = LFC;\n\n    // Compute indices for rotations for homomorphic decryption in CKKS\n    std::vector&lt;int32_t&gt; indexRotationHomDec = FindLTRotationIndicesSwitch(m_dim1FC, M, n);\n\n    // Compute indices for rotations to bring back the final CKKS ciphertext encoding to slots\n    if (ringDim &gt; 2 * slots) {  // if the encoding is full, this does not execute\n        indexRotationHomDec.reserve(indexRotationHomDec.size() + GetMSB(ringDim) - 2);\n        for (uint32_t j = 1; j &lt; ringDim / (2 * slots); j &lt;&lt;= 1) {\n            indexRotationHomDec.emplace_back(j * slots);\n        }\n    }\n\n    std::vector&lt;int32_t&gt; indexRotationArgmin;\n\n    /* Compute indices for Argmin if numValues != 0. Otherwise, the KeyGen is not used for Argmin*/\n    if (numValues &gt; 0) {\n        indexRotationArgmin.reserve(GetMSB(numValues) - 2 + static_cast&lt;int32_t&gt;(!alt) * 2 * (GetMSB(numValues) - 2));\n        for (uint32_t i = 1; i &lt; numValues; i &lt;&lt;= 1) {\n            indexRotationArgmin.emplace_back(static_cast&lt;int32_t&gt;(numValues / (2 * i)));\n            if (!alt) {\n                indexRotationArgmin.emplace_back(-static_cast&lt;int32_t&gt;(numValues / (2 * i)));\n                if (i &gt; 1) {\n                    for (uint32_t j = numValues / i; j &lt; numValues; j &lt;&lt;= 1)\n                        indexRotationArgmin.emplace_back(-static_cast&lt;int32_t&gt;(j));\n                }\n            }\n        }\n    }\n\n    // Combine the indices lists\n    indexRotationS2C.reserve(indexRotationS2C.size() + indexRotationHomDec.size() + indexRotationArgmin.size());\n    indexRotationS2C.insert(indexRotationS2C.end(), indexRotationHomDec.begin(), indexRotationHomDec.end());\n    indexRotationS2C.insert(indexRotationS2C.end(), indexRotationArgmin.begin(), indexRotationArgmin.end());\n\n    // Remove possible duplicates\n    sort(indexRotationS2C.begin(), indexRotationS2C.end());\n    indexRotationS2C.erase(unique(indexRotationS2C.begin(), indexRotationS2C.end()), indexRotationS2C.end());\n\n    auto algo     = ccCKKS-&gt;GetScheme();\n    auto evalKeys = algo-&gt;EvalAtIndexKeyGen(publicKey, privateKey, indexRotationS2C);\n\n    // Compute conjugation key\n    const DCRTPoly&amp; s                       = privateKey-&gt;GetPrivateElement();\n    usint N                                 = s.GetRingDimension();\n    PrivateKey&lt;DCRTPoly&gt; privateKeyPermuted = std::make_shared&lt;PrivateKeyImpl&lt;DCRTPoly&gt;&gt;(ccCKKS);\n    usint index                             = 2 * N - 1;\n    std::vector&lt;usint&gt; vec(N);\n    PrecomputeAutoMap(N, index, &amp;vec);\n    DCRTPoly sPermuted = s.AutomorphismTransform(index, vec);\n    privateKeyPermuted-&gt;SetPrivateElement(sPermuted);\n    privateKeyPermuted-&gt;SetKeyTag(privateKey-&gt;GetKeyTag());\n    auto conjKey       = algo-&gt;KeySwitchGen(privateKey, privateKeyPermuted);\n    (*evalKeys)[M - 1] = conjKey;\n\n    // Compute multiplication key\n    ccCKKS-&gt;EvalMultKeyGen(privateKey);\n\n    // Compute automorphism keys if we don&#x27;t want one hot encoding for argmin\n    if (numValues != 0 &amp;&amp; oneHot == false) {\n        ccCKKS-&gt;EvalSumKeyGen(privateKey);\n    }\n\n    /* FHEW computations */\n    // Generate the bootstrapping keys (refresh and switching keys)\n    m_ccLWE.BTKeyGen(lwesk);\n\n    return evalKeys;\n}\n\nvoid SWITCHCKKSRNS::EvalCompareSwitchPrecompute(const CryptoContextImpl&lt;DCRTPoly&gt;&amp; ccCKKS, uint32_t pLWE,\n                                                uint32_t initLevel, double scaleSign, bool unit) {\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(ccCKKS.GetCryptoParameters());\n\n    double scaleCF = 1.0;\n\n    if (pLWE != 0) {\n        double scFactor = cryptoParams-&gt;GetScalingFactorReal(initLevel);\n        if (unit)  // The messages are already scaled between 0 and 1, no need to divide by pLWE\n            scaleCF = m_modulus_CKKS_initial.ConvertToDouble() / scFactor;\n        else\n            scaleCF = m_modulus_CKKS_initial.ConvertToDouble() / (scFactor * pLWE);\n    }\n    // Else perform no scaling; the implicit FHEW plaintext modulus will be m_modulus_CKKS_initial / scFactor\n\n    m_plaintextFHEW = pLWE;\n    scaleCF *= scaleSign;\n\n    EvalCKKStoFHEWPrecompute(ccCKKS, scaleCF);\n}\n\nCiphertext&lt;DCRTPoly&gt; SWITCHCKKSRNS::EvalCompareSchemeSwitching(ConstCiphertext&lt;DCRTPoly&gt; ciphertext1,\n                                                               ConstCiphertext&lt;DCRTPoly&gt; ciphertext2, uint32_t numCtxts,\n                                                               uint32_t numSlots, uint32_t pLWE, double scaleSign,\n                                                               bool unit) {\n    auto ccCKKS             = ciphertext1-&gt;GetCryptoContext();\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(ccCKKS-&gt;GetCryptoParameters());\n\n    auto cDiff = ccCKKS-&gt;EvalSub(ciphertext1, ciphertext2);\n\n    if (unit) {\n        if (pLWE == 0) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;To scale to the unit circle, pLWE must be non-zero.&quot;);\n        }\n        else {\n            cDiff = ccCKKS-&gt;EvalMult(cDiff, 1.0 / static_cast&lt;double&gt;(pLWE));\n            cDiff = ccCKKS-&gt;Rescale(cDiff);\n        }\n    }\n\n    // The precomputation has already been performed, but if it is scaled differently than desired, recompute it\n    if (pLWE != 0) {\n        m_scFactorOuter = cryptoParams-&gt;GetScalingFactorReal(0);\n        double scFactor = cryptoParams-&gt;GetScalingFactorReal(cDiff-&gt;GetLevel());\n        if (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT)\n            scFactor = cryptoParams-&gt;GetScalingFactorReal(cDiff-&gt;GetLevel() + 1);\n\n        double scaleCF = 1.0;\n        if (unit)  // The messages are already scaled between 0 and 1, no need to divide by pLWE\n            scaleCF = m_modulus_CKKS_initial.ConvertToDouble() / scFactor;\n        else\n            scaleCF = m_modulus_CKKS_initial.ConvertToDouble() / (scFactor * pLWE);\n        scaleCF *= scaleSign;\n        ccCKKS-&gt;EvalCKKStoFHEWPrecompute(scaleCF);\n    }\n\n    auto LWECiphertexts = EvalCKKStoFHEW(cDiff, numCtxts);\n\n    std::vector&lt;LWECiphertext&gt; cSigns(LWECiphertexts.size());\n#pragma omp parallel for\n    for (uint32_t i = 0; i &lt; LWECiphertexts.size(); i++) {\n        cSigns[i] = m_ccLWE.EvalSign(LWECiphertexts[i], true);\n    }\n\n    return EvalFHEWtoCKKS(cSigns, numCtxts, numSlots, 4, -1.0, 1.0);\n    // return ccCKKS-&gt;EvalFHEWtoCKKS(cSigns, numCtxts, numSlots, 4, -1.0, 1.0);\n}\n\nstd::vector&lt;Ciphertext&lt;DCRTPoly&gt;&gt; SWITCHCKKSRNS::EvalMinSchemeSwitching(ConstCiphertext&lt;DCRTPoly&gt; ciphertext,\n                                                                        PublicKey&lt;DCRTPoly&gt; publicKey,\n                                                                        uint32_t numValues, uint32_t numSlots,\n                                                                        bool oneHot, uint32_t pLWE, double scaleSign) {\n    auto cc                 = ciphertext-&gt;GetCryptoContext();\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersRNS&gt;(ciphertext-&gt;GetCryptoParameters());\n\n    // The precomputation has already been performed, but if it is scaled differently than desired, recompute it\n    if (pLWE != 0) {\n        double scFactor = cryptoParams-&gt;GetScalingFactorReal(ciphertext-&gt;GetLevel());\n        if (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT)\n            scFactor = cryptoParams-&gt;GetScalingFactorReal(ciphertext-&gt;GetLevel() + 1);\n        double scaleCF = m_modulus_CKKS_initial.ConvertToDouble() / (scFactor * pLWE);\n        scaleCF *= scaleSign;\n        cc-&gt;EvalCKKStoFHEWPrecompute(scaleCF);\n    }\n\n    uint32_t towersToDrop = 12;  // How many levels are consumed in the EvalFHEWtoCKKS\n    uint32_t slots        = (numSlots == 0) ? m_numSlotsCKKS : numSlots;\n\n    Plaintext pInd;\n    if (oneHot) {\n        std::vector&lt;std::complex&lt;double&gt;&gt; ind(numValues, 1.0);\n        pInd = cc-&gt;MakeCKKSPackedPlaintext(ind, 1, towersToDrop, nullptr, slots);\n    }\n    else {\n        std::vector&lt;std::complex&lt;double&gt;&gt; ind(numValues);\n        std::iota(ind.begin(), ind.end(), 0);\n        pInd = cc-&gt;MakeCKKSPackedPlaintext(ind, 1, towersToDrop, nullptr, slots);\n    }\n    Ciphertext&lt;DCRTPoly&gt; cInd          = cc-&gt;Encrypt(publicKey, pInd);\n    Ciphertext&lt;DCRTPoly&gt; newCiphertext = ciphertext-&gt;Clone();\n\n    for (uint32_t M = 1; M &lt; numValues; M &lt;&lt;= 1) {\n        // Compute CKKS ciphertext encoding difference of the first numValues\n        auto cDiff = cc-&gt;EvalSub(newCiphertext, cc-&gt;EvalAtIndex(newCiphertext, numValues / (2 * M)));\n\n        // Transform the ciphertext from CKKS to FHEW\n        auto cTemp = cc-&gt;EvalCKKStoFHEW(cDiff, numValues / (2 * M));\n\n        // Evaluate the sign\n        // We always assume for the moment that numValues is a power of 2\n        std::vector&lt;LWECiphertext&gt; LWESign(numValues / (2 * M));\n#pragma omp parallel for\n        for (uint32_t j = 0; j &lt; numValues / (2 * M); j++) {\n            LWESign[j] = m_ccLWE.EvalSign(cTemp[j], true);\n        }\n\n        // Scheme switching from FHEW to CKKS\n        auto cSelect = cc-&gt;EvalFHEWtoCKKS(LWESign, numValues / (2 * M), numSlots, 4, -1.0, 1.0);\n\n        std::vector&lt;std::complex&lt;double&gt;&gt; ones(numValues / (2 * M), 1.0);\n        Plaintext ptxtOnes = cc-&gt;MakeCKKSPackedPlaintext(ones, 1, 0, nullptr, slots);\n        cSelect            = cc-&gt;EvalAdd(\n            cSelect, cc-&gt;EvalAtIndex(cc-&gt;EvalSub(ptxtOnes, cSelect), -static_cast&lt;int32_t&gt;(numValues / (2 * M))));\n\n        auto cExpandSelect = cSelect;\n        if (M &gt; 1) {\n            for (uint32_t j = numValues / M; j &lt; numValues; j &lt;&lt;= 1)\n                cExpandSelect = cc-&gt;EvalAdd(cExpandSelect, cc-&gt;EvalAtIndex(cExpandSelect, -static_cast&lt;int32_t&gt;(j)));\n        }\n\n        // Update the ciphertext of values and the indicator\n        newCiphertext = cc-&gt;EvalMult(newCiphertext, cExpandSelect);\n        newCiphertext = cc-&gt;EvalAdd(newCiphertext, cc-&gt;EvalAtIndex(newCiphertext, numValues / (2 * M)));\n        if (cryptoParams-&gt;GetScalingTechnique() == FIXEDMANUAL) {\n            cc-&gt;ModReduceInPlace(newCiphertext);\n        }\n\n        cInd = cc-&gt;EvalMult(cInd, cExpandSelect);\n        if (cryptoParams-&gt;GetScalingTechnique() == FIXEDMANUAL) {\n            cc-&gt;ModReduceInPlace(cInd);\n        }\n    }\n    // After computing the minimum and argument\n    if (!oneHot) {\n        cInd = cc-&gt;EvalSum(cInd, numValues);\n    }\n\n    std::vector&lt;Ciphertext&lt;DCRTPoly&gt;&gt; cRes{newCiphertext, cInd};\n\n    return cRes;\n}\n\nstd::vector&lt;Ciphertext&lt;DCRTPoly&gt;&gt; SWITCHCKKSRNS::EvalMinSchemeSwitchingAlt(ConstCiphertext&lt;DCRTPoly&gt; ciphertext,\n                                                                           PublicKey&lt;DCRTPoly&gt; publicKey,\n                                                                           uint32_t numValues, uint32_t numSlots,\n                                                                           bool oneHot, uint32_t pLWE,\n                                                                           double scaleSign) {\n    auto cc                 = ciphertext-&gt;GetCryptoContext();\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersRNS&gt;(ciphertext-&gt;GetCryptoParameters());\n\n    // The precomputation has already been performed, but if it is scaled differently than desired, recompute it\n    if (pLWE != 0) {\n        double scFactor = cryptoParams-&gt;GetScalingFactorReal(ciphertext-&gt;GetLevel());\n        if (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT)\n            scFactor = cryptoParams-&gt;GetScalingFactorReal(ciphertext-&gt;GetLevel() + 1);\n        double scaleCF = m_modulus_CKKS_initial.ConvertToDouble() / (scFactor * pLWE);\n        scaleCF *= scaleSign;\n        cc-&gt;EvalCKKStoFHEWPrecompute(scaleCF);\n    }\n\n    uint32_t towersToDrop = 12;  // How many levels are consumed in the EvalFHEWtoCKKS, for binary FHEW output.\n    uint32_t slots        = (numSlots == 0) ? m_numSlotsCKKS : numSlots;\n\n    Plaintext pInd;\n    if (oneHot) {\n        std::vector&lt;std::complex&lt;double&gt;&gt; ind(numValues, 1.0);\n        pInd = cc-&gt;MakeCKKSPackedPlaintext(ind, 1, towersToDrop, nullptr, slots);\n    }\n    else {\n        std::vector&lt;std::complex&lt;double&gt;&gt; ind(numValues);\n        std::iota(ind.begin(), ind.end(), 0);\n        pInd = cc-&gt;MakeCKKSPackedPlaintext(ind, 1, towersToDrop, nullptr, slots);\n    }\n    Ciphertext&lt;DCRTPoly&gt; cInd          = cc-&gt;Encrypt(publicKey, pInd);\n    Ciphertext&lt;DCRTPoly&gt; newCiphertext = ciphertext-&gt;Clone();\n\n    for (uint32_t M = 1; M &lt; numValues; M &lt;&lt;= 1) {\n        // Compute CKKS ciphertext encoding difference of the first numValues\n        auto cDiff = cc-&gt;EvalSub(newCiphertext, cc-&gt;EvalAtIndex(newCiphertext, numValues / (2 * M)));\n\n        // Transform the ciphertext from CKKS to FHEW\n        auto cTemp = cc-&gt;EvalCKKStoFHEW(cDiff, numValues / (2 * M));\n\n        // Evaluate the sign\n        // We always assume for the moment that numValues is a power of 2\n        std::vector&lt;LWECiphertext&gt; LWESign(numValues);\n#pragma omp parallel for\n        for (uint32_t j = 0; j &lt; numValues / (2 * M); j++) {\n            LWECiphertext tempSign    = m_ccLWE.EvalSign(cTemp[j], true);\n            LWECiphertext negTempSign = std::make_shared&lt;LWECiphertextImpl&gt;(*tempSign);\n            m_ccLWE.GetLWEScheme()-&gt;EvalAddConstEq(negTempSign, negTempSign-&gt;GetModulus() &gt;&gt; 1);  // &quot;negated&quot; tempSign\n            for (uint32_t i = 0; i &lt; 2 * M; i += 2) {\n                LWESign[i * numValues / (2 * M) + j]       = tempSign;\n                LWESign[(i + 1) * numValues / (2 * M) + j] = negTempSign;\n            }\n        }\n\n        // Scheme switching from FHEW to CKKS\n        auto cExpandSelect = cc-&gt;EvalFHEWtoCKKS(LWESign, numValues, numSlots, 4, -1.0, 1.0);\n\n        // Update the ciphertext of values and the indicator\n        newCiphertext = cc-&gt;EvalMult(newCiphertext, cExpandSelect);\n        newCiphertext = cc-&gt;EvalAdd(newCiphertext, cc-&gt;EvalAtIndex(newCiphertext, numValues / (2 * M)));\n\n        if (cryptoParams-&gt;GetScalingTechnique() == FIXEDMANUAL) {\n            cc-&gt;ModReduceInPlace(newCiphertext);\n        }\n\n        cInd = cc-&gt;EvalMult(cInd, cExpandSelect);\n        if (cryptoParams-&gt;GetScalingTechnique() == FIXEDMANUAL) {\n            cc-&gt;ModReduceInPlace(cInd);\n        }\n    }\n    // After computing the minimum and argument\n    if (!oneHot) {\n        cInd = cc-&gt;EvalSum(cInd, numValues);\n    }\n\n    std::vector&lt;Ciphertext&lt;DCRTPoly&gt;&gt; cRes{newCiphertext, cInd};\n\n    return cRes;\n}\n\nstd::vector&lt;Ciphertext&lt;DCRTPoly&gt;&gt; SWITCHCKKSRNS::EvalMaxSchemeSwitching(ConstCiphertext&lt;DCRTPoly&gt; ciphertext,\n                                                                        PublicKey&lt;DCRTPoly&gt; publicKey,\n                                                                        uint32_t numValues, uint32_t numSlots,\n                                                                        bool oneHot, uint32_t pLWE, double scaleSign) {\n    auto cc                 = ciphertext-&gt;GetCryptoContext();\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersRNS&gt;(ciphertext-&gt;GetCryptoParameters());\n\n    // The precomputation has already been performed, but if it is scaled differently than desired, recompute it\n    if (pLWE != 0) {\n        double scFactor = cryptoParams-&gt;GetScalingFactorReal(ciphertext-&gt;GetLevel());\n        if (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT)\n            scFactor = cryptoParams-&gt;GetScalingFactorReal(ciphertext-&gt;GetLevel() + 1);\n        double scaleCF = m_modulus_CKKS_initial.ConvertToDouble() / (scFactor * pLWE);\n        scaleCF *= scaleSign;\n        cc-&gt;EvalCKKStoFHEWPrecompute(scaleCF);\n    }\n\n    uint32_t towersToDrop = 12;  // How many levels are consumed in the EvalFHEWtoCKKS, for binary FHEW output.\n    uint32_t slots        = (numSlots == 0) ? m_numSlotsCKKS : numSlots;\n\n    Plaintext pInd;\n    if (oneHot) {\n        std::vector&lt;std::complex&lt;double&gt;&gt; ind(numValues, 1.0);\n        pInd = cc-&gt;MakeCKKSPackedPlaintext(ind, 1, towersToDrop, nullptr, slots);\n    }\n    else {\n        std::vector&lt;std::complex&lt;double&gt;&gt; ind(numValues);\n        std::iota(ind.begin(), ind.end(), 0);\n        pInd = cc-&gt;MakeCKKSPackedPlaintext(ind, 1, towersToDrop, nullptr, slots);\n    }\n    Ciphertext&lt;DCRTPoly&gt; cInd          = cc-&gt;Encrypt(publicKey, pInd);\n    Ciphertext&lt;DCRTPoly&gt; newCiphertext = ciphertext-&gt;Clone();\n\n    for (uint32_t M = 1; M &lt; numValues; M &lt;&lt;= 1) {\n        // Compute CKKS ciphertext encoding difference of the first numValues\n        auto cDiff = cc-&gt;EvalSub(newCiphertext, cc-&gt;EvalAtIndex(newCiphertext, numValues / (2 * M)));\n\n        // Transform the ciphertext from CKKS to FHEW\n        auto cTemp = cc-&gt;EvalCKKStoFHEW(cDiff, numValues / (2 * M));\n\n        // Evaluate the sign\n        // We always assume for the moment that numValues is a power of 2\n        std::vector&lt;LWECiphertext&gt; LWESign(numValues / (2 * M));\n#pragma omp parallel for\n        for (uint32_t j = 0; j &lt; numValues / (2 * M); j++) {\n            LWESign[j] = m_ccLWE.EvalSign(cTemp[j], true);\n        }\n\n        // Scheme switching from FHEW to CKKS\n        auto cSelect = cc-&gt;EvalFHEWtoCKKS(LWESign, numValues / (2 * M), numSlots, 4, -1.0, 1.0);\n\n        std::vector&lt;std::complex&lt;double&gt;&gt; ones(numValues / (2 * M), 1.0);\n        Plaintext ptxtOnes = cc-&gt;MakeCKKSPackedPlaintext(ones, 1, 0, nullptr, slots);\n        cSelect            = cc-&gt;EvalAdd(cc-&gt;EvalSub(ptxtOnes, cSelect),\n                                         cc-&gt;EvalAtIndex(cSelect, -static_cast&lt;int32_t&gt;(numValues / (2 * M))));\n\n        auto cExpandSelect = cSelect;\n        if (M &gt; 1) {\n            for (uint32_t j = numValues / M; j &lt; numValues; j &lt;&lt;= 1)\n                cExpandSelect = cc-&gt;EvalAdd(cExpandSelect, cc-&gt;EvalAtIndex(cExpandSelect, -static_cast&lt;int32_t&gt;(j)));\n        }\n\n        // Update the ciphertext of values and the indicator\n        newCiphertext = cc-&gt;EvalMult(newCiphertext, cExpandSelect);\n        newCiphertext = cc-&gt;EvalAdd(newCiphertext, cc-&gt;EvalAtIndex(newCiphertext, numValues / (2 * M)));\n\n        if (cryptoParams-&gt;GetScalingTechnique() == FIXEDMANUAL) {\n            cc-&gt;ModReduceInPlace(newCiphertext);\n        }\n\n        cInd = cc-&gt;EvalMult(cInd, cExpandSelect);\n        if (cryptoParams-&gt;GetScalingTechnique() == FIXEDMANUAL) {\n            cc-&gt;ModReduceInPlace(cInd);\n        }\n    }\n    // After computing the minimum and argument\n    if (!oneHot) {\n        cInd = cc-&gt;EvalSum(cInd, numValues);\n    }\n\n    std::vector&lt;Ciphertext&lt;DCRTPoly&gt;&gt; cRes{newCiphertext, cInd};\n\n    return cRes;\n}\n\nstd::vector&lt;Ciphertext&lt;DCRTPoly&gt;&gt; SWITCHCKKSRNS::EvalMaxSchemeSwitchingAlt(ConstCiphertext&lt;DCRTPoly&gt; ciphertext,\n                                                                           PublicKey&lt;DCRTPoly&gt; publicKey,\n                                                                           uint32_t numValues, uint32_t numSlots,\n                                                                           bool oneHot, uint32_t pLWE,\n                                                                           double scaleSign) {\n    auto cc                 = ciphertext-&gt;GetCryptoContext();\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersRNS&gt;(ciphertext-&gt;GetCryptoParameters());\n\n    // The precomputation has already been performed, but if it is scaled differently than desired, recompute it\n    if (pLWE != 0) {\n        double scFactor = cryptoParams-&gt;GetScalingFactorReal(ciphertext-&gt;GetLevel());\n        if (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT)\n            scFactor = cryptoParams-&gt;GetScalingFactorReal(ciphertext-&gt;GetLevel() + 1);\n        double scaleCF = m_modulus_CKKS_initial.ConvertToDouble() / (scFactor * pLWE);\n        scaleCF *= scaleSign;\n        cc-&gt;EvalCKKStoFHEWPrecompute(scaleCF);\n    }\n\n    uint32_t towersToDrop = 12;  // How many levels are consumed in the EvalFHEWtoCKKS, for binary FHEW output\n    uint32_t slots        = (numSlots == 0) ? m_numSlotsCKKS : numSlots;\n\n    Plaintext pInd;\n    if (oneHot) {\n        std::vector&lt;std::complex&lt;double&gt;&gt; ind(numValues, 1.0);\n        pInd = cc-&gt;MakeCKKSPackedPlaintext(ind, 1, towersToDrop, nullptr, slots);\n    }\n    else {\n        std::vector&lt;std::complex&lt;double&gt;&gt; ind(numValues);\n        std::iota(ind.begin(), ind.end(), 0);\n        pInd = cc-&gt;MakeCKKSPackedPlaintext(ind, 1, towersToDrop, nullptr, slots);\n    }\n    Ciphertext&lt;DCRTPoly&gt; cInd          = cc-&gt;Encrypt(publicKey, pInd);\n    Ciphertext&lt;DCRTPoly&gt; newCiphertext = ciphertext-&gt;Clone();\n\n    for (uint32_t M = 1; M &lt; numValues; M &lt;&lt;= 1) {\n        // Compute CKKS ciphertext encoding difference of the first numValues\n        auto cDiff = cc-&gt;EvalSub(newCiphertext, cc-&gt;EvalAtIndex(newCiphertext, numValues / (2 * M)));\n\n        // Transform the ciphertext from CKKS to FHEW\n        auto cTemp = cc-&gt;EvalCKKStoFHEW(cDiff, numValues / (2 * M));\n\n        // Evaluate the sign\n        // We always assume for the moment that numValues is a power of 2\n        std::vector&lt;LWECiphertext&gt; LWESign(numValues);\n#pragma omp parallel for\n        for (uint32_t j = 0; j &lt; numValues / (2 * M); j++) {\n            LWECiphertext tempSign    = m_ccLWE.EvalSign(cTemp[j], true);\n            LWECiphertext negTempSign = std::make_shared&lt;LWECiphertextImpl&gt;(*tempSign);\n            m_ccLWE.GetLWEScheme()-&gt;EvalAddConstEq(negTempSign, negTempSign-&gt;GetModulus() &gt;&gt; 1);  // &quot;negated&quot; tempSign\n            for (uint32_t i = 0; i &lt; 2 * M; i += 2) {\n                LWESign[i * numValues / (2 * M) + j]       = negTempSign;\n                LWESign[(i + 1) * numValues / (2 * M) + j] = tempSign;\n            }\n        }\n\n        // Scheme switching from FHEW to CKKS\n        auto cExpandSelect = cc-&gt;EvalFHEWtoCKKS(LWESign, numValues, numSlots, 4, -1.0, 1.0);\n\n        // Update the ciphertext of values and the indicator\n        newCiphertext = cc-&gt;EvalMult(newCiphertext, cExpandSelect);\n        newCiphertext = cc-&gt;EvalAdd(newCiphertext, cc-&gt;EvalAtIndex(newCiphertext, numValues / (2 * M)));\n\n        if (cryptoParams-&gt;GetScalingTechnique() == FIXEDMANUAL) {\n            cc-&gt;ModReduceInPlace(newCiphertext);\n        }\n\n        cInd = cc-&gt;EvalMult(cInd, cExpandSelect);\n        if (cryptoParams-&gt;GetScalingTechnique() == FIXEDMANUAL) {\n            cc-&gt;ModReduceInPlace(cInd);\n        }\n    }\n    // After computing the minimum and argument\n    if (!oneHot) {\n        cInd = cc-&gt;EvalSum(cInd, numValues);\n    }\n\n    std::vector&lt;Ciphertext&lt;DCRTPoly&gt;&gt; cRes{newCiphertext, cInd};\n\n    return cRes;\n}\n\n}  // namespace lbcrypto\n"}, "/home/zero0000/static-analyze-openfhe/src/binfhe/lib/binfhecontext.cpp": {"id": "/home/zero0000/static-analyze-openfhe/src/binfhe/lib/binfhecontext.cpp", "filePath": "/home/zero0000/static-analyze-openfhe/src/binfhe/lib/binfhecontext.cpp", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Implementation file for Boolean Circuit FHE context class\n */\n\n#include &quot;binfhecontext.h&quot;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n\nnamespace lbcrypto {\n\nvoid BinFHEContext::GenerateBinFHEContext(uint32_t n, uint32_t N, const NativeInteger&amp; q, const NativeInteger&amp; Q,\n                                          double std, uint32_t baseKS, uint32_t baseG, uint32_t baseR,\n                                          SecretKeyDist keyDist, BINFHE_METHOD method, uint32_t numAutoKeys) {\n    auto lweparams = std::make_shared&lt;LWECryptoParams&gt;(n, N, q, Q, Q, std, baseKS);\n    auto rgswparams =\n        std::make_shared&lt;RingGSWCryptoParams&gt;(N, Q, q, baseG, baseR, method, std, keyDist, true, numAutoKeys);\n    m_params       = std::make_shared&lt;BinFHECryptoParams&gt;(lweparams, rgswparams);\n    m_binfhescheme = std::make_shared&lt;BinFHEScheme&gt;(method);\n}\n\nvoid BinFHEContext::GenerateBinFHEContext(BINFHE_PARAMSET set, bool arbFunc, uint32_t logQ, int64_t N,\n                                          BINFHE_METHOD method, bool timeOptimization) {\n    if (GINX != method) {\n        std::string errMsg(&quot;ERROR: CGGI is the only supported method&quot;);\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, errMsg);\n    }\n    if (set != STD128 &amp;&amp; set != TOY) {\n        std::string errMsg(&quot;ERROR: STD128 and TOY are the only supported sets&quot;);\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, errMsg);\n    }\n\n    if (logQ &gt; 29) {\n        std::string errMsg(&quot;ERROR: logQ &gt; 29 is not supported&quot;);\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, errMsg);\n    }\n    if (logQ &lt; 11) {\n        std::string errMsg(&quot;ERROR: logQ &lt; 11 is not supported&quot;);\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, errMsg);\n    }\n    auto logQprime = 54;\n    uint32_t baseG = 0;\n    if (logQ &gt; 25) {\n        baseG = 1 &lt;&lt; 14;\n    }\n    else if (logQ &gt; 16) {\n        baseG = 1 &lt;&lt; 18;\n    }\n    else if (logQ &gt; 11) {\n        baseG = 1 &lt;&lt; 27;\n    }\n    else {  // if (logQ == 11)\n        baseG     = 1 &lt;&lt; 5;\n        logQprime = 27;\n    }\n\n    m_timeOptimization = timeOptimization;\n    SecurityLevel sl   = HEStd_128_classic;\n    // choose minimum ringD satisfying sl and Q\n    uint32_t ringDim = StdLatticeParm::FindRingDim(HEStd_ternary, sl, logQprime);\n    if (N &gt;= ringDim) {  // if specified some larger N, security is also satisfied\n        ringDim = N;\n    }\n    // find prime Q for NTT\n    NativeInteger Q = PreviousPrime&lt;NativeInteger&gt;(FirstPrime&lt;NativeInteger&gt;(logQprime, 2 * ringDim), 2 * ringDim);\n    // q = 2*ringDim by default for maximum plaintext space, if needed for arbitrary function evaluation, q = ringDim\n    uint32_t q = arbFunc ? ringDim : 2 * ringDim;\n\n    uint64_t qKS = 1 &lt;&lt; 30;\n    qKS &lt;&lt;= 5;\n\n    uint32_t n      = (set == TOY) ? 32 : 1305;\n    auto lweparams  = std::make_shared&lt;LWECryptoParams&gt;(n, ringDim, q, Q, qKS, 3.19, 32);\n    auto rgswparams = std::make_shared&lt;RingGSWCryptoParams&gt;(ringDim, Q, q, baseG, 23, method, 3.19, UNIFORM_TERNARY,\n                                                            ((logQ != 11) &amp;&amp; timeOptimization));\n\n    m_params       = std::make_shared&lt;BinFHECryptoParams&gt;(lweparams, rgswparams);\n    m_binfhescheme = std::make_shared&lt;BinFHEScheme&gt;(method);\n\n#if defined(BINFHE_DEBUG)\n    std::cout &lt;&lt; ringDim &lt;&lt; &quot; &quot; &lt;&lt; Q &lt; &lt; &lt; &lt; &quot; &quot; &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; q &lt;&lt; &quot; &quot; &lt;&lt; baseG &lt;&lt; std::endl;\n#endif\n}\n\nvoid BinFHEContext::GenerateBinFHEContext(BINFHE_PARAMSET set, BINFHE_METHOD method) {\n    enum { PRIME = 0 };  // value for modKS if you want to use the intermediate prime for modulus for key switching\n    constexpr double STD_DEV = 3.19;\n    // clang-format off\n    const std::unordered_map&lt;BINFHE_PARAMSET, BinFHEContextParams&gt; paramsMap({\n        //               numberBits|cyclOrder|latticeParam|  mod|   modKS|  stdDev| baseKS| gadgetBase| baseRK| numAutoKeys| keyDist\n        { TOY,               { 27,     1024,          64,  512,   PRIME, STD_DEV,     25,    1 &lt;&lt;  9,  23,     9,  UNIFORM_TERNARY} },\n        { MEDIUM,            { 28,     2048,         422, 1024, 1 &lt;&lt; 14, STD_DEV, 1 &lt;&lt; 7,    1 &lt;&lt; 10,  32,    10,  UNIFORM_TERNARY} },\n        { STD128_LMKCDEY,    { 28,     2048,         446, 1024, 1 &lt;&lt; 13, STD_DEV, 1 &lt;&lt; 5,    1 &lt;&lt; 10,  32,    10,  GAUSSIAN       } },\n        { STD128_AP,         { 27,     2048,         503, 1024, 1 &lt;&lt; 14, STD_DEV, 1 &lt;&lt; 5,    1 &lt;&lt;  9,  32,    10,  UNIFORM_TERNARY} },\n        { STD128,            { 27,     2048,         503, 1024, 1 &lt;&lt; 14, STD_DEV, 1 &lt;&lt; 5,    1 &lt;&lt;  9,  32,    10,  UNIFORM_TERNARY} },\n        { STD192,            { 37,     4096,         805, 1024, 1 &lt;&lt; 15, STD_DEV,     32,    1 &lt;&lt; 13,  32,    10,  UNIFORM_TERNARY} },\n        { STD256,            { 29,     4096,         990, 2048, 1 &lt;&lt; 14, STD_DEV, 1 &lt;&lt; 7,    1 &lt;&lt;  8,  46,    10,  UNIFORM_TERNARY} },\n        { STD128Q,           { 25,     2048,         534, 1024, 1 &lt;&lt; 14, STD_DEV,     32,    1 &lt;&lt;  7,  32,    10,  UNIFORM_TERNARY} },\n        { STD128Q_LMKCDEY,   { 27,     2048,         448, 1024, 1 &lt;&lt; 13, STD_DEV,     32,    1 &lt;&lt;  9,  32,    10,  GAUSSIAN       } },\n        { STD192Q,           { 35,     4096,         875, 1024, 1 &lt;&lt; 15, STD_DEV,     32,    1 &lt;&lt; 12,  32,    10,  UNIFORM_TERNARY} },\n        { STD256Q,           { 27,     4096,        1225, 1024, 1 &lt;&lt; 16, STD_DEV,     16,    1 &lt;&lt;  7,  32,    10,  UNIFORM_TERNARY} },\n        { STD128_3,          { 27,     2048,         541, 1024, 1 &lt;&lt; 15, STD_DEV,     32,    1 &lt;&lt;  7,  32,    10,  UNIFORM_TERNARY} },\n        { STD128_3_LMKCDEY,  { 28,     2048,         485, 1024, 1 &lt;&lt; 15, STD_DEV,     32,    1 &lt;&lt; 10,  32,    10,  GAUSSIAN       } },\n        { STD128Q_3,         { 50,     4096,         575, 2048, 1 &lt;&lt; 15, STD_DEV,     32,    1 &lt;&lt; 25,  32,    10,  UNIFORM_TERNARY} },\n        { STD128Q_3_LMKCDEY, { 27,     2048,         524, 1024, 1 &lt;&lt; 15, STD_DEV,     32,    1 &lt;&lt;  9,  32,    10,  GAUSSIAN       } },\n        { STD192Q_3,         { 34,     4096,         922, 2048, 1 &lt;&lt; 16, STD_DEV,     16,    1 &lt;&lt; 12,  32,    10,  UNIFORM_TERNARY} },\n        { STD256Q_3,         { 27,     4096,        1400, 4096, 1 &lt;&lt; 16, STD_DEV,     21,    1 &lt;&lt;  6,  32,    10,  UNIFORM_TERNARY} },\n        { STD128_4,          { 27,     2048,         541, 2048, 1 &lt;&lt; 15, STD_DEV,     32,    1 &lt;&lt;  7,  32,    10,  UNIFORM_TERNARY} },\n        { STD128_4_LMKCDEY,  { 28,     2048,         522, 2048, 1 &lt;&lt; 15, STD_DEV,     32,    1 &lt;&lt; 10,  32,    10,  GAUSSIAN       } },\n        { STD128Q_4,         { 50,     4096,         647, 2048, 1 &lt;&lt; 16, STD_DEV,     16,    1 &lt;&lt; 25,  32,    10,  UNIFORM_TERNARY} },\n        { STD128Q_4_LMKCDEY, { 27,     2048,         524, 2048, 1 &lt;&lt; 15, STD_DEV,     32,    1 &lt;&lt;  7,  32,    10,  GAUSSIAN       } },\n        { STD192Q_4,         { 34,     4096,         980, 2048, 1 &lt;&lt; 17, STD_DEV,     16,    1 &lt;&lt; 12,  32,    10,  UNIFORM_TERNARY} },\n        { STD256Q_4,         { 27,     4096,        1625, 4096, 1 &lt;&lt; 21, STD_DEV,     16,    1 &lt;&lt;  6,  32,    10,  UNIFORM_TERNARY} },\n        { SIGNED_MOD_TEST,   { 28,     2048,         512, 1024,   PRIME, STD_DEV,     25,    1 &lt;&lt;  7,  23,    10,  UNIFORM_TERNARY} },\n    });\n    // clang-format on\n\n    auto search = paramsMap.find(set);\n    if (paramsMap.end() == search) {\n        std::string errMsg(&quot;ERROR: Unknown parameter set [&quot; + std::to_string(set) + &quot;] for FHEW.&quot;);\n        &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n    }\n\n    BinFHEContextParams params = search-&gt;second;\n    // intermediate prime\n    NativeInteger Q(\n        PreviousPrime&lt;NativeInteger&gt;(FirstPrime&lt;NativeInteger&gt;(params.numberBits, params.cyclOrder), params.cyclOrder));\n\n    usint ringDim  = params.cyclOrder / 2;\n    auto lweparams = (PRIME == params.modKS) ?\n                         std::make_shared&lt;LWECryptoParams&gt;(params.latticeParam, ringDim, params.mod, Q, Q,\n                                                           params.stdDev, params.baseKS, params.keyDist) :\n                         std::make_shared&lt;LWECryptoParams&gt;(params.latticeParam, ringDim, params.mod, Q, params.modKS,\n                                                           params.stdDev, params.baseKS, params.keyDist);\n    auto rgswparams =\n        std::make_shared&lt;RingGSWCryptoParams&gt;(ringDim, Q, params.mod, params.gadgetBase, params.baseRK, method,\n                                              params.stdDev, params.keyDist, false, params.numAutoKeys);\n\n    m_params       = std::make_shared&lt;BinFHECryptoParams&gt;(lweparams, rgswparams);\n    m_binfhescheme = std::make_shared&lt;BinFHEScheme&gt;(method);\n}\n\nvoid BinFHEContext::GenerateBinFHEContext(const BinFHEContextParams&amp; params, BINFHE_METHOD method) {\n    enum { PRIME = 0 };  // value for modKS if you want to use the intermediate prime for modulus for key switching\n    // intermediate prime\n    NativeInteger Q(\n        PreviousPrime&lt;NativeInteger&gt;(FirstPrime&lt;NativeInteger&gt;(params.numberBits, params.cyclOrder), params.cyclOrder));\n\n    usint ringDim = params.cyclOrder / 2;\n\n    auto lweparams = (PRIME == params.modKS) ?\n                         std::make_shared&lt;LWECryptoParams&gt;(params.latticeParam, ringDim, params.mod, Q, Q,\n                                                           params.stdDev, params.baseKS, params.keyDist) :\n                         std::make_shared&lt;LWECryptoParams&gt;(params.latticeParam, ringDim, params.mod, Q, params.modKS,\n                                                           params.stdDev, params.baseKS, params.keyDist);\n\n    auto rgswparams =\n        std::make_shared&lt;RingGSWCryptoParams&gt;(ringDim, Q, params.mod, params.gadgetBase, params.baseRK, method,\n                                              params.stdDev, params.keyDist, false, params.numAutoKeys);\n\n    m_params       = std::make_shared&lt;BinFHECryptoParams&gt;(lweparams, rgswparams);\n    m_binfhescheme = std::make_shared&lt;BinFHEScheme&gt;(method);\n}\n\nLWEPrivateKey BinFHEContext::KeyGen() const {\n    auto&amp; LWEParams = m_params-&gt;GetLWEParams();\n    if (LWEParams-&gt;GetKeyDist() == GAUSSIAN)\n        return m_LWEscheme-&gt;KeyGenGaussian(LWEParams-&gt;Getn(), LWEParams-&gt;GetqKS());\n    return m_LWEscheme-&gt;KeyGen(LWEParams-&gt;Getn(), LWEParams-&gt;GetqKS());\n}\n\nLWEPrivateKey BinFHEContext::KeyGenN() const {\n    auto&amp; LWEParams = m_params-&gt;GetLWEParams();\n    if (LWEParams-&gt;GetKeyDist() == GAUSSIAN)\n        return m_LWEscheme-&gt;KeyGenGaussian(LWEParams-&gt;GetN(), LWEParams-&gt;GetQ());\n    return m_LWEscheme-&gt;KeyGen(LWEParams-&gt;GetN(), LWEParams-&gt;GetQ());\n}\n\nLWEKeyPair BinFHEContext::KeyGenPair() const {\n    auto&amp;&amp; LWEParams = m_params-&gt;GetLWEParams();\n    return m_LWEscheme-&gt;KeyGenPair(LWEParams);\n}\n\nLWEPublicKey BinFHEContext::PubKeyGen(ConstLWEPrivateKey&amp; sk) const {\n    auto&amp;&amp; LWEParams = m_params-&gt;GetLWEParams();\n    return m_LWEscheme-&gt;PubKeyGen(LWEParams, sk);\n}\n\nLWECiphertext BinFHEContext::Encrypt(ConstLWEPrivateKey&amp; sk, LWEPlaintext m, BINFHE_OUTPUT output,\n                                     LWEPlaintextModulus p, const NativeInteger&amp; mod) const {\n    const auto&amp; LWEParams = m_params-&gt;GetLWEParams();\n\n    LWECiphertext ct = (mod == 0) ? m_LWEscheme-&gt;Encrypt(LWEParams, sk, m, p, LWEParams-&gt;Getq()) :\n                                    m_LWEscheme-&gt;Encrypt(LWEParams, sk, m, p, mod);\n\n    // BINFHE_OUTPUT is kept as it is for backward compatibility but\n    // this logic is obsolete now and commented out\n    // if ((output != FRESH) &amp;&amp; (p == 4)) {\n    //    ct = m_binfhescheme-&gt;Bootstrap(m_params, m_BTKey, ct);\n    //}\n\n    return ct;\n}\n\nLWECiphertext BinFHEContext::Encrypt(ConstLWEPublicKey&amp; pk, LWEPlaintext m, BINFHE_OUTPUT output, LWEPlaintextModulus p,\n                                     const NativeInteger&amp; mod) const {\n    const auto&amp; LWEParams = m_params-&gt;GetLWEParams();\n\n    LWECiphertext ct = (mod == 0) ? m_LWEscheme-&gt;EncryptN(LWEParams, pk, m, p, LWEParams-&gt;GetQ()) :\n                                    m_LWEscheme-&gt;EncryptN(LWEParams, pk, m, p, mod);\n\n    // Switch from ct of modulus Q and dimension N to smaller q and n\n    // This is done by default while calling Encrypt but the output could\n    // be set to LARGE_DIM to skip this switching\n    if (output == SMALL_DIM) {\n        LWECiphertext ct1 = SwitchCTtoqn(m_BTKey.KSkey, ct);\n        return ct1;\n    }\n    return ct;\n}\n\nLWECiphertext BinFHEContext::SwitchCTtoqn(ConstLWESwitchingKey&amp; ksk, ConstLWECiphertext&amp; ct) const {\n    const auto&amp; LWEParams = m_params-&gt;GetLWEParams();\n    auto Q                = LWEParams-&gt;GetQ();\n    auto N                = LWEParams-&gt;GetN();\n\n    if ((ct-&gt;GetLength() != N) &amp;&amp; (ct-&gt;GetModulus() != Q)) {\n        std::string errMsg(&quot;ERROR: Ciphertext dimension and modulus are not large N and Q&quot;);\n        &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n    }\n\n    LWECiphertext ct1 = m_LWEscheme-&gt;SwitchCTtoqn(LWEParams, ksk, ct);\n\n    return ct1;\n}\n\nvoid BinFHEContext::Decrypt(ConstLWEPrivateKey&amp; sk, ConstLWECiphertext&amp; ct, LWEPlaintext* result,\n                            LWEPlaintextModulus p) const {\n    auto&amp;&amp; LWEParams = m_params-&gt;GetLWEParams();\n    m_LWEscheme-&gt;Decrypt(LWEParams, sk, ct, result, p);\n}\n\nLWESwitchingKey BinFHEContext::KeySwitchGen(ConstLWEPrivateKey&amp; sk, ConstLWEPrivateKey&amp; skN) const {\n    return m_LWEscheme-&gt;KeySwitchGen(m_params-&gt;GetLWEParams(), sk, skN);\n}\n\nvoid BinFHEContext::BTKeyGen(ConstLWEPrivateKey&amp; sk, KEYGEN_MODE keygenMode) {\n    auto&amp; RGSWParams = m_params-&gt;GetRingGSWParams();\n\n    auto temp = RGSWParams-&gt;GetBaseG();\n\n    if (m_timeOptimization) {\n        auto gpowermap = RGSWParams-&gt;GetGPowerMap();\n        for (std::map&lt;uint32_t, std::vector&lt;NativeInteger&gt;&gt;::iterator it = gpowermap.begin(); it != gpowermap.end();\n             ++it) {\n            RGSWParams-&gt;Change_BaseG(it-&gt;first);\n            m_BTKey_map[it-&gt;first] = m_binfhescheme-&gt;KeyGen(m_params, sk, keygenMode);\n        }\n        RGSWParams-&gt;Change_BaseG(temp);\n    }\n\n    if (m_BTKey_map.size() != 0) {\n        m_BTKey = m_BTKey_map[temp];\n    }\n    else {\n        m_BTKey           = m_binfhescheme-&gt;KeyGen(m_params, sk, keygenMode);\n        m_BTKey_map[temp] = m_BTKey;\n    }\n}\n\nLWECiphertext BinFHEContext::EvalBinGate(const BINGATE gate, ConstLWECiphertext&amp; ct1, ConstLWECiphertext&amp; ct2) const {\n    return m_binfhescheme-&gt;EvalBinGate(m_params, gate, m_BTKey, ct1, ct2);\n}\n\nLWECiphertext BinFHEContext::EvalBinGate(const BINGATE gate, const std::vector&lt;LWECiphertext&gt;&amp; ctvector) const {\n    return m_binfhescheme-&gt;EvalBinGate(m_params, gate, m_BTKey, ctvector);\n}\n\nLWECiphertext BinFHEContext::Bootstrap(ConstLWECiphertext&amp; ct) const {\n    return m_binfhescheme-&gt;Bootstrap(m_params, m_BTKey, ct);\n}\n\nLWECiphertext BinFHEContext::EvalNOT(ConstLWECiphertext&amp; ct) const {\n    return m_binfhescheme-&gt;EvalNOT(m_params, ct);\n}\n\nLWECiphertext BinFHEContext::EvalConstant(bool value) const {\n    return m_LWEscheme-&gt;NoiselessEmbedding(m_params-&gt;GetLWEParams(), value);\n}\n\nLWECiphertext BinFHEContext::EvalFunc(ConstLWECiphertext&amp; ct, const std::vector&lt;NativeInteger&gt;&amp; LUT) const {\n    return m_binfhescheme-&gt;EvalFunc(m_params, m_BTKey, ct, LUT, GetBeta());\n}\n\nLWECiphertext BinFHEContext::EvalFloor(ConstLWECiphertext&amp; ct, uint32_t roundbits) const {\n    //    auto q = m_params-&gt;GetLWEParams()-&gt;Getq().ConvertToInt();\n    //    if (roundbits != 0) {\n    //        NativeInteger newp = this-&gt;GetMaxPlaintextSpace();\n    //        SetQ(q / newp * (1 &lt;&lt; roundbits));\n    //    }\n    //    SetQ(q);\n    //    return res;\n    return m_binfhescheme-&gt;EvalFloor(m_params, m_BTKey, ct, GetBeta(), roundbits);\n}\n\nLWECiphertext BinFHEContext::EvalSign(ConstLWECiphertext&amp; ct, bool schemeSwitch) {\n    const auto&amp; params = std::make_shared&lt;BinFHECryptoParams&gt;(*m_params);\n    return m_binfhescheme-&gt;EvalSign(params, m_BTKey_map, ct, GetBeta(), schemeSwitch);\n}\n\nstd::vector&lt;LWECiphertext&gt; BinFHEContext::EvalDecomp(ConstLWECiphertext&amp; ct) {\n    return m_binfhescheme-&gt;EvalDecomp(m_params, m_BTKey_map, ct, GetBeta());\n}\n\nstd::vector&lt;NativeInteger&gt; BinFHEContext::GenerateLUTviaFunction(NativeInteger (*f)(NativeInteger m, NativeInteger p),\n                                                                 NativeInteger p) {\n    if (ceil(log2(p.ConvertToInt())) != floor(log2(p.ConvertToInt()))) {\n        std::string errMsg(&quot;ERROR: Only support plaintext space to be power-of-two.&quot;);\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, errMsg);\n    }\n\n    NativeInteger q        = GetParams()-&gt;GetLWEParams()-&gt;Getq();\n    NativeInteger interval = q / p;\n    NativeInteger outerval = interval;\n    usint vecSize          = q.ConvertToInt();\n    std::vector&lt;NativeInteger&gt; vec(vecSize);\n    for (size_t i = 0; i &lt; vecSize; ++i) {\n        auto temp = f(NativeInteger(i) / interval, p);\n        if (temp &gt;= p) {\n            std::string errMsg(&quot;ERROR: input function should output in Z_{p_output}.&quot;);\n            &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, errMsg);\n        }\n        vec[i] = temp * outerval;\n    }\n\n    return vec;\n}\n\n}  // namespace lbcrypto\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Wraps parameters for integer lattice operations using double-CRT representation. Inherits from ElemParams\n */\n\n#ifndef LBCRYPTO_INC_LATTICE_ILDCRTPARAMS_H\n#define LBCRYPTO_INC_LATTICE_ILDCRTPARAMS_H\n\n#include &quot;lattice/elemparams.h&quot;\n#include &quot;lattice/ilparams.h&quot;\n\n#include &quot;math/math-hal.h&quot;\n#include &quot;math/nbtheory-impl.h&quot;\n\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/inttypes.h&quot;\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\nnamespace lbcrypto {\n\n/**\n * @brief Parameters for array of ideal lattices (used for Double-CRT).\n *\n * The double-CRT representation of polynomials is a common optimization for\n * lattice encryption operations. Basically, it allows large-modulus polynamials\n * to be represented as multiple smaller-modulus polynomials. The double-CRT\n * representations are discussed theoretically here:\n *   - Gentry C., Halevi S., Smart N.P. (2012) Homomorphic Evaluation of the AES\n * Circuit. In: Safavi-Naini R., Canetti R. (eds) Advances in Cryptology \u2013\n * CRYPTO 2012. Lecture Notes in Computer Science, vol 7417. Springer, Berlin,\n * Heidelberg\n */\ntemplate &lt;typename IntType&gt;\nclass ILDCRTParams final : public ElemParams&lt;IntType&gt; {\npublic:\n    static constexpr usint DEFAULT_NBITS = 20;\n\n    using Integer        = IntType;\n    using ILNativeParams = ILParamsImpl&lt;NativeInteger&gt;;\n\n    /**\n   * @brief Constructor with basic parameter set.\n   * q is selected as FirstPrime(bits, order)\n   * @param order the order of the ciphertext.\n   * @param depth is the size of the tower.\n   * @param bits is the number of bits of each tower&#x27;s moduli.\n   */\n    explicit ILDCRTParams(usint order = 0, usint depth = 1, usint bits = DEFAULT_NBITS)\n        : ElemParams&lt;IntType&gt;(order, 0), m_params(depth) {\n        if (order == 0)\n            return;\n        if (depth == 0)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Invalid depth for ILDCRTParams&quot;);\n        if (bits == 0 || bits &gt; 64)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Invalid bits for ILDCRTParams&quot;);\n        auto q{FirstPrime&lt;NativeInteger&gt;(bits, order)};\n        for (usint j = 0; j &lt; depth; ++j, q = NextPrime&lt;NativeInteger&gt;(q, order))\n            m_params[j] = std::make_shared&lt;ILNativeParams&gt;(order, q, RootOfUnity&lt;NativeInteger&gt;(order, q));\n        RecalculateModulus();\n    }\n\n    /**\n   * @brief Constructor with basic parameters\n   *\n   * @param cyclotomic_order the order of the ciphertext\n   * @param &amp;modulus is the modulus for the primary ciphertext.\n   * @param rootsOfUnity is unused\n   */\n\n    // root of unity unused?\n    ILDCRTParams(usint cyclotomic_order, const IntType&amp; modulus, const IntType&amp; rootOfUnity)\n        : ElemParams&lt;IntType&gt;(cyclotomic_order, modulus, 0, 0, 0), m_originalModulus(modulus) {\n        // NOTE params generation uses this constructor to make an empty params that\n        // it will later populate during the gen process. For that special case...\n        // we don&#x27;t populate, and we just return\n        if (cyclotomic_order == 0)\n            return;\n        std::vector&lt;NativeInteger&gt; moduli;\n        std::vector&lt;NativeInteger&gt; rootsOfUnity;\n        auto q{FirstPrime&lt;NativeInteger&gt;(DEFAULT_NBITS, cyclotomic_order)};\n        IntType compositeModulus(1);\n        while (true) {\n            moduli.push_back(q);\n            rootsOfUnity.push_back(RootOfUnity(cyclotomic_order, q));\n            m_params.push_back(std::make_shared&lt;ILNativeParams&gt;(cyclotomic_order, q, rootsOfUnity.back()));\n            compositeModulus = compositeModulus * IntType(q.ConvertToInt());\n            if (compositeModulus &gt;= modulus)\n                break;\n            q = NextPrime(q, cyclotomic_order);\n        }\n        RecalculateModulus();\n    }\n\n    /**\n   * @brief Constructor with some pre-computed parameters provided as input.\n   * @param cyclotomic_order the order of the ciphertext\n   * @param moduli the list of the smaller moduli of the component polynomials.\n   * @param rootsOfUnity the list of the smaller roots of unity of the component\n   * polynomials.\n   * @param moduliBig the list of the big moduli of the component polynomials\n   * (arbitrary cyclotomics).\n   * @param rootsOfUnityBig the list of the roots of unity of the component\n   * polynomials for big moduli (arbitrary cyclotomics).\n   * @return\n   */\n    ILDCRTParams(usint cyclotomic_order, const std::vector&lt;NativeInteger&gt;&amp; moduli,\n                 const std::vector&lt;NativeInteger&gt;&amp; rootsOfUnity, const std::vector&lt;NativeInteger&gt;&amp; moduliBig = {},\n                 const std::vector&lt;NativeInteger&gt;&amp; rootsOfUnityBig = {},\n                 const IntType&amp; inputOriginalModulus               = IntType(0))\n        : ElemParams&lt;IntType&gt;(cyclotomic_order, 0, 0, 0, 0),\n          m_originalModulus(inputOriginalModulus),\n          m_params(moduli.size()) {\n        if (moduli.size() != rootsOfUnity.size())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;sizes of moduli and roots of unity do not match&quot;);\n        size_t size{moduli.size()};\n        if (moduliBig.size() == size) {\n            for (size_t i = 0; i &lt; size; ++i)\n                m_params[i] = std::make_shared&lt;ILNativeParams&gt;(cyclotomic_order, moduli[i], rootsOfUnity[i],\n                                                               moduliBig[i], rootsOfUnityBig[i]);\n        }\n        else {\n            for (size_t i = 0; i &lt; size; ++i)\n                m_params[i] = std::make_shared&lt;ILNativeParams&gt;(cyclotomic_order, moduli[i], rootsOfUnity[i]);\n        }\n        RecalculateModulus();\n    }\n\n    /**\n   * @brief Constructor with only cylotomic order and chain of moduli.\n   * Multiplied values of the chain of moduli is automatically calculated. Root\n   * of unity of the modulus is also calculated.\n   *\n   * @param cyclotomic_order the order of the ciphertext\n   * @param &amp;moduli is the tower of moduli\n   */\n    ILDCRTParams(usint cyclotomic_order, const std::vector&lt;NativeInteger&gt;&amp; moduli,\n                 const IntType&amp; inputOriginalModulus = IntType(0))\n        : ElemParams&lt;IntType&gt;(cyclotomic_order, 0, 0, 0, 0),\n          m_originalModulus(inputOriginalModulus),\n          m_params(moduli.size()) {\n        for (size_t i = 0; i &lt; moduli.size(); i++)\n            m_params[i] = std::make_shared&lt;ILNativeParams&gt;(cyclotomic_order, moduli[i], 0, 0, 0);\n        RecalculateModulus();\n    }\n\n    /**\n   * @brief Constructor that takes in the cyclotomic order and the component\n   * parameters of the component moduli.\n   * @param cyclotomic_order the primary cyclotomic order.  This is not checked\n   * against the component moduli.\n   * @param params the componet parameters.\n   * @return\n   */\n    ILDCRTParams(usint cyclotomic_order, std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt;&amp; params,\n                 const IntType&amp; inputOriginalModulus = IntType(0))\n        : ElemParams&lt;IntType&gt;(cyclotomic_order, 0, 0, 0, 0), m_originalModulus(inputOriginalModulus), m_params(params) {\n        RecalculateModulus();\n    }\n\n    ILDCRTParams(const ILDCRTParams&amp; rhs)\n        : ElemParams&lt;IntType&gt;(rhs), m_originalModulus(rhs.m_originalModulus), m_params(rhs.m_params) {}\n\n    ILDCRTParams(ILDCRTParams&amp;&amp; rhs) noexcept\n        : ElemParams&lt;IntType&gt;(rhs),\n          m_originalModulus(std::move(rhs.m_originalModulus)),\n          m_params(std::move(rhs.m_params)) {}\n\n    /**\n   * Assignment Operator.\n   *\n   * @param &amp;rhs the copied ILDCRTParams.\n   * @return the resulting ILDCRTParams.\n   */\n    ILDCRTParams&amp; operator=(const ILDCRTParams&amp; rhs) {\n        ElemParams&lt;IntType&gt;::operator=(rhs);\n        m_originalModulus = rhs.m_originalModulus;\n        m_params          = rhs.m_params;\n        return *this;\n    }\n\n    ILDCRTParams&amp; operator=(ILDCRTParams&amp;&amp; rhs) noexcept {\n        ElemParams&lt;IntType&gt;::operator=(rhs);\n        m_originalModulus = std::move(rhs.m_originalModulus);\n        m_params          = std::move(rhs.m_params);\n        return *this;\n    }\n\n    // ACCESSORS\n    /**\n   * @brief Getter method for the component parameters.\n   * @return A vector of the component polynomial parameters.\n   */\n    const std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt;&amp; GetParams() const {\n        return m_params;\n    }\n\n    /**\n   * @brief Getter method that returns a subset of the component parameters.\n   *\n   * @param start The index of the first tower to include in the result.\n   * @param end The index of the last tower to include.\n   * @return A vector of the component polynomial parameters.\n   */\n    std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt; GetParamPartition(uint32_t start, uint32_t end) const {\n        if (end &lt; start || end &gt;= m_params.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Incorrect parameters for GetParamPartition - (start: &quot; + std::to_string(start) +\n                                          &quot;, end:&quot; + std::to_string(end) + &quot;)&quot;);\n        }\n\n        std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt; resParams;\n        for (uint32_t i = start; i &lt;= end; ++i)\n            resParams.push_back(m_params[i]);\n        return resParams;\n    }\n\n    /**\n   * @brief Simple getter method for the original modulus, not the ciphertex\n   * modulus.\n   * @return The original  modulus, not the big ciphertext modulus.\n   */\n    const IntType&amp; GetOriginalModulus() const {\n        return m_originalModulus;\n    }\n    /**\n   * @brief Simple setter method for the original modulus, not the ciphertex\n   * modulus.\n   * @return void\n   */\n    void SetOriginalModulus(const IntType&amp; inputOriginalModulus) {\n        m_originalModulus = inputOriginalModulus;\n    }\n    /**\n   * @brief Getter method for the component parameters of a specific index.\n   * @param i the index of the parameters to return.  Note this this call is\n   * unguarded if the index is out of bounds.\n   * @return the parameters at index i.\n   */\n    std::shared_ptr&lt;ILNativeParams&gt;&amp; operator[](usint i) {\n        return m_params[i];\n    }\n\n    /**\n   * @brief Removes the last parameter set and adjust the multiplied moduli.\n   *\n   */\n    void PopLastParam() {\n        ElemParams&lt;IntType&gt;::m_ciphertextModulus /= IntType(m_params.back()-&gt;GetModulus().ConvertToInt());\n        m_params.pop_back();\n    }\n\n    /**\n   * @brief Removes the first parameter set and adjust the multiplied moduli.\n   *\n   */\n    void PopFirstParam() {\n        ElemParams&lt;IntType&gt;::m_ciphertextModulus /= IntType(m_params[0]-&gt;GetModulus().ConvertToInt());\n        m_params.erase(m_params.begin());\n    }\n\n    /**\n   * Destructor.\n   */\n    ~ILDCRTParams() override = default;\n\n    /**\n   * @brief Equality operator checks if the ElemParams are the same.\n   *\n   * @param &amp;other ElemParams to compare against.\n   * @return the equality check results.\n   */\n    bool operator==(const ElemParams&lt;IntType&gt;&amp; other) const override {\n        const auto* dcrtParams = dynamic_cast&lt;const ILDCRTParams*&gt;(&amp;other);\n\n        if (dcrtParams == nullptr)\n            return false;\n\n        if (ElemParams&lt;IntType&gt;::operator==(other) == false)\n            return false;\n\n        if (m_params.size() != dcrtParams-&gt;m_params.size())\n            return false;\n\n        for (size_t i = 0; i &lt; m_params.size(); i++) {\n            if (*m_params[i] != *dcrtParams-&gt;m_params[i])\n                return false;\n        }\n\n        //    if (originalModulus != dcrtParams-&gt;originalModulus)\n        //      return false;\n\n        return true;\n    }\n\n    /**\n   * @brief Method to recalculate the composite modulus from the component\n   * moduli.\n   */\n    void RecalculateModulus() {\n        ElemParams&lt;IntType&gt;::m_ciphertextModulus = 1;\n        for (size_t i = 0; i &lt; m_params.size(); i++)\n            ElemParams&lt;IntType&gt;::m_ciphertextModulus =\n                ElemParams&lt;IntType&gt;::m_ciphertextModulus * IntType(m_params[i]-&gt;GetModulus().ConvertToInt());\n    }\n\n    /**\n   * @brief Method to recalculate the big composite modulus from the component\n   * moduli.\n   */\n    void RecalculateBigModulus() {\n        ElemParams&lt;IntType&gt;::m_bigCiphertextModulus = 1;\n        for (size_t i = 0; i &lt; m_params.size(); i++)\n            ElemParams&lt;IntType&gt;::m_bigCiphertextModulus =\n                ElemParams&lt;IntType&gt;::m_bigCiphertextModulus * IntType(m_params[i]-&gt;GetBigModulus().ConvertToInt());\n    }\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::base_class&lt;ElemParams&lt;IntType&gt;&gt;(this));\n        ar(::cereal::make_nvp(&quot;p&quot;, m_params));\n        ar(::cereal::make_nvp(&quot;m&quot;, m_originalModulus));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                 &quot; is from a later version of the library&quot;);\n        }\n        ar(::cereal::base_class&lt;ElemParams&lt;IntType&gt;&gt;(this));\n        ar(::cereal::make_nvp(&quot;p&quot;, m_params));\n        ar(::cereal::make_nvp(&quot;m&quot;, m_originalModulus));\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;DCRTParams&quot;;\n    }\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\nprivate:\n    std::ostream&amp; doprint(std::ostream&amp; out) const override {\n        out &lt;&lt; &quot;ILDCRTParams &quot;;\n        ElemParams&lt;IntType&gt;::doprint(out);\n        out &lt;&lt; std::endl &lt;&lt; &quot; Params:&quot; &lt;&lt; std::endl;\n        for (size_t i = 0; i &lt; m_params.size(); i++) {\n            out &lt;&lt; &quot;   &quot; &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; *m_params[i] &lt;&lt; std::endl;\n        }\n        out &lt;&lt; &quot;OriginalModulus &quot; &lt;&lt; m_originalModulus &lt;&lt; std::endl;\n        return out;\n    }\n\n    // original modulus when being constructed from a Poly or when\n    // ctor is passed that parameter\n    // note orignalModulus will be &lt;= composite modules\n    //   i.e. \\Prod_i=0^k-1 m_params[i]-&gt;GetModulus()\n    // note not using ElemParams::ciphertextModulus due to object stripping\n    IntType m_originalModulus{};\n\n    // array of smaller ILParams\n    std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt; m_params;\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/usr/include/c++/11/bits/shared_ptr.h": {"id": "/usr/include/c++/11/bits/shared_ptr.h", "filePath": "/usr/include/c++/11/bits/shared_ptr.h", "content": "// shared_ptr and weak_ptr implementation -*- C++ -*-\n\n// Copyright (C) 2007-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n// GCC Note: Based on files from version 1.32.0 of the Boost library.\n\n//  shared_count.hpp\n//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n\n//  shared_ptr.hpp\n//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  weak_ptr.hpp\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  enable_shared_from_this.hpp\n//  Copyright (C) 2002 Peter Dimov\n\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n\n/** @file\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _SHARED_PTR_H\n#define _SHARED_PTR_H 1\n\n#include &lt;iosfwd&gt;           \t  // std::basic_ostream\n#include &lt;bits/shared_ptr_base.h&gt;\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   * @addtogroup pointer_abstractions\n   * @{\n   */\n\n  // 20.7.2.2.11 shared_ptr I/O\n\n  /// Write the stored pointer to an ostream.\n  /// @relates shared_ptr\n  template&lt;typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp&gt;\n    inline std::basic_ostream&lt;_Ch, _Tr&gt;&amp;\n    operator&lt;&lt;(std::basic_ostream&lt;_Ch, _Tr&gt;&amp; __os,\n\t       const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __p)\n    {\n      __os &lt;&lt; __p.get();\n      return __os;\n    }\n\n  template&lt;typename _Del, typename _Tp, _Lock_policy _Lp&gt;\n    inline _Del*\n    get_deleter(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __p) noexcept\n    {\n#if __cpp_rtti\n      return static_cast&lt;_Del*&gt;(__p._M_get_deleter(typeid(_Del)));\n#else\n      return 0;\n#endif\n    }\n\n  /// 20.7.2.2.10 shared_ptr get_deleter\n\n  /// If `__p` has a deleter of type `_Del`, return a pointer to it.\n  /// @relates shared_ptr\n  template&lt;typename _Del, typename _Tp&gt;\n    inline _Del*\n    get_deleter(const shared_ptr&lt;_Tp&gt;&amp; __p) noexcept\n    {\n#if __cpp_rtti\n      return static_cast&lt;_Del*&gt;(__p._M_get_deleter(typeid(_Del)));\n#else\n      return 0;\n#endif\n    }\n\n  /**\n   *  @brief  A smart pointer with reference-counted copy semantics.\n   *\n   * A `shared_ptr` object is either empty or _owns_ a pointer passed\n   * to the constructor. Copies of a `shared_ptr` share ownership of\n   * the same pointer. When the last `shared_ptr` that owns the pointer\n   * is destroyed or reset, the owned pointer is freed (either by `delete`\n   * or by invoking a custom deleter that was passed to the constructor).\n   *\n   * A `shared_ptr` also stores another pointer, which is usually\n   * (but not always) the same pointer as it owns. The stored pointer\n   * can be retrieved by calling the `get()` member function.\n   *\n   * The equality and relational operators for `shared_ptr` only compare\n   * the stored pointer returned by `get()`, not the owned pointer.\n   * To test whether two `shared_ptr` objects share ownership of the same\n   * pointer see `std::shared_ptr::owner_before` and `std::owner_less`.\n  */\n  template&lt;typename _Tp&gt;\n    class shared_ptr : public __shared_ptr&lt;_Tp&gt;\n    {\n      template&lt;typename... _Args&gt;\n\tusing _Constructible = typename enable_if&lt;\n\t  is_constructible&lt;__shared_ptr&lt;_Tp&gt;, _Args...&gt;::value\n\t&gt;::type;\n\n      template&lt;typename _Arg&gt;\n\tusing _Assignable = typename enable_if&lt;\n\t  is_assignable&lt;__shared_ptr&lt;_Tp&gt;&amp;, _Arg&gt;::value, shared_ptr&amp;\n\t&gt;::type;\n\n    public:\n\n      /// The type pointed to by the stored pointer, remove_extent_t&lt;_Tp&gt;\n      using element_type = typename __shared_ptr&lt;_Tp&gt;::element_type;\n\n#if __cplusplus &gt;= 201703L\n# define __cpp_lib_shared_ptr_weak_type 201606\n      /// The corresponding weak_ptr type for this shared_ptr\n      using weak_type = weak_ptr&lt;_Tp&gt;;\n#endif\n      /**\n       *  @brief  Construct an empty %shared_ptr.\n       *  @post   use_count()==0 &amp;&amp; get()==0\n       */\n      constexpr shared_ptr() noexcept : __shared_ptr&lt;_Tp&gt;() { }\n\n      shared_ptr(const shared_ptr&amp;) noexcept = default; ///&lt; Copy constructor\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns the pointer @a __p.\n       *  @param  __p  A pointer that is convertible to element_type*.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @c delete @a __p is called.\n       */\n      template&lt;typename _Yp, typename = _Constructible&lt;_Yp*&gt;&gt;\n\texplicit\n\tshared_ptr(_Yp* __p) : __shared_ptr&lt;_Tp&gt;(__p) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns the pointer @a __p\n       *          and the deleter @a __d.\n       *  @param  __p  A pointer.\n       *  @param  __d  A deleter.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw\n       *\n       *  __shared_ptr will release __p by calling __d(__p)\n       */\n      template&lt;typename _Yp, typename _Deleter,\n\t       typename = _Constructible&lt;_Yp*, _Deleter&gt;&gt;\n\tshared_ptr(_Yp* __p, _Deleter __d)\n        : __shared_ptr&lt;_Tp&gt;(__p, std::move(__d)) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns a null pointer\n       *          and the deleter @a __d.\n       *  @param  __p  A null pointer constant.\n       *  @param  __d  A deleter.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw\n       *\n       *  The last owner will call __d(__p)\n       */\n      template&lt;typename _Deleter&gt;\n\tshared_ptr(nullptr_t __p, _Deleter __d)\n        : __shared_ptr&lt;_Tp&gt;(__p, std::move(__d)) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns the pointer @a __p\n       *          and the deleter @a __d.\n       *  @param  __p  A pointer.\n       *  @param  __d  A deleter.\n       *  @param  __a  An allocator.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw _Alloc&#x27;s copy constructor and destructor must not\n       *  throw.\n       *\n       *  __shared_ptr will release __p by calling __d(__p)\n       */\n      template&lt;typename _Yp, typename _Deleter, typename _Alloc,\n\t       typename = _Constructible&lt;_Yp*, _Deleter, _Alloc&gt;&gt;\n\tshared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)\n\t: __shared_ptr&lt;_Tp&gt;(__p, std::move(__d), std::move(__a)) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns a null pointer\n       *          and the deleter @a __d.\n       *  @param  __p  A null pointer constant.\n       *  @param  __d  A deleter.\n       *  @param  __a  An allocator.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw _Alloc&#x27;s copy constructor and destructor must not\n       *  throw.\n       *\n       *  The last owner will call __d(__p)\n       */\n      template&lt;typename _Deleter, typename _Alloc&gt;\n\tshared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)\n\t: __shared_ptr&lt;_Tp&gt;(__p, std::move(__d), std::move(__a)) { }\n\n      // Aliasing constructor\n\n      /**\n       *  @brief  Constructs a `shared_ptr` instance that stores `__p`\n       *          and shares ownership with `__r`.\n       *  @param  __r  A `shared_ptr`.\n       *  @param  __p  A pointer that will remain valid while `*__r` is valid.\n       *  @post   `get() == __p &amp;&amp; use_count() == __r.use_count()`\n       *\n       *  This can be used to construct a `shared_ptr` to a sub-object\n       *  of an object managed by an existing `shared_ptr`. The complete\n       *  object will remain valid while any `shared_ptr` owns it, even\n       *  if they don&#x27;t store a pointer to the complete object.\n       *\n       * @code\n       * shared_ptr&lt;pair&lt;int,int&gt;&gt; pii(new pair&lt;int,int&gt;());\n       * shared_ptr&lt;int&gt; pi(pii, &amp;pii-&gt;first);\n       * assert(pii.use_count() == 2);\n       * @endcode\n       */\n      template&lt;typename _Yp&gt;\n\tshared_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r, element_type* __p) noexcept\n\t: __shared_ptr&lt;_Tp&gt;(__r, __p) { }\n\n#if __cplusplus &gt; 201703L\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2996. Missing rvalue overloads for shared_ptr operations\n      /**\n       *  @brief  Constructs a `shared_ptr` instance that stores `__p`\n       *          and shares ownership with `__r`.\n       *  @param  __r  A `shared_ptr`.\n       *  @param  __p  A pointer that will remain valid while `*__r` is valid.\n       *  @post   `get() == __p &amp;&amp; !__r.use_count() &amp;&amp; !__r.get()`\n       *\n       *  This can be used to construct a `shared_ptr` to a sub-object\n       *  of an object managed by an existing `shared_ptr`. The complete\n       *  object will remain valid while any `shared_ptr` owns it, even\n       *  if they don&#x27;t store a pointer to the complete object.\n       *\n       * @code\n       * shared_ptr&lt;pair&lt;int,int&gt;&gt; pii(new pair&lt;int,int&gt;());\n       * shared_ptr&lt;int&gt; pi1(pii, &amp;pii-&gt;first);\n       * assert(pii.use_count() == 2);\n       * shared_ptr&lt;int&gt; pi2(std::move(pii), &amp;pii-&gt;second);\n       * assert(pii.use_count() == 0);\n       * @endcode\n       */\n      template&lt;typename _Yp&gt;\n\tshared_ptr(shared_ptr&lt;_Yp&gt;&amp;&amp; __r, element_type* __p) noexcept\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r), __p) { }\n#endif\n      /**\n       *  @brief  If @a __r is empty, constructs an empty %shared_ptr;\n       *          otherwise construct a %shared_ptr that shares ownership\n       *          with @a __r.\n       *  @param  __r  A %shared_ptr.\n       *  @post   get() == __r.get() &amp;&amp; use_count() == __r.use_count()\n       */\n      template&lt;typename _Yp,\n\t       typename = _Constructible&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\tshared_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n        : __shared_ptr&lt;_Tp&gt;(__r) { }\n\n      /**\n       *  @brief  Move-constructs a %shared_ptr instance from @a __r.\n       *  @param  __r  A %shared_ptr rvalue.\n       *  @post   *this contains the old value of @a __r, @a __r is empty.\n       */\n      shared_ptr(shared_ptr&amp;&amp; __r) noexcept\n      : __shared_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n      /**\n       *  @brief  Move-constructs a %shared_ptr instance from @a __r.\n       *  @param  __r  A %shared_ptr rvalue.\n       *  @post   *this contains the old value of @a __r, @a __r is empty.\n       */\n      template&lt;typename _Yp, typename = _Constructible&lt;shared_ptr&lt;_Yp&gt;&gt;&gt;\n\tshared_ptr(shared_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n      /**\n       *  @brief  Constructs a %shared_ptr that shares ownership with @a __r\n       *          and stores a copy of the pointer stored in @a __r.\n       *  @param  __r  A weak_ptr.\n       *  @post   use_count() == __r.use_count()\n       *  @throw  bad_weak_ptr when __r.expired(),\n       *          in which case the constructor has no effect.\n       */\n      template&lt;typename _Yp, typename = _Constructible&lt;const weak_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\texplicit shared_ptr(const weak_ptr&lt;_Yp&gt;&amp; __r)\n\t: __shared_ptr&lt;_Tp&gt;(__r) { }\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      template&lt;typename _Yp, typename = _Constructible&lt;auto_ptr&lt;_Yp&gt;&gt;&gt;\n\tshared_ptr(auto_ptr&lt;_Yp&gt;&amp;&amp; __r);\n#pragma GCC diagnostic pop\n#endif\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2399. shared_ptr&#x27;s constructor from unique_ptr should be constrained\n      template&lt;typename _Yp, typename _Del,\n\t       typename = _Constructible&lt;unique_ptr&lt;_Yp, _Del&gt;&gt;&gt;\n\tshared_ptr(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n#if __cplusplus &lt;= 201402L &amp;&amp; _GLIBCXX_USE_DEPRECATED\n      // This non-standard constructor exists to support conversions that\n      // were possible in C++11 and C++14 but are ill-formed in C++17.\n      // If an exception is thrown this constructor has no effect.\n      template&lt;typename _Yp, typename _Del,\n\t\t_Constructible&lt;unique_ptr&lt;_Yp, _Del&gt;, __sp_array_delete&gt;* = 0&gt;\n\tshared_ptr(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r), __sp_array_delete()) { }\n#endif\n\n      /**\n       *  @brief  Construct an empty %shared_ptr.\n       *  @post   use_count() == 0 &amp;&amp; get() == nullptr\n       */\n      constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }\n\n      shared_ptr&amp; operator=(const shared_ptr&amp;) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;\n\toperator=(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(__r);\n\t  return *this;\n\t}\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;auto_ptr&lt;_Yp&gt;&gt;\n\toperator=(auto_ptr&lt;_Yp&gt;&amp;&amp; __r)\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n#pragma GCC diagnostic pop\n#endif\n\n      shared_ptr&amp;\n      operator=(shared_ptr&amp;&amp; __r) noexcept\n      {\n\tthis-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\treturn *this;\n      }\n\n      template&lt;class _Yp&gt;\n\t_Assignable&lt;shared_ptr&lt;_Yp&gt;&gt;\n\toperator=(shared_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp, typename _Del&gt;\n\t_Assignable&lt;unique_ptr&lt;_Yp, _Del&gt;&gt;\n\toperator=(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n\n    private:\n      // This constructor is non-standard, it is used by allocate_shared.\n      template&lt;typename _Alloc, typename... _Args&gt;\n\tshared_ptr(_Sp_alloc_shared_tag&lt;_Alloc&gt; __tag, _Args&amp;&amp;... __args)\n\t: __shared_ptr&lt;_Tp&gt;(__tag, std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n      template&lt;typename _Yp, typename _Alloc, typename... _Args&gt;\n\tfriend shared_ptr&lt;_Yp&gt;\n\tallocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args);\n\n      // This constructor is non-standard, it is used by weak_ptr::lock().\n      shared_ptr(const weak_ptr&lt;_Tp&gt;&amp; __r, std::nothrow_t) noexcept\n      : __shared_ptr&lt;_Tp&gt;(__r, std::nothrow) { }\n\n      friend class weak_ptr&lt;_Tp&gt;;\n    };\n\n#if __cpp_deduction_guides &gt;= 201606\n  template&lt;typename _Tp&gt;\n    shared_ptr(weak_ptr&lt;_Tp&gt;) -&gt;  shared_ptr&lt;_Tp&gt;;\n  template&lt;typename _Tp, typename _Del&gt;\n    shared_ptr(unique_ptr&lt;_Tp, _Del&gt;) -&gt;  shared_ptr&lt;_Tp&gt;;\n#endif\n\n  // 20.7.2.2.7 shared_ptr comparisons\n\n  /// @relates shared_ptr @{\n\n  /// Equality operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator==(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return __a.get() == __b.get(); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator==(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return !__a; }\n\n#ifdef __cpp_lib_three_way_comparison\n  template&lt;typename _Tp, typename _Up&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a,\n\t\tconst shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return compare_three_way()(__a.get(), __b.get()); }\n\n  template&lt;typename _Tp&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using pointer = typename shared_ptr&lt;_Tp&gt;::element_type*;\n      return compare_three_way()(__a.get(), static_cast&lt;pointer&gt;(nullptr));\n    }\n#else\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator==(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return !__a; }\n\n  /// Inequality operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator!=(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return __a.get() != __b.get(); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator!=(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return (bool)__a; }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator!=(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return (bool)__a; }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    {\n      using _Tp_elt = typename shared_ptr&lt;_Tp&gt;::element_type;\n      using _Up_elt = typename shared_ptr&lt;_Up&gt;::element_type;\n      using _Vp = typename common_type&lt;_Tp_elt*, _Up_elt*&gt;::type;\n      return less&lt;_Vp&gt;()(__a.get(), __b.get());\n    }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using _Tp_elt = typename shared_ptr&lt;_Tp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(__a.get(), nullptr);\n    }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    {\n      using _Tp_elt = typename shared_ptr&lt;_Tp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(nullptr, __a.get());\n    }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return !(__b &lt; __a); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(nullptr &lt; __a); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;=(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return !(__a &lt; nullptr); }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return (__b &lt; __a); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return nullptr &lt; __a; }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return __a &lt; nullptr; }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return !(__a &lt; __b); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(__a &lt; nullptr); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;=(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return !(nullptr &lt; __a); }\n#endif\n\n  // 20.7.2.2.8 shared_ptr specialized algorithms.\n\n  /// Swap overload for shared_ptr\n  template&lt;typename _Tp&gt;\n    inline void\n    swap(shared_ptr&lt;_Tp&gt;&amp; __a, shared_ptr&lt;_Tp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n  // 20.7.2.2.9 shared_ptr casts.\n\n  /// Convert type of `shared_ptr`, via `static_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    static_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(__r, static_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr`, via `const_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    const_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(__r, const_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr`, via `dynamic_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    dynamic_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      if (auto* __p = dynamic_cast&lt;typename _Sp::element_type*&gt;(__r.get()))\n\treturn _Sp(__r, __p);\n      return _Sp();\n    }\n\n#if __cplusplus &gt;= 201703L\n  /// Convert type of `shared_ptr`, via `reinterpret_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    reinterpret_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(__r, reinterpret_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n#if __cplusplus &gt; 201703L\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 2996. Missing rvalue overloads for shared_ptr operations\n\n  /// Convert type of `shared_ptr` rvalue, via `static_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    static_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(std::move(__r),\n\t\t static_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr` rvalue, via `const_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    const_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(std::move(__r),\n\t\t const_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr` rvalue, via `dynamic_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    dynamic_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      if (auto* __p = dynamic_cast&lt;typename _Sp::element_type*&gt;(__r.get()))\n\treturn _Sp(std::move(__r), __p);\n      return _Sp();\n    }\n\n  /// Convert type of `shared_ptr` rvalue, via `reinterpret_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    reinterpret_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(std::move(__r),\n\t\t reinterpret_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n#endif // C++20\n#endif // C++17\n\n  /// @}\n\n  /**\n   * @brief  A non-owning observer for a pointer owned by a shared_ptr\n   *\n   * A weak_ptr provides a safe alternative to a raw pointer when you want\n   * a non-owning reference to an object that is managed by a shared_ptr.\n   *\n   * Unlike a raw pointer, a weak_ptr can be converted to a new shared_ptr\n   * that shares ownership with every other shared_ptr that already owns\n   * the pointer. In other words you can upgrade from a non-owning &quot;weak&quot;\n   * reference to an owning shared_ptr, without having access to any of\n   * the existing shared_ptr objects.\n   *\n   * Also unlike a raw pointer, a weak_ptr does not become &quot;dangling&quot; after\n   * the object it points to has been destroyed. Instead, a weak_ptr\n   * becomes _expired_ and can no longer be converted to a shared_ptr that\n   * owns the freed pointer, so you cannot accidentally access the pointed-to\n   * object after it has been destroyed.\n   */\n  template&lt;typename _Tp&gt;\n    class weak_ptr : public __weak_ptr&lt;_Tp&gt;\n    {\n      template&lt;typename _Arg&gt;\n\tusing _Constructible = typename enable_if&lt;\n\t  is_constructible&lt;__weak_ptr&lt;_Tp&gt;, _Arg&gt;::value\n\t&gt;::type;\n\n      template&lt;typename _Arg&gt;\n\tusing _Assignable = typename enable_if&lt;\n\t  is_assignable&lt;__weak_ptr&lt;_Tp&gt;&amp;, _Arg&gt;::value, weak_ptr&amp;\n\t&gt;::type;\n\n    public:\n      constexpr weak_ptr() noexcept = default;\n\n      template&lt;typename _Yp,\n\t       typename = _Constructible&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\tweak_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t: __weak_ptr&lt;_Tp&gt;(__r) { }\n\n      weak_ptr(const weak_ptr&amp;) noexcept = default;\n\n      template&lt;typename _Yp, typename = _Constructible&lt;const weak_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\tweak_ptr(const weak_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t: __weak_ptr&lt;_Tp&gt;(__r) { }\n\n      weak_ptr(weak_ptr&amp;&amp;) noexcept = default;\n\n      template&lt;typename _Yp, typename = _Constructible&lt;weak_ptr&lt;_Yp&gt;&gt;&gt;\n\tweak_ptr(weak_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t: __weak_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n      weak_ptr&amp;\n      operator=(const weak_ptr&amp; __r) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;const weak_ptr&lt;_Yp&gt;&amp;&gt;\n\toperator=(const weak_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t{\n\t  this-&gt;__weak_ptr&lt;_Tp&gt;::operator=(__r);\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;\n\toperator=(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t{\n\t  this-&gt;__weak_ptr&lt;_Tp&gt;::operator=(__r);\n\t  return *this;\n\t}\n\n      weak_ptr&amp;\n      operator=(weak_ptr&amp;&amp; __r) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;weak_ptr&lt;_Yp&gt;&gt;\n\toperator=(weak_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  this-&gt;__weak_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n\n      shared_ptr&lt;_Tp&gt;\n      lock() const noexcept\n      { return shared_ptr&lt;_Tp&gt;(*this, std::nothrow); }\n    };\n\n#if __cpp_deduction_guides &gt;= 201606\n  template&lt;typename _Tp&gt;\n    weak_ptr(shared_ptr&lt;_Tp&gt;) -&gt;  weak_ptr&lt;_Tp&gt;;\n#endif\n\n  // 20.7.2.3.6 weak_ptr specialized algorithms.\n  /// Swap overload for weak_ptr\n  /// @relates weak_ptr\n  template&lt;typename _Tp&gt;\n    inline void\n    swap(weak_ptr&lt;_Tp&gt;&amp; __a, weak_ptr&lt;_Tp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n\n  /// Primary template owner_less\n  template&lt;typename _Tp = void&gt;\n    struct owner_less;\n\n  /// Void specialization of owner_less compares either shared_ptr or weak_ptr\n  template&lt;&gt;\n    struct owner_less&lt;void&gt; : _Sp_owner_less&lt;void, void&gt;\n    { };\n\n  /// Partial specialization of owner_less for shared_ptr.\n  template&lt;typename _Tp&gt;\n    struct owner_less&lt;shared_ptr&lt;_Tp&gt;&gt;\n    : public _Sp_owner_less&lt;shared_ptr&lt;_Tp&gt;, weak_ptr&lt;_Tp&gt;&gt;\n    { };\n\n  /// Partial specialization of owner_less for weak_ptr.\n  template&lt;typename _Tp&gt;\n    struct owner_less&lt;weak_ptr&lt;_Tp&gt;&gt;\n    : public _Sp_owner_less&lt;weak_ptr&lt;_Tp&gt;, shared_ptr&lt;_Tp&gt;&gt;\n    { };\n\n  /**\n   *  @brief Base class allowing use of member function shared_from_this.\n   */\n  template&lt;typename _Tp&gt;\n    class enable_shared_from_this\n    {\n    protected:\n      constexpr enable_shared_from_this() noexcept { }\n\n      enable_shared_from_this(const enable_shared_from_this&amp;) noexcept { }\n\n      enable_shared_from_this&amp;\n      operator=(const enable_shared_from_this&amp;) noexcept\n      { return *this; }\n\n      ~enable_shared_from_this() { }\n\n    public:\n      shared_ptr&lt;_Tp&gt;\n      shared_from_this()\n      { return shared_ptr&lt;_Tp&gt;(this-&gt;_M_weak_this); }\n\n      shared_ptr&lt;const _Tp&gt;\n      shared_from_this() const\n      { return shared_ptr&lt;const _Tp&gt;(this-&gt;_M_weak_this); }\n\n#if __cplusplus &gt; 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n#define __cpp_lib_enable_shared_from_this 201603\n      weak_ptr&lt;_Tp&gt;\n      weak_from_this() noexcept\n      { return this-&gt;_M_weak_this; }\n\n      weak_ptr&lt;const _Tp&gt;\n      weak_from_this() const noexcept\n      { return this-&gt;_M_weak_this; }\n#endif\n\n    private:\n      template&lt;typename _Tp1&gt;\n\tvoid\n\t_M_weak_assign(_Tp1* __p, const __shared_count&lt;&gt;&amp; __n) const noexcept\n\t{ _M_weak_this._M_assign(__p, __n); }\n\n      // Found by ADL when this is an associated class.\n      friend const enable_shared_from_this*\n      __enable_shared_from_this_base(const __shared_count&lt;&gt;&amp;,\n\t\t\t\t     const enable_shared_from_this* __p)\n      { return __p; }\n\n      template&lt;typename, _Lock_policy&gt;\n\tfriend class __shared_ptr;\n\n      mutable weak_ptr&lt;_Tp&gt;  _M_weak_this;\n    };\n\n  /// @relates shared_ptr @{\n\n  /**\n   *  @brief  Create an object that is owned by a shared_ptr.\n   *  @param  __a     An allocator.\n   *  @param  __args  Arguments for the @a _Tp object&#x27;s constructor.\n   *  @return A shared_ptr that owns the newly created object.\n   *  @throw  An exception thrown from @a _Alloc::allocate or from the\n   *          constructor of @a _Tp.\n   *\n   *  A copy of @a __a will be used to allocate memory for the shared_ptr\n   *  and the new object.\n   */\n  template&lt;typename _Tp, typename _Alloc, typename... _Args&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args)\n    {\n      static_assert(!is_array&lt;_Tp&gt;::value, &quot;make_shared&lt;T[]&gt; not supported&quot;);\n\n      return shared_ptr&lt;_Tp&gt;(_Sp_alloc_shared_tag&lt;_Alloc&gt;{__a},\n\t\t\t     std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  /**\n   *  @brief  Create an object that is owned by a shared_ptr.\n   *  @param  __args  Arguments for the @a _Tp object&#x27;s constructor.\n   *  @return A shared_ptr that owns the newly created object.\n   *  @throw  std::bad_alloc, or an exception thrown from the\n   *          constructor of @a _Tp.\n   */\n  template&lt;typename _Tp, typename... _Args&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    make_shared(_Args&amp;&amp;... __args)\n    {\n      typedef typename std::remove_cv&lt;_Tp&gt;::type _Tp_nc;\n      return std::allocate_shared&lt;_Tp&gt;(std::allocator&lt;_Tp_nc&gt;(),\n\t\t\t\t       std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  /// std::hash specialization for shared_ptr.\n  template&lt;typename _Tp&gt;\n    struct hash&lt;shared_ptr&lt;_Tp&gt;&gt;\n    : public __hash_base&lt;size_t, shared_ptr&lt;_Tp&gt;&gt;\n    {\n      size_t\n      operator()(const shared_ptr&lt;_Tp&gt;&amp; __s) const noexcept\n      {\n\treturn std::hash&lt;typename shared_ptr&lt;_Tp&gt;::element_type*&gt;()(__s.get());\n      }\n    };\n\n  /// @} relates shared_ptr\n  /// @} group pointer_abstractions\n\n#if __cplusplus &gt;= 201703L\n  namespace __detail::__variant\n  {\n    template&lt;typename&gt; struct _Never_valueless_alt; // see &lt;variant&gt;\n\n    // Provide the strong exception-safety guarantee when emplacing a\n    // shared_ptr into a variant.\n    template&lt;typename _Tp&gt;\n      struct _Never_valueless_alt&lt;std::shared_ptr&lt;_Tp&gt;&gt;\n      : std::true_type\n      { };\n\n    // Provide the strong exception-safety guarantee when emplacing a\n    // weak_ptr into a variant.\n    template&lt;typename _Tp&gt;\n      struct _Never_valueless_alt&lt;std::weak_ptr&lt;_Tp&gt;&gt;\n      : std::true_type\n      { };\n  }  // namespace __detail::__variant\n#endif // C++17\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif // _SHARED_PTR_H\n"}, "/usr/include/c++/11/bits/shared_ptr_base.h": {"id": "/usr/include/c++/11/bits/shared_ptr_base.h", "filePath": "/usr/include/c++/11/bits/shared_ptr_base.h", "content": "// shared_ptr and weak_ptr implementation details -*- C++ -*-\n\n// Copyright (C) 2007-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n// GCC Note: Based on files from version 1.32.0 of the Boost library.\n\n//  shared_count.hpp\n//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n\n//  shared_ptr.hpp\n//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  weak_ptr.hpp\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  enable_shared_from_this.hpp\n//  Copyright (C) 2002 Peter Dimov\n\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n\n/** @file bits/shared_ptr_base.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _SHARED_PTR_BASE_H\n#define _SHARED_PTR_BASE_H 1\n\n#include &lt;typeinfo&gt;\n#include &lt;bits/allocated_ptr.h&gt;\n#include &lt;bits/allocator.h&gt;\n#include &lt;bits/exception_defines.h&gt;\n#include &lt;bits/functional_hash.h&gt;\n#include &lt;bits/refwrap.h&gt;\n#include &lt;bits/stl_function.h&gt;  // std::less\n#include &lt;bits/unique_ptr.h&gt;\n#include &lt;ext/aligned_buffer.h&gt;\n#include &lt;ext/atomicity.h&gt;\n#include &lt;ext/concurrence.h&gt;\n#if __cplusplus &gt; 201703L\n# include &lt;compare&gt;\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n  template&lt;typename&gt; class auto_ptr;\n#pragma GCC diagnostic pop\n#endif\n\n /**\n   *  @brief  Exception possibly thrown by @c shared_ptr.\n   *  @ingroup exceptions\n   */\n  class bad_weak_ptr : public std::exception\n  {\n  public:\n    virtual char const* what() const noexcept;\n\n    virtual ~bad_weak_ptr() noexcept;\n  };\n\n  // Substitute for bad_weak_ptr object in the case of -fno-exceptions.\n  inline void\n  __throw_bad_weak_ptr()\n  { _GLIBCXX_THROW_OR_ABORT(bad_weak_ptr()); }\n\n  using __gnu_cxx::_Lock_policy;\n  using __gnu_cxx::__default_lock_policy;\n  using __gnu_cxx::_S_single;\n  using __gnu_cxx::_S_mutex;\n  using __gnu_cxx::_S_atomic;\n\n  // Empty helper class except when the template argument is _S_mutex.\n  template&lt;_Lock_policy _Lp&gt;\n    class _Mutex_base\n    {\n    protected:\n      // The atomic policy uses fully-fenced builtins, single doesn&#x27;t care.\n      enum { _S_need_barriers = 0 };\n    };\n\n  template&lt;&gt;\n    class _Mutex_base&lt;_S_mutex&gt;\n    : public __gnu_cxx::__mutex\n    {\n    protected:\n      // This policy is used when atomic builtins are not available.\n      // The replacement atomic operations might not have the necessary\n      // memory barriers.\n      enum { _S_need_barriers = 1 };\n    };\n\n  template&lt;_Lock_policy _Lp = __default_lock_policy&gt;\n    class _Sp_counted_base\n    : public _Mutex_base&lt;_Lp&gt;\n    {\n    public:\n      _Sp_counted_base() noexcept\n      : _M_use_count(1), _M_weak_count(1) { }\n\n      virtual\n      ~_Sp_counted_base() noexcept\n      { }\n\n      // Called when _M_use_count drops to zero, to release the resources\n      // managed by *this.\n      virtual void\n      _M_dispose() noexcept = 0;\n\n      // Called when _M_weak_count drops to zero.\n      virtual void\n      _M_destroy() noexcept\n      { delete this; }\n\n      virtual void*\n      _M_get_deleter(const std::type_info&amp;) noexcept = 0;\n\n      void\n      _M_add_ref_copy()\n      { __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, 1); }\n\n      void\n      _M_add_ref_lock()\n      {\n\tif (!_M_add_ref_lock_nothrow())\n\t  __throw_bad_weak_ptr();\n      }\n\n      bool\n      _M_add_ref_lock_nothrow() noexcept;\n\n      void\n      _M_release() noexcept\n      {\n        // Be race-detector-friendly.  For more info see bits/c++config.\n        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);\n\tif (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, -1) == 1)\n\t  {\n            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);\n\t    _M_dispose();\n\t    // There must be a memory barrier between dispose() and destroy()\n\t    // to ensure that the effects of dispose() are observed in the\n\t    // thread that runs destroy().\n\t    // See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html\n\t    if (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)\n\t      {\n\t\t__atomic_thread_fence (__ATOMIC_ACQ_REL);\n\t      }\n\n            // Be race-detector-friendly.  For more info see bits/c++config.\n            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);\n\t    if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count,\n\t\t\t\t\t\t       -1) == 1)\n              {\n                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);\n\t        _M_destroy();\n              }\n\t  }\n      }\n\n      void\n      _M_weak_add_ref() noexcept\n      { __gnu_cxx::__atomic_add_dispatch(&amp;_M_weak_count, 1); }\n\n      void\n      _M_weak_release() noexcept\n      {\n        // Be race-detector-friendly. For more info see bits/c++config.\n        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);\n\tif (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, -1) == 1)\n\t  {\n            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);\n\t    if (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)\n\t      {\n\t        // See _M_release(),\n\t        // destroy() must observe results of dispose()\n\t\t__atomic_thread_fence (__ATOMIC_ACQ_REL);\n\t      }\n\t    _M_destroy();\n\t  }\n      }\n\n      long\n      _M_get_use_count() const noexcept\n      {\n        // No memory barrier is used here so there is no synchronization\n        // with other threads.\n        return __atomic_load_n(&amp;_M_use_count, __ATOMIC_RELAXED);\n      }\n\n    private:\n      _Sp_counted_base(_Sp_counted_base const&amp;) = delete;\n      _Sp_counted_base&amp; operator=(_Sp_counted_base const&amp;) = delete;\n\n      _Atomic_word  _M_use_count;     // #shared\n      _Atomic_word  _M_weak_count;    // #weak + (#shared != 0)\n    };\n\n  template&lt;&gt;\n    inline bool\n    _Sp_counted_base&lt;_S_single&gt;::\n    _M_add_ref_lock_nothrow() noexcept\n    {\n      if (_M_use_count == 0)\n\treturn false;\n      ++_M_use_count;\n      return true;\n    }\n\n  template&lt;&gt;\n    inline bool\n    _Sp_counted_base&lt;_S_mutex&gt;::\n    _M_add_ref_lock_nothrow() noexcept\n    {\n      __gnu_cxx::__scoped_lock sentry(*this);\n      if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, 1) == 0)\n\t{\n\t  _M_use_count = 0;\n\t  return false;\n\t}\n      return true;\n    }\n\n  template&lt;&gt;\n    inline bool\n    _Sp_counted_base&lt;_S_atomic&gt;::\n    _M_add_ref_lock_nothrow() noexcept\n    {\n      // Perform lock-free add-if-not-zero operation.\n      _Atomic_word __count = _M_get_use_count();\n      do\n\t{\n\t  if (__count == 0)\n\t    return false;\n\t  // Replace the current counter value with the old value + 1, as\n\t  // long as it&#x27;s not changed meanwhile.\n\t}\n      while (!__atomic_compare_exchange_n(&amp;_M_use_count, &amp;__count, __count + 1,\n\t\t\t\t\t  true, __ATOMIC_ACQ_REL,\n\t\t\t\t\t  __ATOMIC_RELAXED));\n      return true;\n    }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_add_ref_copy()\n    { ++_M_use_count; }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_release() noexcept\n    {\n      if (--_M_use_count == 0)\n        {\n          _M_dispose();\n          if (--_M_weak_count == 0)\n            _M_destroy();\n        }\n    }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_weak_add_ref() noexcept\n    { ++_M_weak_count; }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_weak_release() noexcept\n    {\n      if (--_M_weak_count == 0)\n        _M_destroy();\n    }\n\n  template&lt;&gt;\n    inline long\n    _Sp_counted_base&lt;_S_single&gt;::_M_get_use_count() const noexcept\n    { return _M_use_count; }\n\n\n  // Forward declarations.\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy&gt;\n    class __shared_ptr;\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy&gt;\n    class __weak_ptr;\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy&gt;\n    class __enable_shared_from_this;\n\n  template&lt;typename _Tp&gt;\n    class shared_ptr;\n\n  template&lt;typename _Tp&gt;\n    class weak_ptr;\n\n  template&lt;typename _Tp&gt;\n    struct owner_less;\n\n  template&lt;typename _Tp&gt;\n    class enable_shared_from_this;\n\n  template&lt;_Lock_policy _Lp = __default_lock_policy&gt;\n    class __weak_count;\n\n  template&lt;_Lock_policy _Lp = __default_lock_policy&gt;\n    class __shared_count;\n\n\n  // Counted ptr with no deleter or allocator support\n  template&lt;typename _Ptr, _Lock_policy _Lp&gt;\n    class _Sp_counted_ptr final : public _Sp_counted_base&lt;_Lp&gt;\n    {\n    public:\n      explicit\n      _Sp_counted_ptr(_Ptr __p) noexcept\n      : _M_ptr(__p) { }\n\n      virtual void\n      _M_dispose() noexcept\n      { delete _M_ptr; }\n\n      virtual void\n      _M_destroy() noexcept\n      { delete this; }\n\n      virtual void*\n      _M_get_deleter(const std::type_info&amp;) noexcept\n      { return nullptr; }\n\n      _Sp_counted_ptr(const _Sp_counted_ptr&amp;) = delete;\n      _Sp_counted_ptr&amp; operator=(const _Sp_counted_ptr&amp;) = delete;\n\n    private:\n      _Ptr             _M_ptr;\n    };\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_ptr&lt;nullptr_t, _S_single&gt;::_M_dispose() noexcept { }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_ptr&lt;nullptr_t, _S_mutex&gt;::_M_dispose() noexcept { }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_ptr&lt;nullptr_t, _S_atomic&gt;::_M_dispose() noexcept { }\n\n  template&lt;int _Nm, typename _Tp,\n\t   bool __use_ebo = !__is_final(_Tp) &amp;&amp; __is_empty(_Tp)&gt;\n    struct _Sp_ebo_helper;\n\n  /// Specialization using EBO.\n  template&lt;int _Nm, typename _Tp&gt;\n    struct _Sp_ebo_helper&lt;_Nm, _Tp, true&gt; : private _Tp\n    {\n      explicit _Sp_ebo_helper(const _Tp&amp; __tp) : _Tp(__tp) { }\n      explicit _Sp_ebo_helper(_Tp&amp;&amp; __tp) : _Tp(std::move(__tp)) { }\n\n      static _Tp&amp;\n      _S_get(_Sp_ebo_helper&amp; __eboh) { return static_cast&lt;_Tp&amp;&gt;(__eboh); }\n    };\n\n  /// Specialization not using EBO.\n  template&lt;int _Nm, typename _Tp&gt;\n    struct _Sp_ebo_helper&lt;_Nm, _Tp, false&gt;\n    {\n      explicit _Sp_ebo_helper(const _Tp&amp; __tp) : _M_tp(__tp) { }\n      explicit _Sp_ebo_helper(_Tp&amp;&amp; __tp) : _M_tp(std::move(__tp)) { }\n\n      static _Tp&amp;\n      _S_get(_Sp_ebo_helper&amp; __eboh)\n      { return __eboh._M_tp; }\n\n    private:\n      _Tp _M_tp;\n    };\n\n  // Support for custom deleter and/or allocator\n  template&lt;typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp&gt;\n    class _Sp_counted_deleter final : public _Sp_counted_base&lt;_Lp&gt;\n    {\n      class _Impl : _Sp_ebo_helper&lt;0, _Deleter&gt;, _Sp_ebo_helper&lt;1, _Alloc&gt;\n      {\n\ttypedef _Sp_ebo_helper&lt;0, _Deleter&gt;\t_Del_base;\n\ttypedef _Sp_ebo_helper&lt;1, _Alloc&gt;\t_Alloc_base;\n\n      public:\n\t_Impl(_Ptr __p, _Deleter __d, const _Alloc&amp; __a) noexcept\n\t: _Del_base(std::move(__d)), _Alloc_base(__a), _M_ptr(__p)\n\t{ }\n\n\t_Deleter&amp; _M_del() noexcept { return _Del_base::_S_get(*this); }\n\t_Alloc&amp; _M_alloc() noexcept { return _Alloc_base::_S_get(*this); }\n\n\t_Ptr _M_ptr;\n      };\n\n    public:\n      using __allocator_type = __alloc_rebind&lt;_Alloc, _Sp_counted_deleter&gt;;\n\n      // __d(__p) must not throw.\n      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept\n      : _M_impl(__p, std::move(__d), _Alloc()) { }\n\n      // __d(__p) must not throw.\n      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc&amp; __a) noexcept\n      : _M_impl(__p, std::move(__d), __a) { }\n\n      ~_Sp_counted_deleter() noexcept { }\n\n      virtual void\n      _M_dispose() noexcept\n      { _M_impl._M_del()(_M_impl._M_ptr); }\n\n      virtual void\n      _M_destroy() noexcept\n      {\n\t__allocator_type __a(_M_impl._M_alloc());\n\t__allocated_ptr&lt;__allocator_type&gt; __guard_ptr{ __a, this };\n\tthis-&gt;~_Sp_counted_deleter();\n      }\n\n      virtual void*\n      _M_get_deleter(const type_info&amp; __ti [[__gnu__::__unused__]]) noexcept\n      {\n#if __cpp_rtti\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// 2400. shared_ptr&#x27;s get_deleter() should use addressof()\n        return __ti == typeid(_Deleter)\n\t  ? std::__addressof(_M_impl._M_del())\n\t  : nullptr;\n#else\n        return nullptr;\n#endif\n      }\n\n    private:\n      _Impl _M_impl;\n    };\n\n  // helpers for make_shared / allocate_shared\n\n  struct _Sp_make_shared_tag\n  {\n  private:\n    template&lt;typename _Tp, typename _Alloc, _Lock_policy _Lp&gt;\n      friend class _Sp_counted_ptr_inplace;\n\n    static const type_info&amp;\n    _S_ti() noexcept _GLIBCXX_VISIBILITY(default)\n    {\n      alignas(type_info) static constexpr char __tag[sizeof(type_info)] = { };\n      return reinterpret_cast&lt;const type_info&amp;&gt;(__tag);\n    }\n\n    static bool _S_eq(const type_info&amp;) noexcept;\n  };\n\n  template&lt;typename _Alloc&gt;\n    struct _Sp_alloc_shared_tag\n    {\n      const _Alloc&amp; _M_a;\n    };\n\n  template&lt;typename _Tp, typename _Alloc, _Lock_policy _Lp&gt;\n    class _Sp_counted_ptr_inplace final : public _Sp_counted_base&lt;_Lp&gt;\n    {\n      class _Impl : _Sp_ebo_helper&lt;0, _Alloc&gt;\n      {\n\ttypedef _Sp_ebo_helper&lt;0, _Alloc&gt;\t_A_base;\n\n      public:\n\texplicit _Impl(_Alloc __a) noexcept : _A_base(__a) { }\n\n\t_Alloc&amp; _M_alloc() noexcept { return _A_base::_S_get(*this); }\n\n\t__gnu_cxx::__aligned_buffer&lt;_Tp&gt; _M_storage;\n      };\n\n    public:\n      using __allocator_type = __alloc_rebind&lt;_Alloc, _Sp_counted_ptr_inplace&gt;;\n\n      // Alloc parameter is not a reference so doesn&#x27;t alias anything in __args\n      template&lt;typename... _Args&gt;\n\t_Sp_counted_ptr_inplace(_Alloc __a, _Args&amp;&amp;... __args)\n\t: _M_impl(__a)\n\t{\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 2070.  allocate_shared should use allocator_traits&lt;A&gt;::construct\n\t  allocator_traits&lt;_Alloc&gt;::construct(__a, _M_ptr(),\n\t      std::forward&lt;_Args&gt;(__args)...); // might throw\n\t}\n\n      ~_Sp_counted_ptr_inplace() noexcept { }\n\n      virtual void\n      _M_dispose() noexcept\n      {\n\tallocator_traits&lt;_Alloc&gt;::destroy(_M_impl._M_alloc(), _M_ptr());\n      }\n\n      // Override because the allocator needs to know the dynamic type\n      virtual void\n      _M_destroy() noexcept\n      {\n\t__allocator_type __a(_M_impl._M_alloc());\n\t__allocated_ptr&lt;__allocator_type&gt; __guard_ptr{ __a, this };\n\tthis-&gt;~_Sp_counted_ptr_inplace();\n      }\n\n    private:\n      friend class __shared_count&lt;_Lp&gt;; // To be able to call _M_ptr().\n\n      // No longer used, but code compiled against old libstdc++ headers\n      // might still call it from __shared_ptr ctor to get the pointer out.\n      virtual void*\n      _M_get_deleter(const std::type_info&amp; __ti) noexcept override\n      {\n\tauto __ptr = const_cast&lt;typename remove_cv&lt;_Tp&gt;::type*&gt;(_M_ptr());\n\t// Check for the fake type_info first, so we don&#x27;t try to access it\n\t// as a real type_info object. Otherwise, check if it&#x27;s the real\n\t// type_info for this class. With RTTI enabled we can check directly,\n\t// or call a library function to do it.\n\tif (&amp;__ti == &amp;_Sp_make_shared_tag::_S_ti()\n\t    ||\n#if __cpp_rtti\n\t    __ti == typeid(_Sp_make_shared_tag)\n#else\n\t    _Sp_make_shared_tag::_S_eq(__ti)\n#endif\n\t   )\n\t  return __ptr;\n\treturn nullptr;\n      }\n\n      _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }\n\n      _Impl _M_impl;\n    };\n\n  // The default deleter for shared_ptr&lt;T[]&gt; and shared_ptr&lt;T[N]&gt;.\n  struct __sp_array_delete\n  {\n    template&lt;typename _Yp&gt;\n      void operator()(_Yp* __p) const { delete[] __p; }\n  };\n\n  template&lt;_Lock_policy _Lp&gt;\n    class __shared_count\n    {\n      template&lt;typename _Tp&gt;\n\tstruct __not_alloc_shared_tag { using type = void; };\n\n      template&lt;typename _Tp&gt;\n\tstruct __not_alloc_shared_tag&lt;_Sp_alloc_shared_tag&lt;_Tp&gt;&gt; { };\n\n    public:\n      constexpr __shared_count() noexcept : _M_pi(0)\n      { }\n\n      template&lt;typename _Ptr&gt;\n        explicit\n\t__shared_count(_Ptr __p) : _M_pi(0)\n\t{\n\t  __try\n\t    {\n\t      _M_pi = new _Sp_counted_ptr&lt;_Ptr, _Lp&gt;(__p);\n\t    }\n\t  __catch(...)\n\t    {\n\t      delete __p;\n\t      __throw_exception_again;\n\t    }\n\t}\n\n      template&lt;typename _Ptr&gt;\n\t__shared_count(_Ptr __p, /* is_array = */ false_type)\n\t: __shared_count(__p)\n\t{ }\n\n      template&lt;typename _Ptr&gt;\n\t__shared_count(_Ptr __p, /* is_array = */ true_type)\n\t: __shared_count(__p, __sp_array_delete{}, allocator&lt;void&gt;())\n\t{ }\n\n      template&lt;typename _Ptr, typename _Deleter,\n\t       typename = typename __not_alloc_shared_tag&lt;_Deleter&gt;::type&gt;\n\t__shared_count(_Ptr __p, _Deleter __d)\n\t: __shared_count(__p, std::move(__d), allocator&lt;void&gt;())\n\t{ }\n\n      template&lt;typename _Ptr, typename _Deleter, typename _Alloc,\n\t       typename = typename __not_alloc_shared_tag&lt;_Deleter&gt;::type&gt;\n\t__shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)\n\t{\n\t  typedef _Sp_counted_deleter&lt;_Ptr, _Deleter, _Alloc, _Lp&gt; _Sp_cd_type;\n\t  __try\n\t    {\n\t      typename _Sp_cd_type::__allocator_type __a2(__a);\n\t      auto __guard = std::__allocate_guarded(__a2);\n\t      _Sp_cd_type* __mem = __guard.get();\n\t      ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));\n\t      _M_pi = __mem;\n\t      __guard = nullptr;\n\t    }\n\t  __catch(...)\n\t    {\n\t      __d(__p); // Call _Deleter on __p.\n\t      __throw_exception_again;\n\t    }\n\t}\n\n      template&lt;typename _Tp, typename _Alloc, typename... _Args&gt;\n\t__shared_count(_Tp*&amp; __p, _Sp_alloc_shared_tag&lt;_Alloc&gt; __a,\n\t\t       _Args&amp;&amp;... __args)\n\t{\n\t  typedef _Sp_counted_ptr_inplace&lt;_Tp, _Alloc, _Lp&gt; _Sp_cp_type;\n\t  typename _Sp_cp_type::__allocator_type __a2(__a._M_a);\n\t  auto __guard = std::__allocate_guarded(__a2);\n\t  _Sp_cp_type* __mem = __guard.get();\n\t  auto __pi = ::new (__mem)\n\t    _Sp_cp_type(__a._M_a, std::forward&lt;_Args&gt;(__args)...);\n\t  __guard = nullptr;\n\t  _M_pi = __pi;\n\t  __p = __pi-&gt;_M_ptr();\n\t}\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      // Special case for auto_ptr&lt;_Tp&gt; to provide the strong guarantee.\n      template&lt;typename _Tp&gt;\n        explicit\n\t__shared_count(std::auto_ptr&lt;_Tp&gt;&amp;&amp; __r);\n#pragma GCC diagnostic pop\n#endif\n\n      // Special case for unique_ptr&lt;_Tp,_Del&gt; to provide the strong guarantee.\n      template&lt;typename _Tp, typename _Del&gt;\n        explicit\n\t__shared_count(std::unique_ptr&lt;_Tp, _Del&gt;&amp;&amp; __r) : _M_pi(0)\n\t{\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 2415. Inconsistency between unique_ptr and shared_ptr\n\t  if (__r.get() == nullptr)\n\t    return;\n\n\t  using _Ptr = typename unique_ptr&lt;_Tp, _Del&gt;::pointer;\n\t  using _Del2 = typename conditional&lt;is_reference&lt;_Del&gt;::value,\n\t      reference_wrapper&lt;typename remove_reference&lt;_Del&gt;::type&gt;,\n\t      _Del&gt;::type;\n\t  using _Sp_cd_type\n\t    = _Sp_counted_deleter&lt;_Ptr, _Del2, allocator&lt;void&gt;, _Lp&gt;;\n\t  using _Alloc = allocator&lt;_Sp_cd_type&gt;;\n\t  using _Alloc_traits = allocator_traits&lt;_Alloc&gt;;\n\t  _Alloc __a;\n\t  _Sp_cd_type* __mem = _Alloc_traits::allocate(__a, 1);\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 3548. shared_ptr construction from unique_ptr should move\n\t  // (not copy) the deleter\n\t  _Alloc_traits::construct(__a, __mem, __r.release(),\n\t\t\t\t   std::forward&lt;_Del&gt;(__r.get_deleter()));\n\t  _M_pi = __mem;\n\t}\n\n      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.\n      explicit __shared_count(const __weak_count&lt;_Lp&gt;&amp; __r);\n\n      // Does not throw if __r._M_get_use_count() == 0, caller must check.\n      explicit\n      __shared_count(const __weak_count&lt;_Lp&gt;&amp; __r, std::nothrow_t) noexcept;\n\n      ~__shared_count() noexcept\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_release();\n      }\n\n      __shared_count(const __shared_count&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_add_ref_copy();\n      }\n\n      __shared_count&amp;\n      operator=(const __shared_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\tif (__tmp != _M_pi)\n\t  {\n\t    if (__tmp != nullptr)\n\t      __tmp-&gt;_M_add_ref_copy();\n\t    if (_M_pi != nullptr)\n\t      _M_pi-&gt;_M_release();\n\t    _M_pi = __tmp;\n\t  }\n\treturn *this;\n      }\n\n      void\n      _M_swap(__shared_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\t__r._M_pi = _M_pi;\n\t_M_pi = __tmp;\n      }\n\n      long\n      _M_get_use_count() const noexcept\n      { return _M_pi ? _M_pi-&gt;_M_get_use_count() : 0; }\n\n      bool\n      _M_unique() const noexcept\n      { return this-&gt;_M_get_use_count() == 1; }\n\n      void*\n      _M_get_deleter(const std::type_info&amp; __ti) const noexcept\n      { return _M_pi ? _M_pi-&gt;_M_get_deleter(__ti) : nullptr; }\n\n      bool\n      _M_less(const __shared_count&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      bool\n      _M_less(const __weak_count&lt;_Lp&gt;&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      // Friend function injected into enclosing namespace and found by ADL\n      friend inline bool\n      operator==(const __shared_count&amp; __a, const __shared_count&amp; __b) noexcept\n      { return __a._M_pi == __b._M_pi; }\n\n    private:\n      friend class __weak_count&lt;_Lp&gt;;\n\n      _Sp_counted_base&lt;_Lp&gt;*  _M_pi;\n    };\n\n\n  template&lt;_Lock_policy _Lp&gt;\n    class __weak_count\n    {\n    public:\n      constexpr __weak_count() noexcept : _M_pi(nullptr)\n      { }\n\n      __weak_count(const __shared_count&lt;_Lp&gt;&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_add_ref();\n      }\n\n      __weak_count(const __weak_count&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_add_ref();\n      }\n\n      __weak_count(__weak_count&amp;&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      { __r._M_pi = nullptr; }\n\n      ~__weak_count() noexcept\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n      }\n\n      __weak_count&amp;\n      operator=(const __shared_count&lt;_Lp&gt;&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\tif (__tmp != nullptr)\n\t  __tmp-&gt;_M_weak_add_ref();\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n\t_M_pi = __tmp;\n\treturn *this;\n      }\n\n      __weak_count&amp;\n      operator=(const __weak_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\tif (__tmp != nullptr)\n\t  __tmp-&gt;_M_weak_add_ref();\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n\t_M_pi = __tmp;\n\treturn *this;\n      }\n\n      __weak_count&amp;\n      operator=(__weak_count&amp;&amp; __r) noexcept\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n\t_M_pi = __r._M_pi;\n        __r._M_pi = nullptr;\n\treturn *this;\n      }\n\n      void\n      _M_swap(__weak_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\t__r._M_pi = _M_pi;\n\t_M_pi = __tmp;\n      }\n\n      long\n      _M_get_use_count() const noexcept\n      { return _M_pi != nullptr ? _M_pi-&gt;_M_get_use_count() : 0; }\n\n      bool\n      _M_less(const __weak_count&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      bool\n      _M_less(const __shared_count&lt;_Lp&gt;&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      // Friend function injected into enclosing namespace and found by ADL\n      friend inline bool\n      operator==(const __weak_count&amp; __a, const __weak_count&amp; __b) noexcept\n      { return __a._M_pi == __b._M_pi; }\n\n    private:\n      friend class __shared_count&lt;_Lp&gt;;\n\n      _Sp_counted_base&lt;_Lp&gt;*  _M_pi;\n    };\n\n  // Now that __weak_count is defined we can define this constructor:\n  template&lt;_Lock_policy _Lp&gt;\n    inline\n    __shared_count&lt;_Lp&gt;::__shared_count(const __weak_count&lt;_Lp&gt;&amp; __r)\n    : _M_pi(__r._M_pi)\n    {\n      if (_M_pi == nullptr || !_M_pi-&gt;_M_add_ref_lock_nothrow())\n\t__throw_bad_weak_ptr();\n    }\n\n  // Now that __weak_count is defined we can define this constructor:\n  template&lt;_Lock_policy _Lp&gt;\n    inline\n    __shared_count&lt;_Lp&gt;::\n    __shared_count(const __weak_count&lt;_Lp&gt;&amp; __r, std::nothrow_t) noexcept\n    : _M_pi(__r._M_pi)\n    {\n      if (_M_pi &amp;&amp; !_M_pi-&gt;_M_add_ref_lock_nothrow())\n\t_M_pi = nullptr;\n    }\n\n#define __cpp_lib_shared_ptr_arrays 201611L\n\n  // Helper traits for shared_ptr of array:\n\n  // A pointer type Y* is said to be compatible with a pointer type T* when\n  // either Y* is convertible to T* or Y is U[N] and T is U cv [].\n  template&lt;typename _Yp_ptr, typename _Tp_ptr&gt;\n    struct __sp_compatible_with\n    : false_type\n    { };\n\n  template&lt;typename _Yp, typename _Tp&gt;\n    struct __sp_compatible_with&lt;_Yp*, _Tp*&gt;\n    : is_convertible&lt;_Yp*, _Tp*&gt;::type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], _Up(*)[]&gt;\n    : true_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], const _Up(*)[]&gt;\n    : true_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], volatile _Up(*)[]&gt;\n    : true_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], const volatile _Up(*)[]&gt;\n    : true_type\n    { };\n\n  // Test conversion from Y(*)[N] to U(*)[N] without forming invalid type Y[N].\n  template&lt;typename _Up, size_t _Nm, typename _Yp, typename = void&gt;\n    struct __sp_is_constructible_arrN\n    : false_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm, typename _Yp&gt;\n    struct __sp_is_constructible_arrN&lt;_Up, _Nm, _Yp, __void_t&lt;_Yp[_Nm]&gt;&gt;\n    : is_convertible&lt;_Yp(*)[_Nm], _Up(*)[_Nm]&gt;::type\n    { };\n\n  // Test conversion from Y(*)[] to U(*)[] without forming invalid type Y[].\n  template&lt;typename _Up, typename _Yp, typename = void&gt;\n    struct __sp_is_constructible_arr\n    : false_type\n    { };\n\n  template&lt;typename _Up, typename _Yp&gt;\n    struct __sp_is_constructible_arr&lt;_Up, _Yp, __void_t&lt;_Yp[]&gt;&gt;\n    : is_convertible&lt;_Yp(*)[], _Up(*)[]&gt;::type\n    { };\n\n  // Trait to check if shared_ptr&lt;T&gt; can be constructed from Y*.\n  template&lt;typename _Tp, typename _Yp&gt;\n    struct __sp_is_constructible;\n\n  // When T is U[N], Y(*)[N] shall be convertible to T*;\n  template&lt;typename _Up, size_t _Nm, typename _Yp&gt;\n    struct __sp_is_constructible&lt;_Up[_Nm], _Yp&gt;\n    : __sp_is_constructible_arrN&lt;_Up, _Nm, _Yp&gt;::type\n    { };\n\n  // when T is U[], Y(*)[] shall be convertible to T*;\n  template&lt;typename _Up, typename _Yp&gt;\n    struct __sp_is_constructible&lt;_Up[], _Yp&gt;\n    : __sp_is_constructible_arr&lt;_Up, _Yp&gt;::type\n    { };\n\n  // otherwise, Y* shall be convertible to T*.\n  template&lt;typename _Tp, typename _Yp&gt;\n    struct __sp_is_constructible\n    : is_convertible&lt;_Yp*, _Tp*&gt;::type\n    { };\n\n\n  // Define operator* and operator-&gt; for shared_ptr&lt;T&gt;.\n  template&lt;typename _Tp, _Lock_policy _Lp,\n\t   bool = is_array&lt;_Tp&gt;::value, bool = is_void&lt;_Tp&gt;::value&gt;\n    class __shared_ptr_access\n    {\n    public:\n      using element_type = _Tp;\n\n      element_type&amp;\n      operator*() const noexcept\n      {\n\t__glibcxx_assert(_M_get() != nullptr);\n\treturn *_M_get();\n      }\n\n      element_type*\n      operator-&gt;() const noexcept\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_get() != nullptr);\n\treturn _M_get();\n      }\n\n    private:\n      element_type*\n      _M_get() const noexcept\n      { return static_cast&lt;const __shared_ptr&lt;_Tp, _Lp&gt;*&gt;(this)-&gt;get(); }\n    };\n\n  // Define operator-&gt; for shared_ptr&lt;cv void&gt;.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __shared_ptr_access&lt;_Tp, _Lp, false, true&gt;\n    {\n    public:\n      using element_type = _Tp;\n\n      element_type*\n      operator-&gt;() const noexcept\n      {\n\tauto __ptr = static_cast&lt;const __shared_ptr&lt;_Tp, _Lp&gt;*&gt;(this)-&gt;get();\n\t_GLIBCXX_DEBUG_PEDASSERT(__ptr != nullptr);\n\treturn __ptr;\n      }\n    };\n\n  // Define operator[] for shared_ptr&lt;T[]&gt; and shared_ptr&lt;T[N]&gt;.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __shared_ptr_access&lt;_Tp, _Lp, true, false&gt;\n    {\n    public:\n      using element_type = typename remove_extent&lt;_Tp&gt;::type;\n\n#if __cplusplus &lt;= 201402L\n      [[__deprecated__(&quot;shared_ptr&lt;T[]&gt;::operator* is absent from C++17&quot;)]]\n      element_type&amp;\n      operator*() const noexcept\n      {\n\t__glibcxx_assert(_M_get() != nullptr);\n\treturn *_M_get();\n      }\n\n      [[__deprecated__(&quot;shared_ptr&lt;T[]&gt;::operator-&gt; is absent from C++17&quot;)]]\n      element_type*\n      operator-&gt;() const noexcept\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_get() != nullptr);\n\treturn _M_get();\n      }\n#endif\n\n      element_type&amp;\n      operator[](ptrdiff_t __i) const\n      {\n\t__glibcxx_assert(_M_get() != nullptr);\n\t__glibcxx_assert(!extent&lt;_Tp&gt;::value || __i &lt; extent&lt;_Tp&gt;::value);\n\treturn _M_get()[__i];\n      }\n\n    private:\n      element_type*\n      _M_get() const noexcept\n      { return static_cast&lt;const __shared_ptr&lt;_Tp, _Lp&gt;*&gt;(this)-&gt;get(); }\n    };\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __shared_ptr\n    : public __shared_ptr_access&lt;_Tp, _Lp&gt;\n    {\n    public:\n      using element_type = typename remove_extent&lt;_Tp&gt;::type;\n\n    private:\n      // Constraint for taking ownership of a pointer of type _Yp*:\n      template&lt;typename _Yp&gt;\n\tusing _SafeConv\n\t  = typename enable_if&lt;__sp_is_constructible&lt;_Tp, _Yp&gt;::value&gt;::type;\n\n      // Constraint for construction from shared_ptr and weak_ptr:\n      template&lt;typename _Yp, typename _Res = void&gt;\n\tusing _Compatible = typename\n\t  enable_if&lt;__sp_compatible_with&lt;_Yp*, _Tp*&gt;::value, _Res&gt;::type;\n\n      // Constraint for assignment from shared_ptr and weak_ptr:\n      template&lt;typename _Yp&gt;\n\tusing _Assignable = _Compatible&lt;_Yp, __shared_ptr&amp;&gt;;\n\n      // Constraint for construction from unique_ptr:\n      template&lt;typename _Yp, typename _Del, typename _Res = void,\n\t       typename _Ptr = typename unique_ptr&lt;_Yp, _Del&gt;::pointer&gt;\n\tusing _UniqCompatible = __enable_if_t&lt;__and_&lt;\n\t  __sp_compatible_with&lt;_Yp*, _Tp*&gt;,\n\t  is_convertible&lt;_Ptr, element_type*&gt;,\n\t  is_move_constructible&lt;_Del&gt;\n\t  &gt;::value, _Res&gt;;\n\n      // Constraint for assignment from unique_ptr:\n      template&lt;typename _Yp, typename _Del&gt;\n\tusing _UniqAssignable = _UniqCompatible&lt;_Yp, _Del, __shared_ptr&amp;&gt;;\n\n    public:\n\n#if __cplusplus &gt; 201402L\n      using weak_type = __weak_ptr&lt;_Tp, _Lp&gt;;\n#endif\n\n      constexpr __shared_ptr() noexcept\n      : _M_ptr(0), _M_refcount()\n      { }\n\n      template&lt;typename _Yp, typename = _SafeConv&lt;_Yp&gt;&gt;\n\texplicit\n\t__shared_ptr(_Yp* __p)\n\t: _M_ptr(__p), _M_refcount(__p, typename is_array&lt;_Tp&gt;::type())\n\t{\n\t  static_assert( !is_void&lt;_Yp&gt;::value, &quot;incomplete type&quot; );\n\t  static_assert( sizeof(_Yp) &gt; 0, &quot;incomplete type&quot; );\n\t  _M_enable_shared_from_this_with(__p);\n\t}\n\n      template&lt;typename _Yp, typename _Deleter, typename = _SafeConv&lt;_Yp&gt;&gt;\n\t__shared_ptr(_Yp* __p, _Deleter __d)\n\t: _M_ptr(__p), _M_refcount(__p, std::move(__d))\n\t{\n\t  static_assert(__is_invocable&lt;_Deleter&amp;, _Yp*&amp;&gt;::value,\n\t      &quot;deleter expression d(p) is well-formed&quot;);\n\t  _M_enable_shared_from_this_with(__p);\n\t}\n\n      template&lt;typename _Yp, typename _Deleter, typename _Alloc,\n\t       typename = _SafeConv&lt;_Yp&gt;&gt;\n\t__shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)\n\t: _M_ptr(__p), _M_refcount(__p, std::move(__d), std::move(__a))\n\t{\n\t  static_assert(__is_invocable&lt;_Deleter&amp;, _Yp*&amp;&gt;::value,\n\t      &quot;deleter expression d(p) is well-formed&quot;);\n\t  _M_enable_shared_from_this_with(__p);\n\t}\n\n      template&lt;typename _Deleter&gt;\n\t__shared_ptr(nullptr_t __p, _Deleter __d)\n\t: _M_ptr(0), _M_refcount(__p, std::move(__d))\n\t{ }\n\n      template&lt;typename _Deleter, typename _Alloc&gt;\n        __shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)\n\t: _M_ptr(0), _M_refcount(__p, std::move(__d), std::move(__a))\n\t{ }\n\n      // Aliasing constructor\n      template&lt;typename _Yp&gt;\n\t__shared_ptr(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r,\n\t\t     element_type* __p) noexcept\n\t: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws\n\t{ }\n\n      // Aliasing constructor\n      template&lt;typename _Yp&gt;\n\t__shared_ptr(__shared_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r,\n\t\t     element_type* __p) noexcept\n\t: _M_ptr(__p), _M_refcount()\n\t{\n\t  _M_refcount._M_swap(__r._M_refcount);\n\t  __r._M_ptr = nullptr;\n\t}\n\n      __shared_ptr(const __shared_ptr&amp;) noexcept = default;\n      __shared_ptr&amp; operator=(const __shared_ptr&amp;) noexcept = default;\n      ~__shared_ptr() = default;\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__shared_ptr(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)\n\t{ }\n\n      __shared_ptr(__shared_ptr&amp;&amp; __r) noexcept\n      : _M_ptr(__r._M_ptr), _M_refcount()\n      {\n\t_M_refcount._M_swap(__r._M_refcount);\n\t__r._M_ptr = nullptr;\n      }\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__shared_ptr(__shared_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t: _M_ptr(__r._M_ptr), _M_refcount()\n\t{\n\t  _M_refcount._M_swap(__r._M_refcount);\n\t  __r._M_ptr = nullptr;\n\t}\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\texplicit __shared_ptr(const __weak_ptr&lt;_Yp, _Lp&gt;&amp; __r)\n\t: _M_refcount(__r._M_refcount) // may throw\n\t{\n\t  // It is now safe to copy __r._M_ptr, as\n\t  // _M_refcount(__r._M_refcount) did not throw.\n\t  _M_ptr = __r._M_ptr;\n\t}\n\n      // If an exception is thrown this constructor has no effect.\n      template&lt;typename _Yp, typename _Del,\n\t       typename = _UniqCompatible&lt;_Yp, _Del&gt;&gt;\n\t__shared_ptr(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t: _M_ptr(__r.get()), _M_refcount()\n\t{\n\t  auto __raw = __to_address(__r.get());\n\t  _M_refcount = __shared_count&lt;_Lp&gt;(std::move(__r));\n\t  _M_enable_shared_from_this_with(__raw);\n\t}\n\n#if __cplusplus &lt;= 201402L &amp;&amp; _GLIBCXX_USE_DEPRECATED\n    protected:\n      // If an exception is thrown this constructor has no effect.\n      template&lt;typename _Tp1, typename _Del,\n\t       typename enable_if&lt;__and_&lt;\n\t\t __not_&lt;is_array&lt;_Tp&gt;&gt;, is_array&lt;_Tp1&gt;,\n\t         is_convertible&lt;typename unique_ptr&lt;_Tp1, _Del&gt;::pointer, _Tp*&gt;\n\t       &gt;::value, bool&gt;::type = true&gt;\n\t__shared_ptr(unique_ptr&lt;_Tp1, _Del&gt;&amp;&amp; __r, __sp_array_delete)\n\t: _M_ptr(__r.get()), _M_refcount()\n\t{\n\t  auto __raw = __to_address(__r.get());\n\t  _M_refcount = __shared_count&lt;_Lp&gt;(std::move(__r));\n\t  _M_enable_shared_from_this_with(__raw);\n\t}\n    public:\n#endif\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      // Postcondition: use_count() == 1 and __r.get() == 0\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__shared_ptr(auto_ptr&lt;_Yp&gt;&amp;&amp; __r);\n#pragma GCC diagnostic pop\n#endif\n\n      constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { }\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r._M_ptr;\n\t  _M_refcount = __r._M_refcount; // __shared_count::op= doesn&#x27;t throw\n\t  return *this;\n\t}\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(auto_ptr&lt;_Yp&gt;&amp;&amp; __r)\n\t{\n\t  __shared_ptr(std::move(__r)).swap(*this);\n\t  return *this;\n\t}\n#pragma GCC diagnostic pop\n#endif\n\n      __shared_ptr&amp;\n      operator=(__shared_ptr&amp;&amp; __r) noexcept\n      {\n\t__shared_ptr(std::move(__r)).swap(*this);\n\treturn *this;\n      }\n\n      template&lt;class _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(__shared_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  __shared_ptr(std::move(__r)).swap(*this);\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp, typename _Del&gt;\n\t_UniqAssignable&lt;_Yp, _Del&gt;\n\toperator=(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t{\n\t  __shared_ptr(std::move(__r)).swap(*this);\n\t  return *this;\n\t}\n\n      void\n      reset() noexcept\n      { __shared_ptr().swap(*this); }\n\n      template&lt;typename _Yp&gt;\n\t_SafeConv&lt;_Yp&gt;\n\treset(_Yp* __p) // _Yp must be complete.\n\t{\n\t  // Catch self-reset errors.\n\t  __glibcxx_assert(__p == nullptr || __p != _M_ptr);\n\t  __shared_ptr(__p).swap(*this);\n\t}\n\n      template&lt;typename _Yp, typename _Deleter&gt;\n\t_SafeConv&lt;_Yp&gt;\n\treset(_Yp* __p, _Deleter __d)\n\t{ __shared_ptr(__p, std::move(__d)).swap(*this); }\n\n      template&lt;typename _Yp, typename _Deleter, typename _Alloc&gt;\n\t_SafeConv&lt;_Yp&gt;\n\treset(_Yp* __p, _Deleter __d, _Alloc __a)\n        { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }\n\n      /// Return the stored pointer.\n      element_type*\n      get() const noexcept\n      { return _M_ptr; }\n\n      /// Return true if the stored pointer is not null.\n      explicit operator bool() const noexcept\n      { return _M_ptr != nullptr; }\n\n      /// Return true if use_count() == 1.\n      bool\n      unique() const noexcept\n      { return _M_refcount._M_unique(); }\n\n      /// If *this owns a pointer, return the number of owners, otherwise zero.\n      long\n      use_count() const noexcept\n      { return _M_refcount._M_get_use_count(); }\n\n      /// Exchange both the owned pointer and the stored pointer.\n      void\n      swap(__shared_ptr&lt;_Tp, _Lp&gt;&amp; __other) noexcept\n      {\n\tstd::swap(_M_ptr, __other._M_ptr);\n\t_M_refcount._M_swap(__other._M_refcount);\n      }\n\n      /** @brief Define an ordering based on ownership.\n       *\n       * This function defines a strict weak ordering between two shared_ptr\n       * or weak_ptr objects, such that one object is less than the other\n       * unless they share ownership of the same pointer, or are both empty.\n       * @{\n      */\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(__shared_ptr&lt;_Tp1, _Lp&gt; const&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(__weak_ptr&lt;_Tp1, _Lp&gt; const&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n      /// @}\n\n    protected:\n      // This constructor is non-standard, it is used by allocate_shared.\n      template&lt;typename _Alloc, typename... _Args&gt;\n\t__shared_ptr(_Sp_alloc_shared_tag&lt;_Alloc&gt; __tag, _Args&amp;&amp;... __args)\n\t: _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward&lt;_Args&gt;(__args)...)\n\t{ _M_enable_shared_from_this_with(_M_ptr); }\n\n      template&lt;typename _Tp1, _Lock_policy _Lp1, typename _Alloc,\n\t       typename... _Args&gt;\n\tfriend __shared_ptr&lt;_Tp1, _Lp1&gt;\n\t__allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args);\n\n      // This constructor is used by __weak_ptr::lock() and\n      // shared_ptr::shared_ptr(const weak_ptr&amp;, std::nothrow_t).\n      __shared_ptr(const __weak_ptr&lt;_Tp, _Lp&gt;&amp; __r, std::nothrow_t) noexcept\n      : _M_refcount(__r._M_refcount, std::nothrow)\n      {\n\t_M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;\n      }\n\n      friend class __weak_ptr&lt;_Tp, _Lp&gt;;\n\n    private:\n\n      template&lt;typename _Yp&gt;\n\tusing __esft_base_t = decltype(__enable_shared_from_this_base(\n\t      std::declval&lt;const __shared_count&lt;_Lp&gt;&amp;&gt;(),\n\t      std::declval&lt;_Yp*&gt;()));\n\n      // Detect an accessible and unambiguous enable_shared_from_this base.\n      template&lt;typename _Yp, typename = void&gt;\n\tstruct __has_esft_base\n\t: false_type { };\n\n      template&lt;typename _Yp&gt;\n\tstruct __has_esft_base&lt;_Yp, __void_t&lt;__esft_base_t&lt;_Yp&gt;&gt;&gt;\n\t: __not_&lt;is_array&lt;_Tp&gt;&gt; { }; // No enable shared_from_this for arrays\n\n      template&lt;typename _Yp, typename _Yp2 = typename remove_cv&lt;_Yp&gt;::type&gt;\n\ttypename enable_if&lt;__has_esft_base&lt;_Yp2&gt;::value&gt;::type\n\t_M_enable_shared_from_this_with(_Yp* __p) noexcept\n\t{\n\t  if (auto __base = __enable_shared_from_this_base(_M_refcount, __p))\n\t    __base-&gt;_M_weak_assign(const_cast&lt;_Yp2*&gt;(__p), _M_refcount);\n\t}\n\n      template&lt;typename _Yp, typename _Yp2 = typename remove_cv&lt;_Yp&gt;::type&gt;\n\ttypename enable_if&lt;!__has_esft_base&lt;_Yp2&gt;::value&gt;::type\n\t_M_enable_shared_from_this_with(_Yp*) noexcept\n\t{ }\n\n      void*\n      _M_get_deleter(const std::type_info&amp; __ti) const noexcept\n      { return _M_refcount._M_get_deleter(__ti); }\n\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __shared_ptr;\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __weak_ptr;\n\n      template&lt;typename _Del, typename _Tp1, _Lock_policy _Lp1&gt;\n\tfriend _Del* get_deleter(const __shared_ptr&lt;_Tp1, _Lp1&gt;&amp;) noexcept;\n\n      template&lt;typename _Del, typename _Tp1&gt;\n\tfriend _Del* get_deleter(const shared_ptr&lt;_Tp1&gt;&amp;) noexcept;\n\n      element_type*\t   _M_ptr;         // Contained pointer.\n      __shared_count&lt;_Lp&gt;  _M_refcount;    // Reference counter.\n    };\n\n\n  // 20.7.2.2.7 shared_ptr comparisons\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator==(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return __a.get() == __b.get(); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator==(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return !__a; }\n\n#ifdef __cpp_lib_three_way_comparison\n  template&lt;typename _Tp, typename _Up, _Lock_policy _Lp&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a,\n\t\tconst __shared_ptr&lt;_Up, _Lp&gt;&amp; __b) noexcept\n    { return compare_three_way()(__a.get(), __b.get()); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using pointer = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type*;\n      return compare_three_way()(__a.get(), static_cast&lt;pointer&gt;(nullptr));\n    }\n#else\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator==(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return !__a; }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator!=(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return __a.get() != __b.get(); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator!=(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return (bool)__a; }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator!=(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return (bool)__a; }\n\n  template&lt;typename _Tp, typename _Up, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a,\n\t      const __shared_ptr&lt;_Up, _Lp&gt;&amp; __b) noexcept\n    {\n      using _Tp_elt = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type;\n      using _Up_elt = typename __shared_ptr&lt;_Up, _Lp&gt;::element_type;\n      using _Vp = typename common_type&lt;_Tp_elt*, _Up_elt*&gt;::type;\n      return less&lt;_Vp&gt;()(__a.get(), __b.get());\n    }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using _Tp_elt = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(__a.get(), nullptr);\n    }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    {\n      using _Tp_elt = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(nullptr, __a.get());\n    }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;=(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return !(__b &lt; __a); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;=(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(nullptr &lt; __a); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;=(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return !(__a &lt; nullptr); }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t      const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return (__b &lt; __a); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return nullptr &lt; __a; }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return __a &lt; nullptr; }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;=(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return !(__a &lt; __b); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;=(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(__a &lt; nullptr); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;=(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return !(nullptr &lt; __a); }\n#endif // three-way comparison\n\n  // 20.7.2.2.8 shared_ptr specialized algorithms.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline void\n    swap(__shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, __shared_ptr&lt;_Tp, _Lp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n  // 20.7.2.2.9 shared_ptr casts\n\n  // The seemingly equivalent code:\n  // shared_ptr&lt;_Tp, _Lp&gt;(static_cast&lt;_Tp*&gt;(__r.get()))\n  // will eventually result in undefined behaviour, attempting to\n  // delete the same object twice.\n  /// static_pointer_cast\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    static_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      return _Sp(__r, static_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  // The seemingly equivalent code:\n  // shared_ptr&lt;_Tp, _Lp&gt;(const_cast&lt;_Tp*&gt;(__r.get()))\n  // will eventually result in undefined behaviour, attempting to\n  // delete the same object twice.\n  /// const_pointer_cast\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    const_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      return _Sp(__r, const_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  // The seemingly equivalent code:\n  // shared_ptr&lt;_Tp, _Lp&gt;(dynamic_cast&lt;_Tp*&gt;(__r.get()))\n  // will eventually result in undefined behaviour, attempting to\n  // delete the same object twice.\n  /// dynamic_pointer_cast\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    dynamic_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      if (auto* __p = dynamic_cast&lt;typename _Sp::element_type*&gt;(__r.get()))\n\treturn _Sp(__r, __p);\n      return _Sp();\n    }\n\n#if __cplusplus &gt; 201402L\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    reinterpret_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      return _Sp(__r, reinterpret_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n#endif\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __weak_ptr\n    {\n      template&lt;typename _Yp, typename _Res = void&gt;\n\tusing _Compatible = typename\n\t  enable_if&lt;__sp_compatible_with&lt;_Yp*, _Tp*&gt;::value, _Res&gt;::type;\n\n      // Constraint for assignment from shared_ptr and weak_ptr:\n      template&lt;typename _Yp&gt;\n\tusing _Assignable = _Compatible&lt;_Yp, __weak_ptr&amp;&gt;;\n\n    public:\n      using element_type = typename remove_extent&lt;_Tp&gt;::type;\n\n      constexpr __weak_ptr() noexcept\n      : _M_ptr(nullptr), _M_refcount()\n      { }\n\n      __weak_ptr(const __weak_ptr&amp;) noexcept = default;\n\n      ~__weak_ptr() = default;\n\n      // The &quot;obvious&quot; converting constructor implementation:\n      //\n      //  template&lt;typename _Tp1&gt;\n      //    __weak_ptr(const __weak_ptr&lt;_Tp1, _Lp&gt;&amp; __r)\n      //    : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n      //    { }\n      //\n      // has a serious problem.\n      //\n      //  __r._M_ptr may already have been invalidated. The _M_ptr(__r._M_ptr)\n      //  conversion may require access to *__r._M_ptr (virtual inheritance).\n      //\n      // It is not possible to avoid spurious access violations since\n      // in multithreaded programs __r._M_ptr may be invalidated at any point.\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__weak_ptr(const __weak_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t: _M_refcount(__r._M_refcount)\n        { _M_ptr = __r.lock().get(); }\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__weak_ptr(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)\n\t{ }\n\n      __weak_ptr(__weak_ptr&amp;&amp; __r) noexcept\n      : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount))\n      { __r._M_ptr = nullptr; }\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__weak_ptr(__weak_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t: _M_ptr(__r.lock().get()), _M_refcount(std::move(__r._M_refcount))\n        { __r._M_ptr = nullptr; }\n\n      __weak_ptr&amp;\n      operator=(const __weak_ptr&amp; __r) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(const __weak_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r.lock().get();\n\t  _M_refcount = __r._M_refcount;\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r._M_ptr;\n\t  _M_refcount = __r._M_refcount;\n\t  return *this;\n\t}\n\n      __weak_ptr&amp;\n      operator=(__weak_ptr&amp;&amp; __r) noexcept\n      {\n\t_M_ptr = __r._M_ptr;\n\t_M_refcount = std::move(__r._M_refcount);\n\t__r._M_ptr = nullptr;\n\treturn *this;\n      }\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(__weak_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r.lock().get();\n\t  _M_refcount = std::move(__r._M_refcount);\n\t  __r._M_ptr = nullptr;\n\t  return *this;\n\t}\n\n      __shared_ptr&lt;_Tp, _Lp&gt;\n      lock() const noexcept\n      { return __shared_ptr&lt;element_type, _Lp&gt;(*this, std::nothrow); }\n\n      long\n      use_count() const noexcept\n      { return _M_refcount._M_get_use_count(); }\n\n      bool\n      expired() const noexcept\n      { return _M_refcount._M_get_use_count() == 0; }\n\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(const __weak_ptr&lt;_Tp1, _Lp&gt;&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n\n      void\n      reset() noexcept\n      { __weak_ptr().swap(*this); }\n\n      void\n      swap(__weak_ptr&amp; __s) noexcept\n      {\n\tstd::swap(_M_ptr, __s._M_ptr);\n\t_M_refcount._M_swap(__s._M_refcount);\n      }\n\n    private:\n      // Used by __enable_shared_from_this.\n      void\n      _M_assign(_Tp* __ptr, const __shared_count&lt;_Lp&gt;&amp; __refcount) noexcept\n      {\n\tif (use_count() == 0)\n\t  {\n\t    _M_ptr = __ptr;\n\t    _M_refcount = __refcount;\n\t  }\n      }\n\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __shared_ptr;\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __weak_ptr;\n      friend class __enable_shared_from_this&lt;_Tp, _Lp&gt;;\n      friend class enable_shared_from_this&lt;_Tp&gt;;\n\n      element_type*\t _M_ptr;         // Contained pointer.\n      __weak_count&lt;_Lp&gt;  _M_refcount;    // Reference counter.\n    };\n\n  // 20.7.2.3.6 weak_ptr specialized algorithms.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline void\n    swap(__weak_ptr&lt;_Tp, _Lp&gt;&amp; __a, __weak_ptr&lt;_Tp, _Lp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n  template&lt;typename _Tp, typename _Tp1&gt;\n    struct _Sp_owner_less : public binary_function&lt;_Tp, _Tp, bool&gt;\n    {\n      bool\n      operator()(const _Tp&amp; __lhs, const _Tp&amp; __rhs) const noexcept\n      { return __lhs.owner_before(__rhs); }\n\n      bool\n      operator()(const _Tp&amp; __lhs, const _Tp1&amp; __rhs) const noexcept\n      { return __lhs.owner_before(__rhs); }\n\n      bool\n      operator()(const _Tp1&amp; __lhs, const _Tp&amp; __rhs) const noexcept\n      { return __lhs.owner_before(__rhs); }\n    };\n\n  template&lt;&gt;\n    struct _Sp_owner_less&lt;void, void&gt;\n    {\n      template&lt;typename _Tp, typename _Up&gt;\n\tauto\n\toperator()(const _Tp&amp; __lhs, const _Up&amp; __rhs) const noexcept\n\t-&gt; decltype(__lhs.owner_before(__rhs))\n\t{ return __lhs.owner_before(__rhs); }\n\n      using is_transparent = void;\n    };\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    struct owner_less&lt;__shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    : public _Sp_owner_less&lt;__shared_ptr&lt;_Tp, _Lp&gt;, __weak_ptr&lt;_Tp, _Lp&gt;&gt;\n    { };\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    struct owner_less&lt;__weak_ptr&lt;_Tp, _Lp&gt;&gt;\n    : public _Sp_owner_less&lt;__weak_ptr&lt;_Tp, _Lp&gt;, __shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    { };\n\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __enable_shared_from_this\n    {\n    protected:\n      constexpr __enable_shared_from_this() noexcept { }\n\n      __enable_shared_from_this(const __enable_shared_from_this&amp;) noexcept { }\n\n      __enable_shared_from_this&amp;\n      operator=(const __enable_shared_from_this&amp;) noexcept\n      { return *this; }\n\n      ~__enable_shared_from_this() { }\n\n    public:\n      __shared_ptr&lt;_Tp, _Lp&gt;\n      shared_from_this()\n      { return __shared_ptr&lt;_Tp, _Lp&gt;(this-&gt;_M_weak_this); }\n\n      __shared_ptr&lt;const _Tp, _Lp&gt;\n      shared_from_this() const\n      { return __shared_ptr&lt;const _Tp, _Lp&gt;(this-&gt;_M_weak_this); }\n\n#if __cplusplus &gt; 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n      __weak_ptr&lt;_Tp, _Lp&gt;\n      weak_from_this() noexcept\n      { return this-&gt;_M_weak_this; }\n\n      __weak_ptr&lt;const _Tp, _Lp&gt;\n      weak_from_this() const noexcept\n      { return this-&gt;_M_weak_this; }\n#endif\n\n    private:\n      template&lt;typename _Tp1&gt;\n\tvoid\n\t_M_weak_assign(_Tp1* __p, const __shared_count&lt;_Lp&gt;&amp; __n) const noexcept\n\t{ _M_weak_this._M_assign(__p, __n); }\n\n      friend const __enable_shared_from_this*\n      __enable_shared_from_this_base(const __shared_count&lt;_Lp&gt;&amp;,\n\t\t\t\t     const __enable_shared_from_this* __p)\n      { return __p; }\n\n      template&lt;typename, _Lock_policy&gt;\n\tfriend class __shared_ptr;\n\n      mutable __weak_ptr&lt;_Tp, _Lp&gt;  _M_weak_this;\n    };\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy,\n\t   typename _Alloc, typename... _Args&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    __allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args)\n    {\n      static_assert(!is_array&lt;_Tp&gt;::value, &quot;make_shared&lt;T[]&gt; not supported&quot;);\n\n      return __shared_ptr&lt;_Tp, _Lp&gt;(_Sp_alloc_shared_tag&lt;_Alloc&gt;{__a},\n\t\t\t\t    std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy,\n\t   typename... _Args&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    __make_shared(_Args&amp;&amp;... __args)\n    {\n      typedef typename std::remove_const&lt;_Tp&gt;::type _Tp_nc;\n      return std::__allocate_shared&lt;_Tp, _Lp&gt;(std::allocator&lt;_Tp_nc&gt;(),\n\t\t\t\t\t      std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  /// std::hash specialization for __shared_ptr.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    struct hash&lt;__shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    : public __hash_base&lt;size_t, __shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    {\n      size_t\n      operator()(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __s) const noexcept\n      {\n\treturn hash&lt;typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type*&gt;()(\n\t    __s.get());\n      }\n    };\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif // _SHARED_PTR_BASE_H\n"}, "/usr/include/c++/11/bits/alloc_traits.h": {"id": "/usr/include/c++/11/bits/alloc_traits.h", "filePath": "/usr/include/c++/11/bits/alloc_traits.h", "content": "// Allocator traits -*- C++ -*-\n\n// Copyright (C) 2011-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n/** @file bits/alloc_traits.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _ALLOC_TRAITS_H\n#define _ALLOC_TRAITS_H 1\n\n#include &lt;bits/stl_construct.h&gt;\n#include &lt;bits/memoryfwd.h&gt;\n#if __cplusplus &gt;= 201103L\n# include &lt;bits/allocator.h&gt;\n# include &lt;bits/ptr_traits.h&gt;\n# include &lt;ext/numeric_traits.h&gt;\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#if __cplusplus &gt;= 201103L\n#define __cpp_lib_allocator_traits_is_always_equal 201411\n\n  /// @cond undocumented\n  struct __allocator_traits_base\n  {\n    template&lt;typename _Tp, typename _Up, typename = void&gt;\n      struct __rebind : __replace_first_arg&lt;_Tp, _Up&gt; { };\n\n    template&lt;typename _Tp, typename _Up&gt;\n      struct __rebind&lt;_Tp, _Up,\n\t\t      __void_t&lt;typename _Tp::template rebind&lt;_Up&gt;::other&gt;&gt;\n      { using type = typename _Tp::template rebind&lt;_Up&gt;::other; };\n\n  protected:\n    template&lt;typename _Tp&gt;\n      using __pointer = typename _Tp::pointer;\n    template&lt;typename _Tp&gt;\n      using __c_pointer = typename _Tp::const_pointer;\n    template&lt;typename _Tp&gt;\n      using __v_pointer = typename _Tp::void_pointer;\n    template&lt;typename _Tp&gt;\n      using __cv_pointer = typename _Tp::const_void_pointer;\n    template&lt;typename _Tp&gt;\n      using __pocca = typename _Tp::propagate_on_container_copy_assignment;\n    template&lt;typename _Tp&gt;\n      using __pocma = typename _Tp::propagate_on_container_move_assignment;\n    template&lt;typename _Tp&gt;\n      using __pocs = typename _Tp::propagate_on_container_swap;\n    template&lt;typename _Tp&gt;\n      using __equal = typename _Tp::is_always_equal;\n  };\n\n  template&lt;typename _Alloc, typename _Up&gt;\n    using __alloc_rebind\n      = typename __allocator_traits_base::template __rebind&lt;_Alloc, _Up&gt;::type;\n  /// @endcond\n\n  /**\n   * @brief  Uniform interface to all allocator types.\n   * @headerfile memory\n   * @ingroup allocators\n   * @since C++11\n  */\n  template&lt;typename _Alloc&gt;\n    struct allocator_traits : __allocator_traits_base\n    {\n      /// The allocator type\n      typedef _Alloc allocator_type;\n      /// The allocated type\n      typedef typename _Alloc::value_type value_type;\n\n      /**\n       * @brief   The allocator&#x27;s pointer type.\n       *\n       * @c Alloc::pointer if that type exists, otherwise @c value_type*\n      */\n      using pointer = __detected_or_t&lt;value_type*, __pointer, _Alloc&gt;;\n\n    private:\n      // Select _Func&lt;_Alloc&gt; or pointer_traits&lt;pointer&gt;::rebind&lt;_Tp&gt;\n      template&lt;template&lt;typename&gt; class _Func, typename _Tp, typename = void&gt;\n\tstruct _Ptr\n\t{\n\t  using type = typename pointer_traits&lt;pointer&gt;::template rebind&lt;_Tp&gt;;\n\t};\n\n      template&lt;template&lt;typename&gt; class _Func, typename _Tp&gt;\n\tstruct _Ptr&lt;_Func, _Tp, __void_t&lt;_Func&lt;_Alloc&gt;&gt;&gt;\n\t{\n\t  using type = _Func&lt;_Alloc&gt;;\n\t};\n\n      // Select _A2::difference_type or pointer_traits&lt;_Ptr&gt;::difference_type\n      template&lt;typename _A2, typename _PtrT, typename = void&gt;\n\tstruct _Diff\n\t{ using type = typename pointer_traits&lt;_PtrT&gt;::difference_type; };\n\n      template&lt;typename _A2, typename _PtrT&gt;\n\tstruct _Diff&lt;_A2, _PtrT, __void_t&lt;typename _A2::difference_type&gt;&gt;\n\t{ using type = typename _A2::difference_type; };\n\n      // Select _A2::size_type or make_unsigned&lt;_DiffT&gt;::type\n      template&lt;typename _A2, typename _DiffT, typename = void&gt;\n\tstruct _Size : make_unsigned&lt;_DiffT&gt; { };\n\n      template&lt;typename _A2, typename _DiffT&gt;\n\tstruct _Size&lt;_A2, _DiffT, __void_t&lt;typename _A2::size_type&gt;&gt;\n\t{ using type = typename _A2::size_type; };\n\n    public:\n      /**\n       * @brief   The allocator&#x27;s const pointer type.\n       *\n       * @c Alloc::const_pointer if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::rebind&lt;const value_type&gt; &lt;/tt&gt;\n      */\n      using const_pointer = typename _Ptr&lt;__c_pointer, const value_type&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s void pointer type.\n       *\n       * @c Alloc::void_pointer if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::rebind&lt;void&gt; &lt;/tt&gt;\n      */\n      using void_pointer = typename _Ptr&lt;__v_pointer, void&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s const void pointer type.\n       *\n       * @c Alloc::const_void_pointer if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::rebind&lt;const void&gt; &lt;/tt&gt;\n      */\n      using const_void_pointer = typename _Ptr&lt;__cv_pointer, const void&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s difference type\n       *\n       * @c Alloc::difference_type if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::difference_type &lt;/tt&gt;\n      */\n      using difference_type = typename _Diff&lt;_Alloc, pointer&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s size type\n       *\n       * @c Alloc::size_type if that type exists, otherwise\n       * &lt;tt&gt; make_unsigned&lt;difference_type&gt;::type &lt;/tt&gt;\n      */\n      using size_type = typename _Size&lt;_Alloc, difference_type&gt;::type;\n\n      /**\n       * @brief   How the allocator is propagated on copy assignment\n       *\n       * @c Alloc::propagate_on_container_copy_assignment if that type exists,\n       * otherwise @c false_type\n      */\n      using propagate_on_container_copy_assignment\n\t= __detected_or_t&lt;false_type, __pocca, _Alloc&gt;;\n\n      /**\n       * @brief   How the allocator is propagated on move assignment\n       *\n       * @c Alloc::propagate_on_container_move_assignment if that type exists,\n       * otherwise @c false_type\n      */\n      using propagate_on_container_move_assignment\n\t= __detected_or_t&lt;false_type, __pocma, _Alloc&gt;;\n\n      /**\n       * @brief   How the allocator is propagated on swap\n       *\n       * @c Alloc::propagate_on_container_swap if that type exists,\n       * otherwise @c false_type\n      */\n      using propagate_on_container_swap\n\t= __detected_or_t&lt;false_type, __pocs, _Alloc&gt;;\n\n      /**\n       * @brief   Whether all instances of the allocator type compare equal.\n       *\n       * @c Alloc::is_always_equal if that type exists,\n       * otherwise @c is_empty&lt;Alloc&gt;::type\n      */\n      using is_always_equal\n\t= __detected_or_t&lt;typename is_empty&lt;_Alloc&gt;::type, __equal, _Alloc&gt;;\n\n      template&lt;typename _Tp&gt;\n\tusing rebind_alloc = __alloc_rebind&lt;_Alloc, _Tp&gt;;\n      template&lt;typename _Tp&gt;\n\tusing rebind_traits = allocator_traits&lt;rebind_alloc&lt;_Tp&gt;&gt;;\n\n    private:\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr auto\n\t_S_allocate(_Alloc2&amp; __a, size_type __n, const_void_pointer __hint, int)\n\t-&gt; decltype(__a.allocate(__n, __hint))\n\t{ return __a.allocate(__n, __hint); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr pointer\n\t_S_allocate(_Alloc2&amp; __a, size_type __n, const_void_pointer, ...)\n\t{ return __a.allocate(__n); }\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstruct __construct_helper\n\t{\n\t  template&lt;typename _Alloc2,\n\t    typename = decltype(std::declval&lt;_Alloc2*&gt;()-&gt;construct(\n\t\t  std::declval&lt;_Tp*&gt;(), std::declval&lt;_Args&gt;()...))&gt;\n\t    static true_type __test(int);\n\n\t  template&lt;typename&gt;\n\t    static false_type __test(...);\n\n\t  using type = decltype(__test&lt;_Alloc&gt;(0));\n\t};\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tusing __has_construct\n\t  = typename __construct_helper&lt;_Tp, _Args...&gt;::type;\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstatic _GLIBCXX14_CONSTEXPR _Require&lt;__has_construct&lt;_Tp, _Args...&gt;&gt;\n\t_S_construct(_Alloc&amp; __a, _Tp* __p, _Args&amp;&amp;... __args)\n\tnoexcept(noexcept(__a.construct(__p, std::forward&lt;_Args&gt;(__args)...)))\n\t{ __a.construct(__p, std::forward&lt;_Args&gt;(__args)...); }\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstatic _GLIBCXX14_CONSTEXPR\n\t_Require&lt;__and_&lt;__not_&lt;__has_construct&lt;_Tp, _Args...&gt;&gt;,\n\t\t\t       is_constructible&lt;_Tp, _Args...&gt;&gt;&gt;\n\t_S_construct(_Alloc&amp;, _Tp* __p, _Args&amp;&amp;... __args)\n\tnoexcept(std::is_nothrow_constructible&lt;_Tp, _Args...&gt;::value)\n\t{\n#if __cplusplus &lt;= 201703L\n\t  ::new((void*)__p) _Tp(std::forward&lt;_Args&gt;(__args)...);\n#else\n\t  std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...);\n#endif\n\t}\n\n      template&lt;typename _Alloc2, typename _Tp&gt;\n\tstatic _GLIBCXX14_CONSTEXPR auto\n\t_S_destroy(_Alloc2&amp; __a, _Tp* __p, int)\n\tnoexcept(noexcept(__a.destroy(__p)))\n\t-&gt; decltype(__a.destroy(__p))\n\t{ __a.destroy(__p); }\n\n      template&lt;typename _Alloc2, typename _Tp&gt;\n\tstatic _GLIBCXX14_CONSTEXPR void\n\t_S_destroy(_Alloc2&amp;, _Tp* __p, ...)\n\tnoexcept(std::is_nothrow_destructible&lt;_Tp&gt;::value)\n\t{ std::_Destroy(__p); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr auto\n\t_S_max_size(_Alloc2&amp; __a, int)\n\t-&gt; decltype(__a.max_size())\n\t{ return __a.max_size(); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr size_type\n\t_S_max_size(_Alloc2&amp;, ...)\n\t{\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 2466. allocator_traits::max_size() default behavior is incorrect\n\t  return __gnu_cxx::__numeric_traits&lt;size_type&gt;::__max\n\t    / sizeof(value_type);\n\t}\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr auto\n\t_S_select(_Alloc2&amp; __a, int)\n\t-&gt; decltype(__a.select_on_container_copy_construction())\n\t{ return __a.select_on_container_copy_construction(); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr _Alloc2\n\t_S_select(_Alloc2&amp; __a, ...)\n\t{ return __a; }\n\n    public:\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *\n       *  Calls @c a.allocate(n)\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(_Alloc&amp; __a, size_type __n)\n      { return __a.allocate(__n); }\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *  @param  __hint Aid to locality.\n       *  @return Memory of suitable size and alignment for @a n objects\n       *          of type @c value_type\n       *\n       *  Returns &lt;tt&gt; a.allocate(n, hint) &lt;/tt&gt; if that expression is\n       *  well-formed, otherwise returns @c a.allocate(n)\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(_Alloc&amp; __a, size_type __n, const_void_pointer __hint)\n      { return _S_allocate(__a, __n, __hint, 0); }\n\n      /**\n       *  @brief  Deallocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the memory to deallocate.\n       *  @param  __n  The number of objects space was allocated for.\n       *\n       *  Calls &lt;tt&gt; a.deallocate(p, n) &lt;/tt&gt;\n      */\n      static _GLIBCXX20_CONSTEXPR void\n      deallocate(_Alloc&amp; __a, pointer __p, size_type __n)\n      { __a.deallocate(__p, __n); }\n\n      /**\n       *  @brief  Construct an object of type `_Tp`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to memory of suitable size and alignment for Tp\n       *  @param  __args Constructor arguments.\n       *\n       *  Calls &lt;tt&gt; __a.construct(__p, std::forward&lt;Args&gt;(__args)...) &lt;/tt&gt;\n       *  if that expression is well-formed, otherwise uses placement-new\n       *  to construct an object of type @a _Tp at location @a __p from the\n       *  arguments @a __args...\n      */\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstatic _GLIBCXX20_CONSTEXPR auto\n\tconstruct(_Alloc&amp; __a, _Tp* __p, _Args&amp;&amp;... __args)\n\tnoexcept(noexcept(_S_construct(__a, __p,\n\t\t\t\t       std::forward&lt;_Args&gt;(__args)...)))\n\t-&gt; decltype(_S_construct(__a, __p, std::forward&lt;_Args&gt;(__args)...))\n\t{ _S_construct(__a, __p, std::forward&lt;_Args&gt;(__args)...); }\n\n      /**\n       *  @brief  Destroy an object of type @a _Tp\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the object to destroy\n       *\n       *  Calls @c __a.destroy(__p) if that expression is well-formed,\n       *  otherwise calls @c __p-&gt;~_Tp()\n      */\n      template&lt;typename _Tp&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tdestroy(_Alloc&amp; __a, _Tp* __p)\n\tnoexcept(noexcept(_S_destroy(__a, __p, 0)))\n\t{ _S_destroy(__a, __p, 0); }\n\n      /**\n       *  @brief  The maximum supported allocation size\n       *  @param  __a  An allocator.\n       *  @return @c __a.max_size() or @c numeric_limits&lt;size_type&gt;::max()\n       *\n       *  Returns @c __a.max_size() if that expression is well-formed,\n       *  otherwise returns @c numeric_limits&lt;size_type&gt;::max()\n      */\n      static _GLIBCXX20_CONSTEXPR size_type\n      max_size(const _Alloc&amp; __a) noexcept\n      { return _S_max_size(__a, 0); }\n\n      /**\n       *  @brief  Obtain an allocator to use when copying a container.\n       *  @param  __rhs  An allocator.\n       *  @return @c __rhs.select_on_container_copy_construction() or @a __rhs\n       *\n       *  Returns @c __rhs.select_on_container_copy_construction() if that\n       *  expression is well-formed, otherwise returns @a __rhs\n      */\n      static _GLIBCXX20_CONSTEXPR _Alloc\n      select_on_container_copy_construction(const _Alloc&amp; __rhs)\n      { return _S_select(__rhs, 0); }\n    };\n\n#if __cplusplus &gt; 201703L\n# define __cpp_lib_constexpr_dynamic_alloc 201907L\n#endif\n\n  /// Partial specialization for std::allocator.\n  template&lt;typename _Tp&gt;\n    struct allocator_traits&lt;allocator&lt;_Tp&gt;&gt;\n    {\n      /// The allocator type\n      using allocator_type = allocator&lt;_Tp&gt;;\n\n      /// The allocated type\n      using value_type = _Tp;\n\n      /// The allocator&#x27;s pointer type.\n      using pointer = _Tp*;\n\n      /// The allocator&#x27;s const pointer type.\n      using const_pointer = const _Tp*;\n\n      /// The allocator&#x27;s void pointer type.\n      using void_pointer = void*;\n\n      /// The allocator&#x27;s const void pointer type.\n      using const_void_pointer = const void*;\n\n      /// The allocator&#x27;s difference type\n      using difference_type = std::ptrdiff_t;\n\n      /// The allocator&#x27;s size type\n      using size_type = std::size_t;\n\n      /// How the allocator is propagated on copy assignment\n      using propagate_on_container_copy_assignment = false_type;\n\n      /// How the allocator is propagated on move assignment\n      using propagate_on_container_move_assignment = true_type;\n\n      /// How the allocator is propagated on swap\n      using propagate_on_container_swap = false_type;\n\n      /// Whether all instances of the allocator type compare equal.\n      using is_always_equal = true_type;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_alloc = allocator&lt;_Up&gt;;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_traits = allocator_traits&lt;allocator&lt;_Up&gt;&gt;;\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *\n       *  Calls @c a.allocate(n)\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(allocator_type&amp; __a, size_type __n)\n      { return __a.allocate(__n); }\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *  @param  __hint Aid to locality.\n       *  @return Memory of suitable size and alignment for @a n objects\n       *          of type @c value_type\n       *\n       *  Returns &lt;tt&gt; a.allocate(n, hint) &lt;/tt&gt;\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(allocator_type&amp; __a, size_type __n, const_void_pointer __hint)\n      {\n#if __cplusplus &lt;= 201703L\n\treturn __a.allocate(__n, __hint);\n#else\n\treturn __a.allocate(__n);\n#endif\n      }\n\n      /**\n       *  @brief  Deallocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the memory to deallocate.\n       *  @param  __n  The number of objects space was allocated for.\n       *\n       *  Calls &lt;tt&gt; a.deallocate(p, n) &lt;/tt&gt;\n      */\n      static _GLIBCXX20_CONSTEXPR void\n      deallocate(allocator_type&amp; __a, pointer __p, size_type __n)\n      { __a.deallocate(__p, __n); }\n\n      /**\n       *  @brief  Construct an object of type `_Up`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to memory of suitable size and alignment for\n       *\t       an object of type `_Up`.\n       *  @param  __args Constructor arguments.\n       *\n       *  Calls `__a.construct(__p, std::forward&lt;_Args&gt;(__args)...)`\n       *  in C++11, C++14 and C++17. Changed in C++20 to call\n       *  `std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...)` instead.\n      */\n      template&lt;typename _Up, typename... _Args&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tconstruct(allocator_type&amp; __a __attribute__((__unused__)), _Up* __p,\n\t\t  _Args&amp;&amp;... __args)\n\tnoexcept(std::is_nothrow_constructible&lt;_Up, _Args...&gt;::value)\n\t{\n#if __cplusplus &lt;= 201703L\n\t  __a.construct(__p, std::forward&lt;_Args&gt;(__args)...);\n#else\n\t  std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...);\n#endif\n\t}\n\n      /**\n       *  @brief  Destroy an object of type @a _Up\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the object to destroy\n       *\n       *  Calls @c __a.destroy(__p).\n      */\n      template&lt;typename _Up&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tdestroy(allocator_type&amp; __a __attribute__((__unused__)), _Up* __p)\n\tnoexcept(is_nothrow_destructible&lt;_Up&gt;::value)\n\t{\n#if __cplusplus &lt;= 201703L\n\t  __a.destroy(__p);\n#else\n\t  std::destroy_at(__p);\n#endif\n\t}\n\n      /**\n       *  @brief  The maximum supported allocation size\n       *  @param  __a  An allocator.\n       *  @return @c __a.max_size()\n      */\n      static _GLIBCXX20_CONSTEXPR size_type\n      max_size(const allocator_type&amp; __a __attribute__((__unused__))) noexcept\n      {\n#if __cplusplus &lt;= 201703L\n\treturn __a.max_size();\n#else\n\treturn size_t(-1) / sizeof(value_type);\n#endif\n      }\n\n      /**\n       *  @brief  Obtain an allocator to use when copying a container.\n       *  @param  __rhs  An allocator.\n       *  @return @c __rhs\n      */\n      static _GLIBCXX20_CONSTEXPR allocator_type\n      select_on_container_copy_construction(const allocator_type&amp; __rhs)\n      { return __rhs; }\n    };\n\n  /// Explicit specialization for std::allocator&lt;void&gt;.\n  template&lt;&gt;\n    struct allocator_traits&lt;allocator&lt;void&gt;&gt;\n    {\n      /// The allocator type\n      using allocator_type = allocator&lt;void&gt;;\n\n      /// The allocated type\n      using value_type = void;\n\n      /// The allocator&#x27;s pointer type.\n      using pointer = void*;\n\n      /// The allocator&#x27;s const pointer type.\n      using const_pointer = const void*;\n\n      /// The allocator&#x27;s void pointer type.\n      using void_pointer = void*;\n\n      /// The allocator&#x27;s const void pointer type.\n      using const_void_pointer = const void*;\n\n      /// The allocator&#x27;s difference type\n      using difference_type = std::ptrdiff_t;\n\n      /// The allocator&#x27;s size type\n      using size_type = std::size_t;\n\n      /// How the allocator is propagated on copy assignment\n      using propagate_on_container_copy_assignment = false_type;\n\n      /// How the allocator is propagated on move assignment\n      using propagate_on_container_move_assignment = true_type;\n\n      /// How the allocator is propagated on swap\n      using propagate_on_container_swap = false_type;\n\n      /// Whether all instances of the allocator type compare equal.\n      using is_always_equal = true_type;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_alloc = allocator&lt;_Up&gt;;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_traits = allocator_traits&lt;allocator&lt;_Up&gt;&gt;;\n\n      /// allocate is ill-formed for allocator&lt;void&gt;\n      static void*\n      allocate(allocator_type&amp;, size_type, const void* = nullptr) = delete;\n\n      /// deallocate is ill-formed for allocator&lt;void&gt;\n      static void\n      deallocate(allocator_type&amp;, void*, size_type) = delete;\n\n      /**\n       *  @brief  Construct an object of type `_Up`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to memory of suitable size and alignment for\n       *\t       an object of type `_Up`.\n       *  @param  __args Constructor arguments.\n       *\n       *  Calls `__a.construct(__p, std::forward&lt;_Args&gt;(__args)...)`\n       *  in C++11, C++14 and C++17. Changed in C++20 to call\n       *  `std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...)` instead.\n      */\n      template&lt;typename _Up, typename... _Args&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tconstruct(allocator_type&amp;, _Up* __p, _Args&amp;&amp;... __args)\n\tnoexcept(std::is_nothrow_constructible&lt;_Up, _Args...&gt;::value)\n\t{ std::_Construct(__p, std::forward&lt;_Args&gt;(__args)...); }\n\n      /**\n       *  @brief  Destroy an object of type `_Up`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the object to destroy\n       *\n       *  Invokes the destructor for `*__p`.\n      */\n      template&lt;typename _Up&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tdestroy(allocator_type&amp;, _Up* __p)\n\tnoexcept(is_nothrow_destructible&lt;_Up&gt;::value)\n\t{ std::_Destroy(__p); }\n\n      /// max_size is ill-formed for allocator&lt;void&gt;\n      static size_type\n      max_size(const allocator_type&amp;) = delete;\n\n      /**\n       *  @brief  Obtain an allocator to use when copying a container.\n       *  @param  __rhs  An allocator.\n       *  @return `__rhs`\n      */\n      static _GLIBCXX20_CONSTEXPR allocator_type\n      select_on_container_copy_construction(const allocator_type&amp; __rhs)\n      { return __rhs; }\n    };\n\n#if __cplusplus &lt; 201703L\n  template&lt;typename _Alloc&gt;\n    inline void\n    __do_alloc_on_copy(_Alloc&amp; __one, const _Alloc&amp; __two, true_type)\n    { __one = __two; }\n\n  template&lt;typename _Alloc&gt;\n    inline void\n    __do_alloc_on_copy(_Alloc&amp;, const _Alloc&amp;, false_type)\n    { }\n#endif\n\n  template&lt;typename _Alloc&gt;\n    _GLIBCXX14_CONSTEXPR inline void\n    __alloc_on_copy(_Alloc&amp; __one, const _Alloc&amp; __two)\n    {\n      typedef allocator_traits&lt;_Alloc&gt; __traits;\n      typedef typename __traits::propagate_on_container_copy_assignment __pocca;\n#if __cplusplus &gt;= 201703L\n      if constexpr (__pocca::value)\n\t__one = __two;\n#else\n      __do_alloc_on_copy(__one, __two, __pocca());\n#endif\n    }\n\n  template&lt;typename _Alloc&gt;\n    constexpr _Alloc\n    __alloc_on_copy(const _Alloc&amp; __a)\n    {\n      typedef allocator_traits&lt;_Alloc&gt; __traits;\n      return __traits::select_on_container_copy_construction(__a);\n    }\n\n#if __cplusplus &lt; 201703L\n  template&lt;typename _Alloc&gt;\n    inline void __do_alloc_on_move(_Alloc&amp; __one, _Alloc&amp; __two, true_type)\n    { __one = std::move(__two); }\n\n  template&lt;typename _Alloc&gt;\n    inline void __do_alloc_on_move(_Alloc&amp;, _Alloc&amp;, false_type)\n    { }\n#endif\n\n  template&lt;typename _Alloc&gt;\n    _GLIBCXX14_CONSTEXPR inline void\n    __alloc_on_move(_Alloc&amp; __one, _Alloc&amp; __two)\n    {\n      typedef allocator_traits&lt;_Alloc&gt; __traits;\n      typedef typename __traits::propagate_on_container_move_assignment __pocma;\n#if __cplusplus &gt;= 201703L\n      if constexpr (__pocma::value)\n\t__one = std::move(__two);\n#else\n      __do_alloc_on_move(__one, __two, __pocma());\n#endif\n    }\n\n#if __cplusplus &lt; 201703L\n  template&lt;typename _Alloc&gt;\n    inline void __do_alloc_on_swap(_Alloc&amp; __one, _Alloc&amp; __two, true_type)\n    {\n      using std::swap;\n      swap(__one, __two);\n    }\n\n  template&lt;typename _Alloc&gt;\n    inline void __do_alloc_on_swap(_Alloc&amp;, _Alloc&amp;, false_type)\n    { }\n#endif\n\n  template&lt;typename _Alloc&gt;\n    _GLIBCXX14_CONSTEXPR inline void\n    __alloc_on_swap(_Alloc&amp; __one, _Alloc&amp; __two)\n    {\n      typedef allocator_traits&lt;_Alloc&gt; __traits;\n      typedef typename __traits::propagate_on_container_swap __pocs;\n#if __cplusplus &gt;= 201703L\n      if constexpr (__pocs::value)\n\t{\n\t  using std::swap;\n\t  swap(__one, __two);\n\t}\n#else\n      __do_alloc_on_swap(__one, __two, __pocs());\n#endif\n    }\n\n  template&lt;typename _Alloc, typename _Tp,\n\t   typename _ValueT = __remove_cvref_t&lt;typename _Alloc::value_type&gt;,\n\t   typename = void&gt;\n    struct __is_alloc_insertable_impl\n    : false_type\n    { };\n\n  template&lt;typename _Alloc, typename _Tp, typename _ValueT&gt;\n    struct __is_alloc_insertable_impl&lt;_Alloc, _Tp, _ValueT,\n      __void_t&lt;decltype(allocator_traits&lt;_Alloc&gt;::construct(\n\t\t   std::declval&lt;_Alloc&amp;&gt;(), std::declval&lt;_ValueT*&gt;(),\n\t\t   std::declval&lt;_Tp&gt;()))&gt;&gt;\n    : true_type\n    { };\n\n  // true if _Alloc::value_type is CopyInsertable into containers using _Alloc\n  // (might be wrong if _Alloc::construct exists but is not constrained,\n  // i.e. actually trying to use it would still be invalid. Use with caution.)\n  template&lt;typename _Alloc&gt;\n    struct __is_copy_insertable\n    : __is_alloc_insertable_impl&lt;_Alloc,\n\t\t\t\t typename _Alloc::value_type const&amp;&gt;::type\n    { };\n\n  // std::allocator&lt;_Tp&gt; just requires CopyConstructible\n  template&lt;typename _Tp&gt;\n    struct __is_copy_insertable&lt;allocator&lt;_Tp&gt;&gt;\n    : is_copy_constructible&lt;_Tp&gt;\n    { };\n\n  // true if _Alloc::value_type is MoveInsertable into containers using _Alloc\n  // (might be wrong if _Alloc::construct exists but is not constrained,\n  // i.e. actually trying to use it would still be invalid. Use with caution.)\n  template&lt;typename _Alloc&gt;\n    struct __is_move_insertable\n    : __is_alloc_insertable_impl&lt;_Alloc, typename _Alloc::value_type&gt;::type\n    { };\n\n  // std::allocator&lt;_Tp&gt; just requires MoveConstructible\n  template&lt;typename _Tp&gt;\n    struct __is_move_insertable&lt;allocator&lt;_Tp&gt;&gt;\n    : is_move_constructible&lt;_Tp&gt;\n    { };\n\n  // Trait to detect Allocator-like types.\n  template&lt;typename _Alloc, typename = void&gt;\n    struct __is_allocator : false_type { };\n\n  template&lt;typename _Alloc&gt;\n    struct __is_allocator&lt;_Alloc,\n      __void_t&lt;typename _Alloc::value_type,\n\t       decltype(std::declval&lt;_Alloc&amp;&gt;().allocate(size_t{}))&gt;&gt;\n    : true_type { };\n\n  template&lt;typename _Alloc&gt;\n    using _RequireAllocator\n      = typename enable_if&lt;__is_allocator&lt;_Alloc&gt;::value, _Alloc&gt;::type;\n\n  template&lt;typename _Alloc&gt;\n    using _RequireNotAllocator\n      = typename enable_if&lt;!__is_allocator&lt;_Alloc&gt;::value, _Alloc&gt;::type;\n\n#if __cpp_concepts &gt;= 201907L\n  template&lt;typename _Alloc&gt;\n    concept __allocator_like = requires (_Alloc&amp; __a) {\n      typename _Alloc::value_type;\n      __a.deallocate(__a.allocate(1u), 1u);\n    };\n#endif\n#endif // C++11\n\n  /**\n   * Destroy a range of objects using the supplied allocator.  For\n   * non-default allocators we do not optimize away invocation of\n   * destroy() even if _Tp has a trivial destructor.\n   */\n\n  template&lt;typename _ForwardIterator, typename _Allocator&gt;\n    void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n\t     _Allocator&amp; __alloc)\n    {\n      for (; __first != __last; ++__first)\n#if __cplusplus &lt; 201103L\n\t__alloc.destroy(std::__addressof(*__first));\n#else\n\tallocator_traits&lt;_Allocator&gt;::destroy(__alloc,\n\t\t\t\t\t      std::__addressof(*__first));\n#endif\n    }\n\n  template&lt;typename _ForwardIterator, typename _Tp&gt;\n    inline void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n\t     allocator&lt;_Tp&gt;&amp;)\n    {\n      _Destroy(__first, __last);\n    }\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n#endif // _ALLOC_TRAITS_H\n"}, "/usr/include/c++/11/ext/new_allocator.h": {"id": "/usr/include/c++/11/ext/new_allocator.h", "filePath": "/usr/include/c++/11/ext/new_allocator.h", "content": "// Allocator that wraps operator new -*- C++ -*-\n\n// Copyright (C) 2001-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n/** @file ext/new_allocator.h\n *  This file is a GNU extension to the Standard C++ Library.\n */\n\n#ifndef _NEW_ALLOCATOR_H\n#define _NEW_ALLOCATOR_H 1\n\n#include &lt;bits/c++config.h&gt;\n#include &lt;new&gt;\n#include &lt;bits/functexcept.h&gt;\n#include &lt;bits/move.h&gt;\n#if __cplusplus &gt;= 201103L\n#include &lt;type_traits&gt;\n#endif\n\nnamespace __gnu_cxx _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   *  @brief  An allocator that uses global new, as per C++03 [20.4.1].\n   *  @ingroup allocators\n   *\n   *  This is precisely the allocator defined in the C++ Standard.\n   *    - all allocation calls operator new\n   *    - all deallocation calls operator delete\n   *\n   *  @tparam  _Tp  Type of allocated object.\n   */\n  template&lt;typename _Tp&gt;\n    class new_allocator\n    {\n    public:\n      typedef _Tp        value_type;\n      typedef std::size_t     size_type;\n      typedef std::ptrdiff_t  difference_type;\n#if __cplusplus &lt;= 201703L\n      typedef _Tp*       pointer;\n      typedef const _Tp* const_pointer;\n      typedef _Tp&amp;       reference;\n      typedef const _Tp&amp; const_reference;\n\n      template&lt;typename _Tp1&gt;\n\tstruct rebind\n\t{ typedef new_allocator&lt;_Tp1&gt; other; };\n#endif\n\n#if __cplusplus &gt;= 201103L\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2103. propagate_on_container_move_assignment\n      typedef std::true_type propagate_on_container_move_assignment;\n#endif\n\n      _GLIBCXX20_CONSTEXPR\n      new_allocator() _GLIBCXX_USE_NOEXCEPT { }\n\n      _GLIBCXX20_CONSTEXPR\n      new_allocator(const new_allocator&amp;) _GLIBCXX_USE_NOEXCEPT { }\n\n      template&lt;typename _Tp1&gt;\n\t_GLIBCXX20_CONSTEXPR\n\tnew_allocator(const new_allocator&lt;_Tp1&gt;&amp;) _GLIBCXX_USE_NOEXCEPT { }\n\n#if __cplusplus &lt;= 201703L\n      ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }\n\n      pointer\n      address(reference __x) const _GLIBCXX_NOEXCEPT\n      { return std::__addressof(__x); }\n\n      const_pointer\n      address(const_reference __x) const _GLIBCXX_NOEXCEPT\n      { return std::__addressof(__x); }\n#endif\n\n      // NB: __n is permitted to be 0.  The C++ standard says nothing\n      // about what the return value is when __n == 0.\n      _GLIBCXX_NODISCARD _Tp*\n      allocate(size_type __n, const void* = static_cast&lt;const void*&gt;(0))\n      {\n#if __cplusplus &gt;= 201103L\n\t // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t // 3308. std::allocator&lt;void&gt;().allocate(n)\n\t static_assert(sizeof(_Tp) != 0, &quot;cannot allocate incomplete types&quot;);\n#endif\n\n\tif (__builtin_expect(__n &gt; this-&gt;_M_max_size(), false))\n\t  {\n\t    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t    // 3190. allocator::allocate sometimes returns too little storage\n\t    if (__n &gt; (std::size_t(-1) / sizeof(_Tp)))\n\t      std::__throw_bad_array_new_length();\n\t    std::__throw_bad_alloc();\n\t  }\n\n#if __cpp_aligned_new\n\tif (alignof(_Tp) &gt; __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n\t  {\n\t    std::align_val_t __al = std::align_val_t(alignof(_Tp));\n\t    return static_cast&lt;_Tp*&gt;(::operator new(__n * sizeof(_Tp), __al));\n\t  }\n#endif\n\treturn static_cast&lt;_Tp*&gt;(::operator new(__n * sizeof(_Tp)));\n      }\n\n      // __p is not permitted to be a null pointer.\n      void\n      deallocate(_Tp* __p, size_type __t __attribute__ ((__unused__)))\n      {\n#if __cpp_aligned_new\n\tif (alignof(_Tp) &gt; __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n\t  {\n\t    ::operator delete(__p,\n# if __cpp_sized_deallocation\n\t\t\t      __t * sizeof(_Tp),\n# endif\n\t\t\t      std::align_val_t(alignof(_Tp)));\n\t    return;\n\t  }\n#endif\n\t::operator delete(__p\n#if __cpp_sized_deallocation\n\t\t\t  , __t * sizeof(_Tp)\n#endif\n\t\t\t );\n      }\n\n#if __cplusplus &lt;= 201703L\n      size_type\n      max_size() const _GLIBCXX_USE_NOEXCEPT\n      { return _M_max_size(); }\n\n#if __cplusplus &gt;= 201103L\n      template&lt;typename _Up, typename... _Args&gt;\n\tvoid\n\tconstruct(_Up* __p, _Args&amp;&amp;... __args)\n\tnoexcept(std::is_nothrow_constructible&lt;_Up, _Args...&gt;::value)\n\t{ ::new((void *)__p) _Up(std::forward&lt;_Args&gt;(__args)...); }\n\n      template&lt;typename _Up&gt;\n\tvoid\n\tdestroy(_Up* __p)\n\tnoexcept(std::is_nothrow_destructible&lt;_Up&gt;::value)\n\t{ __p-&gt;~_Up(); }\n#else\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 402. wrong new expression in [some_] allocator::construct\n      void\n      construct(pointer __p, const _Tp&amp; __val)\n      { ::new((void *)__p) _Tp(__val); }\n\n      void\n      destroy(pointer __p) { __p-&gt;~_Tp(); }\n#endif\n#endif // ! C++20\n\n      template&lt;typename _Up&gt;\n\tfriend _GLIBCXX20_CONSTEXPR bool\n\toperator==(const new_allocator&amp;, const new_allocator&lt;_Up&gt;&amp;)\n\t_GLIBCXX_NOTHROW\n\t{ return true; }\n\n#if __cpp_impl_three_way_comparison &lt; 201907L\n      template&lt;typename _Up&gt;\n\tfriend _GLIBCXX20_CONSTEXPR bool\n\toperator!=(const new_allocator&amp;, const new_allocator&lt;_Up&gt;&amp;)\n\t_GLIBCXX_NOTHROW\n\t{ return false; }\n#endif\n\n    private:\n      _GLIBCXX_CONSTEXPR size_type\n      _M_max_size() const _GLIBCXX_USE_NOEXCEPT\n      {\n#if __PTRDIFF_MAX__ &lt; __SIZE_MAX__\n\treturn std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);\n#else\n\treturn std::size_t(-1) / sizeof(_Tp);\n#endif\n      }\n    };\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_UTILS_CKKSPACKEDEXTENCODING_H\n#define LBCRYPTO_UTILS_CKKSPACKEDEXTENCODING_H\n\n#include &quot;constants.h&quot;\n\n#include &quot;encoding/encodingparams.h&quot;\n#include &quot;encoding/plaintext.h&quot;\n\n#include &quot;math/hal/basicint.h&quot;\n\n#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n#include &lt;initializer_list&gt;\n#include &lt;memory&gt;\n#include &lt;numeric&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\nnamespace lbcrypto {\n\n/**\n * @class CKKSPackedEncoding\n * @brief Type used for representing IntArray types.\n * Provides conversion functions to encode and decode plaintext data as type\n * vector&lt;uint64_t&gt;. This class uses bit packing techniques to enable efficient\n * computing on vectors of integers. It is NOT supported for DCRTPoly\n */\n\nclass CKKSPackedEncoding : public PlaintextImpl {\npublic:\n    // these two constructors are used inside of Decrypt\n    template &lt;typename T, typename std::enable_if&lt;std::is_same&lt;T, Poly::Params&gt;::value ||\n                                                      std::is_same&lt;T, NativePoly::Params&gt;::value ||\n                                                      std::is_same&lt;T, DCRTPoly::Params&gt;::value,\n                                                  bool&gt;::type = true&gt;\n    CKKSPackedEncoding(std::shared_ptr&lt;T&gt; vp, EncodingParams ep) : PlaintextImpl(vp, ep, CKKSRNS_SCHEME) {\n        this-&gt;slots = GetDefaultSlotSize();\n        if (this-&gt;slots &gt; (GetElementRingDimension() / 2)) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots cannot be larger than half of ring dimension&quot;);\n        }\n    }\n\n    /*\n   * @param noiseScaleDeg degree of the scaling factor of a plaintext\n   * @param level level of plaintext to create.\n   * @param scFact scaling factor of a plaintext of this level at depth 1.\n   *\n   */\n    template &lt;typename T, typename std::enable_if&lt;std::is_same&lt;T, Poly::Params&gt;::value ||\n                                                      std::is_same&lt;T, NativePoly::Params&gt;::value ||\n                                                      std::is_same&lt;T, DCRTPoly::Params&gt;::value,\n                                                  bool&gt;::type = true&gt;\n    CKKSPackedEncoding(std::shared_ptr&lt;T&gt; vp, EncodingParams ep, const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; coeffs,\n                       size_t noiseScaleDeg, uint32_t level, double scFact, size_t slots)\n        : PlaintextImpl(vp, ep, CKKSRNS_SCHEME), value(coeffs) {\n        // validate the number of slots\n        if ((slots &amp; (slots - 1)) != 0) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots should be a power of two&quot;);\n        }\n\n        this-&gt;slots = (slots) ? slots : GetDefaultSlotSize();\n\n        if (this-&gt;slots &lt; coeffs.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots cannot be smaller than value vector size&quot;);\n        }\n        else if (this-&gt;slots &gt; (GetElementRingDimension() / 2)) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots cannot be larger than half of ring dimension&quot;);\n        }\n\n        this-&gt;noiseScaleDeg = noiseScaleDeg;\n        this-&gt;level         = level;\n        this-&gt;scalingFactor = scFact;\n    }\n\n    /**\n   * @brief Constructs a container with a copy of each of the elements in rhs,\n   * in the same order.\n   * @param rhs - The input object to copy.\n   */\n    explicit CKKSPackedEncoding(const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; rhs, size_t slots)\n        : PlaintextImpl(std::shared_ptr&lt;Poly::Params&gt;(0), nullptr, CKKSRNS_SCHEME), value(rhs) {\n        // validate the number of slots\n        if ((slots &amp; (slots - 1)) != 0) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots should be a power of two&quot;);\n        }\n\n        this-&gt;slots = (slots) ? slots : GetDefaultSlotSize();\n\n        if (this-&gt;slots &lt; rhs.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots cannot be smaller than value vector size&quot;);\n        }\n        else if (this-&gt;slots &gt; (GetElementRingDimension() / 2)) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots cannot be larger than half of ring dimension&quot;);\n        }\n    }\n\n    /**\n   * @brief Default empty constructor with empty uninitialized data elements.\n   */\n    CKKSPackedEncoding() : PlaintextImpl(std::shared_ptr&lt;Poly::Params&gt;(0), nullptr, CKKSRNS_SCHEME) {\n        this-&gt;slots = GetDefaultSlotSize();\n        if (this-&gt;slots &gt; (GetElementRingDimension() / 2)) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots cannot be larger than half of ring dimension&quot;);\n        }\n    }\n\n    CKKSPackedEncoding(const CKKSPackedEncoding&amp; rhs)\n        : PlaintextImpl(rhs), value(rhs.value), m_logError(rhs.m_logError) {}\n\n    CKKSPackedEncoding(CKKSPackedEncoding&amp;&amp; rhs)\n        : PlaintextImpl(std::move(rhs)), value(std::move(rhs.value)), m_logError(rhs.m_logError) {}\n\n    bool Encode();\n\n    bool Decode() {\n        &quot;hey&quot;; OPENFHE_THROW(not_available_error,\n                      &quot;CKKSPackedEncoding::Decode() is not implemented. Use CKKSPackedEncoding::Decode(...) instead.&quot;);\n    }\n\n    bool Decode(size_t depth, double scalingFactor, ScalingTechnique scalTech, ExecutionMode executionMode);\n\n    const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; GetCKKSPackedValue() const {\n        return value;\n    }\n\n    const std::vector&lt;double&gt; GetRealPackedValue() const {\n        std::vector&lt;double&gt; realValue(value.size());\n        std::transform(value.begin(), value.end(), realValue.begin(),\n                       [](std::complex&lt;double&gt; da) { return da.real(); });\n\n        return realValue;\n    }\n\n    /**\n   * Static utility method to multiply two numbers in CRT representation.\n   * CRT representation is stored in a vector of native integers, and each\n   * position corresponds to the remainder of the number against one of\n   * the moduli in mods.\n   *\n   * @param a is the first number in CRT representation.\n   * @param b is the second number in CRT representation.\n   * @return the product of the two numbers in CRT representation.\n   */\n    static std::vector&lt;DCRTPoly::Integer&gt; CRTMult(const std::vector&lt;DCRTPoly::Integer&gt;&amp; a,\n                                                  const std::vector&lt;DCRTPoly::Integer&gt;&amp; b,\n                                                  const std::vector&lt;DCRTPoly::Integer&gt;&amp; mods);\n\n    /**\n   * GetEncodingType\n   * @return CKKS_PACKED_ENCODING\n   */\n    PlaintextEncodings GetEncodingType() const {\n        return CKKS_PACKED_ENCODING;\n    }\n\n    /**\n   * Get method to return the length of plaintext\n   *\n   * @return the length of the plaintext in terms of the number of bits.\n   */\n    size_t GetLength() const {\n        return value.size();\n    }\n\n    /**\n   * Get method to return log2 of estimated standard deviation of approximation\n   * error\n   */\n    double GetLogError() const {\n        return m_logError;\n    }\n\n    /**\n   * Get method to return log2 of estimated precision\n   */\n    double GetLogPrecision() const {\n        return encodingParams-&gt;GetPlaintextModulus() - m_logError;\n    }\n\n    /**\n   * SetLength of the plaintext to the given size\n   * @param siz\n   */\n    void SetLength(size_t siz) {\n        value.resize(siz);\n    }\n\n    /**\n   * Method to compare two plaintext to test for equivalence.  This method does\n   * not test that the plaintext are of the same type.\n   *\n   * @param other - the other plaintext to compare to.\n   * @return whether the two plaintext are equivalent.\n   */\n    bool CompareTo(const PlaintextImpl&amp; other) const {\n        const auto&amp; rv = static_cast&lt;const CKKSPackedEncoding&amp;&gt;(other);\n        return this-&gt;value == rv.value;\n    }\n\n    /**\n   * @brief Destructor method.\n   */\n    static void Destroy();\n\n    void PrintValue(std::ostream&amp; out) const {\n        // for sanity&#x27;s sake, trailing zeros get elided into &quot;...&quot;\n        // out.precision(15);\n        out &lt;&lt; &quot;(&quot;;\n        size_t i = value.size();\n        while (--i &gt; 0)\n            if (value[i] != std::complex&lt;double&gt;(0, 0))\n                break;\n\n        for (size_t j = 0; j &lt;= i; j++) {\n            out &lt;&lt; value[j].real() &lt;&lt; &quot;, &quot;;\n        }\n\n        out &lt;&lt; &quot; ... ); &quot;;\n        out &lt;&lt; &quot;Estimated precision: &quot; &lt;&lt; encodingParams-&gt;GetPlaintextModulus() - m_logError &lt;&lt; &quot; bits&quot; &lt;&lt; std::endl;\n    }\n\nprivate:\n    std::vector&lt;std::complex&lt;double&gt;&gt; value;\n\n    double m_logError = 0;\n\nprotected:\n    usint GetDefaultSlotSize() {\n        auto batchSize = GetEncodingParams()-&gt;GetBatchSize();\n        return (0 == batchSize) ? GetElementRingDimension() / 2 : batchSize;\n    }\n    /**\n   * Set modulus and recalculates the vector values to fit the modulus\n   *\n   * @param &amp;vec input vector\n   * @param &amp;bigValue big bound of the vector values.\n   * @param &amp;modulus modulus to be set for vector.\n   */\n    void FitToNativeVector(const std::vector&lt;int64_t&gt;&amp; vec, int64_t bigBound, NativeVector* nativeVec) const;\n\n#if NATIVEINT == 128 &amp;&amp; !defined(__EMSCRIPTEN__)\n    /**\n   * Set modulus and recalculates the vector values to fit the modulus\n   *\n   * @param &amp;vec input vector\n   * @param &amp;bigValue big bound of the vector values.\n   * @param &amp;modulus modulus to be set for vector.\n   */\n    void FitToNativeVector(const std::vector&lt;int128_t&gt;&amp; vec, int128_t bigBound, NativeVector* nativeVec) const;\n#endif\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_BASE_SCHEME_H\n#define LBCRYPTO_CRYPTO_BASE_SCHEME_H\n\n#include &quot;key/evalkey-fwd.h&quot;\n#include &quot;schemebase/base-parametergeneration.h&quot;\n#include &quot;keyswitch/keyswitch-base.h&quot;\n#include &quot;schemebase/base-advancedshe.h&quot;\n#include &quot;schemebase/base-leveledshe.h&quot;\n#include &quot;schemebase/base-multiparty.h&quot;\n#include &quot;schemebase/base-fhe.h&quot;\n#include &quot;schemebase/base-pke.h&quot;\n#include &quot;schemebase/base-pre.h&quot;\n#include &quot;ciphertext.h&quot;\n\n#include &quot;key/keypair.h&quot;\n\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/caller_info.h&quot;\n\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;memory&gt;\n#include &lt;utility&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\n\ntemplate &lt;typename Element&gt;\nclass KeyPair;\n\n// TODO: fix DCRTPoly passed by value\n\n/**\n * @brief Abstract interface for public key encryption schemes\n * @tparam Element a ring element.\n */\ntemplate &lt;typename Element&gt;\nclass SchemeBase {\n    using ParmType = typename Element::Params;\n    using IntType  = typename Element::Integer;\n    using DugType  = typename Element::DugType;\n    using DggType  = typename Element::DggType;\n    using TugType  = typename Element::TugType;\n\nprotected:\n    inline void CheckMultipartyDecryptCompatibility(ConstCiphertext&lt;Element&gt;&amp; ciphertext, CALLER_INFO_ARGS_HDR) const {\n        if (ciphertext-&gt;GetElements().size() &gt; 2) {\n            std::string errorMsg(std::string(&quot;ciphertext&#x27;s number of elements is [&quot;) +\n                                 std::to_string(ciphertext-&gt;GetElements().size()) +\n                                 &quot;]. Must be 2 or less for Multiparty Decryption.&quot; + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(openfhe_error, errorMsg);\n        }\n    }\n\npublic:\n    SchemeBase() {}\n\n    virtual ~SchemeBase() {}\n\n    virtual bool operator==(const SchemeBase&amp; sch) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;operator== is not supported&quot;);\n    }\n\n    virtual bool operator!=(const SchemeBase&amp; sch) const {\n        return !(*this == sch);\n    }\n\n    /**\n   * Enable features with a bit mast of PKESchemeFeature codes\n   * @param mask\n   */\n    virtual void Enable(usint mask) {\n        if (mask &amp; PKE)\n            Enable(PKE);\n        if (mask &amp; KEYSWITCH)\n            Enable(KEYSWITCH);\n        if (mask &amp; LEVELEDSHE)\n            Enable(LEVELEDSHE);\n        if (mask &amp; ADVANCEDSHE)\n            Enable(ADVANCEDSHE);\n        if (mask &amp; PRE)\n            Enable(PRE);\n        if (mask &amp; MULTIPARTY)\n            Enable(MULTIPARTY);\n        if (mask &amp; FHE)\n            Enable(FHE);\n        if (mask &amp; SCHEMESWITCH)\n            Enable(SCHEMESWITCH);\n    }\n\n    virtual usint GetEnabled() const {\n        usint flag = 0;\n        if (m_PKE != nullptr)\n            flag |= PKE;\n        if (m_KeySwitch != nullptr)\n            flag |= KEYSWITCH;\n        if (m_LeveledSHE != nullptr)\n            flag |= LEVELEDSHE;\n        if (m_AdvancedSHE != nullptr)\n            flag |= ADVANCEDSHE;\n        if (m_PRE != nullptr)\n            flag |= PRE;\n        if (m_Multiparty != nullptr)\n            flag |= MULTIPARTY;\n        if (m_FHE != nullptr)\n            flag |= FHE;\n        if (m_SchemeSwitch != nullptr)\n            flag |= SCHEMESWITCH;\n        return flag;\n    }\n\n    // instantiated in the scheme implementation class\n    virtual void Enable(PKESchemeFeature feature) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Enable is not implemented&quot;);\n    }\n\n    //------------------------------------------------------------------------------\n    // PARAMETER GENERATION WRAPPER\n    //------------------------------------------------------------------------------\n\n    virtual bool ParamsGenBFVRNS(std::shared_ptr&lt;CryptoParametersBase&lt;Element&gt;&gt; cryptoParams, uint32_t evalAddCount,\n                                 uint32_t multiplicativeDepth, uint32_t keySwitchCount, size_t dcrtBits, uint32_t n,\n                                 uint32_t numPartQ) const {\n        if (!m_ParamsGen)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;m_ParamsGen is nullptr&quot;);\n        return m_ParamsGen-&gt;ParamsGenBFVRNS(cryptoParams, evalAddCount, multiplicativeDepth, keySwitchCount, dcrtBits,\n                                            n, numPartQ);\n    }\n\n    virtual bool ParamsGenCKKSRNS(std::shared_ptr&lt;CryptoParametersBase&lt;Element&gt;&gt; cryptoParams, usint cyclOrder,\n                                  usint numPrimes, usint scalingModSize, usint firstModSize, uint32_t numPartQ,\n                                  COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel) const {\n        if (!m_ParamsGen)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;m_ParamsGen is nullptr&quot;);\n        return m_ParamsGen-&gt;ParamsGenCKKSRNS(cryptoParams, cyclOrder, numPrimes, scalingModSize, firstModSize, numPartQ,\n                                             mPIntBootCiphertextCompressionLevel);\n    }\n\n    virtual bool ParamsGenBGVRNS(std::shared_ptr&lt;CryptoParametersBase&lt;DCRTPoly&gt;&gt; cryptoParams, uint32_t evalAddCount,\n                                 uint32_t keySwitchCount, usint cyclOrder, usint numPrimes, usint firstModSize,\n                                 usint dcrtBits, uint32_t numPartQ, usint multihopQBound) const {\n        if (!m_ParamsGen)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;m_ParamsGen is nullptr&quot;);\n        return m_ParamsGen-&gt;ParamsGenBGVRNS(cryptoParams, evalAddCount, keySwitchCount, cyclOrder, numPrimes,\n                                            firstModSize, dcrtBits, numPartQ, multihopQBound);\n    }\n\n    /////////////////////////////////////////\n    // PKE WRAPPER\n    /////////////////////////////////////////\n\n    virtual KeyPair&lt;Element&gt; KeyGen(CryptoContext&lt;Element&gt; cc, bool makeSparse) {\n        VerifyPKEEnabled(__func__);\n        return m_PKE-&gt;KeyGenInternal(cc, makeSparse);\n    }\n\n    virtual Ciphertext&lt;Element&gt; Encrypt(const Element&amp; plaintext, const PrivateKey&lt;Element&gt; privateKey) const {\n        VerifyPKEEnabled(__func__);\n        //      if (!plaintext)\n        //        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n\n        return m_PKE-&gt;Encrypt(plaintext, privateKey);\n    }\n\n    virtual Ciphertext&lt;Element&gt; Encrypt(const Element&amp; plaintext, const PublicKey&lt;Element&gt; publicKey) const {\n        VerifyPKEEnabled(__func__);\n        //      if (!plaintext)\n        //        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        if (!publicKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input public key is nullptr&quot;);\n\n        return m_PKE-&gt;Encrypt(plaintext, publicKey);\n    }\n\n    virtual DecryptResult Decrypt(ConstCiphertext&lt;Element&gt; ciphertext, const PrivateKey&lt;Element&gt; privateKey,\n                                  NativePoly* plaintext) const {\n        VerifyPKEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        return m_PKE-&gt;Decrypt(ciphertext, privateKey, plaintext);\n    }\n\n    virtual DecryptResult Decrypt(ConstCiphertext&lt;Element&gt; ciphertext, const PrivateKey&lt;Element&gt; privateKey,\n                                  Poly* plaintext) const {\n        VerifyPKEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        return m_PKE-&gt;Decrypt(ciphertext, privateKey, plaintext);\n    }\n\n    std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EncryptZeroCore(const PrivateKey&lt;Element&gt; privateKey) const {\n        VerifyPKEEnabled(__func__);\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        return m_PKE-&gt;EncryptZeroCore(privateKey, nullptr);\n    }\n\n    std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EncryptZeroCore(const PublicKey&lt;Element&gt; publicKey) const {\n        VerifyPKEEnabled(__func__);\n        if (!publicKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input public key is nullptr&quot;);\n        return m_PKE-&gt;EncryptZeroCore(publicKey, nullptr);\n    }\n\n    Element DecryptCore(ConstCiphertext&lt;Element&gt; ciphertext, const PrivateKey&lt;Element&gt; privateKey) const {\n        VerifyPKEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        return m_PKE-&gt;DecryptCore(ciphertext-&gt;GetElements(), privateKey);\n    }\n\n    /////////////////////////////////////////\n    // KEY SWITCH WRAPPER\n    /////////////////////////////////////////\n\n    virtual EvalKey&lt;Element&gt; KeySwitchGen(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                          const PrivateKey&lt;Element&gt; newPrivateKey) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!oldPrivateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first private key is nullptr&quot;);\n        if (!newPrivateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second private key is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchGenInternal(oldPrivateKey, newPrivateKey);\n    }\n\n    virtual EvalKey&lt;Element&gt; KeySwitchGen(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                          const PrivateKey&lt;Element&gt; newPrivateKey,\n                                          const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!oldPrivateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first private key is nullptr&quot;);\n        if (!newPrivateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second private key is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input eval key is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchGenInternal(oldPrivateKey, newPrivateKey, evalKey);\n    }\n\n    virtual EvalKey&lt;Element&gt; KeySwitchGen(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                          const PublicKey&lt;Element&gt; newPublicKey) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!oldPrivateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first private key is nullptr&quot;);\n        if (!newPublicKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second public key is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchGenInternal(oldPrivateKey, newPublicKey);\n    }\n\n    virtual Ciphertext&lt;Element&gt; KeySwitch(ConstCiphertext&lt;Element&gt; ciphertext, const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitch(ciphertext, evalKey);\n    }\n\n    virtual void KeySwitchInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        m_KeySwitch-&gt;KeySwitchInPlace(ciphertext, evalKey);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; KeySwitchDown(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchDown(ciphertext);\n    }\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EvalKeySwitchPrecomputeCore(\n        const Element&amp; c, std::shared_ptr&lt;CryptoParametersBase&lt;Element&gt;&gt; cryptoParamsBase) const {\n        VerifyKeySwitchEnabled(__func__);\n        return m_KeySwitch-&gt;EvalKeySwitchPrecomputeCore(c, cryptoParamsBase);\n    }\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EvalFastKeySwitchCoreExt(\n        const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits, const EvalKey&lt;Element&gt; evalKey,\n        const std::shared_ptr&lt;ParmType&gt; params) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (nullptr == digits)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input digits is nullptr&quot;);\n        if (digits-&gt;size() == 0)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input digits size is 0&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        if (!params)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input params is nullptr&quot;);\n        return m_KeySwitch-&gt;EvalFastKeySwitchCoreExt(digits, evalKey, params);\n    }\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EvalFastKeySwitchCore(\n        const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits, const EvalKey&lt;Element&gt; evalKey,\n        const std::shared_ptr&lt;ParmType&gt; params) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (nullptr == digits)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input digits is nullptr&quot;);\n        if (digits-&gt;size() == 0)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input digits size is 0&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        if (!params)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input params is nullptr&quot;);\n        return m_KeySwitch-&gt;EvalFastKeySwitchCore(digits, evalKey, params);\n    }\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; KeySwitchCore(const Element&amp; a,\n                                                                const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchCore(a, evalKey);\n    }\n\n    /////////////////////////////////////////\n    // PRE WRAPPER\n    /////////////////////////////////////////\n\n    virtual EvalKey&lt;Element&gt; ReKeyGen(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                      const PublicKey&lt;Element&gt; newPublicKey) const;\n\n    virtual Ciphertext&lt;Element&gt; ReEncrypt(ConstCiphertext&lt;Element&gt; ciphertext, const EvalKey&lt;Element&gt; evalKey,\n                                          const PublicKey&lt;Element&gt; publicKey) const;\n\n    /////////////////////////////////////////\n    // SHE NEGATION WRAPPER\n    /////////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalNegate(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalNegate(ciphertext);\n    }\n\n    virtual void EvalNegateInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalNegateInPlace(ciphertext);\n        return;\n    }\n\n    /////////////////////////////////////////\n    // SHE ADDITION Wrapper\n    /////////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                        ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalAdd(ciphertext1, ciphertext2);\n    }\n\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalAddInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalAddMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1,\n                                               Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalAddMutable(ciphertext1, ciphertext2);\n    }\n\n    virtual void EvalAddMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalAddMutableInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalAdd(ciphertext, plaintext);\n    }\n\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, ConstPlaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalAddInPlace(ciphertext, plaintext);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalAddMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalAddMutable(ciphertext, plaintext);\n    }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, const NativeInteger &amp;constant) const {\n    //  VerifyLeveledSHEEnabled(__func__);\n    //  if (!ciphertext)\n    //      &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n\n    //  return m_LeveledSHE-&gt;EvalAdd(ciphertext, constant);\n    //}\n\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const NativeInteger&amp; constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalAddInPlace(ciphertext, constant);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalAdd(ciphertext, constant);\n    }\n\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalAddInPlace(ciphertext, constant);\n        return;\n    }\n\n    /////////////////////////////////////////\n    // SHE SUBTRACTION Wrapper\n    /////////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                        ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSub(ciphertext1, ciphertext2);\n    }\n\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalSubInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSubMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1,\n                                               Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSubMutable(ciphertext1, ciphertext2);\n    }\n\n    virtual void EvalSubMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalSubMutableInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSub(ciphertext, plaintext);\n    }\n\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, ConstPlaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalSubInPlace(ciphertext, plaintext);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSubMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSubMutable(ciphertext, plaintext);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, const NativeInteger&amp; constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSub(ciphertext, constant);\n    }\n\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const NativeInteger&amp; constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalSubInPlace(ciphertext, constant);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSub(ciphertext, constant);\n    }\n\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalSubInPlace(ciphertext, constant);\n        return;\n    }\n\n    /////////////////////////////////////////\n    // SHE MULTIPLICATION Wrapper\n    /////////////////////////////////////////\n\n    virtual EvalKey&lt;Element&gt; EvalMultKeyGen(const PrivateKey&lt;Element&gt; privateKey) const;\n\n    virtual std::vector&lt;EvalKey&lt;Element&gt;&gt; EvalMultKeysGen(const PrivateKey&lt;Element&gt; privateKey) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                         ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMult(ciphertext1, ciphertext2);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMultMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1,\n                                                Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMultMutable(ciphertext1, ciphertext2);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSquare(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSquare(ciphertext);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSquareMutable(Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSquareMutable(ciphertext);\n    }\n\n    /////////////////////////////////////////\n    // MULTIPLICATION With Eval Key\n    /////////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2,\n                                         const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMult(ciphertext1, ciphertext2, evalKey);\n    }\n\n    virtual void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2,\n                                 const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalMultInPlace(ciphertext1, ciphertext2, evalKey);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMultMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2,\n                                                const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMultMutable(ciphertext1, ciphertext2, evalKey);\n    }\n\n    virtual void EvalMultMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2,\n                                        const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalMultMutableInPlace(ciphertext1, ciphertext2, evalKey);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSquare(ConstCiphertext&lt;Element&gt; ciphertext, const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSquare(ciphertext, evalKey);\n    }\n\n    virtual void EvalSquareInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalSquareInPlace(ciphertext, evalKey);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSquareMutable(Ciphertext&lt;Element&gt;&amp; ciphertext,\n                                                  const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSquareMutable(ciphertext, evalKey);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMultAndRelinearize(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                       ConstCiphertext&lt;Element&gt; ciphertext2,\n                                                       const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        if (!evalKeyVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key vector is empty&quot;);\n        return m_LeveledSHE-&gt;EvalMultAndRelinearize(ciphertext1, ciphertext2, evalKeyVec);\n    }\n\n    virtual Ciphertext&lt;Element&gt; Relinearize(ConstCiphertext&lt;Element&gt; ciphertext,\n                                            const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKeyVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key vector is empty&quot;);\n        return m_LeveledSHE-&gt;Relinearize(ciphertext, evalKeyVec);\n    }\n\n    virtual void RelinearizeInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext,\n                                    const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKeyVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key vector is empty&quot;);\n        m_LeveledSHE-&gt;RelinearizeInPlace(ciphertext, evalKeyVec);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMult(ciphertext, plaintext);\n    }\n\n    virtual void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, ConstPlaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalMultInPlace(ciphertext, plaintext);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMultMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMultMutable(ciphertext, plaintext);\n    }\n\n    virtual Ciphertext&lt;Element&gt; MultByMonomial(ConstCiphertext&lt;Element&gt; ciphertext, usint power) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;MultByMonomial(ciphertext, power);\n    }\n\n    virtual void MultByMonomialInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, usint power) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;MultByMonomialInPlace(ciphertext, power);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMult(ciphertext, constant);\n    }\n\n    virtual void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalMultInPlace(ciphertext, constant);\n        return;\n    }\n\n    virtual Ciphertext&lt;DCRTPoly&gt; MultByInteger(ConstCiphertext&lt;DCRTPoly&gt; ciphertext, uint64_t integer) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;MultByInteger(ciphertext, integer);\n    }\n\n    virtual void MultByIntegerInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, uint64_t integer) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;MultByIntegerInPlace(ciphertext, integer);\n        return;\n    }\n\n    /////////////////////////////////////////\n    // SHE AUTOMORPHISM Wrapper\n    /////////////////////////////////////////\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalAutomorphismKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::vector&lt;usint&gt;&amp; indexList) const;\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalAutomorphismKeyGen(\n        const PublicKey&lt;Element&gt; publicKey, const PrivateKey&lt;Element&gt; privateKey,\n        const std::vector&lt;usint&gt;&amp; indexList) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalAutomorphism(ConstCiphertext&lt;Element&gt; ciphertext, usint i,\n                                                 const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap,\n                                                 CALLER_INFO_ARGS_HDR) const {\n        if (m_LeveledSHE) {\n            if (!ciphertext)\n                &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n            if (!evalKeyMap.size())\n                &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is empty&quot;);\n\n            return m_LeveledSHE-&gt;EvalAutomorphism(ciphertext, i, evalKeyMap);\n        }\n        std::string errorMsg(std::string(&quot;EvalAutomorphism operation has not been enabled&quot;) + CALLER_INFO);\n        &quot;hey&quot;; OPENFHE_THROW(config_error, errorMsg);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalFastRotation(ConstCiphertext&lt;Element&gt; ciphertext, const usint index, const usint m,\n                                                 const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalFastRotation(ciphertext, index, m, digits);\n    }\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EvalFastRotationPrecompute(\n        ConstCiphertext&lt;Element&gt; ciphertext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalFastRotationPrecompute(ciphertext);\n    }\n\n    /**\n   * Only supported for hybrid key switching.\n   * Performs fast (hoisted) rotation and returns the results\n   * in the extended CRT basis P*Q\n   *\n   * @param ciphertext input ciphertext\n   * @param index the rotation index.\n   * @param precomp the precomputed digits for the ciphertext\n   * @param addFirst if true, the the first element c0 is also computed (otherwise ignored)\n   * @return resulting ciphertext\n   */\n    virtual Ciphertext&lt;Element&gt; EvalFastRotationExt(ConstCiphertext&lt;Element&gt; ciphertext, usint index,\n                                                    const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits, bool addFirst,\n                                                    const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeys) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalFastRotationExt(ciphertext, index, digits, addFirst, evalKeys);\n    }\n\n    /**\n   * Only supported for hybrid key switching.\n   * Scales down the polynomial c0 from extended basis P*Q to Q.\n   *\n   * @param ciphertext input ciphertext in the extended basis\n   * @return resulting polynomial\n   */\n    Element KeySwitchDownFirstElement(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchDownFirstElement(ciphertext);\n    }\n\n    virtual Ciphertext&lt;Element&gt; KeySwitchExt(ConstCiphertext&lt;Element&gt; ciphertext, bool addFirst) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchExt(ciphertext, addFirst);\n    }\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalAtIndexKeyGen(\n        const PublicKey&lt;Element&gt; publicKey, const PrivateKey&lt;Element&gt; privateKey,\n        const std::vector&lt;int32_t&gt;&amp; indexList) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalAtIndex(ConstCiphertext&lt;Element&gt; ciphertext, usint i,\n                                            const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is empty&quot;);\n        return m_LeveledSHE-&gt;EvalAtIndex(ciphertext, i, evalKeyMap);\n    }\n\n    virtual usint FindAutomorphismIndex(usint index, usint m) {\n        VerifyLeveledSHEEnabled(__func__);\n        return m_LeveledSHE-&gt;FindAutomorphismIndex(index, m);\n    }\n\n    /////////////////////////////////////////\n    // SHE Leveled Methods Wrapper\n    /////////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; ComposedEvalMult(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                 ConstCiphertext&lt;Element&gt; ciphertext2,\n                                                 const EvalKey&lt;Element&gt; evalKey) const;\n\n    virtual Ciphertext&lt;Element&gt; ModReduce(ConstCiphertext&lt;Element&gt; ciphertext, size_t levels) const;\n\n    virtual void ModReduceInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;ModReduceInPlace(ciphertext, levels);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; ModReduceInternal(ConstCiphertext&lt;Element&gt; ciphertext, size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;ModReduceInternal(ciphertext, levels);\n    }\n\n    virtual void ModReduceInternalInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (levels == 0)\n            return;\n        m_LeveledSHE-&gt;ModReduceInternalInPlace(ciphertext, levels);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; LevelReduce(ConstCiphertext&lt;Element&gt; ciphertext, const EvalKey&lt;Element&gt; evalKey,\n                                            size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        auto result = m_LeveledSHE-&gt;LevelReduce(ciphertext, evalKey, levels);\n        result-&gt;SetKeyTag(ciphertext-&gt;GetKeyTag());\n        return result;\n    }\n\n    virtual void LevelReduceInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const EvalKey&lt;Element&gt; evalKey,\n                                    size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;LevelReduceInPlace(ciphertext, evalKey, levels);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; LevelReduceInternal(ConstCiphertext&lt;Element&gt; ciphertext, size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;LevelReduceInternal(ciphertext, levels);\n    }\n\n    virtual void LevelReduceInternalInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;LevelReduceInternalInPlace(ciphertext, levels);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; Compress(ConstCiphertext&lt;Element&gt; ciphertext, size_t towersLeft) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;Compress(ciphertext, towersLeft);\n    }\n\n    virtual void AdjustLevelsInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1, Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext1 is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext2 is nullptr&quot;);\n        m_LeveledSHE-&gt;AdjustLevelsInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    virtual void AdjustLevelsAndDepthInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1,\n                                             Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext1 is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext2 is nullptr&quot;);\n        m_LeveledSHE-&gt;AdjustLevelsAndDepthInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    virtual void AdjustLevelsAndDepthToOneInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1,\n                                                  Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext1 is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext2 is nullptr&quot;);\n        m_LeveledSHE-&gt;AdjustLevelsAndDepthToOneInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    /////////////////////////////////////////\n    // Advanced SHE Wrapper\n    /////////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalAddMany(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalAddMany(ciphertextVec);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalAddManyInPlace(std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n\n        return m_AdvancedSHE-&gt;EvalAddManyInPlace(ciphertextVec);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMultMany(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                             const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n        if (!evalKeyVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key vector is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalMultMany(ciphertextVec, evalKeyVec);\n    }\n\n    /////////////////////////////////////\n    // Advanced SHE LINEAR WEIGHTED SUM\n    /////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalLinearWSum(std::vector&lt;ConstCiphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                               const std::vector&lt;double&gt;&amp; constantVec) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalLinearWSum(ciphertextVec, constantVec);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalLinearWSumMutable(std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                                      const std::vector&lt;double&gt;&amp; constantVec) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalLinearWSumMutable(ciphertextVec, constantVec);\n    }\n\n    /////////////////////////////////////\n    // Advanced SHE EVAL POLYNOMIAL\n    /////////////////////////////////////\n\n    Ciphertext&lt;Element&gt; EvalPoly(ConstCiphertext&lt;Element&gt; ciphertext, const std::vector&lt;double&gt;&amp; coefficients) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;EvalPoly(ciphertext, coefficients);\n    }\n\n    Ciphertext&lt;Element&gt; EvalPolyLinear(ConstCiphertext&lt;Element&gt; ciphertext,\n                                       const std::vector&lt;double&gt;&amp; coefficients) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;EvalPolyLinear(ciphertext, coefficients);\n    }\n\n    Ciphertext&lt;Element&gt; EvalPolyPS(ConstCiphertext&lt;Element&gt; ciphertext, const std::vector&lt;double&gt;&amp; coefficients) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;EvalPolyPS(ciphertext, coefficients);\n    }\n\n    /////////////////////////////////////\n    // Advanced SHE EVAL CHEBYSHEV SERIES\n    /////////////////////////////////////\n\n    Ciphertext&lt;Element&gt; EvalChebyshevSeries(ConstCiphertext&lt;Element&gt; ciphertext,\n                                            const std::vector&lt;double&gt;&amp; coefficients, double a, double b) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;EvalChebyshevSeries(ciphertext, coefficients, a, b);\n    }\n\n    Ciphertext&lt;Element&gt; EvalChebyshevSeriesLinear(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                  const std::vector&lt;double&gt;&amp; coefficients, double a, double b) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;EvalChebyshevSeriesLinear(ciphertext, coefficients, a, b);\n    }\n\n    Ciphertext&lt;Element&gt; EvalChebyshevSeriesPS(ConstCiphertext&lt;Element&gt; ciphertext,\n                                              const std::vector&lt;double&gt;&amp; coefficients, double a, double b) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;EvalChebyshevSeriesPS(ciphertext, coefficients, a, b);\n    }\n\n    /////////////////////////////////////\n    // Advanced SHE EVAL SUM\n    /////////////////////////////////////\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSumKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                                                             const PublicKey&lt;Element&gt; publicKey) const;\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSumRowsKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                                                                 const PublicKey&lt;Element&gt; publicKey,\n                                                                                 usint rowSize, usint subringDim) const;\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSumColsKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const PublicKey&lt;Element&gt; publicKey) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalSum(ConstCiphertext&lt;Element&gt; ciphertext, usint batchSize,\n                                        const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalSum(ciphertext, batchSize, evalKeyMap);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSumRows(ConstCiphertext&lt;Element&gt; ciphertext, usint rowSize,\n                                            const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap,\n                                            usint subringDim) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalSumRows(ciphertext, rowSize, evalKeyMap, subringDim);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSumCols(ConstCiphertext&lt;Element&gt; ciphertext, usint batchSize,\n                                            const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap,\n                                            const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; rightEvalKeyMap) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!evalKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first evaluation key map is empty&quot;);\n        if (!rightEvalKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second evaluation key map is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalSumCols(ciphertext, batchSize, evalKeyMap, rightEvalKeyMap);\n    }\n\n    /////////////////////////////////////\n    // Advanced SHE EVAL INNER PRODUCT\n    /////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalInnerProduct(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                 ConstCiphertext&lt;Element&gt; ciphertext2, usint batchSize,\n                                                 const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalSumKeyMap,\n                                                 const EvalKey&lt;Element&gt; evalMultKey) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalInnerProduct(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext,\n                                                 usint batchSize,\n                                                 const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalSumKeyMap) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        if (!evalSumKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalInnerProduct(ciphertext, plaintext, batchSize, evalSumKeyMap);\n    }\n\n    virtual Ciphertext&lt;Element&gt; AddRandomNoise(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;AddRandomNoise(ciphertext);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMerge(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                          const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n        if (!evalKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalMerge(ciphertextVec, evalKeyMap);\n    }\n\n    /////////////////////////////////////////\n    // MULTIPARTY WRAPPER\n    /////////////////////////////////////////\n\n    virtual KeyPair&lt;Element&gt; MultipartyKeyGen(CryptoContext&lt;Element&gt; cc,\n                                              const std::vector&lt;PrivateKey&lt;Element&gt;&gt;&amp; privateKeyVec, bool makeSparse);\n\n    virtual KeyPair&lt;Element&gt; MultipartyKeyGen(CryptoContext&lt;Element&gt; cc, const PublicKey&lt;Element&gt; publicKey,\n                                              bool makeSparse, bool PRE);\n\n    virtual Ciphertext&lt;Element&gt; MultipartyDecryptMain(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                      const PrivateKey&lt;Element&gt; privateKey) const;\n\n    virtual Ciphertext&lt;Element&gt; MultipartyDecryptLead(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                      const PrivateKey&lt;Element&gt; privateKey) const;\n\n    virtual DecryptResult MultipartyDecryptFusion(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                                  NativePoly* plaintext) const {\n        VerifyMultipartyEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n\n        return m_Multiparty-&gt;MultipartyDecryptFusion(ciphertextVec, plaintext);\n    }\n\n    virtual DecryptResult MultipartyDecryptFusion(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                                  Poly* plaintext) const {\n        VerifyMultipartyEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n        return m_Multiparty-&gt;MultipartyDecryptFusion(ciphertextVec, plaintext);\n    }\n\n    virtual EvalKey&lt;Element&gt; MultiKeySwitchGen(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                               const PrivateKey&lt;Element&gt; newPrivateKey,\n                                               const EvalKey&lt;Element&gt; evalKey) const;\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiEvalAutomorphismKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalAutoKeyMap,\n        const std::vector&lt;usint&gt;&amp; indexList, const std::string&amp; keyId);\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiEvalAtIndexKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalAutoKeyMap,\n        const std::vector&lt;int32_t&gt;&amp; indexList, const std::string&amp; keyId);\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiEvalSumKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalSumKeyMap,\n        const std::string&amp; keyId = &quot;&quot;);\n\n    virtual EvalKey&lt;Element&gt; MultiAddEvalKeys(EvalKey&lt;Element&gt; evalKey1, EvalKey&lt;Element&gt; evalKey2,\n                                              const std::string&amp; keyId);\n\n    virtual EvalKey&lt;Element&gt; MultiMultEvalKey(PrivateKey&lt;Element&gt; privateKey, EvalKey&lt;Element&gt; evalKey,\n                                              const std::string&amp; keyId);\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiAddEvalSumKeys(\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalSumKeyMap1,\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalSumKeyMap2, const std::string&amp; keyId);\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiAddEvalAutomorphismKeys(\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalSumKeyMap1,\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalSumKeyMap2, const std::string&amp; keyId);\n\n    virtual PublicKey&lt;Element&gt; MultiAddPubKeys(PublicKey&lt;Element&gt; publicKey1, PublicKey&lt;Element&gt; publicKey2,\n                                               const std::string&amp; keyId);\n\n    virtual EvalKey&lt;Element&gt; MultiAddEvalMultKeys(EvalKey&lt;Element&gt; evalKey1, EvalKey&lt;Element&gt; evalKey2,\n                                                  const std::string&amp; keyId);\n\n    virtual Ciphertext&lt;Element&gt; IntMPBootAdjustScale(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        if (m_Multiparty) {\n            return m_Multiparty-&gt;IntMPBootAdjustScale(ciphertext);\n        }\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;IntMPBootAdjustScale operation has not been enabled&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; IntMPBootRandomElementGen(std::shared_ptr&lt;CryptoParametersCKKSRNS&gt; cryptoParameters,\n                                                          const PublicKey&lt;Element&gt; publicKey) const {\n        if (m_Multiparty) {\n            return m_Multiparty-&gt;IntMPBootRandomElementGen(cryptoParameters, publicKey);\n        }\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;IntMPBootRandomElementGen operation has not been enabled&quot;);\n    }\n\n    virtual std::vector&lt;Ciphertext&lt;Element&gt;&gt; IntMPBootDecrypt(const PrivateKey&lt;Element&gt; privateKey,\n                                                              ConstCiphertext&lt;Element&gt; ciphertext,\n                                                              ConstCiphertext&lt;Element&gt; a) const {\n        if (m_Multiparty) {\n            return m_Multiparty-&gt;IntMPBootDecrypt(privateKey, ciphertext, a);\n        }\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;IntMPBootDecrypt operation has not been enabled&quot;);\n    }\n\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; IntMPBootAdd(std::vector&lt;std::vector&lt;Ciphertext&lt;Element&gt;&gt;&gt;&amp; sharesPairVec) const {\n        if (m_Multiparty) {\n            return m_Multiparty-&gt;IntMPBootAdd(sharesPairVec);\n        }\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;IntMPBootAdd operation has not been enabled&quot;);\n    }\n\n    Ciphertext&lt;Element&gt; IntMPBootEncrypt(const PublicKey&lt;Element&gt; publicKey,\n                                         const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; sharesPair, ConstCiphertext&lt;Element&gt; a,\n                                         ConstCiphertext&lt;Element&gt; ciphertext) const {\n        if (m_Multiparty) {\n            return m_Multiparty-&gt;IntMPBootEncrypt(publicKey, sharesPair, a, ciphertext);\n        }\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;IntMPBootEncrypt operation has not been enabled&quot;);\n    }\n\n    // FHE METHODS\n\n    // TODO Andrey: do we need this method?\n    //  const std::shared_ptr&lt;PKEBase&lt;Element&gt;&gt; getAlgorithm() const { return m_PKE; }\n\n    void EvalBootstrapSetup(const CryptoContextImpl&lt;Element&gt;&amp; cc, const std::vector&lt;uint32_t&gt;&amp; levelBudget = {5, 4},\n                            const std::vector&lt;uint32_t&gt;&amp; dim1 = {0, 0}, uint32_t slots = 0,\n                            uint32_t correctionFactor = 0) {\n        VerifyFHEEnabled(__func__);\n        m_FHE-&gt;EvalBootstrapSetup(cc, levelBudget, dim1, slots, correctionFactor);\n        return;\n    }\n\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalBootstrapKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                                                           uint32_t slots) {\n        VerifyFHEEnabled(__func__);\n        return m_FHE-&gt;EvalBootstrapKeyGen(privateKey, slots);\n    }\n\n    Ciphertext&lt;Element&gt; EvalBootstrap(ConstCiphertext&lt;Element&gt; ciphertext, uint32_t numIterations = 1,\n                                      uint32_t precision = 0) const {\n        VerifyFHEEnabled(__func__);\n        return m_FHE-&gt;EvalBootstrap(ciphertext, numIterations, precision);\n    }\n\n    // SCHEMESWITCHING methods\n\n    std::pair&lt;BinFHEContext, LWEPrivateKey&gt; EvalCKKStoFHEWSetup(const CryptoContextImpl&lt;Element&gt;&amp; cc,\n                                                                SecurityLevel sl      = HEStd_128_classic,\n                                                                BINFHE_PARAMSET slBin = STD128, bool arbFunc = false,\n                                                                uint32_t logQ = 29, bool dynamic = false,\n                                                                uint32_t numSlotsCKKS = 0, uint32_t logQswitch = 27) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalCKKStoFHEWSetup(cc, sl, slBin, arbFunc, logQ, dynamic, numSlotsCKKS, logQswitch);\n    }\n\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalCKKStoFHEWKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair,\n                                                                            ConstLWEPrivateKey&amp; lwesk,\n                                                                            uint32_t dim1 = 0, uint32_t L = 1) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalCKKStoFHEWKeyGen(keyPair, lwesk, dim1, L);\n    }\n\n    void EvalCKKStoFHEWPrecompute(const CryptoContextImpl&lt;Element&gt;&amp; cc, double scale = 1.0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalCKKStoFHEWPrecompute(cc, scale);\n    }\n\n    std::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt; EvalCKKStoFHEW(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                   uint32_t numCtxts = 0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalCKKStoFHEW(ciphertext, numCtxts);\n    }\n\n    void EvalFHEWtoCKKSSetup(const CryptoContextImpl&lt;DCRTPoly&gt;&amp; ccCKKS, const BinFHEContext&amp; ccLWE,\n                             uint32_t numSlotsCKKS = 0, uint32_t logQ = 25) {\n        VerifySchemeSwitchEnabled(__func__);\n        m_SchemeSwitch-&gt;EvalFHEWtoCKKSSetup(ccCKKS, ccLWE, numSlotsCKKS, logQ);\n        return;\n    }\n\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalFHEWtoCKKSKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair,\n                                                                            ConstLWEPrivateKey&amp; lwesk,\n                                                                            uint32_t numSlots = 0, uint32_t dim1 = 0,\n                                                                            uint32_t L = 0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalFHEWtoCKKSKeyGen(keyPair, lwesk, numSlots, dim1, L);\n    }\n\n    void EvalCompareSwitchPrecompute(const CryptoContextImpl&lt;Element&gt;&amp; ccCKKS, uint32_t pLWE = 0,\n                                     uint32_t initLevel = 0, double scaleSign = 1.0, bool unit = false) {\n        VerifySchemeSwitchEnabled(__func__);\n        m_SchemeSwitch-&gt;EvalCompareSwitchPrecompute(ccCKKS, pLWE, initLevel, scaleSign, unit);\n        return;\n    }\n\n    Ciphertext&lt;Element&gt; EvalFHEWtoCKKS(std::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt;&amp; LWECiphertexts,\n                                       uint32_t numCtxts = 0, uint32_t numSlots = 0, uint32_t p = 4, double pmin = 0.0,\n                                       double pmax = 2.0) const {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalFHEWtoCKKS(LWECiphertexts, numCtxts, numSlots, p, pmin, pmax);\n    }\n\n    std::pair&lt;BinFHEContext, LWEPrivateKey&gt; EvalSchemeSwitchingSetup(const CryptoContextImpl&lt;DCRTPoly&gt;&amp; cc,\n                                                                     SecurityLevel sl      = HEStd_128_classic,\n                                                                     BINFHE_PARAMSET slBin = STD128,\n                                                                     bool arbFunc = false, uint32_t logQ = 29,\n                                                                     bool dynamic = false, uint32_t numSlotsCKKS = 0,\n                                                                     uint32_t logQswitch = 27) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalSchemeSwitchingSetup(cc, sl, slBin, arbFunc, logQ, dynamic, numSlotsCKKS,\n                                                        logQswitch);\n    }\n\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSchemeSwitchingKeyGen(\n        const KeyPair&lt;Element&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk, uint32_t numValues = 0, bool oneHot = true,\n        bool alt = false, uint32_t dim1CF = 0, uint32_t dim1FC = 0, uint32_t LCF = 1, uint32_t LFC = 0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalSchemeSwitchingKeyGen(keyPair, lwesk, numValues, oneHot, alt, dim1CF, dim1FC, LCF,\n                                                         LFC);\n    }\n\n    Ciphertext&lt;Element&gt; EvalCompareSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                   ConstCiphertext&lt;Element&gt; ciphertext2, uint32_t numCtxts = 0,\n                                                   uint32_t numSlots = 0, uint32_t pLWE = 0, double scaleSign = 1.0,\n                                                   bool unit = false) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalCompareSchemeSwitching(ciphertext1, ciphertext2, numCtxts, numSlots, pLWE, scaleSign,\n                                                          unit);\n    }\n\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMinSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                            PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                            uint32_t numSlots = 0, bool oneHot = true,\n                                                            uint32_t pLWE = 0, double scaleSign = 1.0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalMinSchemeSwitching(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE,\n                                                      scaleSign);\n    }\n\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMinSchemeSwitchingAlt(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                               PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                               uint32_t numSlots = 0, bool oneHot = true,\n                                                               uint32_t pLWE = 0, double scaleSign = 1.0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalMinSchemeSwitchingAlt(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE,\n                                                         scaleSign);\n    }\n\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMaxSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                            PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                            uint32_t numSlots = 0, bool oneHot = true,\n                                                            uint32_t pLWE = 0, double scaleSign = 1.0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalMaxSchemeSwitching(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE,\n                                                      scaleSign);\n    }\n\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMaxSchemeSwitchingAlt(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                               PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                               uint32_t numSlots = 0, bool oneHot = true,\n                                                               uint32_t pLWE = 0, double scaleSign = 1.0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalMaxSchemeSwitchingAlt(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE,\n                                                         scaleSign);\n    }\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::make_nvp(&quot;enabled&quot;, GetEnabled()));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                 &quot; is from a later version of the library&quot;);\n        }\n\n        usint enabled;\n        ar(::cereal::make_nvp(&quot;enabled&quot;, enabled));\n        Enable(enabled);\n    }\n\n    virtual std::string SerializedObjectName() const {\n        return &quot;SchemeBase&quot;;\n    }\n\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\n    //=================================================================================================================\n    // Functions to check enabled features in the cryptocontext\n    //=================================================================================================================\n    /**\n    * @brief VerifyAdvancedSHEEnabled is to check if Enable(ADVANCEDSHE) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyAdvancedSHEEnabled(const std::string&amp; functionName) const {\n        if (m_AdvancedSHE == nullptr) {\n            std::string errMsg = std::string(functionName) +\n                                 &quot; operation has not been enabled. Enable(ADVANCEDSHE) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n    /**\n    * @brief VerifyMultipartyEnabled is to check if Enable(MULTIPARTY) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyMultipartyEnabled(const std::string&amp; functionName) const {\n        if (m_Multiparty == nullptr) {\n            std::string errMsg = std::string(functionName) +\n                                 &quot; operation has not been enabled. Enable(MULTIPARTY) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n    /**\n    * @brief VerifyLeveledSHEEnabled is to check if Enable(LEVELEDSHE) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyLeveledSHEEnabled(const std::string&amp; functionName) const {\n        if (m_LeveledSHE == nullptr) {\n            std::string errMsg = std::string(functionName) +\n                                 &quot; operation has not been enabled. Enable(LEVELEDSHE) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n    /**\n    * @brief VerifyPKEEnabled is to check if Enable(PKE) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyPKEEnabled(const std::string&amp; functionName) const {\n        if (m_PKE == nullptr) {\n            std::string errMsg =\n                std::string(functionName) + &quot; operation has not been enabled. Enable(PKE) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n    /**\n    * @brief VerifyPREEnabled is to check if Enable(PRE) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyPREEnabled(const std::string&amp; functionName) const {\n        if (m_PRE == nullptr) {\n            std::string errMsg =\n                std::string(functionName) + &quot; operation has not been enabled. Enable(PRE) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n    /**\n    * @brief VerifyKeySwitchEnabled is to check if Enable(KEYSWITCH) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyKeySwitchEnabled(const std::string&amp; functionName) const {\n        if (m_KeySwitch == nullptr) {\n            std::string errMsg = std::string(functionName) +\n                                 &quot; operation has not been enabled. Enable(KEYSWITCH) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n    /**\n    * @brief VerifyFHEEnabled is to check if Enable(FHE) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyFHEEnabled(const std::string&amp; functionName) const {\n        if (m_FHE == nullptr) {\n            std::string errMsg =\n                std::string(functionName) + &quot; operation has not been enabled. Enable(FHE) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n\n    /**\n    * @brief VerifySchemeSwitchEnabled is to check if Enable(SCHEMESWITCH) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifySchemeSwitchEnabled(const std::string&amp; functionName) const {\n        if (m_SchemeSwitch == nullptr) {\n            std::string errMsg = std::string(functionName) +\n                                 &quot; operation has not been enabled. Enable(SCHEMESWITCH) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const SchemeBase&lt;Element&gt;&amp; s) {\n        out &lt;&lt; typeid(s).name() &lt;&lt; &quot;:&quot;;\n        out &lt;&lt; &quot; ParamsGen &quot; &lt;&lt; (s.m_ParamsGen == 0 ? &quot;none&quot; : typeid(*s.m_ParamsGen).name());\n        out &lt;&lt; &quot;, PKE &quot; &lt;&lt; (s.m_PKE == 0 ? &quot;none&quot; : typeid(*s.m_PKE).name());\n        out &lt;&lt; &quot;, KeySwitch &quot; &lt;&lt; (s.m_KeySwitch == 0 ? &quot;none&quot; : typeid(*s.m_KeySwitch).name());\n        out &lt;&lt; &quot;, PRE &quot; &lt;&lt; (s.m_PRE == 0 ? &quot;none&quot; : typeid(*s.m_PRE).name());\n        out &lt;&lt; &quot;, LeveledSHE &quot; &lt;&lt; (s.m_LeveledSHE == 0 ? &quot;none&quot; : typeid(*s.m_LeveledSHE).name());\n        out &lt;&lt; &quot;, AdvancedSHE &quot; &lt;&lt; (s.m_AdvancedSHE == 0 ? &quot;none&quot; : typeid(*s.m_AdvancedSHE).name());\n        out &lt;&lt; &quot;, Multiparty &quot; &lt;&lt; (s.m_Multiparty == 0 ? &quot;none&quot; : typeid(*s.m_Multiparty).name());\n        out &lt;&lt; &quot;, FHE &quot; &lt;&lt; (s.m_FHE == 0 ? &quot;none&quot; : typeid(*s.m_FHE).name());\n        out &lt;&lt; &quot;, SchemeSwitch &quot; &lt;&lt; (s.m_SchemeSwitch == 0 ? &quot;none&quot; : typeid(*s.m_SchemeSwitch).name());\n\n        return out;\n    }\n\nprotected:\n    std::shared_ptr&lt;ParameterGenerationBase&lt;Element&gt;&gt; m_ParamsGen;\n    std::shared_ptr&lt;PKEBase&lt;Element&gt;&gt; m_PKE;\n    std::shared_ptr&lt;KeySwitchBase&lt;Element&gt;&gt; m_KeySwitch;\n    std::shared_ptr&lt;PREBase&lt;Element&gt;&gt; m_PRE;\n    std::shared_ptr&lt;LeveledSHEBase&lt;Element&gt;&gt; m_LeveledSHE;\n    std::shared_ptr&lt;AdvancedSHEBase&lt;Element&gt;&gt; m_AdvancedSHE;\n    std::shared_ptr&lt;MultipartyBase&lt;Element&gt;&gt; m_Multiparty;\n    std::shared_ptr&lt;FHEBase&lt;Element&gt;&gt; m_FHE;\n    std::shared_ptr&lt;FHEBase&lt;Element&gt;&gt; m_SchemeSwitch;\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  API to generate CKKS crypto context. MUST NOT (!) be used without a wrapper function\n */\n\n#ifndef _GEN_CRYPTOCONTEXT_CKKSRNS_INTERNAL_H_\n#define _GEN_CRYPTOCONTEXT_CKKSRNS_INTERNAL_H_\n\n#include &quot;encoding/encodingparams.h&quot;\n#include &quot;constants.h&quot;\n#include &quot;utils/exception.h&quot;\n#include &quot;scheme/scheme-utils.h&quot;\n#include &quot;scheme/scheme-id.h&quot;\n\n#include &lt;memory&gt;\n\nnamespace lbcrypto {\n\n// forward declarations (don&#x27;t include headers as compilation fails when you do)\ntemplate &lt;typename T&gt;\nclass CCParams;\n\ntemplate &lt;typename ContextGeneratorType, typename Element&gt;\ntypename ContextGeneratorType::ContextType genCryptoContextCKKSRNSInternal(\n    const CCParams&lt;ContextGeneratorType&gt;&amp; parameters) {\n#if NATIVEINT == 128 &amp;&amp; !defined(__EMSCRIPTEN__)\n    if (parameters.GetScalingTechnique() == FLEXIBLEAUTO || parameters.GetScalingTechnique() == FLEXIBLEAUTOEXT) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;128-bit CKKS is not supported for the FLEXIBLEAUTO or FLEXIBLEAUTOEXT methods.&quot;);\n    }\n#endif\n    using ParmType                   = typename Element::Params;\n    using IntType                    = typename Element::Integer;\n    constexpr float assuranceMeasure = 36;\n\n    auto ep = std::make_shared&lt;ParmType&gt;(0, IntType(0), IntType(0));\n\n    usint scalingModSize    = parameters.GetScalingModSize();\n    usint firstModSize      = parameters.GetFirstModSize();\n    double floodingNoiseStd = 0;\n    if (parameters.GetDecryptionNoiseMode() == NOISE_FLOODING_DECRYPT &amp;&amp;\n        parameters.GetExecutionMode() == EXEC_EVALUATION) {\n        if (parameters.GetNoiseEstimate() == 0) {\n            &quot;hey&quot;; OPENFHE_THROW(\n                config_error,\n                &quot;Noise estimate must be set in the combination of NOISE_FLOODING_DECRYPT and EXEC_EVALUATION modes.&quot;);\n        }\n        double logstd =\n            parameters.GetStatisticalSecurity() / 2 + log2(sqrt(12 * parameters.GetNumAdversarialQueries()));\n        floodingNoiseStd = pow(2, logstd + parameters.GetNoiseEstimate());\n#if NATIVEINT == 128\n        scalingModSize = parameters.GetDesiredPrecision() + parameters.GetNoiseEstimate() + logstd +\n                         0.5 * log2(parameters.GetRingDim());\n        firstModSize = scalingModSize + 11;\n#else\n        scalingModSize = MAX_MODULUS_SIZE - 1;\n        firstModSize   = MAX_MODULUS_SIZE;\n        if (logstd + parameters.GetNoiseEstimate() &gt; scalingModSize - 3) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Precision of less than 3 bits is not supported. logstd &quot; +\n                                            std::to_string(logstd) + &quot; + noiseEstimate &quot; +\n                                            std::to_string(parameters.GetNoiseEstimate()) + &quot; must be 56 or less.&quot;);\n        }\n#endif\n    }\n    EncodingParams encodingParams(std::make_shared&lt;EncodingParamsImpl&gt;(scalingModSize, parameters.GetBatchSize()));\n\n    // clang-format off\n    auto params = std::make_shared&lt;typename ContextGeneratorType::CryptoParams&gt;(\n        ep,\n        encodingParams,\n        parameters.GetStandardDeviation(),\n        assuranceMeasure,\n        parameters.GetSecurityLevel(),\n        parameters.GetDigitSize(),\n        parameters.GetSecretKeyDist(),\n        parameters.GetMaxRelinSkDeg(),\n        parameters.GetKeySwitchTechnique(),\n        parameters.GetScalingTechnique(),\n        parameters.GetEncryptionTechnique(),\n        parameters.GetMultiplicationTechnique(),\n        parameters.GetPREMode(),\n        parameters.GetMultipartyMode(),\n        parameters.GetExecutionMode(),\n        parameters.GetDecryptionNoiseMode(),\n        1,  // noise scale: TODO (dsuponit): this should be reviewed as we also call SetNoiseScale(1) (see below)\n        parameters.GetStatisticalSecurity(),\n        parameters.GetNumAdversarialQueries(),\n        parameters.GetThresholdNumOfParties(),\n        parameters.GetInteractiveBootCompressionLevel());\n\n    // for CKKS scheme noise scale is always set to 1\n    params-&gt;SetNoiseScale(1);\n    params-&gt;SetFloodingDistributionParameter(floodingNoiseStd);\n\n    uint32_t numLargeDigits =\n        ComputeNumLargeDigits(parameters.GetNumLargeDigits(), parameters.GetMultiplicativeDepth());\n\n    auto scheme = std::make_shared&lt;typename ContextGeneratorType::PublicKeyEncryptionScheme&gt;();\n    scheme-&gt;SetKeySwitchingTechnique(parameters.GetKeySwitchTechnique());\n    scheme-&gt;ParamsGenCKKSRNS(\n        params,\n        2 * parameters.GetRingDim(),\n        parameters.GetMultiplicativeDepth() + 1,\n        scalingModSize,\n        firstModSize,\n        numLargeDigits,\n        parameters.GetInteractiveBootCompressionLevel());\n    // clang-format on\n\n    auto cc = ContextGeneratorType::Factory::GetContext(params, scheme);\n    cc-&gt;setSchemeId(SCHEME::CKKSRNS_SCHEME);\n    return cc;\n}\n}  // namespace lbcrypto\n\n#endif  // _GEN_CRYPTOCONTEXT_CKKSRNS_INTERNAL_H_\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/gen-cryptocontext.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/gen-cryptocontext.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/gen-cryptocontext.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Constructs CryptoContext based on the provided set of parameters\n */\n\n/*\n* HOW TO GENERATE CRYPTOCONTEXT BY CALLING GenCryptoContext()\n* \n* 1. Pick the scheme you want to use. I choose CKKS for our tutorial example.\n* 2. Your code must include this header file and the header with the scheme-specific\n*    context generator (scheme/&lt;scheme&gt;/cryptocontext-&lt;scheme&gt;.h):\n*       #include &quot;scheme/ckks/cryptocontext-ckks.h&quot;\n*       #include &quot;gen-cryptocontext.h&quot;\n* 3. Create a parameter object to be passed as a parameter in to GenCryptoContext(). Its generic\n*    form would look like this: CCParams&lt;GeneratorName&lt;Element&gt;&gt; parameters\n*    where\n*    - GeneratorName is the name of the class defined in cryptocontext-&lt;scheme&gt;.h. In our case\n*      it is CryptoContextCKKS.\n*    - Element is a template parameter representing integer lattice. So, it can stay Element or\n*      be replaced with Poly, NativePoly or DCRTPoly. I leave &quot;Element&quot;.\n*      As the result we can add this line:\n*       CCParams&lt;CryptoContextCKKS&lt;Element&gt;&gt; parameters;\n* 4. Adjust the parameters&#x27; values with set functions for CCParams&lt;CryptoContextCKKS&lt;Element&gt;&gt; as\n*    the object is created using default values from scheme/cryptocontextparams-defaults.h.\n* 5. Call GenCryptoContext() to generate cryptocontext.\n* \n* Now your code should look like this:\n*       #include &quot;scheme/ckks/cryptocontext-ckks.h&quot;\n*       #include &quot;gen-cryptocontext.h&quot;\n*       ...........................................\n*       CCParams&lt;CryptoContextCKKS&lt;Element&gt;&gt; parameters;\n*       parameters.SetMultiplicativeDepth(1);\n*       parameters.SetScalingModSize(50);\n*       parameters.SetBatchSize(8);\n*       parameters.SetSecurityLevel(HEStd_NotSet);\n*       parameters.SetRingDim(16);\n* \n*       auto cryptoContext = GenCryptoContext(parameters);\n* \n*       cryptoContext-&gt;Enable(ENCRYPTION);\n*       cryptoContext-&gt;Enable(KEYSWITCH);\n*       cryptoContext-&gt;Enable(LEVELEDSHE);\n*       ...........................................\n* \n* More examples can be found in src/pke/unittest/UnitTestAutomorphism.cpp or in\n* src/pke/unittest/UnitTestEvalMult.cpp.\n*/\n\n#ifndef _GEN_CRYPTOCONTEXT_H_\n#define _GEN_CRYPTOCONTEXT_H_\n\nnamespace lbcrypto {\n\n// forward declarations (don&#x27;t include headers as compilation fails when you do)\ntemplate &lt;typename T&gt;\nclass CCParams;\n\ntemplate &lt;typename T&gt;\ntypename T::ContextType GenCryptoContext(const CCParams&lt;T&gt;&amp; params) {\n    return T::genCryptoContext(params);\n}\n\n}  // namespace lbcrypto\n\n#endif  // _GEN_CRYPTOCONTEXT_H_\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/cryptocontext-ckksrns.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/cryptocontext-ckksrns.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/cryptocontext-ckksrns.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  API to generate CKKSRNS crypto context\n */\n\n#ifndef _CRYPTOCONTEXT_CKKSRNS_H_\n#define _CRYPTOCONTEXT_CKKSRNS_H_\n\n#include &quot;lattice/lat-hal.h&quot;\n#include &quot;scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h&quot;\n#include &quot;scheme/ckksrns/cryptocontextparams-ckksrns.h&quot;\n#include &quot;scheme/ckksrns/ckksrns-cryptoparameters.h&quot;\n#include &quot;scheme/ckksrns/ckksrns-scheme.h&quot;\n#include &quot;cryptocontextfactory.h&quot;\n\nnamespace lbcrypto {\n\nclass CryptoContextCKKSRNS {\n    using Element = DCRTPoly;\n\npublic:\n    using ContextType               = CryptoContext&lt;Element&gt;;  // required by GenCryptoContext() in gen-cryptocontext.h\n    using Factory                   = CryptoContextFactory&lt;Element&gt;;\n    using PublicKeyEncryptionScheme = SchemeCKKSRNS;\n    using CryptoParams              = CryptoParametersCKKSRNS;\n\n    static CryptoContext&lt;Element&gt; genCryptoContext(const CCParams&lt;CryptoContextCKKSRNS&gt;&amp; parameters) {\n        return genCryptoContextCKKSRNSInternal&lt;CryptoContextCKKSRNS, Element&gt;(parameters);\n    }\n};\n\n}  // namespace lbcrypto\n\n#endif  // _CRYPTOCONTEXT_CKKSRNS_H_\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_RNS_SCHEME_H\n#define LBCRYPTO_CRYPTO_RNS_SCHEME_H\n\n#include &quot;lattice/lat-hal.h&quot;\n\n#include &quot;schemebase/base-scheme.h&quot;\n\n#include &quot;schemerns/rns-cryptoparameters.h&quot;\n#include &quot;schemerns/rns-parametergeneration.h&quot;\n#include &quot;schemerns/rns-pke.h&quot;\n#include &quot;schemerns/rns-pre.h&quot;\n#include &quot;schemerns/rns-leveledshe.h&quot;\n#include &quot;schemerns/rns-advancedshe.h&quot;\n#include &quot;schemerns/rns-multiparty.h&quot;\n\n#include &quot;keyswitch/keyswitch-hybrid.h&quot;\n#include &quot;keyswitch/keyswitch-bv.h&quot;\n#include &quot;constants.h&quot;\n#include &quot;utils/exception.h&quot;\n\n#include &lt;string&gt;\n#include &lt;memory&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\n\n/**\n * @brief Abstract interface class for LBC PRE algorithms\n * @tparam Element a ring element.\n */\nclass SchemeRNS : public SchemeBase&lt;DCRTPoly&gt; {\npublic:\n    SchemeRNS() {}\n\n    virtual ~SchemeRNS() {}\n\n    void SetKeySwitchingTechnique(KeySwitchTechnique ksTech) {\n        if (ksTech == BV) {\n            m_KeySwitch = std::make_shared&lt;KeySwitchBV&gt;();\n        }\n        else if (ksTech == HYBRID) {\n            m_KeySwitch = std::make_shared&lt;KeySwitchHYBRID&gt;();\n        }\n        else\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ksTech is invalid&quot;);\n    }\n\n    /////////////////////////////////////\n    // SERIALIZATION\n    /////////////////////////////////////\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(cereal::base_class&lt;SchemeBase&lt;DCRTPoly&gt;&gt;(this));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        ar(cereal::base_class&lt;SchemeBase&lt;DCRTPoly&gt;&gt;(this));\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;SchemeRNS&quot;;\n    }\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}}, "reports": [{"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "b2e5a3d5d0a4c6051fe5161a7e67ce65", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 245, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::GetEvalAutomorphismKeyMap'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2086, "column": 27}, {"message": "Entered call from 'CryptoContextImpl::EvalRotate'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 242, "column": 1}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 244, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 245, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/lib/binfhe-base-scheme.cpp", "reportHash": "c994c1c2b2d400d32f2955da84643d82", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 365, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'unit' is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1788, "column": 9}, {"message": "Assuming 'pLWE' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1799, "column": 9}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1818, "column": 26}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1818, "column": 26}, {"message": "Calling 'BinFHEContext::EvalSign'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1819, "column": 21}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCompareSchemeSwitching'", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/lib/binfhecontext.cpp", "line": 336, "column": 1}, {"message": "Calling 'BinFHEScheme::EvalSign'", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/lib/binfhecontext.cpp", "line": 338, "column": 12}, {"message": "Entered call from 'BinFHEContext::EvalSign'", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/lib/binfhe-base-scheme.cpp", "line": 356, "column": 1}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/lib/binfhe-base-scheme.cpp", "line": 362, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/lib/binfhe-base-scheme.cpp", "line": 365, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/lib/binfhe-base-scheme.cpp", "reportHash": "b655ab96ea160abb778d88cfeb89c39f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 373, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'unit' is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1788, "column": 9}, {"message": "Assuming 'pLWE' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1799, "column": 9}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1818, "column": 26}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1818, "column": 26}, {"message": "Calling 'BinFHEContext::EvalSign'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1819, "column": 21}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCompareSchemeSwitching'", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/lib/binfhecontext.cpp", "line": 336, "column": 1}, {"message": "Calling 'BinFHEScheme::EvalSign'", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/lib/binfhecontext.cpp", "line": 338, "column": 12}, {"message": "Entered call from 'BinFHEContext::EvalSign'", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/lib/binfhe-base-scheme.cpp", "line": 356, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/lib/binfhe-base-scheme.cpp", "line": 362, "column": 9}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/lib/binfhe-base-scheme.cpp", "line": 371, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/lib/binfhe-base-scheme.cpp", "line": 373, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "reportHash": "82b3965f46ac79ebebbac952a3eee5e1", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 148, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'pLWE' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1764, "column": 9}, {"message": "Calling 'SWITCHCKKSRNS::EvalCKKStoFHEWPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1776, "column": 5}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCompareSwitchPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1223, "column": 1}, {"message": "Assuming 'M' is not equal to 'm'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1228, "column": 22}, {"message": "Assuming 'i' is >= 'slots'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1233, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1233, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1240, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1251, "column": 24}, {"message": "Calling 'SWITCHCKKSRNS::EvalLTPrecomputeSwitch'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1262, "column": 19}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCKKStoFHEWPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 696, "column": 1}, {"message": "Assuming 'dim1' is not equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 703, "column": 23}, {"message": "Assuming 'L' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 710, "column": 9}, {"message": "Assuming 'i' is >= 'sizeQ'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 723, "column": 24}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 723, "column": 24}, {"message": "Assuming 'i' is >= 'sizeP'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 728, "column": 24}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 728, "column": 24}, {"message": "Calling 'make_shared<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, unsigned int &, std::vector<intnat::NativeIntegerT<unsigned long>> &, std::vector<intnat::NativeIntegerT<unsigned long>> &>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 733, "column": 29}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalLTPrecomputeSwitch'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 874, "column": 5}, {"message": "Calling 'allocate_shared<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, std::allocator<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>>, unsigned int &, std::vector<intnat::NativeIntegerT<unsigned long>> &, std::vector<intnat::NativeIntegerT<unsigned long>> &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 878, "column": 14}, {"message": "Entered call from 'make_shared<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, unsigned int &, std::vector<intnat::NativeIntegerT<unsigned long>> &, std::vector<intnat::NativeIntegerT<unsigned long>> &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 857, "column": 5}, {"message": "Calling constructor for 'shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 862, "column": 14}, {"message": "Entered call from 'allocate_shared<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, std::allocator<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>>, unsigned int &, std::vector<intnat::NativeIntegerT<unsigned long>> &, std::vector<intnat::NativeIntegerT<unsigned long>> &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 408, "column": 2}, {"message": "Calling constructor for '__shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 409, "column": 4}, {"message": "Entered call from constructor for 'shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1341, "column": 2}, {"message": "Calling constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1342, "column": 14}, {"message": "Entered call from constructor for '__shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 643, "column": 2}, {"message": "Calling constructor for '_Sp_counted_ptr_inplace<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, std::allocator<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 651, "column": 6}, {"message": "Entered call from constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 514, "column": 2}, {"message": "Calling 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 519, "column": 4}, {"message": "Entered call from constructor for '_Sp_counted_ptr_inplace<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, std::allocator<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 510, "column": 2}, {"message": "Calling 'new_allocator::construct'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 516, "column": 4}, {"message": "Entered call from 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 159, "column": 2}, {"message": "Calling constructor for 'ILDCRTParams<bigintdyn::ubint<unsigned long>>'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 162, "column": 23}, {"message": "Entered call from 'new_allocator::construct'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "line": 140, "column": 5}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "line": 147, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "line": 148, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "reportHash": "2df6f990857565d14399fb6556f12174", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 89, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'pLWE' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1764, "column": 9}, {"message": "Calling 'SWITCHCKKSRNS::EvalCKKStoFHEWPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1776, "column": 5}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCompareSwitchPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1223, "column": 1}, {"message": "Assuming 'M' is equal to 'm'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1228, "column": 22}, {"message": "Assuming 'i' is >= 'slots'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1233, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1233, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1240, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1251, "column": 24}, {"message": "Calling 'SWITCHCKKSRNS::EvalLTPrecomputeSwitch'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1259, "column": 19}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCKKStoFHEWPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 764, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 767, "column": 9}, {"message": "Assuming 'dim1' is not equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 774, "column": 23}, {"message": "Assuming 'L' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 783, "column": 9}, {"message": "Assuming 'i' is < 'sizeQ'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 24}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 24}, {"message": "Looping back to the head of the loop", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 5}, {"message": "Assuming 'i' is >= 'sizeQ'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 24}, {"message": "Assuming 'i' is < 'sizeP'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 24}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 24}, {"message": "Looping back to the head of the loop", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 5}, {"message": "Assuming 'i' is >= 'sizeP'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 24}, {"message": "Assuming 'j' is < 'gStep'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 811, "column": 26}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 811, "column": 26}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 813, "column": 30}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 814, "column": 17}, {"message": "Calling 'SWITCHCKKSRNS::MakeAuxPlaintext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 819, "column": 21}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalLTPrecomputeSwitch'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 207, "column": 1}, {"message": "Calling 'make_shared<lbcrypto::CKKSPackedEncoding, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 214, "column": 29}, {"message": "Entered call from 'SWITCHCKKSRNS::MakeAuxPlaintext'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 874, "column": 5}, {"message": "Calling 'allocate_shared<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 878, "column": 14}, {"message": "Entered call from 'make_shared<lbcrypto::CKKSPackedEncoding, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 857, "column": 5}, {"message": "Calling constructor for 'shared_ptr<lbcrypto::CKKSPackedEncoding>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 862, "column": 14}, {"message": "Entered call from 'allocate_shared<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 408, "column": 2}, {"message": "Calling constructor for '__shared_ptr<lbcrypto::CKKSPackedEncoding, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 409, "column": 4}, {"message": "Entered call from constructor for 'shared_ptr<lbcrypto::CKKSPackedEncoding>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1341, "column": 2}, {"message": "Calling constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1342, "column": 14}, {"message": "Entered call from constructor for '__shared_ptr<lbcrypto::CKKSPackedEncoding, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 643, "column": 2}, {"message": "Calling constructor for '_Sp_counted_ptr_inplace<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 651, "column": 6}, {"message": "Entered call from constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 514, "column": 2}, {"message": "Calling 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 519, "column": 4}, {"message": "Entered call from constructor for '_Sp_counted_ptr_inplace<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 510, "column": 2}, {"message": "Calling 'new_allocator::construct'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 516, "column": 4}, {"message": "Entered call from 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 159, "column": 2}, {"message": "Calling constructor for 'CKKSPackedEncoding'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 162, "column": 23}, {"message": "Entered call from 'new_allocator::construct'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 84, "column": 5}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 88, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 89, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "reportHash": "066c14df91360504fa45dee1da4b759e", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 95, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'pLWE' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1764, "column": 9}, {"message": "Calling 'SWITCHCKKSRNS::EvalCKKStoFHEWPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1776, "column": 5}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCompareSwitchPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1223, "column": 1}, {"message": "Assuming 'M' is equal to 'm'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1228, "column": 22}, {"message": "Assuming 'i' is >= 'slots'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1233, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1233, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1240, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1251, "column": 24}, {"message": "Calling 'SWITCHCKKSRNS::EvalLTPrecomputeSwitch'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1259, "column": 19}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCKKStoFHEWPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 764, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 767, "column": 9}, {"message": "Assuming 'dim1' is not equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 774, "column": 23}, {"message": "Assuming 'L' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 783, "column": 9}, {"message": "Assuming 'i' is < 'sizeQ'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 24}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 24}, {"message": "Looping back to the head of the loop", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 5}, {"message": "Assuming 'i' is >= 'sizeQ'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 24}, {"message": "Assuming 'i' is < 'sizeP'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 24}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 24}, {"message": "Looping back to the head of the loop", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 5}, {"message": "Assuming 'i' is >= 'sizeP'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 24}, {"message": "Assuming 'j' is < 'gStep'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 811, "column": 26}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 811, "column": 26}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 813, "column": 30}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 814, "column": 17}, {"message": "Calling 'SWITCHCKKSRNS::MakeAuxPlaintext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 819, "column": 21}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalLTPrecomputeSwitch'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 207, "column": 1}, {"message": "Calling 'make_shared<lbcrypto::CKKSPackedEncoding, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 214, "column": 29}, {"message": "Entered call from 'SWITCHCKKSRNS::MakeAuxPlaintext'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 874, "column": 5}, {"message": "Calling 'allocate_shared<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 878, "column": 14}, {"message": "Entered call from 'make_shared<lbcrypto::CKKSPackedEncoding, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 857, "column": 5}, {"message": "Calling constructor for 'shared_ptr<lbcrypto::CKKSPackedEncoding>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 862, "column": 14}, {"message": "Entered call from 'allocate_shared<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 408, "column": 2}, {"message": "Calling constructor for '__shared_ptr<lbcrypto::CKKSPackedEncoding, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 409, "column": 4}, {"message": "Entered call from constructor for 'shared_ptr<lbcrypto::CKKSPackedEncoding>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1341, "column": 2}, {"message": "Calling constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1342, "column": 14}, {"message": "Entered call from constructor for '__shared_ptr<lbcrypto::CKKSPackedEncoding, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 643, "column": 2}, {"message": "Calling constructor for '_Sp_counted_ptr_inplace<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 651, "column": 6}, {"message": "Entered call from constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 514, "column": 2}, {"message": "Calling 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 519, "column": 4}, {"message": "Entered call from constructor for '_Sp_counted_ptr_inplace<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 510, "column": 2}, {"message": "Calling 'new_allocator::construct'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 516, "column": 4}, {"message": "Entered call from 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 159, "column": 2}, {"message": "Calling constructor for 'CKKSPackedEncoding'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 162, "column": 23}, {"message": "Entered call from 'new_allocator::construct'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 84, "column": 5}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 88, "column": 13}, {"message": "Assuming 'slots' is not equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 92, "column": 23}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 94, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 95, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "reportHash": "8e5eea636e66e4619a89d2fcfaf26314", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 98, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'pLWE' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1764, "column": 9}, {"message": "Calling 'SWITCHCKKSRNS::EvalCKKStoFHEWPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1776, "column": 5}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCompareSwitchPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1223, "column": 1}, {"message": "Assuming 'M' is equal to 'm'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1228, "column": 22}, {"message": "Assuming 'i' is >= 'slots'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1233, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1233, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1240, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1251, "column": 24}, {"message": "Calling 'SWITCHCKKSRNS::EvalLTPrecomputeSwitch'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1259, "column": 19}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCKKStoFHEWPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 764, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 767, "column": 9}, {"message": "Assuming 'dim1' is not equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 774, "column": 23}, {"message": "Assuming 'L' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 783, "column": 9}, {"message": "Assuming 'i' is < 'sizeQ'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 24}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 24}, {"message": "Looping back to the head of the loop", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 5}, {"message": "Assuming 'i' is >= 'sizeQ'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 24}, {"message": "Assuming 'i' is < 'sizeP'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 24}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 24}, {"message": "Looping back to the head of the loop", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 5}, {"message": "Assuming 'i' is >= 'sizeP'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 24}, {"message": "Assuming 'j' is < 'gStep'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 811, "column": 26}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 811, "column": 26}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 813, "column": 30}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 814, "column": 17}, {"message": "Calling 'SWITCHCKKSRNS::MakeAuxPlaintext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 819, "column": 21}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalLTPrecomputeSwitch'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 207, "column": 1}, {"message": "Calling 'make_shared<lbcrypto::CKKSPackedEncoding, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 214, "column": 29}, {"message": "Entered call from 'SWITCHCKKSRNS::MakeAuxPlaintext'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 874, "column": 5}, {"message": "Calling 'allocate_shared<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 878, "column": 14}, {"message": "Entered call from 'make_shared<lbcrypto::CKKSPackedEncoding, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 857, "column": 5}, {"message": "Calling constructor for 'shared_ptr<lbcrypto::CKKSPackedEncoding>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 862, "column": 14}, {"message": "Entered call from 'allocate_shared<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 408, "column": 2}, {"message": "Calling constructor for '__shared_ptr<lbcrypto::CKKSPackedEncoding, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 409, "column": 4}, {"message": "Entered call from constructor for 'shared_ptr<lbcrypto::CKKSPackedEncoding>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1341, "column": 2}, {"message": "Calling constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1342, "column": 14}, {"message": "Entered call from constructor for '__shared_ptr<lbcrypto::CKKSPackedEncoding, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 643, "column": 2}, {"message": "Calling constructor for '_Sp_counted_ptr_inplace<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 651, "column": 6}, {"message": "Entered call from constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 514, "column": 2}, {"message": "Calling 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 519, "column": 4}, {"message": "Entered call from constructor for '_Sp_counted_ptr_inplace<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 510, "column": 2}, {"message": "Calling 'new_allocator::construct'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 516, "column": 4}, {"message": "Entered call from 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 159, "column": 2}, {"message": "Calling constructor for 'CKKSPackedEncoding'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 162, "column": 23}, {"message": "Entered call from 'new_allocator::construct'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 84, "column": 5}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 88, "column": 13}, {"message": "Assuming 'slots' is not equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 92, "column": 23}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 94, "column": 13}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 97, "column": 18}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 98, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "fb262a8993243911d30a6c86f5843b09", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 149, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::Enable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 895, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::Enable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 148, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 149, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "0076d686029b063a14b7f4bbca1c9841", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 304, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::KeySwitchInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 431, "column": 5}, {"message": "Entered call from 'SWITCHCKKSRNS::Conjugate'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 301, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 304, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "3701fa13e3b63895b6e0e6e1879522d7", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 399, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalAdd'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1328, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalAdd'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 395, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 399, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "89adc7e979a1e8176a429792ce3e76ff", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 408, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalAddInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1339, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalAddInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 405, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 408, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "772a9788a1962bd7a55b29a591688774", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 438, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::EvalAdd'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1383, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalAdd'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1370, "column": 5}, {"message": "Calling 'SchemeBase::EvalAdd'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1373, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalAdd'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 435, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 438, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "86823814785301027efec58c8ab666e9", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 483, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'constant' is < 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1596, "column": 13}, {"message": "Calling 'SchemeBase::EvalAdd'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1596, "column": 74}, {"message": "Entered call from 'CryptoContextImpl::EvalSub'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 480, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 483, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "36127874f4014cdd409944c54caed26c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 585, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'constant' is >= 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1596, "column": 13}, {"message": "Calling 'SchemeBase::EvalSub'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1596, "column": 29}, {"message": "Entered call from 'CryptoContextImpl::EvalSub'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 582, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 585, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "8d645bd7d2b0b8bf0033666e5ef644d7", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 867, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::EvalFastRotationPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 876, "column": 19}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalLTWithPrecomputeSwitch'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2117, "column": 5}, {"message": "Calling 'SchemeBase::EvalFastRotationPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2118, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalFastRotationPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 863, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 867, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "67160562a727516bb1183df549898981", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1580, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::VerifyKeySwitchEnabled'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 356, "column": 9}, {"message": "Entered call from 'SchemeBase::KeySwitchCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1576, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1580, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "a04dfb9c5785af165dca8724209d3fd1", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 98, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 606, "column": 24}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 606, "column": 24}, {"message": "Calling 'CryptoContextImpl::KeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 642, "column": 28}, {"message": "Entered call from 'switchingKeyGenRLWEcc'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1139, "column": 5}, {"message": "Calling 'CryptoContextImpl::GetContextForPointer'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1140, "column": 36}, {"message": "Entered call from 'CryptoContextImpl::KeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 92, "column": 5}, {"message": "Loop body skipped when range is empty", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 94, "column": 30}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 98, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "8902978e38db77221d789cf6992b69f3", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 122, "column": 17, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'level' is > 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 105, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 110, "column": 18}, {"message": "Assuming 'level' is >= 'numModuli'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 113, "column": 17}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 122, "column": 17}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "73a7b8fa82e707654410e4ce0b28ecb4", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 155, "column": 17, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'level' is <= 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 105, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 127, "column": 13}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 154, "column": 17}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 155, "column": 17}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "73a7b8fa82e707654410e4ce0b28ecb4", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 168, "column": 17, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'level' is <= 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 105, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 127, "column": 13}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 167, "column": 17}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 168, "column": 17}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "7a336b4a1ed2f9158c325fc8830f5da7", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 296, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::TypeCheck'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1698, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalMult'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 293, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 296, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "7a336b4a1ed2f9158c325fc8830f5da7", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 300, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::TypeCheck'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1698, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalMult'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 293, "column": 5}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 298, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 300, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "7a336b4a1ed2f9158c325fc8830f5da7", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 304, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::EvalSub'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1786, "column": 18}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCompareSchemeSwitching'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1505, "column": 5}, {"message": "Calling 'CryptoContextImpl::TypeCheck'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1506, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalSub'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 293, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 304, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "7a336b4a1ed2f9158c325fc8830f5da7", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 308, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::EvalSub'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1786, "column": 18}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCompareSchemeSwitching'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1505, "column": 5}, {"message": "Calling 'CryptoContextImpl::TypeCheck'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1506, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalSub'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 293, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 308, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "3e84e470fc7ba453576a355f19252ab5", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 316, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::EvalSub'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1786, "column": 18}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCompareSchemeSwitching'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1505, "column": 5}, {"message": "Calling 'CryptoContextImpl::TypeCheck'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1506, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalSub'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 293, "column": 5}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 310, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 316, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "044c56598b3d6df22176dd4e44746ba1", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 329, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::TypeCheck'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1871, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalMult'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 326, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 329, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "044c56598b3d6df22176dd4e44746ba1", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 333, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::TypeCheck'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1871, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalMult'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 326, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 333, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "044c56598b3d6df22176dd4e44746ba1", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 337, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::TypeCheck'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1871, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalMult'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 326, "column": 5}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 335, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 337, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "133cb604c2a679b3e99bd631eb4ff43c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 345, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::TypeCheck'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1871, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalMult'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 326, "column": 5}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 335, "column": 13}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 339, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 345, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "dd9cdb3fb07b6c532695bca81e81a1c5", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 360, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 360, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "dd9cdb3fb07b6c532695bca81e81a1c5", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 364, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 364, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "6657ed6ed15ab339c6e863f46ecedb72", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 371, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::CheckCiphertext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2555, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalChebyshevSeries'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 368, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 371, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "6657ed6ed15ab339c6e863f46ecedb72", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 376, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::CheckCiphertext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2555, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalChebyshevSeries'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 368, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 376, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "b4f291e89f0a18a9c497013c3896dc04", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1006, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::GetEvalMultKeyVector'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1700, "column": 33}, {"message": "Entered call from 'CryptoContextImpl::EvalMult'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1003, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1006, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "a1339053c7844daa96326af5ad3745aa", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1095, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'i' is >= 'n'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1354, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1354, "column": 26}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1363, "column": 9}, {"message": "Calling 'CryptoContextImpl::MakeCKKSPackedPlaintext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1367, "column": 25}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalFHEWtoCKKSKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1091, "column": 5}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1094, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1095, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "6866f62c13349149a999b5994f346af0", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1112, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1111, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1112, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "5f6d30feec8b0daab3298288d4c841c8", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1161, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::Encrypt'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1185, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::Encrypt'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1159, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1161, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "7a51fb122ea2d763c4d90d330798831f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1666, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1666, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "7d4b89d48ffcda60f05409e3e0db56c9", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1702, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1701, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1702, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "cf6ba5326502b1f7d41a26ef6e4f88f6", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1944, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'unit' is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1788, "column": 9}, {"message": "Assuming 'pLWE' is not equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1789, "column": 13}, {"message": "Calling 'CryptoContextImpl::EvalMult'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1793, "column": 21}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCompareSchemeSwitching'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1942, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1944, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "8a484553f7dbb10bbf88437f3d1fc298", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 2351, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'unit' is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1788, "column": 9}, {"message": "Assuming 'pLWE' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1799, "column": 9}, {"message": "Calling 'SWITCHCKKSRNS::EvalCKKStoFHEW'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1814, "column": 27}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCompareSchemeSwitching'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1266, "column": 1}, {"message": "Calling 'SWITCHCKKSRNS::EvalSlotsToCoeffsSwitch'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1272, "column": 24}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCKKStoFHEW'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1032, "column": 1}, {"message": "Assuming 'M' is equal to 'm'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1037, "column": 23}, {"message": "Calling 'CryptoContextImpl::Compress'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1040, "column": 25}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalSlotsToCoeffsSwitch'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2349, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2351, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h", "reportHash": "43147f09afeecc6effe766c90b221345", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 73, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextCKKSRNS::genCryptoContext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/gen-cryptocontext.h", "line": 90, "column": 12}, {"message": "Entered call from 'GenCryptoContext<lbcrypto::CryptoContextCKKSRNS>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/cryptocontext-ckksrns.h", "line": 57, "column": 5}, {"message": "Calling 'genCryptoContextCKKSRNSInternal<lbcrypto::CryptoContextCKKSRNS, lbcrypto::DCRTPolyImpl<bigintdyn::mubintvec<bigintdyn::ubint<unsigned long>>>>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/cryptocontext-ckksrns.h", "line": 58, "column": 16}, {"message": "Entered call from 'CryptoContextCKKSRNS::genCryptoContext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h", "line": 54, "column": 1}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h", "line": 70, "column": 9}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h", "line": 71, "column": 9}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h", "line": 72, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h", "line": 73, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h", "reportHash": "476bd8eb93fc3197669a7586a289be09", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 88, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextCKKSRNS::genCryptoContext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/gen-cryptocontext.h", "line": 90, "column": 12}, {"message": "Entered call from 'GenCryptoContext<lbcrypto::CryptoContextCKKSRNS>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/cryptocontext-ckksrns.h", "line": 57, "column": 5}, {"message": "Calling 'genCryptoContextCKKSRNSInternal<lbcrypto::CryptoContextCKKSRNS, lbcrypto::DCRTPolyImpl<bigintdyn::mubintvec<bigintdyn::ubint<unsigned long>>>>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/cryptocontext-ckksrns.h", "line": 58, "column": 16}, {"message": "Entered call from 'CryptoContextCKKSRNS::genCryptoContext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h", "line": 54, "column": 1}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h", "line": 70, "column": 9}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h", "line": 71, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h", "line": 72, "column": 13}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h", "line": 87, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h", "line": 88, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "reportHash": "d132ed6a836949e6521bc9548e13fbdf", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 79, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextCKKSRNS::genCryptoContext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/gen-cryptocontext.h", "line": 90, "column": 12}, {"message": "Entered call from 'GenCryptoContext<lbcrypto::CryptoContextCKKSRNS>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/cryptocontext-ckksrns.h", "line": 57, "column": 5}, {"message": "Calling 'genCryptoContextCKKSRNSInternal<lbcrypto::CryptoContextCKKSRNS, lbcrypto::DCRTPolyImpl<bigintdyn::mubintvec<bigintdyn::ubint<unsigned long>>>>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/cryptocontext-ckksrns.h", "line": 58, "column": 16}, {"message": "Entered call from 'CryptoContextCKKSRNS::genCryptoContext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h", "line": 54, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h", "line": 70, "column": 9}, {"message": "Calling 'SchemeRNS::SetKeySwitchingTechnique'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/ckksrns/gen-cryptocontext-ckksrns-internal.h", "line": 128, "column": 5}, {"message": "Entered call from 'genCryptoContextCKKSRNSInternal<lbcrypto::CryptoContextCKKSRNS, lbcrypto::DCRTPolyImpl<bigintdyn::mubintvec<bigintdyn::ubint<unsigned long>>>>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "line": 71, "column": 5}, {"message": "Assuming 'ksTech' is not equal to BV", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "line": 72, "column": 13}, {"message": "Assuming 'ksTech' is not equal to HYBRID", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "line": 75, "column": 18}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "line": 79, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "reportHash": "8dc611a9bdc8f4adab20b39cbb84847b", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 246, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'pLWE' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1764, "column": 9}, {"message": "Calling 'SWITCHCKKSRNS::EvalCKKStoFHEWPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1776, "column": 5}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCompareSwitchPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1223, "column": 1}, {"message": "Assuming 'M' is equal to 'm'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1228, "column": 22}, {"message": "Assuming 'i' is >= 'slots'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1233, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1233, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1240, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1251, "column": 24}, {"message": "Calling 'SWITCHCKKSRNS::EvalLTPrecomputeSwitch'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1259, "column": 19}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCKKStoFHEWPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 764, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 767, "column": 9}, {"message": "Assuming 'dim1' is not equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 774, "column": 23}, {"message": "Assuming 'L' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 783, "column": 9}, {"message": "Assuming 'i' is < 'sizeQ'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 24}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 24}, {"message": "Looping back to the head of the loop", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 5}, {"message": "Assuming 'i' is >= 'sizeQ'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 24}, {"message": "Assuming 'i' is < 'sizeP'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 24}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 24}, {"message": "Looping back to the head of the loop", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 5}, {"message": "Assuming 'i' is >= 'sizeP'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 24}, {"message": "Assuming 'j' is < 'gStep'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 811, "column": 26}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 811, "column": 26}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 813, "column": 30}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 814, "column": 17}, {"message": "Calling 'SWITCHCKKSRNS::MakeAuxPlaintext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 819, "column": 21}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalLTPrecomputeSwitch'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 207, "column": 1}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 232, "column": 24}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 234, "column": 13}, {"message": "Assuming 'logc' is < 'logci'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 236, "column": 17}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 239, "column": 13}, {"message": "Assuming 'logc' is < 'logci'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 241, "column": 17}, {"message": "Looping back to the head of the loop", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 232, "column": 5}, {"message": "Assuming 'i' is >= 'slots'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 232, "column": 24}, {"message": "Assuming 'logc' is < 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 245, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 246, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "reportHash": "4f4545f55156558491bf01c56ff7d670", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 300, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'pLWE' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1764, "column": 9}, {"message": "Calling 'SWITCHCKKSRNS::EvalCKKStoFHEWPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1776, "column": 5}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCompareSwitchPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1223, "column": 1}, {"message": "Assuming 'M' is equal to 'm'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1228, "column": 22}, {"message": "Assuming 'i' is >= 'slots'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1233, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1233, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1240, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1251, "column": 24}, {"message": "Calling 'SWITCHCKKSRNS::EvalLTPrecomputeSwitch'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1259, "column": 19}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCKKStoFHEWPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 764, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 767, "column": 9}, {"message": "Assuming 'dim1' is not equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 774, "column": 23}, {"message": "Assuming 'L' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 783, "column": 9}, {"message": "Assuming 'i' is < 'sizeQ'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 24}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 24}, {"message": "Looping back to the head of the loop", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 5}, {"message": "Assuming 'i' is >= 'sizeQ'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 797, "column": 24}, {"message": "Assuming 'i' is < 'sizeP'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 24}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 24}, {"message": "Looping back to the head of the loop", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 5}, {"message": "Assuming 'i' is >= 'sizeP'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 802, "column": 24}, {"message": "Assuming 'j' is < 'gStep'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 811, "column": 26}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 811, "column": 26}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 813, "column": 30}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 814, "column": 17}, {"message": "Calling 'SWITCHCKKSRNS::MakeAuxPlaintext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 819, "column": 21}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalLTPrecomputeSwitch'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 207, "column": 1}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 232, "column": 24}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 234, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 239, "column": 13}, {"message": "Looping back to the head of the loop", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 232, "column": 5}, {"message": "Assuming 'i' is >= 'slots'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 232, "column": 24}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 253, "column": 24}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 259, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 268, "column": 36}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 268, "column": 36}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 300, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "reportHash": "f34d7a988cb9625611029aad0e4b2965", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 542, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 541, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 542, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "reportHash": "6827056646b99db73b82ecddbd468d22", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 550, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 541, "column": 9}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 549, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 550, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "reportHash": "13f34e96d3b4952943437af0a49b63ea", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 768, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'pLWE' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1764, "column": 9}, {"message": "Calling 'SWITCHCKKSRNS::EvalCKKStoFHEWPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1776, "column": 5}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCompareSwitchPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1223, "column": 1}, {"message": "Assuming 'M' is equal to 'm'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1228, "column": 22}, {"message": "Assuming 'i' is >= 'slots'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1233, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1233, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1240, "column": 26}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1251, "column": 24}, {"message": "Calling 'SWITCHCKKSRNS::EvalLTPrecomputeSwitch'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1259, "column": 19}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalCKKStoFHEWPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 764, "column": 1}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 767, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 768, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "reportHash": "2c57b1a1aead8026c533eb2839819b3e", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 830, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1069, "column": 9}, {"message": "Calling 'EvalLTRectPrecomputeSwitch'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1077, "column": 17}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalPartialHomDecryption'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 827, "column": 1}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 829, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 830, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "reportHash": "a28a5c3b4353595aefe9cb9a694426d0", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1093, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SWITCHCKKSRNS::EvalCKKStoFHEWSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1599, "column": 19}, {"message": "Entered call from 'SWITCHCKKSRNS::EvalSchemeSwitchingSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1087, "column": 1}, {"message": "Assuming 'slBin' is not equal to TOY", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1092, "column": 9}, {"message": "Assuming 'slBin' is not equal to STD128", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1092, "column": 25}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1093, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "reportHash": "2aa62acfaa57aa7269df9fb23d96424e", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1166, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1165, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1166, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "reportHash": "8efe0eceb04644de63c5e1b4a3d7148d", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1325, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1324, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1325, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "reportHash": "da7e69c4e5ec56d0ec84e74ecdfdcb03", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1408, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1407, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1408, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "reportHash": "d80cc421874d741db0b5a29a2dadbd48", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1620, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1619, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1620, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "reportHash": "c3e0f6353ced20decb4d3c14a41bdd7a", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1790, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'unit' is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1788, "column": 9}, {"message": "Assuming 'pLWE' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1789, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/ckksrns/ckksrns-schemeswitching.cpp", "line": 1790, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>

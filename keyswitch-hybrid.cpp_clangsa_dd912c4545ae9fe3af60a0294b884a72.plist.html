<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijn@haverbeke.berlin> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report.events;
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report.events;
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setChecker(report.checker);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.fileId]);
    this.drawBugPath();

    this.jumpTo(event.line, 0);
    this.highlightBugEvent(idx);
  },

  highlightBugEvent : function (idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setChecker : function (checker) {
    var content = checker.name;
    if (checker.url) {
      content = '<a href="' + checker.url + '" target="_blank">' +
        checker.name + '</a>';
    }

    this._checkerName.innerHTML = content;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.filePath;
    let e = document.createElement('div');
    e.innerHTML = file.content;
    this._codeMirror.doc.setValue(e.innerText);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.fileId !== that._currentBugEvent.fileId) {
        return;
      }

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.fileId !== that._currentBugEvent.fileId)
        return;

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Wraps parameters for integer lattice operations using double-CRT representation. Inherits from ElemParams\n */\n\n#ifndef LBCRYPTO_INC_LATTICE_ILDCRTPARAMS_H\n#define LBCRYPTO_INC_LATTICE_ILDCRTPARAMS_H\n\n#include &quot;lattice/elemparams.h&quot;\n#include &quot;lattice/ilparams.h&quot;\n\n#include &quot;math/math-hal.h&quot;\n#include &quot;math/nbtheory-impl.h&quot;\n\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/inttypes.h&quot;\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\nnamespace lbcrypto {\n\n/**\n * @brief Parameters for array of ideal lattices (used for Double-CRT).\n *\n * The double-CRT representation of polynomials is a common optimization for\n * lattice encryption operations. Basically, it allows large-modulus polynamials\n * to be represented as multiple smaller-modulus polynomials. The double-CRT\n * representations are discussed theoretically here:\n *   - Gentry C., Halevi S., Smart N.P. (2012) Homomorphic Evaluation of the AES\n * Circuit. In: Safavi-Naini R., Canetti R. (eds) Advances in Cryptology \u2013\n * CRYPTO 2012. Lecture Notes in Computer Science, vol 7417. Springer, Berlin,\n * Heidelberg\n */\ntemplate &lt;typename IntType&gt;\nclass ILDCRTParams final : public ElemParams&lt;IntType&gt; {\npublic:\n    static constexpr usint DEFAULT_NBITS = 20;\n\n    using Integer        = IntType;\n    using ILNativeParams = ILParamsImpl&lt;NativeInteger&gt;;\n\n    /**\n   * @brief Constructor with basic parameter set.\n   * q is selected as FirstPrime(bits, order)\n   * @param order the order of the ciphertext.\n   * @param depth is the size of the tower.\n   * @param bits is the number of bits of each tower&#x27;s moduli.\n   */\n    explicit ILDCRTParams(usint order = 0, usint depth = 1, usint bits = DEFAULT_NBITS)\n        : ElemParams&lt;IntType&gt;(order, 0), m_params(depth) {\n        if (order == 0)\n            return;\n        if (depth == 0)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Invalid depth for ILDCRTParams&quot;);\n        if (bits == 0 || bits &gt; 64)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Invalid bits for ILDCRTParams&quot;);\n        auto q{FirstPrime&lt;NativeInteger&gt;(bits, order)};\n        for (usint j = 0; j &lt; depth; ++j, q = NextPrime&lt;NativeInteger&gt;(q, order))\n            m_params[j] = std::make_shared&lt;ILNativeParams&gt;(order, q, RootOfUnity&lt;NativeInteger&gt;(order, q));\n        RecalculateModulus();\n    }\n\n    /**\n   * @brief Constructor with basic parameters\n   *\n   * @param cyclotomic_order the order of the ciphertext\n   * @param &amp;modulus is the modulus for the primary ciphertext.\n   * @param rootsOfUnity is unused\n   */\n\n    // root of unity unused?\n    ILDCRTParams(usint cyclotomic_order, const IntType&amp; modulus, const IntType&amp; rootOfUnity)\n        : ElemParams&lt;IntType&gt;(cyclotomic_order, modulus, 0, 0, 0), m_originalModulus(modulus) {\n        // NOTE params generation uses this constructor to make an empty params that\n        // it will later populate during the gen process. For that special case...\n        // we don&#x27;t populate, and we just return\n        if (cyclotomic_order == 0)\n            return;\n        std::vector&lt;NativeInteger&gt; moduli;\n        std::vector&lt;NativeInteger&gt; rootsOfUnity;\n        auto q{FirstPrime&lt;NativeInteger&gt;(DEFAULT_NBITS, cyclotomic_order)};\n        IntType compositeModulus(1);\n        while (true) {\n            moduli.push_back(q);\n            rootsOfUnity.push_back(RootOfUnity(cyclotomic_order, q));\n            m_params.push_back(std::make_shared&lt;ILNativeParams&gt;(cyclotomic_order, q, rootsOfUnity.back()));\n            compositeModulus = compositeModulus * IntType(q.ConvertToInt());\n            if (compositeModulus &gt;= modulus)\n                break;\n            q = NextPrime(q, cyclotomic_order);\n        }\n        RecalculateModulus();\n    }\n\n    /**\n   * @brief Constructor with some pre-computed parameters provided as input.\n   * @param cyclotomic_order the order of the ciphertext\n   * @param moduli the list of the smaller moduli of the component polynomials.\n   * @param rootsOfUnity the list of the smaller roots of unity of the component\n   * polynomials.\n   * @param moduliBig the list of the big moduli of the component polynomials\n   * (arbitrary cyclotomics).\n   * @param rootsOfUnityBig the list of the roots of unity of the component\n   * polynomials for big moduli (arbitrary cyclotomics).\n   * @return\n   */\n    ILDCRTParams(usint cyclotomic_order, const std::vector&lt;NativeInteger&gt;&amp; moduli,\n                 const std::vector&lt;NativeInteger&gt;&amp; rootsOfUnity, const std::vector&lt;NativeInteger&gt;&amp; moduliBig = {},\n                 const std::vector&lt;NativeInteger&gt;&amp; rootsOfUnityBig = {},\n                 const IntType&amp; inputOriginalModulus               = IntType(0))\n        : ElemParams&lt;IntType&gt;(cyclotomic_order, 0, 0, 0, 0),\n          m_originalModulus(inputOriginalModulus),\n          m_params(moduli.size()) {\n        if (moduli.size() != rootsOfUnity.size())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;sizes of moduli and roots of unity do not match&quot;);\n        size_t size{moduli.size()};\n        if (moduliBig.size() == size) {\n            for (size_t i = 0; i &lt; size; ++i)\n                m_params[i] = std::make_shared&lt;ILNativeParams&gt;(cyclotomic_order, moduli[i], rootsOfUnity[i],\n                                                               moduliBig[i], rootsOfUnityBig[i]);\n        }\n        else {\n            for (size_t i = 0; i &lt; size; ++i)\n                m_params[i] = std::make_shared&lt;ILNativeParams&gt;(cyclotomic_order, moduli[i], rootsOfUnity[i]);\n        }\n        RecalculateModulus();\n    }\n\n    /**\n   * @brief Constructor with only cylotomic order and chain of moduli.\n   * Multiplied values of the chain of moduli is automatically calculated. Root\n   * of unity of the modulus is also calculated.\n   *\n   * @param cyclotomic_order the order of the ciphertext\n   * @param &amp;moduli is the tower of moduli\n   */\n    ILDCRTParams(usint cyclotomic_order, const std::vector&lt;NativeInteger&gt;&amp; moduli,\n                 const IntType&amp; inputOriginalModulus = IntType(0))\n        : ElemParams&lt;IntType&gt;(cyclotomic_order, 0, 0, 0, 0),\n          m_originalModulus(inputOriginalModulus),\n          m_params(moduli.size()) {\n        for (size_t i = 0; i &lt; moduli.size(); i++)\n            m_params[i] = std::make_shared&lt;ILNativeParams&gt;(cyclotomic_order, moduli[i], 0, 0, 0);\n        RecalculateModulus();\n    }\n\n    /**\n   * @brief Constructor that takes in the cyclotomic order and the component\n   * parameters of the component moduli.\n   * @param cyclotomic_order the primary cyclotomic order.  This is not checked\n   * against the component moduli.\n   * @param params the componet parameters.\n   * @return\n   */\n    ILDCRTParams(usint cyclotomic_order, std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt;&amp; params,\n                 const IntType&amp; inputOriginalModulus = IntType(0))\n        : ElemParams&lt;IntType&gt;(cyclotomic_order, 0, 0, 0, 0), m_originalModulus(inputOriginalModulus), m_params(params) {\n        RecalculateModulus();\n    }\n\n    ILDCRTParams(const ILDCRTParams&amp; rhs)\n        : ElemParams&lt;IntType&gt;(rhs), m_originalModulus(rhs.m_originalModulus), m_params(rhs.m_params) {}\n\n    ILDCRTParams(ILDCRTParams&amp;&amp; rhs) noexcept\n        : ElemParams&lt;IntType&gt;(rhs),\n          m_originalModulus(std::move(rhs.m_originalModulus)),\n          m_params(std::move(rhs.m_params)) {}\n\n    /**\n   * Assignment Operator.\n   *\n   * @param &amp;rhs the copied ILDCRTParams.\n   * @return the resulting ILDCRTParams.\n   */\n    ILDCRTParams&amp; operator=(const ILDCRTParams&amp; rhs) {\n        ElemParams&lt;IntType&gt;::operator=(rhs);\n        m_originalModulus = rhs.m_originalModulus;\n        m_params          = rhs.m_params;\n        return *this;\n    }\n\n    ILDCRTParams&amp; operator=(ILDCRTParams&amp;&amp; rhs) noexcept {\n        ElemParams&lt;IntType&gt;::operator=(rhs);\n        m_originalModulus = std::move(rhs.m_originalModulus);\n        m_params          = std::move(rhs.m_params);\n        return *this;\n    }\n\n    // ACCESSORS\n    /**\n   * @brief Getter method for the component parameters.\n   * @return A vector of the component polynomial parameters.\n   */\n    const std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt;&amp; GetParams() const {\n        return m_params;\n    }\n\n    /**\n   * @brief Getter method that returns a subset of the component parameters.\n   *\n   * @param start The index of the first tower to include in the result.\n   * @param end The index of the last tower to include.\n   * @return A vector of the component polynomial parameters.\n   */\n    std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt; GetParamPartition(uint32_t start, uint32_t end) const {\n        if (end &lt; start || end &gt;= m_params.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Incorrect parameters for GetParamPartition - (start: &quot; + std::to_string(start) +\n                                          &quot;, end:&quot; + std::to_string(end) + &quot;)&quot;);\n        }\n\n        std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt; resParams;\n        for (uint32_t i = start; i &lt;= end; ++i)\n            resParams.push_back(m_params[i]);\n        return resParams;\n    }\n\n    /**\n   * @brief Simple getter method for the original modulus, not the ciphertex\n   * modulus.\n   * @return The original  modulus, not the big ciphertext modulus.\n   */\n    const IntType&amp; GetOriginalModulus() const {\n        return m_originalModulus;\n    }\n    /**\n   * @brief Simple setter method for the original modulus, not the ciphertex\n   * modulus.\n   * @return void\n   */\n    void SetOriginalModulus(const IntType&amp; inputOriginalModulus) {\n        m_originalModulus = inputOriginalModulus;\n    }\n    /**\n   * @brief Getter method for the component parameters of a specific index.\n   * @param i the index of the parameters to return.  Note this this call is\n   * unguarded if the index is out of bounds.\n   * @return the parameters at index i.\n   */\n    std::shared_ptr&lt;ILNativeParams&gt;&amp; operator[](usint i) {\n        return m_params[i];\n    }\n\n    /**\n   * @brief Removes the last parameter set and adjust the multiplied moduli.\n   *\n   */\n    void PopLastParam() {\n        ElemParams&lt;IntType&gt;::m_ciphertextModulus /= IntType(m_params.back()-&gt;GetModulus().ConvertToInt());\n        m_params.pop_back();\n    }\n\n    /**\n   * @brief Removes the first parameter set and adjust the multiplied moduli.\n   *\n   */\n    void PopFirstParam() {\n        ElemParams&lt;IntType&gt;::m_ciphertextModulus /= IntType(m_params[0]-&gt;GetModulus().ConvertToInt());\n        m_params.erase(m_params.begin());\n    }\n\n    /**\n   * Destructor.\n   */\n    ~ILDCRTParams() override = default;\n\n    /**\n   * @brief Equality operator checks if the ElemParams are the same.\n   *\n   * @param &amp;other ElemParams to compare against.\n   * @return the equality check results.\n   */\n    bool operator==(const ElemParams&lt;IntType&gt;&amp; other) const override {\n        const auto* dcrtParams = dynamic_cast&lt;const ILDCRTParams*&gt;(&amp;other);\n\n        if (dcrtParams == nullptr)\n            return false;\n\n        if (ElemParams&lt;IntType&gt;::operator==(other) == false)\n            return false;\n\n        if (m_params.size() != dcrtParams-&gt;m_params.size())\n            return false;\n\n        for (size_t i = 0; i &lt; m_params.size(); i++) {\n            if (*m_params[i] != *dcrtParams-&gt;m_params[i])\n                return false;\n        }\n\n        //    if (originalModulus != dcrtParams-&gt;originalModulus)\n        //      return false;\n\n        return true;\n    }\n\n    /**\n   * @brief Method to recalculate the composite modulus from the component\n   * moduli.\n   */\n    void RecalculateModulus() {\n        ElemParams&lt;IntType&gt;::m_ciphertextModulus = 1;\n        for (size_t i = 0; i &lt; m_params.size(); i++)\n            ElemParams&lt;IntType&gt;::m_ciphertextModulus =\n                ElemParams&lt;IntType&gt;::m_ciphertextModulus * IntType(m_params[i]-&gt;GetModulus().ConvertToInt());\n    }\n\n    /**\n   * @brief Method to recalculate the big composite modulus from the component\n   * moduli.\n   */\n    void RecalculateBigModulus() {\n        ElemParams&lt;IntType&gt;::m_bigCiphertextModulus = 1;\n        for (size_t i = 0; i &lt; m_params.size(); i++)\n            ElemParams&lt;IntType&gt;::m_bigCiphertextModulus =\n                ElemParams&lt;IntType&gt;::m_bigCiphertextModulus * IntType(m_params[i]-&gt;GetBigModulus().ConvertToInt());\n    }\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::base_class&lt;ElemParams&lt;IntType&gt;&gt;(this));\n        ar(::cereal::make_nvp(&quot;p&quot;, m_params));\n        ar(::cereal::make_nvp(&quot;m&quot;, m_originalModulus));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                 &quot; is from a later version of the library&quot;);\n        }\n        ar(::cereal::base_class&lt;ElemParams&lt;IntType&gt;&gt;(this));\n        ar(::cereal::make_nvp(&quot;p&quot;, m_params));\n        ar(::cereal::make_nvp(&quot;m&quot;, m_originalModulus));\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;DCRTParams&quot;;\n    }\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\nprivate:\n    std::ostream&amp; doprint(std::ostream&amp; out) const override {\n        out &lt;&lt; &quot;ILDCRTParams &quot;;\n        ElemParams&lt;IntType&gt;::doprint(out);\n        out &lt;&lt; std::endl &lt;&lt; &quot; Params:&quot; &lt;&lt; std::endl;\n        for (size_t i = 0; i &lt; m_params.size(); i++) {\n            out &lt;&lt; &quot;   &quot; &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; *m_params[i] &lt;&lt; std::endl;\n        }\n        out &lt;&lt; &quot;OriginalModulus &quot; &lt;&lt; m_originalModulus &lt;&lt; std::endl;\n        return out;\n    }\n\n    // original modulus when being constructed from a Poly or when\n    // ctor is passed that parameter\n    // note orignalModulus will be &lt;= composite modules\n    //   i.e. \\Prod_i=0^k-1 m_params[i]-&gt;GetModulus()\n    // note not using ElemParams::ciphertextModulus due to object stripping\n    IntType m_originalModulus{};\n\n    // array of smaller ILParams\n    std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt; m_params;\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/**\n * Hybrid key switching implementation. See\n * Appendix of https://eprint.iacr.org/2021/204 for details.\n */\n#define PROFILE\n\n#include &quot;keyswitch/keyswitch-hybrid.h&quot;\n\n#include &quot;key/privatekey.h&quot;\n#include &quot;key/publickey.h&quot;\n#include &quot;key/evalkeyrelin.h&quot;\n#include &quot;scheme/ckksrns/ckksrns-cryptoparameters.h&quot;\n#include &quot;ciphertext.h&quot;\n\nnamespace lbcrypto {\n\nEvalKey&lt;DCRTPoly&gt; KeySwitchHYBRID::KeySwitchGenInternal(const PrivateKey&lt;DCRTPoly&gt; oldKey,\n                                                        const PrivateKey&lt;DCRTPoly&gt; newKey) const {\n    return KeySwitchHYBRID::KeySwitchGenInternal(oldKey, newKey, nullptr);\n}\n\nEvalKey&lt;DCRTPoly&gt; KeySwitchHYBRID::KeySwitchGenInternal(const PrivateKey&lt;DCRTPoly&gt; oldKey,\n                                                        const PrivateKey&lt;DCRTPoly&gt; newKey,\n                                                        const EvalKey&lt;DCRTPoly&gt; ekPrev) const {\n    EvalKeyRelin&lt;DCRTPoly&gt; ek(std::make_shared&lt;EvalKeyRelinImpl&lt;DCRTPoly&gt;&gt;(newKey-&gt;GetCryptoContext()));\n\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersRNS&gt;(newKey-&gt;GetCryptoParameters());\n\n    const std::shared_ptr&lt;ParmType&gt; paramsQ  = cryptoParams-&gt;GetElementParams();\n    const std::shared_ptr&lt;ParmType&gt; paramsQP = cryptoParams-&gt;GetParamsQP();\n\n    size_t sizeQ  = paramsQ-&gt;GetParams().size();\n    size_t sizeQP = paramsQP-&gt;GetParams().size();\n\n    DCRTPoly sOld = oldKey-&gt;GetPrivateElement();\n    DCRTPoly sNew = newKey-&gt;GetPrivateElement().Clone();\n\n    // skNew is currently in basis Q. This extends it to basis QP.\n    sNew.SetFormat(Format::COEFFICIENT);\n\n    DCRTPoly sNewExt(paramsQP, Format::COEFFICIENT, true);\n\n    // The part with basis Q\n    for (size_t i = 0; i &lt; sizeQ; i++) {\n        sNewExt.SetElementAtIndex(i, sNew.GetElementAtIndex(i));\n    }\n\n    // The part with basis P\n    for (size_t j = sizeQ; j &lt; sizeQP; j++) {\n        const NativeInteger&amp; pj    = paramsQP-&gt;GetParams()[j]-&gt;GetModulus();\n        const NativeInteger&amp; rootj = paramsQP-&gt;GetParams()[j]-&gt;GetRootOfUnity();\n        auto sNew0                 = sNew.GetElementAtIndex(0);\n        sNew0.SwitchModulus(pj, rootj, 0, 0);\n        sNewExt.SetElementAtIndex(j, std::move(sNew0));\n    }\n\n    sNewExt.SetFormat(Format::EVALUATION);\n\n    const auto ns      = cryptoParams-&gt;GetNoiseScale();\n    const DggType&amp; dgg = cryptoParams-&gt;GetDiscreteGaussianGenerator();\n    DugType dug;\n\n    size_t numPartQ = cryptoParams-&gt;GetNumPartQ();\n\n    std::vector&lt;DCRTPoly&gt; av(numPartQ);\n    std::vector&lt;DCRTPoly&gt; bv(numPartQ);\n\n    std::vector&lt;NativeInteger&gt; PModq = cryptoParams-&gt;GetPModq();\n    size_t numPerPartQ               = cryptoParams-&gt;GetNumPerPartQ();\n\n    for (size_t part = 0; part &lt; numPartQ; ++part) {\n        DCRTPoly a = (ekPrev == nullptr) ? DCRTPoly(dug, paramsQP, Format::EVALUATION) :  // single-key HE\n                                           ekPrev-&gt;GetAVector()[part];                                      // threshold HE\n        DCRTPoly e(dgg, paramsQP, Format::EVALUATION);\n        DCRTPoly b(paramsQP, Format::EVALUATION, true);\n\n        // starting and ending position of current part\n        size_t startPartIdx = numPerPartQ * part;\n        size_t endPartIdx   = (sizeQ &gt; (startPartIdx + numPerPartQ)) ? (startPartIdx + numPerPartQ) : sizeQ;\n\n        for (size_t i = 0; i &lt; sizeQP; ++i) {\n            auto ai    = a.GetElementAtIndex(i);\n            auto ei    = e.GetElementAtIndex(i);\n            auto sNewi = sNewExt.GetElementAtIndex(i);\n\n            if (i &lt; startPartIdx || i &gt;= endPartIdx) {\n                b.SetElementAtIndex(i, -ai * sNewi + ns * ei);\n            }\n            else {\n                // P * sOld is only applied for the current part\n                auto sOldi = sOld.GetElementAtIndex(i);\n                b.SetElementAtIndex(i, -ai * sNewi + PModq[i] * sOldi + ns * ei);\n            }\n        }\n\n        av[part] = a;\n        bv[part] = b;\n    }\n\n    ek-&gt;SetAVector(std::move(av));\n    ek-&gt;SetBVector(std::move(bv));\n    ek-&gt;SetKeyTag(newKey-&gt;GetKeyTag());\n    return ek;\n}\n\nEvalKey&lt;DCRTPoly&gt; KeySwitchHYBRID::KeySwitchGenInternal(const PrivateKey&lt;DCRTPoly&gt; oldKey,\n                                                        const PublicKey&lt;DCRTPoly&gt; newKey) const {\n    EvalKeyRelin&lt;DCRTPoly&gt; ek = std::make_shared&lt;EvalKeyRelinImpl&lt;DCRTPoly&gt;&gt;(newKey-&gt;GetCryptoContext());\n\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersRNS&gt;(newKey-&gt;GetCryptoParameters());\n\n    const std::shared_ptr&lt;ParmType&gt; paramsQ  = cryptoParams-&gt;GetElementParams();\n    const std::shared_ptr&lt;ParmType&gt; paramsQP = cryptoParams-&gt;GetParamsQP();\n\n    usint sizeQ  = paramsQ-&gt;GetParams().size();\n    usint sizeQP = paramsQP-&gt;GetParams().size();\n\n    DCRTPoly sOld = oldKey-&gt;GetPrivateElement();\n\n    DCRTPoly newp0 = newKey-&gt;GetPublicElements().at(0);\n    DCRTPoly newp1 = newKey-&gt;GetPublicElements().at(1);\n\n    const auto ns      = cryptoParams-&gt;GetNoiseScale();\n    const DggType&amp; dgg = cryptoParams-&gt;GetDiscreteGaussianGenerator();\n    DugType dug;\n    TugType tug;\n\n    auto numPartQ = cryptoParams-&gt;GetNumPartQ();\n\n    std::vector&lt;DCRTPoly&gt; av(numPartQ);\n    std::vector&lt;DCRTPoly&gt; bv(numPartQ);\n\n    std::vector&lt;NativeInteger&gt; PModq = cryptoParams-&gt;GetPModq();\n    usint numPerPartQ                = cryptoParams-&gt;GetNumPerPartQ();\n\n    for (usint part = 0; part &lt; numPartQ; part++) {\n        DCRTPoly u = (cryptoParams-&gt;GetSecretKeyDist() == GAUSSIAN) ? DCRTPoly(dgg, paramsQP, Format::EVALUATION) :\n                                                                      DCRTPoly(tug, paramsQP, Format::EVALUATION);\n\n        DCRTPoly e0(dgg, paramsQP, Format::EVALUATION);\n        DCRTPoly e1(dgg, paramsQP, Format::EVALUATION);\n\n        DCRTPoly a(paramsQP, Format::EVALUATION, true);\n        DCRTPoly b(paramsQP, Format::EVALUATION, true);\n\n        // starting and ending position of current part\n        usint startPartIdx = numPerPartQ * part;\n        usint endPartIdx   = (sizeQ &gt; startPartIdx + numPerPartQ) ? (startPartIdx + numPerPartQ) : sizeQ;\n\n        for (usint i = 0; i &lt; sizeQP; i++) {\n            auto e0i = e0.GetElementAtIndex(i);\n            auto e1i = e1.GetElementAtIndex(i);\n\n            auto ui = u.GetElementAtIndex(i);\n\n            auto newp0i = newp0.GetElementAtIndex(i);\n            auto newp1i = newp1.GetElementAtIndex(i);\n\n            a.SetElementAtIndex(i, newp1i * ui + ns * e1i);\n\n            if (i &lt; startPartIdx || i &gt;= endPartIdx) {\n                b.SetElementAtIndex(i, newp0i * ui + ns * e0i);\n            }\n            else {\n                // P * sOld is only applied for the current part\n                auto sOldi = sOld.GetElementAtIndex(i);\n                b.SetElementAtIndex(i, newp0i * ui + ns * e0i + PModq[i] * sOldi);\n            }\n        }\n\n        av[part] = a;\n        bv[part] = b;\n    }\n\n    ek-&gt;SetAVector(std::move(av));\n    ek-&gt;SetBVector(std::move(bv));\n    ek-&gt;SetKeyTag(newKey-&gt;GetKeyTag());\n\n    return ek;\n}\n\nvoid KeySwitchHYBRID::KeySwitchInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, const EvalKey&lt;DCRTPoly&gt; ek) const {\n    std::vector&lt;DCRTPoly&gt;&amp; cv = ciphertext-&gt;GetElements();\n\n    std::shared_ptr&lt;std::vector&lt;DCRTPoly&gt;&gt; ba = (cv.size() == 2) ? KeySwitchCore(cv[1], ek) : KeySwitchCore(cv[2], ek);\n\n    cv[0].SetFormat((*ba)[0].GetFormat());\n    cv[0] += (*ba)[0];\n\n    cv[1].SetFormat((*ba)[1].GetFormat());\n    if (cv.size() &gt; 2) {\n        cv[1] += (*ba)[1];\n    }\n    else {\n        cv[1] = (*ba)[1];\n    }\n    cv.resize(2);\n}\n\nCiphertext&lt;DCRTPoly&gt; KeySwitchHYBRID::KeySwitchExt(ConstCiphertext&lt;DCRTPoly&gt; ciphertext, bool addFirst) const {\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(ciphertext-&gt;GetCryptoParameters());\n\n    const std::vector&lt;DCRTPoly&gt;&amp; cv = ciphertext-&gt;GetElements();\n\n    const auto paramsQl  = cv[0].GetParams();\n    const auto paramsP   = cryptoParams-&gt;GetParamsP();\n    const auto paramsQlP = cv[0].GetExtendedCRTBasis(paramsP);\n\n    size_t sizeQl = paramsQl-&gt;GetParams().size();\n    usint sizeCv  = cv.size();\n    std::vector&lt;DCRTPoly&gt; resultElements(sizeCv);\n    for (usint k = 0; k &lt; sizeCv; k++) {\n        resultElements[k] = DCRTPoly(paramsQlP, Format::EVALUATION, true);\n        if ((addFirst) || (k &gt; 0)) {\n            auto cMult = cv[k].TimesNoCheck(cryptoParams-&gt;GetPModq());\n            for (usint i = 0; i &lt; sizeQl; i++) {\n                resultElements[k].SetElementAtIndex(i, cMult.GetElementAtIndex(i));\n            }\n        }\n    }\n\n    Ciphertext&lt;DCRTPoly&gt; result = ciphertext-&gt;CloneZero();\n    result-&gt;SetElements(resultElements);\n    return result;\n}\n\nCiphertext&lt;DCRTPoly&gt; KeySwitchHYBRID::KeySwitchDown(ConstCiphertext&lt;DCRTPoly&gt; ciphertext) const {\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(ciphertext-&gt;GetCryptoParameters());\n\n    const auto paramsP   = cryptoParams-&gt;GetParamsP();\n    const auto paramsQlP = ciphertext-&gt;GetElements()[0].GetParams();\n\n    // TODO : (Andrey) precompute paramsQl in cryptoparameters\n    usint sizeQl = paramsQlP-&gt;GetParams().size() - paramsP-&gt;GetParams().size();\n    std::vector&lt;NativeInteger&gt; moduliQ(sizeQl);\n    std::vector&lt;NativeInteger&gt; rootsQ(sizeQl);\n    for (size_t i = 0; i &lt; sizeQl; i++) {\n        moduliQ[i] = paramsQlP-&gt;GetParams()[i]-&gt;GetModulus();\n        rootsQ[i]  = paramsQlP-&gt;GetParams()[i]-&gt;GetRootOfUnity();\n    }\n    auto paramsQl = std::make_shared&lt;typename DCRTPoly::Params&gt;(2 * paramsQlP-&gt;GetRingDimension(), moduliQ, rootsQ);\n\n    auto cTilda = ciphertext-&gt;GetElements();\n\n    PlaintextModulus t = (cryptoParams-&gt;GetNoiseScale() == 1) ? 0 : cryptoParams-&gt;GetPlaintextModulus();\n\n    DCRTPoly ct0 = cTilda[0].ApproxModDown(paramsQl, cryptoParams-&gt;GetParamsP(), cryptoParams-&gt;GetPInvModq(),\n                                           cryptoParams-&gt;GetPInvModqPrecon(), cryptoParams-&gt;GetPHatInvModp(),\n                                           cryptoParams-&gt;GetPHatInvModpPrecon(), cryptoParams-&gt;GetPHatModq(),\n                                           cryptoParams-&gt;GetModqBarrettMu(), cryptoParams-&gt;GettInvModp(),\n                                           cryptoParams-&gt;GettInvModpPrecon(), t, cryptoParams-&gt;GettModqPrecon());\n\n    DCRTPoly ct1 = cTilda[1].ApproxModDown(paramsQl, cryptoParams-&gt;GetParamsP(), cryptoParams-&gt;GetPInvModq(),\n                                           cryptoParams-&gt;GetPInvModqPrecon(), cryptoParams-&gt;GetPHatInvModp(),\n                                           cryptoParams-&gt;GetPHatInvModpPrecon(), cryptoParams-&gt;GetPHatModq(),\n                                           cryptoParams-&gt;GetModqBarrettMu(), cryptoParams-&gt;GettInvModp(),\n                                           cryptoParams-&gt;GettInvModpPrecon(), t, cryptoParams-&gt;GettModqPrecon());\n\n    Ciphertext&lt;DCRTPoly&gt; result = ciphertext-&gt;CloneZero();\n    result-&gt;SetElements({ct0, ct1});\n    return result;\n}\n\nDCRTPoly KeySwitchHYBRID::KeySwitchDownFirstElement(ConstCiphertext&lt;DCRTPoly&gt; ciphertext) const {\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(ciphertext-&gt;GetCryptoParameters());\n\n    const std::vector&lt;DCRTPoly&gt;&amp; cTilda = ciphertext-&gt;GetElements();\n\n    const auto paramsP   = cryptoParams-&gt;GetParamsP();\n    const auto paramsQlP = cTilda[0].GetParams();\n\n    // TODO : (Andrey) precompute paramsQl in cryptoparameters\n    usint sizeQl = paramsQlP-&gt;GetParams().size() - paramsP-&gt;GetParams().size();\n    std::vector&lt;NativeInteger&gt; moduliQ(sizeQl);\n    std::vector&lt;NativeInteger&gt; rootsQ(sizeQl);\n    for (size_t i = 0; i &lt; sizeQl; i++) {\n        moduliQ[i] = paramsQlP-&gt;GetParams()[i]-&gt;GetModulus();\n        rootsQ[i]  = paramsQlP-&gt;GetParams()[i]-&gt;GetRootOfUnity();\n    }\n    auto paramsQl = std::make_shared&lt;typename DCRTPoly::Params&gt;(2 * paramsQlP-&gt;GetRingDimension(), moduliQ, rootsQ);\n\n    PlaintextModulus t = (cryptoParams-&gt;GetNoiseScale() == 1) ? 0 : cryptoParams-&gt;GetPlaintextModulus();\n\n    DCRTPoly cv0 = cTilda[0].ApproxModDown(paramsQl, cryptoParams-&gt;GetParamsP(), cryptoParams-&gt;GetPInvModq(),\n                                           cryptoParams-&gt;GetPInvModqPrecon(), cryptoParams-&gt;GetPHatInvModp(),\n                                           cryptoParams-&gt;GetPHatInvModpPrecon(), cryptoParams-&gt;GetPHatModq(),\n                                           cryptoParams-&gt;GetModqBarrettMu(), cryptoParams-&gt;GettInvModp(),\n                                           cryptoParams-&gt;GettInvModpPrecon(), t, cryptoParams-&gt;GettModqPrecon());\n\n    return cv0;\n}\n\nstd::shared_ptr&lt;std::vector&lt;DCRTPoly&gt;&gt; KeySwitchHYBRID::KeySwitchCore(const DCRTPoly&amp; a,\n                                                                      const EvalKey&lt;DCRTPoly&gt; evalKey) const {\n    return EvalFastKeySwitchCore(EvalKeySwitchPrecomputeCore(a, evalKey-&gt;GetCryptoParameters()), evalKey,\n                                 a.GetParams());\n}\n\nstd::shared_ptr&lt;std::vector&lt;DCRTPoly&gt;&gt; KeySwitchHYBRID::EvalKeySwitchPrecomputeCore(\n    const DCRTPoly&amp; c, std::shared_ptr&lt;CryptoParametersBase&lt;DCRTPoly&gt;&gt; cryptoParamsBase) const {\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersRNS&gt;(cryptoParamsBase);\n\n    const std::shared_ptr&lt;ParmType&gt; paramsQl  = c.GetParams();\n    const std::shared_ptr&lt;ParmType&gt; paramsP   = cryptoParams-&gt;GetParamsP();\n    const std::shared_ptr&lt;ParmType&gt; paramsQlP = c.GetExtendedCRTBasis(paramsP);\n\n    size_t sizeQl  = paramsQl-&gt;GetParams().size();\n    size_t sizeP   = paramsP-&gt;GetParams().size();\n    size_t sizeQlP = sizeQl + sizeP;\n\n    uint32_t alpha = cryptoParams-&gt;GetNumPerPartQ();\n    // The number of digits of the current ciphertext\n    uint32_t numPartQl = ceil((static_cast&lt;double&gt;(sizeQl)) / alpha);\n    if (numPartQl &gt; cryptoParams-&gt;GetNumberOfQPartitions())\n        numPartQl = cryptoParams-&gt;GetNumberOfQPartitions();\n\n    std::vector&lt;DCRTPoly&gt; partsCt(numPartQl);\n\n    // Digit decomposition\n    // Zero-padding and split\n    for (uint32_t part = 0; part &lt; numPartQl; part++) {\n        if (part == numPartQl - 1) {\n            auto paramsPartQ = cryptoParams-&gt;GetParamsPartQ(part);\n\n            uint32_t sizePartQl = sizeQl - alpha * part;\n\n            std::vector&lt;NativeInteger&gt; moduli(sizePartQl);\n            std::vector&lt;NativeInteger&gt; roots(sizePartQl);\n\n            for (uint32_t i = 0; i &lt; sizePartQl; i++) {\n                moduli[i] = paramsPartQ-&gt;GetParams()[i]-&gt;GetModulus();\n                roots[i]  = paramsPartQ-&gt;GetParams()[i]-&gt;GetRootOfUnity();\n            }\n\n            auto params = DCRTPoly::Params(paramsPartQ-&gt;GetCyclotomicOrder(), moduli, roots, {}, {}, 0);\n\n            partsCt[part] = DCRTPoly(std::make_shared&lt;ParmType&gt;(params), Format::EVALUATION, true);\n        }\n        else {\n            partsCt[part] = DCRTPoly(cryptoParams-&gt;GetParamsPartQ(part), Format::EVALUATION, true);\n        }\n\n        usint sizePartQl   = partsCt[part].GetNumOfElements();\n        usint startPartIdx = alpha * part;\n        for (uint32_t i = 0, idx = startPartIdx; i &lt; sizePartQl; i++, idx++) {\n            partsCt[part].SetElementAtIndex(i, c.GetElementAtIndex(idx));\n        }\n    }\n\n    std::vector&lt;DCRTPoly&gt; partsCtCompl(numPartQl);\n    std::vector&lt;DCRTPoly&gt; partsCtExt(numPartQl);\n\n    for (uint32_t part = 0; part &lt; numPartQl; part++) {\n        auto partCtClone = partsCt[part].Clone();\n        partCtClone.SetFormat(Format::COEFFICIENT);\n\n        uint32_t sizePartQl = partsCt[part].GetNumOfElements();\n        partsCtCompl[part]  = partCtClone.ApproxSwitchCRTBasis(\n             cryptoParams-&gt;GetParamsPartQ(part), cryptoParams-&gt;GetParamsComplPartQ(sizeQl - 1, part),\n             cryptoParams-&gt;GetPartQlHatInvModq(part, sizePartQl - 1),\n             cryptoParams-&gt;GetPartQlHatInvModqPrecon(part, sizePartQl - 1),\n             cryptoParams-&gt;GetPartQlHatModp(sizeQl - 1, part),\n             cryptoParams-&gt;GetmodComplPartqBarrettMu(sizeQl - 1, part));\n\n        partsCtCompl[part].SetFormat(Format::EVALUATION);\n\n        partsCtExt[part] = DCRTPoly(paramsQlP, Format::EVALUATION, true);\n\n        usint startPartIdx = alpha * part;\n        usint endPartIdx   = startPartIdx + sizePartQl;\n        for (usint i = 0; i &lt; startPartIdx; i++) {\n            partsCtExt[part].SetElementAtIndex(i, partsCtCompl[part].GetElementAtIndex(i));\n        }\n        for (usint i = startPartIdx, idx = 0; i &lt; endPartIdx; i++, idx++) {\n            partsCtExt[part].SetElementAtIndex(i, partsCt[part].GetElementAtIndex(idx));\n        }\n        for (usint i = endPartIdx; i &lt; sizeQlP; ++i) {\n            partsCtExt[part].SetElementAtIndex(i, partsCtCompl[part].GetElementAtIndex(i - sizePartQl));\n        }\n    }\n\n    return std::make_shared&lt;std::vector&lt;DCRTPoly&gt;&gt;(std::move(partsCtExt));\n}\n\nstd::shared_ptr&lt;std::vector&lt;DCRTPoly&gt;&gt; KeySwitchHYBRID::EvalFastKeySwitchCore(\n    const std::shared_ptr&lt;std::vector&lt;DCRTPoly&gt;&gt; digits, const EvalKey&lt;DCRTPoly&gt; evalKey,\n    const std::shared_ptr&lt;ParmType&gt; paramsQl) const {\n    const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersRNS&gt;(evalKey-&gt;GetCryptoParameters());\n\n    std::shared_ptr&lt;std::vector&lt;DCRTPoly&gt;&gt; cTilda = EvalFastKeySwitchCoreExt(digits, evalKey, paramsQl);\n\n    PlaintextModulus t = (cryptoParams-&gt;GetNoiseScale() == 1) ? 0 : cryptoParams-&gt;GetPlaintextModulus();\n\n    DCRTPoly ct0 = (*cTilda)[0].ApproxModDown(paramsQl, cryptoParams-&gt;GetParamsP(), cryptoParams-&gt;GetPInvModq(),\n                                              cryptoParams-&gt;GetPInvModqPrecon(), cryptoParams-&gt;GetPHatInvModp(),\n                                              cryptoParams-&gt;GetPHatInvModpPrecon(), cryptoParams-&gt;GetPHatModq(),\n                                              cryptoParams-&gt;GetModqBarrettMu(), cryptoParams-&gt;GettInvModp(),\n                                              cryptoParams-&gt;GettInvModpPrecon(), t, cryptoParams-&gt;GettModqPrecon());\n\n    DCRTPoly ct1 = (*cTilda)[1].ApproxModDown(paramsQl, cryptoParams-&gt;GetParamsP(), cryptoParams-&gt;GetPInvModq(),\n                                              cryptoParams-&gt;GetPInvModqPrecon(), cryptoParams-&gt;GetPHatInvModp(),\n                                              cryptoParams-&gt;GetPHatInvModpPrecon(), cryptoParams-&gt;GetPHatModq(),\n                                              cryptoParams-&gt;GetModqBarrettMu(), cryptoParams-&gt;GettInvModp(),\n                                              cryptoParams-&gt;GettInvModpPrecon(), t, cryptoParams-&gt;GettModqPrecon());\n\n    return std::make_shared&lt;std::vector&lt;DCRTPoly&gt;&gt;(std::initializer_list&lt;DCRTPoly&gt;{std::move(ct0), std::move(ct1)});\n}\n\nstd::shared_ptr&lt;std::vector&lt;DCRTPoly&gt;&gt; KeySwitchHYBRID::EvalFastKeySwitchCoreExt(\n    const std::shared_ptr&lt;std::vector&lt;DCRTPoly&gt;&gt; digits, const EvalKey&lt;DCRTPoly&gt; evalKey,\n    const std::shared_ptr&lt;ParmType&gt; paramsQl) const {\n    const auto cryptoParams         = std::dynamic_pointer_cast&lt;CryptoParametersRNS&gt;(evalKey-&gt;GetCryptoParameters());\n    const std::vector&lt;DCRTPoly&gt;&amp; bv = evalKey-&gt;GetBVector();\n    const std::vector&lt;DCRTPoly&gt;&amp; av = evalKey-&gt;GetAVector();\n\n    const std::shared_ptr&lt;ParmType&gt; paramsP   = cryptoParams-&gt;GetParamsP();\n    const std::shared_ptr&lt;ParmType&gt; paramsQlP = (*digits)[0].GetParams();\n\n    size_t sizeQl  = paramsQl-&gt;GetParams().size();\n    size_t sizeQlP = paramsQlP-&gt;GetParams().size();\n    size_t sizeQ   = cryptoParams-&gt;GetElementParams()-&gt;GetParams().size();\n\n    DCRTPoly cTilda0(paramsQlP, Format::EVALUATION, true);\n    DCRTPoly cTilda1(paramsQlP, Format::EVALUATION, true);\n\n    for (uint32_t j = 0; j &lt; digits-&gt;size(); j++) {\n        const DCRTPoly&amp; cj = (*digits)[j];\n        const DCRTPoly&amp; bj = bv[j];\n        const DCRTPoly&amp; aj = av[j];\n\n        for (usint i = 0; i &lt; sizeQl; i++) {\n            const auto&amp; cji = cj.GetElementAtIndex(i);\n            const auto&amp; aji = aj.GetElementAtIndex(i);\n            const auto&amp; bji = bj.GetElementAtIndex(i);\n\n            cTilda0.SetElementAtIndex(i, cTilda0.GetElementAtIndex(i) + cji * bji);\n            cTilda1.SetElementAtIndex(i, cTilda1.GetElementAtIndex(i) + cji * aji);\n        }\n        for (usint i = sizeQl, idx = sizeQ; i &lt; sizeQlP; i++, idx++) {\n            const auto&amp; cji = cj.GetElementAtIndex(i);\n            const auto&amp; aji = aj.GetElementAtIndex(idx);\n            const auto&amp; bji = bj.GetElementAtIndex(idx);\n\n            cTilda0.SetElementAtIndex(i, cTilda0.GetElementAtIndex(i) + cji * bji);\n            cTilda1.SetElementAtIndex(i, cTilda1.GetElementAtIndex(i) + cji * aji);\n        }\n    }\n\n    return std::make_shared&lt;std::vector&lt;DCRTPoly&gt;&gt;(\n        std::initializer_list&lt;DCRTPoly&gt;{std::move(cTilda0), std::move(cTilda1)});\n}\n\n}  // namespace lbcrypto\n"}, "/usr/include/c++/11/bits/shared_ptr.h": {"id": "/usr/include/c++/11/bits/shared_ptr.h", "filePath": "/usr/include/c++/11/bits/shared_ptr.h", "content": "// shared_ptr and weak_ptr implementation -*- C++ -*-\n\n// Copyright (C) 2007-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n// GCC Note: Based on files from version 1.32.0 of the Boost library.\n\n//  shared_count.hpp\n//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n\n//  shared_ptr.hpp\n//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  weak_ptr.hpp\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  enable_shared_from_this.hpp\n//  Copyright (C) 2002 Peter Dimov\n\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n\n/** @file\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _SHARED_PTR_H\n#define _SHARED_PTR_H 1\n\n#include &lt;iosfwd&gt;           \t  // std::basic_ostream\n#include &lt;bits/shared_ptr_base.h&gt;\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   * @addtogroup pointer_abstractions\n   * @{\n   */\n\n  // 20.7.2.2.11 shared_ptr I/O\n\n  /// Write the stored pointer to an ostream.\n  /// @relates shared_ptr\n  template&lt;typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp&gt;\n    inline std::basic_ostream&lt;_Ch, _Tr&gt;&amp;\n    operator&lt;&lt;(std::basic_ostream&lt;_Ch, _Tr&gt;&amp; __os,\n\t       const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __p)\n    {\n      __os &lt;&lt; __p.get();\n      return __os;\n    }\n\n  template&lt;typename _Del, typename _Tp, _Lock_policy _Lp&gt;\n    inline _Del*\n    get_deleter(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __p) noexcept\n    {\n#if __cpp_rtti\n      return static_cast&lt;_Del*&gt;(__p._M_get_deleter(typeid(_Del)));\n#else\n      return 0;\n#endif\n    }\n\n  /// 20.7.2.2.10 shared_ptr get_deleter\n\n  /// If `__p` has a deleter of type `_Del`, return a pointer to it.\n  /// @relates shared_ptr\n  template&lt;typename _Del, typename _Tp&gt;\n    inline _Del*\n    get_deleter(const shared_ptr&lt;_Tp&gt;&amp; __p) noexcept\n    {\n#if __cpp_rtti\n      return static_cast&lt;_Del*&gt;(__p._M_get_deleter(typeid(_Del)));\n#else\n      return 0;\n#endif\n    }\n\n  /**\n   *  @brief  A smart pointer with reference-counted copy semantics.\n   *\n   * A `shared_ptr` object is either empty or _owns_ a pointer passed\n   * to the constructor. Copies of a `shared_ptr` share ownership of\n   * the same pointer. When the last `shared_ptr` that owns the pointer\n   * is destroyed or reset, the owned pointer is freed (either by `delete`\n   * or by invoking a custom deleter that was passed to the constructor).\n   *\n   * A `shared_ptr` also stores another pointer, which is usually\n   * (but not always) the same pointer as it owns. The stored pointer\n   * can be retrieved by calling the `get()` member function.\n   *\n   * The equality and relational operators for `shared_ptr` only compare\n   * the stored pointer returned by `get()`, not the owned pointer.\n   * To test whether two `shared_ptr` objects share ownership of the same\n   * pointer see `std::shared_ptr::owner_before` and `std::owner_less`.\n  */\n  template&lt;typename _Tp&gt;\n    class shared_ptr : public __shared_ptr&lt;_Tp&gt;\n    {\n      template&lt;typename... _Args&gt;\n\tusing _Constructible = typename enable_if&lt;\n\t  is_constructible&lt;__shared_ptr&lt;_Tp&gt;, _Args...&gt;::value\n\t&gt;::type;\n\n      template&lt;typename _Arg&gt;\n\tusing _Assignable = typename enable_if&lt;\n\t  is_assignable&lt;__shared_ptr&lt;_Tp&gt;&amp;, _Arg&gt;::value, shared_ptr&amp;\n\t&gt;::type;\n\n    public:\n\n      /// The type pointed to by the stored pointer, remove_extent_t&lt;_Tp&gt;\n      using element_type = typename __shared_ptr&lt;_Tp&gt;::element_type;\n\n#if __cplusplus &gt;= 201703L\n# define __cpp_lib_shared_ptr_weak_type 201606\n      /// The corresponding weak_ptr type for this shared_ptr\n      using weak_type = weak_ptr&lt;_Tp&gt;;\n#endif\n      /**\n       *  @brief  Construct an empty %shared_ptr.\n       *  @post   use_count()==0 &amp;&amp; get()==0\n       */\n      constexpr shared_ptr() noexcept : __shared_ptr&lt;_Tp&gt;() { }\n\n      shared_ptr(const shared_ptr&amp;) noexcept = default; ///&lt; Copy constructor\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns the pointer @a __p.\n       *  @param  __p  A pointer that is convertible to element_type*.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @c delete @a __p is called.\n       */\n      template&lt;typename _Yp, typename = _Constructible&lt;_Yp*&gt;&gt;\n\texplicit\n\tshared_ptr(_Yp* __p) : __shared_ptr&lt;_Tp&gt;(__p) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns the pointer @a __p\n       *          and the deleter @a __d.\n       *  @param  __p  A pointer.\n       *  @param  __d  A deleter.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw\n       *\n       *  __shared_ptr will release __p by calling __d(__p)\n       */\n      template&lt;typename _Yp, typename _Deleter,\n\t       typename = _Constructible&lt;_Yp*, _Deleter&gt;&gt;\n\tshared_ptr(_Yp* __p, _Deleter __d)\n        : __shared_ptr&lt;_Tp&gt;(__p, std::move(__d)) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns a null pointer\n       *          and the deleter @a __d.\n       *  @param  __p  A null pointer constant.\n       *  @param  __d  A deleter.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw\n       *\n       *  The last owner will call __d(__p)\n       */\n      template&lt;typename _Deleter&gt;\n\tshared_ptr(nullptr_t __p, _Deleter __d)\n        : __shared_ptr&lt;_Tp&gt;(__p, std::move(__d)) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns the pointer @a __p\n       *          and the deleter @a __d.\n       *  @param  __p  A pointer.\n       *  @param  __d  A deleter.\n       *  @param  __a  An allocator.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw _Alloc&#x27;s copy constructor and destructor must not\n       *  throw.\n       *\n       *  __shared_ptr will release __p by calling __d(__p)\n       */\n      template&lt;typename _Yp, typename _Deleter, typename _Alloc,\n\t       typename = _Constructible&lt;_Yp*, _Deleter, _Alloc&gt;&gt;\n\tshared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)\n\t: __shared_ptr&lt;_Tp&gt;(__p, std::move(__d), std::move(__a)) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns a null pointer\n       *          and the deleter @a __d.\n       *  @param  __p  A null pointer constant.\n       *  @param  __d  A deleter.\n       *  @param  __a  An allocator.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw _Alloc&#x27;s copy constructor and destructor must not\n       *  throw.\n       *\n       *  The last owner will call __d(__p)\n       */\n      template&lt;typename _Deleter, typename _Alloc&gt;\n\tshared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)\n\t: __shared_ptr&lt;_Tp&gt;(__p, std::move(__d), std::move(__a)) { }\n\n      // Aliasing constructor\n\n      /**\n       *  @brief  Constructs a `shared_ptr` instance that stores `__p`\n       *          and shares ownership with `__r`.\n       *  @param  __r  A `shared_ptr`.\n       *  @param  __p  A pointer that will remain valid while `*__r` is valid.\n       *  @post   `get() == __p &amp;&amp; use_count() == __r.use_count()`\n       *\n       *  This can be used to construct a `shared_ptr` to a sub-object\n       *  of an object managed by an existing `shared_ptr`. The complete\n       *  object will remain valid while any `shared_ptr` owns it, even\n       *  if they don&#x27;t store a pointer to the complete object.\n       *\n       * @code\n       * shared_ptr&lt;pair&lt;int,int&gt;&gt; pii(new pair&lt;int,int&gt;());\n       * shared_ptr&lt;int&gt; pi(pii, &amp;pii-&gt;first);\n       * assert(pii.use_count() == 2);\n       * @endcode\n       */\n      template&lt;typename _Yp&gt;\n\tshared_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r, element_type* __p) noexcept\n\t: __shared_ptr&lt;_Tp&gt;(__r, __p) { }\n\n#if __cplusplus &gt; 201703L\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2996. Missing rvalue overloads for shared_ptr operations\n      /**\n       *  @brief  Constructs a `shared_ptr` instance that stores `__p`\n       *          and shares ownership with `__r`.\n       *  @param  __r  A `shared_ptr`.\n       *  @param  __p  A pointer that will remain valid while `*__r` is valid.\n       *  @post   `get() == __p &amp;&amp; !__r.use_count() &amp;&amp; !__r.get()`\n       *\n       *  This can be used to construct a `shared_ptr` to a sub-object\n       *  of an object managed by an existing `shared_ptr`. The complete\n       *  object will remain valid while any `shared_ptr` owns it, even\n       *  if they don&#x27;t store a pointer to the complete object.\n       *\n       * @code\n       * shared_ptr&lt;pair&lt;int,int&gt;&gt; pii(new pair&lt;int,int&gt;());\n       * shared_ptr&lt;int&gt; pi1(pii, &amp;pii-&gt;first);\n       * assert(pii.use_count() == 2);\n       * shared_ptr&lt;int&gt; pi2(std::move(pii), &amp;pii-&gt;second);\n       * assert(pii.use_count() == 0);\n       * @endcode\n       */\n      template&lt;typename _Yp&gt;\n\tshared_ptr(shared_ptr&lt;_Yp&gt;&amp;&amp; __r, element_type* __p) noexcept\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r), __p) { }\n#endif\n      /**\n       *  @brief  If @a __r is empty, constructs an empty %shared_ptr;\n       *          otherwise construct a %shared_ptr that shares ownership\n       *          with @a __r.\n       *  @param  __r  A %shared_ptr.\n       *  @post   get() == __r.get() &amp;&amp; use_count() == __r.use_count()\n       */\n      template&lt;typename _Yp,\n\t       typename = _Constructible&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\tshared_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n        : __shared_ptr&lt;_Tp&gt;(__r) { }\n\n      /**\n       *  @brief  Move-constructs a %shared_ptr instance from @a __r.\n       *  @param  __r  A %shared_ptr rvalue.\n       *  @post   *this contains the old value of @a __r, @a __r is empty.\n       */\n      shared_ptr(shared_ptr&amp;&amp; __r) noexcept\n      : __shared_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n      /**\n       *  @brief  Move-constructs a %shared_ptr instance from @a __r.\n       *  @param  __r  A %shared_ptr rvalue.\n       *  @post   *this contains the old value of @a __r, @a __r is empty.\n       */\n      template&lt;typename _Yp, typename = _Constructible&lt;shared_ptr&lt;_Yp&gt;&gt;&gt;\n\tshared_ptr(shared_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n      /**\n       *  @brief  Constructs a %shared_ptr that shares ownership with @a __r\n       *          and stores a copy of the pointer stored in @a __r.\n       *  @param  __r  A weak_ptr.\n       *  @post   use_count() == __r.use_count()\n       *  @throw  bad_weak_ptr when __r.expired(),\n       *          in which case the constructor has no effect.\n       */\n      template&lt;typename _Yp, typename = _Constructible&lt;const weak_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\texplicit shared_ptr(const weak_ptr&lt;_Yp&gt;&amp; __r)\n\t: __shared_ptr&lt;_Tp&gt;(__r) { }\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      template&lt;typename _Yp, typename = _Constructible&lt;auto_ptr&lt;_Yp&gt;&gt;&gt;\n\tshared_ptr(auto_ptr&lt;_Yp&gt;&amp;&amp; __r);\n#pragma GCC diagnostic pop\n#endif\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2399. shared_ptr&#x27;s constructor from unique_ptr should be constrained\n      template&lt;typename _Yp, typename _Del,\n\t       typename = _Constructible&lt;unique_ptr&lt;_Yp, _Del&gt;&gt;&gt;\n\tshared_ptr(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n#if __cplusplus &lt;= 201402L &amp;&amp; _GLIBCXX_USE_DEPRECATED\n      // This non-standard constructor exists to support conversions that\n      // were possible in C++11 and C++14 but are ill-formed in C++17.\n      // If an exception is thrown this constructor has no effect.\n      template&lt;typename _Yp, typename _Del,\n\t\t_Constructible&lt;unique_ptr&lt;_Yp, _Del&gt;, __sp_array_delete&gt;* = 0&gt;\n\tshared_ptr(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r), __sp_array_delete()) { }\n#endif\n\n      /**\n       *  @brief  Construct an empty %shared_ptr.\n       *  @post   use_count() == 0 &amp;&amp; get() == nullptr\n       */\n      constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }\n\n      shared_ptr&amp; operator=(const shared_ptr&amp;) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;\n\toperator=(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(__r);\n\t  return *this;\n\t}\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;auto_ptr&lt;_Yp&gt;&gt;\n\toperator=(auto_ptr&lt;_Yp&gt;&amp;&amp; __r)\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n#pragma GCC diagnostic pop\n#endif\n\n      shared_ptr&amp;\n      operator=(shared_ptr&amp;&amp; __r) noexcept\n      {\n\tthis-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\treturn *this;\n      }\n\n      template&lt;class _Yp&gt;\n\t_Assignable&lt;shared_ptr&lt;_Yp&gt;&gt;\n\toperator=(shared_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp, typename _Del&gt;\n\t_Assignable&lt;unique_ptr&lt;_Yp, _Del&gt;&gt;\n\toperator=(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n\n    private:\n      // This constructor is non-standard, it is used by allocate_shared.\n      template&lt;typename _Alloc, typename... _Args&gt;\n\tshared_ptr(_Sp_alloc_shared_tag&lt;_Alloc&gt; __tag, _Args&amp;&amp;... __args)\n\t: __shared_ptr&lt;_Tp&gt;(__tag, std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n      template&lt;typename _Yp, typename _Alloc, typename... _Args&gt;\n\tfriend shared_ptr&lt;_Yp&gt;\n\tallocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args);\n\n      // This constructor is non-standard, it is used by weak_ptr::lock().\n      shared_ptr(const weak_ptr&lt;_Tp&gt;&amp; __r, std::nothrow_t) noexcept\n      : __shared_ptr&lt;_Tp&gt;(__r, std::nothrow) { }\n\n      friend class weak_ptr&lt;_Tp&gt;;\n    };\n\n#if __cpp_deduction_guides &gt;= 201606\n  template&lt;typename _Tp&gt;\n    shared_ptr(weak_ptr&lt;_Tp&gt;) -&gt;  shared_ptr&lt;_Tp&gt;;\n  template&lt;typename _Tp, typename _Del&gt;\n    shared_ptr(unique_ptr&lt;_Tp, _Del&gt;) -&gt;  shared_ptr&lt;_Tp&gt;;\n#endif\n\n  // 20.7.2.2.7 shared_ptr comparisons\n\n  /// @relates shared_ptr @{\n\n  /// Equality operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator==(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return __a.get() == __b.get(); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator==(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return !__a; }\n\n#ifdef __cpp_lib_three_way_comparison\n  template&lt;typename _Tp, typename _Up&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a,\n\t\tconst shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return compare_three_way()(__a.get(), __b.get()); }\n\n  template&lt;typename _Tp&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using pointer = typename shared_ptr&lt;_Tp&gt;::element_type*;\n      return compare_three_way()(__a.get(), static_cast&lt;pointer&gt;(nullptr));\n    }\n#else\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator==(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return !__a; }\n\n  /// Inequality operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator!=(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return __a.get() != __b.get(); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator!=(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return (bool)__a; }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator!=(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return (bool)__a; }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    {\n      using _Tp_elt = typename shared_ptr&lt;_Tp&gt;::element_type;\n      using _Up_elt = typename shared_ptr&lt;_Up&gt;::element_type;\n      using _Vp = typename common_type&lt;_Tp_elt*, _Up_elt*&gt;::type;\n      return less&lt;_Vp&gt;()(__a.get(), __b.get());\n    }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using _Tp_elt = typename shared_ptr&lt;_Tp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(__a.get(), nullptr);\n    }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    {\n      using _Tp_elt = typename shared_ptr&lt;_Tp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(nullptr, __a.get());\n    }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return !(__b &lt; __a); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(nullptr &lt; __a); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;=(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return !(__a &lt; nullptr); }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return (__b &lt; __a); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return nullptr &lt; __a; }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return __a &lt; nullptr; }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return !(__a &lt; __b); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(__a &lt; nullptr); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;=(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return !(nullptr &lt; __a); }\n#endif\n\n  // 20.7.2.2.8 shared_ptr specialized algorithms.\n\n  /// Swap overload for shared_ptr\n  template&lt;typename _Tp&gt;\n    inline void\n    swap(shared_ptr&lt;_Tp&gt;&amp; __a, shared_ptr&lt;_Tp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n  // 20.7.2.2.9 shared_ptr casts.\n\n  /// Convert type of `shared_ptr`, via `static_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    static_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(__r, static_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr`, via `const_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    const_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(__r, const_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr`, via `dynamic_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    dynamic_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      if (auto* __p = dynamic_cast&lt;typename _Sp::element_type*&gt;(__r.get()))\n\treturn _Sp(__r, __p);\n      return _Sp();\n    }\n\n#if __cplusplus &gt;= 201703L\n  /// Convert type of `shared_ptr`, via `reinterpret_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    reinterpret_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(__r, reinterpret_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n#if __cplusplus &gt; 201703L\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 2996. Missing rvalue overloads for shared_ptr operations\n\n  /// Convert type of `shared_ptr` rvalue, via `static_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    static_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(std::move(__r),\n\t\t static_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr` rvalue, via `const_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    const_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(std::move(__r),\n\t\t const_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr` rvalue, via `dynamic_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    dynamic_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      if (auto* __p = dynamic_cast&lt;typename _Sp::element_type*&gt;(__r.get()))\n\treturn _Sp(std::move(__r), __p);\n      return _Sp();\n    }\n\n  /// Convert type of `shared_ptr` rvalue, via `reinterpret_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    reinterpret_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(std::move(__r),\n\t\t reinterpret_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n#endif // C++20\n#endif // C++17\n\n  /// @}\n\n  /**\n   * @brief  A non-owning observer for a pointer owned by a shared_ptr\n   *\n   * A weak_ptr provides a safe alternative to a raw pointer when you want\n   * a non-owning reference to an object that is managed by a shared_ptr.\n   *\n   * Unlike a raw pointer, a weak_ptr can be converted to a new shared_ptr\n   * that shares ownership with every other shared_ptr that already owns\n   * the pointer. In other words you can upgrade from a non-owning &quot;weak&quot;\n   * reference to an owning shared_ptr, without having access to any of\n   * the existing shared_ptr objects.\n   *\n   * Also unlike a raw pointer, a weak_ptr does not become &quot;dangling&quot; after\n   * the object it points to has been destroyed. Instead, a weak_ptr\n   * becomes _expired_ and can no longer be converted to a shared_ptr that\n   * owns the freed pointer, so you cannot accidentally access the pointed-to\n   * object after it has been destroyed.\n   */\n  template&lt;typename _Tp&gt;\n    class weak_ptr : public __weak_ptr&lt;_Tp&gt;\n    {\n      template&lt;typename _Arg&gt;\n\tusing _Constructible = typename enable_if&lt;\n\t  is_constructible&lt;__weak_ptr&lt;_Tp&gt;, _Arg&gt;::value\n\t&gt;::type;\n\n      template&lt;typename _Arg&gt;\n\tusing _Assignable = typename enable_if&lt;\n\t  is_assignable&lt;__weak_ptr&lt;_Tp&gt;&amp;, _Arg&gt;::value, weak_ptr&amp;\n\t&gt;::type;\n\n    public:\n      constexpr weak_ptr() noexcept = default;\n\n      template&lt;typename _Yp,\n\t       typename = _Constructible&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\tweak_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t: __weak_ptr&lt;_Tp&gt;(__r) { }\n\n      weak_ptr(const weak_ptr&amp;) noexcept = default;\n\n      template&lt;typename _Yp, typename = _Constructible&lt;const weak_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\tweak_ptr(const weak_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t: __weak_ptr&lt;_Tp&gt;(__r) { }\n\n      weak_ptr(weak_ptr&amp;&amp;) noexcept = default;\n\n      template&lt;typename _Yp, typename = _Constructible&lt;weak_ptr&lt;_Yp&gt;&gt;&gt;\n\tweak_ptr(weak_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t: __weak_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n      weak_ptr&amp;\n      operator=(const weak_ptr&amp; __r) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;const weak_ptr&lt;_Yp&gt;&amp;&gt;\n\toperator=(const weak_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t{\n\t  this-&gt;__weak_ptr&lt;_Tp&gt;::operator=(__r);\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;\n\toperator=(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t{\n\t  this-&gt;__weak_ptr&lt;_Tp&gt;::operator=(__r);\n\t  return *this;\n\t}\n\n      weak_ptr&amp;\n      operator=(weak_ptr&amp;&amp; __r) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;weak_ptr&lt;_Yp&gt;&gt;\n\toperator=(weak_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  this-&gt;__weak_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n\n      shared_ptr&lt;_Tp&gt;\n      lock() const noexcept\n      { return shared_ptr&lt;_Tp&gt;(*this, std::nothrow); }\n    };\n\n#if __cpp_deduction_guides &gt;= 201606\n  template&lt;typename _Tp&gt;\n    weak_ptr(shared_ptr&lt;_Tp&gt;) -&gt;  weak_ptr&lt;_Tp&gt;;\n#endif\n\n  // 20.7.2.3.6 weak_ptr specialized algorithms.\n  /// Swap overload for weak_ptr\n  /// @relates weak_ptr\n  template&lt;typename _Tp&gt;\n    inline void\n    swap(weak_ptr&lt;_Tp&gt;&amp; __a, weak_ptr&lt;_Tp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n\n  /// Primary template owner_less\n  template&lt;typename _Tp = void&gt;\n    struct owner_less;\n\n  /// Void specialization of owner_less compares either shared_ptr or weak_ptr\n  template&lt;&gt;\n    struct owner_less&lt;void&gt; : _Sp_owner_less&lt;void, void&gt;\n    { };\n\n  /// Partial specialization of owner_less for shared_ptr.\n  template&lt;typename _Tp&gt;\n    struct owner_less&lt;shared_ptr&lt;_Tp&gt;&gt;\n    : public _Sp_owner_less&lt;shared_ptr&lt;_Tp&gt;, weak_ptr&lt;_Tp&gt;&gt;\n    { };\n\n  /// Partial specialization of owner_less for weak_ptr.\n  template&lt;typename _Tp&gt;\n    struct owner_less&lt;weak_ptr&lt;_Tp&gt;&gt;\n    : public _Sp_owner_less&lt;weak_ptr&lt;_Tp&gt;, shared_ptr&lt;_Tp&gt;&gt;\n    { };\n\n  /**\n   *  @brief Base class allowing use of member function shared_from_this.\n   */\n  template&lt;typename _Tp&gt;\n    class enable_shared_from_this\n    {\n    protected:\n      constexpr enable_shared_from_this() noexcept { }\n\n      enable_shared_from_this(const enable_shared_from_this&amp;) noexcept { }\n\n      enable_shared_from_this&amp;\n      operator=(const enable_shared_from_this&amp;) noexcept\n      { return *this; }\n\n      ~enable_shared_from_this() { }\n\n    public:\n      shared_ptr&lt;_Tp&gt;\n      shared_from_this()\n      { return shared_ptr&lt;_Tp&gt;(this-&gt;_M_weak_this); }\n\n      shared_ptr&lt;const _Tp&gt;\n      shared_from_this() const\n      { return shared_ptr&lt;const _Tp&gt;(this-&gt;_M_weak_this); }\n\n#if __cplusplus &gt; 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n#define __cpp_lib_enable_shared_from_this 201603\n      weak_ptr&lt;_Tp&gt;\n      weak_from_this() noexcept\n      { return this-&gt;_M_weak_this; }\n\n      weak_ptr&lt;const _Tp&gt;\n      weak_from_this() const noexcept\n      { return this-&gt;_M_weak_this; }\n#endif\n\n    private:\n      template&lt;typename _Tp1&gt;\n\tvoid\n\t_M_weak_assign(_Tp1* __p, const __shared_count&lt;&gt;&amp; __n) const noexcept\n\t{ _M_weak_this._M_assign(__p, __n); }\n\n      // Found by ADL when this is an associated class.\n      friend const enable_shared_from_this*\n      __enable_shared_from_this_base(const __shared_count&lt;&gt;&amp;,\n\t\t\t\t     const enable_shared_from_this* __p)\n      { return __p; }\n\n      template&lt;typename, _Lock_policy&gt;\n\tfriend class __shared_ptr;\n\n      mutable weak_ptr&lt;_Tp&gt;  _M_weak_this;\n    };\n\n  /// @relates shared_ptr @{\n\n  /**\n   *  @brief  Create an object that is owned by a shared_ptr.\n   *  @param  __a     An allocator.\n   *  @param  __args  Arguments for the @a _Tp object&#x27;s constructor.\n   *  @return A shared_ptr that owns the newly created object.\n   *  @throw  An exception thrown from @a _Alloc::allocate or from the\n   *          constructor of @a _Tp.\n   *\n   *  A copy of @a __a will be used to allocate memory for the shared_ptr\n   *  and the new object.\n   */\n  template&lt;typename _Tp, typename _Alloc, typename... _Args&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args)\n    {\n      static_assert(!is_array&lt;_Tp&gt;::value, &quot;make_shared&lt;T[]&gt; not supported&quot;);\n\n      return shared_ptr&lt;_Tp&gt;(_Sp_alloc_shared_tag&lt;_Alloc&gt;{__a},\n\t\t\t     std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  /**\n   *  @brief  Create an object that is owned by a shared_ptr.\n   *  @param  __args  Arguments for the @a _Tp object&#x27;s constructor.\n   *  @return A shared_ptr that owns the newly created object.\n   *  @throw  std::bad_alloc, or an exception thrown from the\n   *          constructor of @a _Tp.\n   */\n  template&lt;typename _Tp, typename... _Args&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    make_shared(_Args&amp;&amp;... __args)\n    {\n      typedef typename std::remove_cv&lt;_Tp&gt;::type _Tp_nc;\n      return std::allocate_shared&lt;_Tp&gt;(std::allocator&lt;_Tp_nc&gt;(),\n\t\t\t\t       std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  /// std::hash specialization for shared_ptr.\n  template&lt;typename _Tp&gt;\n    struct hash&lt;shared_ptr&lt;_Tp&gt;&gt;\n    : public __hash_base&lt;size_t, shared_ptr&lt;_Tp&gt;&gt;\n    {\n      size_t\n      operator()(const shared_ptr&lt;_Tp&gt;&amp; __s) const noexcept\n      {\n\treturn std::hash&lt;typename shared_ptr&lt;_Tp&gt;::element_type*&gt;()(__s.get());\n      }\n    };\n\n  /// @} relates shared_ptr\n  /// @} group pointer_abstractions\n\n#if __cplusplus &gt;= 201703L\n  namespace __detail::__variant\n  {\n    template&lt;typename&gt; struct _Never_valueless_alt; // see &lt;variant&gt;\n\n    // Provide the strong exception-safety guarantee when emplacing a\n    // shared_ptr into a variant.\n    template&lt;typename _Tp&gt;\n      struct _Never_valueless_alt&lt;std::shared_ptr&lt;_Tp&gt;&gt;\n      : std::true_type\n      { };\n\n    // Provide the strong exception-safety guarantee when emplacing a\n    // weak_ptr into a variant.\n    template&lt;typename _Tp&gt;\n      struct _Never_valueless_alt&lt;std::weak_ptr&lt;_Tp&gt;&gt;\n      : std::true_type\n      { };\n  }  // namespace __detail::__variant\n#endif // C++17\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif // _SHARED_PTR_H\n"}, "/usr/include/c++/11/bits/shared_ptr_base.h": {"id": "/usr/include/c++/11/bits/shared_ptr_base.h", "filePath": "/usr/include/c++/11/bits/shared_ptr_base.h", "content": "// shared_ptr and weak_ptr implementation details -*- C++ -*-\n\n// Copyright (C) 2007-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n// GCC Note: Based on files from version 1.32.0 of the Boost library.\n\n//  shared_count.hpp\n//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n\n//  shared_ptr.hpp\n//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  weak_ptr.hpp\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  enable_shared_from_this.hpp\n//  Copyright (C) 2002 Peter Dimov\n\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n\n/** @file bits/shared_ptr_base.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _SHARED_PTR_BASE_H\n#define _SHARED_PTR_BASE_H 1\n\n#include &lt;typeinfo&gt;\n#include &lt;bits/allocated_ptr.h&gt;\n#include &lt;bits/allocator.h&gt;\n#include &lt;bits/exception_defines.h&gt;\n#include &lt;bits/functional_hash.h&gt;\n#include &lt;bits/refwrap.h&gt;\n#include &lt;bits/stl_function.h&gt;  // std::less\n#include &lt;bits/unique_ptr.h&gt;\n#include &lt;ext/aligned_buffer.h&gt;\n#include &lt;ext/atomicity.h&gt;\n#include &lt;ext/concurrence.h&gt;\n#if __cplusplus &gt; 201703L\n# include &lt;compare&gt;\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n  template&lt;typename&gt; class auto_ptr;\n#pragma GCC diagnostic pop\n#endif\n\n /**\n   *  @brief  Exception possibly thrown by @c shared_ptr.\n   *  @ingroup exceptions\n   */\n  class bad_weak_ptr : public std::exception\n  {\n  public:\n    virtual char const* what() const noexcept;\n\n    virtual ~bad_weak_ptr() noexcept;\n  };\n\n  // Substitute for bad_weak_ptr object in the case of -fno-exceptions.\n  inline void\n  __throw_bad_weak_ptr()\n  { _GLIBCXX_THROW_OR_ABORT(bad_weak_ptr()); }\n\n  using __gnu_cxx::_Lock_policy;\n  using __gnu_cxx::__default_lock_policy;\n  using __gnu_cxx::_S_single;\n  using __gnu_cxx::_S_mutex;\n  using __gnu_cxx::_S_atomic;\n\n  // Empty helper class except when the template argument is _S_mutex.\n  template&lt;_Lock_policy _Lp&gt;\n    class _Mutex_base\n    {\n    protected:\n      // The atomic policy uses fully-fenced builtins, single doesn&#x27;t care.\n      enum { _S_need_barriers = 0 };\n    };\n\n  template&lt;&gt;\n    class _Mutex_base&lt;_S_mutex&gt;\n    : public __gnu_cxx::__mutex\n    {\n    protected:\n      // This policy is used when atomic builtins are not available.\n      // The replacement atomic operations might not have the necessary\n      // memory barriers.\n      enum { _S_need_barriers = 1 };\n    };\n\n  template&lt;_Lock_policy _Lp = __default_lock_policy&gt;\n    class _Sp_counted_base\n    : public _Mutex_base&lt;_Lp&gt;\n    {\n    public:\n      _Sp_counted_base() noexcept\n      : _M_use_count(1), _M_weak_count(1) { }\n\n      virtual\n      ~_Sp_counted_base() noexcept\n      { }\n\n      // Called when _M_use_count drops to zero, to release the resources\n      // managed by *this.\n      virtual void\n      _M_dispose() noexcept = 0;\n\n      // Called when _M_weak_count drops to zero.\n      virtual void\n      _M_destroy() noexcept\n      { delete this; }\n\n      virtual void*\n      _M_get_deleter(const std::type_info&amp;) noexcept = 0;\n\n      void\n      _M_add_ref_copy()\n      { __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, 1); }\n\n      void\n      _M_add_ref_lock()\n      {\n\tif (!_M_add_ref_lock_nothrow())\n\t  __throw_bad_weak_ptr();\n      }\n\n      bool\n      _M_add_ref_lock_nothrow() noexcept;\n\n      void\n      _M_release() noexcept\n      {\n        // Be race-detector-friendly.  For more info see bits/c++config.\n        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);\n\tif (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, -1) == 1)\n\t  {\n            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);\n\t    _M_dispose();\n\t    // There must be a memory barrier between dispose() and destroy()\n\t    // to ensure that the effects of dispose() are observed in the\n\t    // thread that runs destroy().\n\t    // See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html\n\t    if (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)\n\t      {\n\t\t__atomic_thread_fence (__ATOMIC_ACQ_REL);\n\t      }\n\n            // Be race-detector-friendly.  For more info see bits/c++config.\n            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);\n\t    if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count,\n\t\t\t\t\t\t       -1) == 1)\n              {\n                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);\n\t        _M_destroy();\n              }\n\t  }\n      }\n\n      void\n      _M_weak_add_ref() noexcept\n      { __gnu_cxx::__atomic_add_dispatch(&amp;_M_weak_count, 1); }\n\n      void\n      _M_weak_release() noexcept\n      {\n        // Be race-detector-friendly. For more info see bits/c++config.\n        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);\n\tif (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, -1) == 1)\n\t  {\n            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);\n\t    if (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)\n\t      {\n\t        // See _M_release(),\n\t        // destroy() must observe results of dispose()\n\t\t__atomic_thread_fence (__ATOMIC_ACQ_REL);\n\t      }\n\t    _M_destroy();\n\t  }\n      }\n\n      long\n      _M_get_use_count() const noexcept\n      {\n        // No memory barrier is used here so there is no synchronization\n        // with other threads.\n        return __atomic_load_n(&amp;_M_use_count, __ATOMIC_RELAXED);\n      }\n\n    private:\n      _Sp_counted_base(_Sp_counted_base const&amp;) = delete;\n      _Sp_counted_base&amp; operator=(_Sp_counted_base const&amp;) = delete;\n\n      _Atomic_word  _M_use_count;     // #shared\n      _Atomic_word  _M_weak_count;    // #weak + (#shared != 0)\n    };\n\n  template&lt;&gt;\n    inline bool\n    _Sp_counted_base&lt;_S_single&gt;::\n    _M_add_ref_lock_nothrow() noexcept\n    {\n      if (_M_use_count == 0)\n\treturn false;\n      ++_M_use_count;\n      return true;\n    }\n\n  template&lt;&gt;\n    inline bool\n    _Sp_counted_base&lt;_S_mutex&gt;::\n    _M_add_ref_lock_nothrow() noexcept\n    {\n      __gnu_cxx::__scoped_lock sentry(*this);\n      if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, 1) == 0)\n\t{\n\t  _M_use_count = 0;\n\t  return false;\n\t}\n      return true;\n    }\n\n  template&lt;&gt;\n    inline bool\n    _Sp_counted_base&lt;_S_atomic&gt;::\n    _M_add_ref_lock_nothrow() noexcept\n    {\n      // Perform lock-free add-if-not-zero operation.\n      _Atomic_word __count = _M_get_use_count();\n      do\n\t{\n\t  if (__count == 0)\n\t    return false;\n\t  // Replace the current counter value with the old value + 1, as\n\t  // long as it&#x27;s not changed meanwhile.\n\t}\n      while (!__atomic_compare_exchange_n(&amp;_M_use_count, &amp;__count, __count + 1,\n\t\t\t\t\t  true, __ATOMIC_ACQ_REL,\n\t\t\t\t\t  __ATOMIC_RELAXED));\n      return true;\n    }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_add_ref_copy()\n    { ++_M_use_count; }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_release() noexcept\n    {\n      if (--_M_use_count == 0)\n        {\n          _M_dispose();\n          if (--_M_weak_count == 0)\n            _M_destroy();\n        }\n    }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_weak_add_ref() noexcept\n    { ++_M_weak_count; }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_weak_release() noexcept\n    {\n      if (--_M_weak_count == 0)\n        _M_destroy();\n    }\n\n  template&lt;&gt;\n    inline long\n    _Sp_counted_base&lt;_S_single&gt;::_M_get_use_count() const noexcept\n    { return _M_use_count; }\n\n\n  // Forward declarations.\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy&gt;\n    class __shared_ptr;\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy&gt;\n    class __weak_ptr;\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy&gt;\n    class __enable_shared_from_this;\n\n  template&lt;typename _Tp&gt;\n    class shared_ptr;\n\n  template&lt;typename _Tp&gt;\n    class weak_ptr;\n\n  template&lt;typename _Tp&gt;\n    struct owner_less;\n\n  template&lt;typename _Tp&gt;\n    class enable_shared_from_this;\n\n  template&lt;_Lock_policy _Lp = __default_lock_policy&gt;\n    class __weak_count;\n\n  template&lt;_Lock_policy _Lp = __default_lock_policy&gt;\n    class __shared_count;\n\n\n  // Counted ptr with no deleter or allocator support\n  template&lt;typename _Ptr, _Lock_policy _Lp&gt;\n    class _Sp_counted_ptr final : public _Sp_counted_base&lt;_Lp&gt;\n    {\n    public:\n      explicit\n      _Sp_counted_ptr(_Ptr __p) noexcept\n      : _M_ptr(__p) { }\n\n      virtual void\n      _M_dispose() noexcept\n      { delete _M_ptr; }\n\n      virtual void\n      _M_destroy() noexcept\n      { delete this; }\n\n      virtual void*\n      _M_get_deleter(const std::type_info&amp;) noexcept\n      { return nullptr; }\n\n      _Sp_counted_ptr(const _Sp_counted_ptr&amp;) = delete;\n      _Sp_counted_ptr&amp; operator=(const _Sp_counted_ptr&amp;) = delete;\n\n    private:\n      _Ptr             _M_ptr;\n    };\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_ptr&lt;nullptr_t, _S_single&gt;::_M_dispose() noexcept { }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_ptr&lt;nullptr_t, _S_mutex&gt;::_M_dispose() noexcept { }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_ptr&lt;nullptr_t, _S_atomic&gt;::_M_dispose() noexcept { }\n\n  template&lt;int _Nm, typename _Tp,\n\t   bool __use_ebo = !__is_final(_Tp) &amp;&amp; __is_empty(_Tp)&gt;\n    struct _Sp_ebo_helper;\n\n  /// Specialization using EBO.\n  template&lt;int _Nm, typename _Tp&gt;\n    struct _Sp_ebo_helper&lt;_Nm, _Tp, true&gt; : private _Tp\n    {\n      explicit _Sp_ebo_helper(const _Tp&amp; __tp) : _Tp(__tp) { }\n      explicit _Sp_ebo_helper(_Tp&amp;&amp; __tp) : _Tp(std::move(__tp)) { }\n\n      static _Tp&amp;\n      _S_get(_Sp_ebo_helper&amp; __eboh) { return static_cast&lt;_Tp&amp;&gt;(__eboh); }\n    };\n\n  /// Specialization not using EBO.\n  template&lt;int _Nm, typename _Tp&gt;\n    struct _Sp_ebo_helper&lt;_Nm, _Tp, false&gt;\n    {\n      explicit _Sp_ebo_helper(const _Tp&amp; __tp) : _M_tp(__tp) { }\n      explicit _Sp_ebo_helper(_Tp&amp;&amp; __tp) : _M_tp(std::move(__tp)) { }\n\n      static _Tp&amp;\n      _S_get(_Sp_ebo_helper&amp; __eboh)\n      { return __eboh._M_tp; }\n\n    private:\n      _Tp _M_tp;\n    };\n\n  // Support for custom deleter and/or allocator\n  template&lt;typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp&gt;\n    class _Sp_counted_deleter final : public _Sp_counted_base&lt;_Lp&gt;\n    {\n      class _Impl : _Sp_ebo_helper&lt;0, _Deleter&gt;, _Sp_ebo_helper&lt;1, _Alloc&gt;\n      {\n\ttypedef _Sp_ebo_helper&lt;0, _Deleter&gt;\t_Del_base;\n\ttypedef _Sp_ebo_helper&lt;1, _Alloc&gt;\t_Alloc_base;\n\n      public:\n\t_Impl(_Ptr __p, _Deleter __d, const _Alloc&amp; __a) noexcept\n\t: _Del_base(std::move(__d)), _Alloc_base(__a), _M_ptr(__p)\n\t{ }\n\n\t_Deleter&amp; _M_del() noexcept { return _Del_base::_S_get(*this); }\n\t_Alloc&amp; _M_alloc() noexcept { return _Alloc_base::_S_get(*this); }\n\n\t_Ptr _M_ptr;\n      };\n\n    public:\n      using __allocator_type = __alloc_rebind&lt;_Alloc, _Sp_counted_deleter&gt;;\n\n      // __d(__p) must not throw.\n      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept\n      : _M_impl(__p, std::move(__d), _Alloc()) { }\n\n      // __d(__p) must not throw.\n      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc&amp; __a) noexcept\n      : _M_impl(__p, std::move(__d), __a) { }\n\n      ~_Sp_counted_deleter() noexcept { }\n\n      virtual void\n      _M_dispose() noexcept\n      { _M_impl._M_del()(_M_impl._M_ptr); }\n\n      virtual void\n      _M_destroy() noexcept\n      {\n\t__allocator_type __a(_M_impl._M_alloc());\n\t__allocated_ptr&lt;__allocator_type&gt; __guard_ptr{ __a, this };\n\tthis-&gt;~_Sp_counted_deleter();\n      }\n\n      virtual void*\n      _M_get_deleter(const type_info&amp; __ti [[__gnu__::__unused__]]) noexcept\n      {\n#if __cpp_rtti\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// 2400. shared_ptr&#x27;s get_deleter() should use addressof()\n        return __ti == typeid(_Deleter)\n\t  ? std::__addressof(_M_impl._M_del())\n\t  : nullptr;\n#else\n        return nullptr;\n#endif\n      }\n\n    private:\n      _Impl _M_impl;\n    };\n\n  // helpers for make_shared / allocate_shared\n\n  struct _Sp_make_shared_tag\n  {\n  private:\n    template&lt;typename _Tp, typename _Alloc, _Lock_policy _Lp&gt;\n      friend class _Sp_counted_ptr_inplace;\n\n    static const type_info&amp;\n    _S_ti() noexcept _GLIBCXX_VISIBILITY(default)\n    {\n      alignas(type_info) static constexpr char __tag[sizeof(type_info)] = { };\n      return reinterpret_cast&lt;const type_info&amp;&gt;(__tag);\n    }\n\n    static bool _S_eq(const type_info&amp;) noexcept;\n  };\n\n  template&lt;typename _Alloc&gt;\n    struct _Sp_alloc_shared_tag\n    {\n      const _Alloc&amp; _M_a;\n    };\n\n  template&lt;typename _Tp, typename _Alloc, _Lock_policy _Lp&gt;\n    class _Sp_counted_ptr_inplace final : public _Sp_counted_base&lt;_Lp&gt;\n    {\n      class _Impl : _Sp_ebo_helper&lt;0, _Alloc&gt;\n      {\n\ttypedef _Sp_ebo_helper&lt;0, _Alloc&gt;\t_A_base;\n\n      public:\n\texplicit _Impl(_Alloc __a) noexcept : _A_base(__a) { }\n\n\t_Alloc&amp; _M_alloc() noexcept { return _A_base::_S_get(*this); }\n\n\t__gnu_cxx::__aligned_buffer&lt;_Tp&gt; _M_storage;\n      };\n\n    public:\n      using __allocator_type = __alloc_rebind&lt;_Alloc, _Sp_counted_ptr_inplace&gt;;\n\n      // Alloc parameter is not a reference so doesn&#x27;t alias anything in __args\n      template&lt;typename... _Args&gt;\n\t_Sp_counted_ptr_inplace(_Alloc __a, _Args&amp;&amp;... __args)\n\t: _M_impl(__a)\n\t{\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 2070.  allocate_shared should use allocator_traits&lt;A&gt;::construct\n\t  allocator_traits&lt;_Alloc&gt;::construct(__a, _M_ptr(),\n\t      std::forward&lt;_Args&gt;(__args)...); // might throw\n\t}\n\n      ~_Sp_counted_ptr_inplace() noexcept { }\n\n      virtual void\n      _M_dispose() noexcept\n      {\n\tallocator_traits&lt;_Alloc&gt;::destroy(_M_impl._M_alloc(), _M_ptr());\n      }\n\n      // Override because the allocator needs to know the dynamic type\n      virtual void\n      _M_destroy() noexcept\n      {\n\t__allocator_type __a(_M_impl._M_alloc());\n\t__allocated_ptr&lt;__allocator_type&gt; __guard_ptr{ __a, this };\n\tthis-&gt;~_Sp_counted_ptr_inplace();\n      }\n\n    private:\n      friend class __shared_count&lt;_Lp&gt;; // To be able to call _M_ptr().\n\n      // No longer used, but code compiled against old libstdc++ headers\n      // might still call it from __shared_ptr ctor to get the pointer out.\n      virtual void*\n      _M_get_deleter(const std::type_info&amp; __ti) noexcept override\n      {\n\tauto __ptr = const_cast&lt;typename remove_cv&lt;_Tp&gt;::type*&gt;(_M_ptr());\n\t// Check for the fake type_info first, so we don&#x27;t try to access it\n\t// as a real type_info object. Otherwise, check if it&#x27;s the real\n\t// type_info for this class. With RTTI enabled we can check directly,\n\t// or call a library function to do it.\n\tif (&amp;__ti == &amp;_Sp_make_shared_tag::_S_ti()\n\t    ||\n#if __cpp_rtti\n\t    __ti == typeid(_Sp_make_shared_tag)\n#else\n\t    _Sp_make_shared_tag::_S_eq(__ti)\n#endif\n\t   )\n\t  return __ptr;\n\treturn nullptr;\n      }\n\n      _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }\n\n      _Impl _M_impl;\n    };\n\n  // The default deleter for shared_ptr&lt;T[]&gt; and shared_ptr&lt;T[N]&gt;.\n  struct __sp_array_delete\n  {\n    template&lt;typename _Yp&gt;\n      void operator()(_Yp* __p) const { delete[] __p; }\n  };\n\n  template&lt;_Lock_policy _Lp&gt;\n    class __shared_count\n    {\n      template&lt;typename _Tp&gt;\n\tstruct __not_alloc_shared_tag { using type = void; };\n\n      template&lt;typename _Tp&gt;\n\tstruct __not_alloc_shared_tag&lt;_Sp_alloc_shared_tag&lt;_Tp&gt;&gt; { };\n\n    public:\n      constexpr __shared_count() noexcept : _M_pi(0)\n      { }\n\n      template&lt;typename _Ptr&gt;\n        explicit\n\t__shared_count(_Ptr __p) : _M_pi(0)\n\t{\n\t  __try\n\t    {\n\t      _M_pi = new _Sp_counted_ptr&lt;_Ptr, _Lp&gt;(__p);\n\t    }\n\t  __catch(...)\n\t    {\n\t      delete __p;\n\t      __throw_exception_again;\n\t    }\n\t}\n\n      template&lt;typename _Ptr&gt;\n\t__shared_count(_Ptr __p, /* is_array = */ false_type)\n\t: __shared_count(__p)\n\t{ }\n\n      template&lt;typename _Ptr&gt;\n\t__shared_count(_Ptr __p, /* is_array = */ true_type)\n\t: __shared_count(__p, __sp_array_delete{}, allocator&lt;void&gt;())\n\t{ }\n\n      template&lt;typename _Ptr, typename _Deleter,\n\t       typename = typename __not_alloc_shared_tag&lt;_Deleter&gt;::type&gt;\n\t__shared_count(_Ptr __p, _Deleter __d)\n\t: __shared_count(__p, std::move(__d), allocator&lt;void&gt;())\n\t{ }\n\n      template&lt;typename _Ptr, typename _Deleter, typename _Alloc,\n\t       typename = typename __not_alloc_shared_tag&lt;_Deleter&gt;::type&gt;\n\t__shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)\n\t{\n\t  typedef _Sp_counted_deleter&lt;_Ptr, _Deleter, _Alloc, _Lp&gt; _Sp_cd_type;\n\t  __try\n\t    {\n\t      typename _Sp_cd_type::__allocator_type __a2(__a);\n\t      auto __guard = std::__allocate_guarded(__a2);\n\t      _Sp_cd_type* __mem = __guard.get();\n\t      ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));\n\t      _M_pi = __mem;\n\t      __guard = nullptr;\n\t    }\n\t  __catch(...)\n\t    {\n\t      __d(__p); // Call _Deleter on __p.\n\t      __throw_exception_again;\n\t    }\n\t}\n\n      template&lt;typename _Tp, typename _Alloc, typename... _Args&gt;\n\t__shared_count(_Tp*&amp; __p, _Sp_alloc_shared_tag&lt;_Alloc&gt; __a,\n\t\t       _Args&amp;&amp;... __args)\n\t{\n\t  typedef _Sp_counted_ptr_inplace&lt;_Tp, _Alloc, _Lp&gt; _Sp_cp_type;\n\t  typename _Sp_cp_type::__allocator_type __a2(__a._M_a);\n\t  auto __guard = std::__allocate_guarded(__a2);\n\t  _Sp_cp_type* __mem = __guard.get();\n\t  auto __pi = ::new (__mem)\n\t    _Sp_cp_type(__a._M_a, std::forward&lt;_Args&gt;(__args)...);\n\t  __guard = nullptr;\n\t  _M_pi = __pi;\n\t  __p = __pi-&gt;_M_ptr();\n\t}\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      // Special case for auto_ptr&lt;_Tp&gt; to provide the strong guarantee.\n      template&lt;typename _Tp&gt;\n        explicit\n\t__shared_count(std::auto_ptr&lt;_Tp&gt;&amp;&amp; __r);\n#pragma GCC diagnostic pop\n#endif\n\n      // Special case for unique_ptr&lt;_Tp,_Del&gt; to provide the strong guarantee.\n      template&lt;typename _Tp, typename _Del&gt;\n        explicit\n\t__shared_count(std::unique_ptr&lt;_Tp, _Del&gt;&amp;&amp; __r) : _M_pi(0)\n\t{\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 2415. Inconsistency between unique_ptr and shared_ptr\n\t  if (__r.get() == nullptr)\n\t    return;\n\n\t  using _Ptr = typename unique_ptr&lt;_Tp, _Del&gt;::pointer;\n\t  using _Del2 = typename conditional&lt;is_reference&lt;_Del&gt;::value,\n\t      reference_wrapper&lt;typename remove_reference&lt;_Del&gt;::type&gt;,\n\t      _Del&gt;::type;\n\t  using _Sp_cd_type\n\t    = _Sp_counted_deleter&lt;_Ptr, _Del2, allocator&lt;void&gt;, _Lp&gt;;\n\t  using _Alloc = allocator&lt;_Sp_cd_type&gt;;\n\t  using _Alloc_traits = allocator_traits&lt;_Alloc&gt;;\n\t  _Alloc __a;\n\t  _Sp_cd_type* __mem = _Alloc_traits::allocate(__a, 1);\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 3548. shared_ptr construction from unique_ptr should move\n\t  // (not copy) the deleter\n\t  _Alloc_traits::construct(__a, __mem, __r.release(),\n\t\t\t\t   std::forward&lt;_Del&gt;(__r.get_deleter()));\n\t  _M_pi = __mem;\n\t}\n\n      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.\n      explicit __shared_count(const __weak_count&lt;_Lp&gt;&amp; __r);\n\n      // Does not throw if __r._M_get_use_count() == 0, caller must check.\n      explicit\n      __shared_count(const __weak_count&lt;_Lp&gt;&amp; __r, std::nothrow_t) noexcept;\n\n      ~__shared_count() noexcept\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_release();\n      }\n\n      __shared_count(const __shared_count&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_add_ref_copy();\n      }\n\n      __shared_count&amp;\n      operator=(const __shared_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\tif (__tmp != _M_pi)\n\t  {\n\t    if (__tmp != nullptr)\n\t      __tmp-&gt;_M_add_ref_copy();\n\t    if (_M_pi != nullptr)\n\t      _M_pi-&gt;_M_release();\n\t    _M_pi = __tmp;\n\t  }\n\treturn *this;\n      }\n\n      void\n      _M_swap(__shared_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\t__r._M_pi = _M_pi;\n\t_M_pi = __tmp;\n      }\n\n      long\n      _M_get_use_count() const noexcept\n      { return _M_pi ? _M_pi-&gt;_M_get_use_count() : 0; }\n\n      bool\n      _M_unique() const noexcept\n      { return this-&gt;_M_get_use_count() == 1; }\n\n      void*\n      _M_get_deleter(const std::type_info&amp; __ti) const noexcept\n      { return _M_pi ? _M_pi-&gt;_M_get_deleter(__ti) : nullptr; }\n\n      bool\n      _M_less(const __shared_count&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      bool\n      _M_less(const __weak_count&lt;_Lp&gt;&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      // Friend function injected into enclosing namespace and found by ADL\n      friend inline bool\n      operator==(const __shared_count&amp; __a, const __shared_count&amp; __b) noexcept\n      { return __a._M_pi == __b._M_pi; }\n\n    private:\n      friend class __weak_count&lt;_Lp&gt;;\n\n      _Sp_counted_base&lt;_Lp&gt;*  _M_pi;\n    };\n\n\n  template&lt;_Lock_policy _Lp&gt;\n    class __weak_count\n    {\n    public:\n      constexpr __weak_count() noexcept : _M_pi(nullptr)\n      { }\n\n      __weak_count(const __shared_count&lt;_Lp&gt;&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_add_ref();\n      }\n\n      __weak_count(const __weak_count&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_add_ref();\n      }\n\n      __weak_count(__weak_count&amp;&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      { __r._M_pi = nullptr; }\n\n      ~__weak_count() noexcept\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n      }\n\n      __weak_count&amp;\n      operator=(const __shared_count&lt;_Lp&gt;&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\tif (__tmp != nullptr)\n\t  __tmp-&gt;_M_weak_add_ref();\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n\t_M_pi = __tmp;\n\treturn *this;\n      }\n\n      __weak_count&amp;\n      operator=(const __weak_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\tif (__tmp != nullptr)\n\t  __tmp-&gt;_M_weak_add_ref();\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n\t_M_pi = __tmp;\n\treturn *this;\n      }\n\n      __weak_count&amp;\n      operator=(__weak_count&amp;&amp; __r) noexcept\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n\t_M_pi = __r._M_pi;\n        __r._M_pi = nullptr;\n\treturn *this;\n      }\n\n      void\n      _M_swap(__weak_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\t__r._M_pi = _M_pi;\n\t_M_pi = __tmp;\n      }\n\n      long\n      _M_get_use_count() const noexcept\n      { return _M_pi != nullptr ? _M_pi-&gt;_M_get_use_count() : 0; }\n\n      bool\n      _M_less(const __weak_count&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      bool\n      _M_less(const __shared_count&lt;_Lp&gt;&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      // Friend function injected into enclosing namespace and found by ADL\n      friend inline bool\n      operator==(const __weak_count&amp; __a, const __weak_count&amp; __b) noexcept\n      { return __a._M_pi == __b._M_pi; }\n\n    private:\n      friend class __shared_count&lt;_Lp&gt;;\n\n      _Sp_counted_base&lt;_Lp&gt;*  _M_pi;\n    };\n\n  // Now that __weak_count is defined we can define this constructor:\n  template&lt;_Lock_policy _Lp&gt;\n    inline\n    __shared_count&lt;_Lp&gt;::__shared_count(const __weak_count&lt;_Lp&gt;&amp; __r)\n    : _M_pi(__r._M_pi)\n    {\n      if (_M_pi == nullptr || !_M_pi-&gt;_M_add_ref_lock_nothrow())\n\t__throw_bad_weak_ptr();\n    }\n\n  // Now that __weak_count is defined we can define this constructor:\n  template&lt;_Lock_policy _Lp&gt;\n    inline\n    __shared_count&lt;_Lp&gt;::\n    __shared_count(const __weak_count&lt;_Lp&gt;&amp; __r, std::nothrow_t) noexcept\n    : _M_pi(__r._M_pi)\n    {\n      if (_M_pi &amp;&amp; !_M_pi-&gt;_M_add_ref_lock_nothrow())\n\t_M_pi = nullptr;\n    }\n\n#define __cpp_lib_shared_ptr_arrays 201611L\n\n  // Helper traits for shared_ptr of array:\n\n  // A pointer type Y* is said to be compatible with a pointer type T* when\n  // either Y* is convertible to T* or Y is U[N] and T is U cv [].\n  template&lt;typename _Yp_ptr, typename _Tp_ptr&gt;\n    struct __sp_compatible_with\n    : false_type\n    { };\n\n  template&lt;typename _Yp, typename _Tp&gt;\n    struct __sp_compatible_with&lt;_Yp*, _Tp*&gt;\n    : is_convertible&lt;_Yp*, _Tp*&gt;::type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], _Up(*)[]&gt;\n    : true_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], const _Up(*)[]&gt;\n    : true_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], volatile _Up(*)[]&gt;\n    : true_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], const volatile _Up(*)[]&gt;\n    : true_type\n    { };\n\n  // Test conversion from Y(*)[N] to U(*)[N] without forming invalid type Y[N].\n  template&lt;typename _Up, size_t _Nm, typename _Yp, typename = void&gt;\n    struct __sp_is_constructible_arrN\n    : false_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm, typename _Yp&gt;\n    struct __sp_is_constructible_arrN&lt;_Up, _Nm, _Yp, __void_t&lt;_Yp[_Nm]&gt;&gt;\n    : is_convertible&lt;_Yp(*)[_Nm], _Up(*)[_Nm]&gt;::type\n    { };\n\n  // Test conversion from Y(*)[] to U(*)[] without forming invalid type Y[].\n  template&lt;typename _Up, typename _Yp, typename = void&gt;\n    struct __sp_is_constructible_arr\n    : false_type\n    { };\n\n  template&lt;typename _Up, typename _Yp&gt;\n    struct __sp_is_constructible_arr&lt;_Up, _Yp, __void_t&lt;_Yp[]&gt;&gt;\n    : is_convertible&lt;_Yp(*)[], _Up(*)[]&gt;::type\n    { };\n\n  // Trait to check if shared_ptr&lt;T&gt; can be constructed from Y*.\n  template&lt;typename _Tp, typename _Yp&gt;\n    struct __sp_is_constructible;\n\n  // When T is U[N], Y(*)[N] shall be convertible to T*;\n  template&lt;typename _Up, size_t _Nm, typename _Yp&gt;\n    struct __sp_is_constructible&lt;_Up[_Nm], _Yp&gt;\n    : __sp_is_constructible_arrN&lt;_Up, _Nm, _Yp&gt;::type\n    { };\n\n  // when T is U[], Y(*)[] shall be convertible to T*;\n  template&lt;typename _Up, typename _Yp&gt;\n    struct __sp_is_constructible&lt;_Up[], _Yp&gt;\n    : __sp_is_constructible_arr&lt;_Up, _Yp&gt;::type\n    { };\n\n  // otherwise, Y* shall be convertible to T*.\n  template&lt;typename _Tp, typename _Yp&gt;\n    struct __sp_is_constructible\n    : is_convertible&lt;_Yp*, _Tp*&gt;::type\n    { };\n\n\n  // Define operator* and operator-&gt; for shared_ptr&lt;T&gt;.\n  template&lt;typename _Tp, _Lock_policy _Lp,\n\t   bool = is_array&lt;_Tp&gt;::value, bool = is_void&lt;_Tp&gt;::value&gt;\n    class __shared_ptr_access\n    {\n    public:\n      using element_type = _Tp;\n\n      element_type&amp;\n      operator*() const noexcept\n      {\n\t__glibcxx_assert(_M_get() != nullptr);\n\treturn *_M_get();\n      }\n\n      element_type*\n      operator-&gt;() const noexcept\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_get() != nullptr);\n\treturn _M_get();\n      }\n\n    private:\n      element_type*\n      _M_get() const noexcept\n      { return static_cast&lt;const __shared_ptr&lt;_Tp, _Lp&gt;*&gt;(this)-&gt;get(); }\n    };\n\n  // Define operator-&gt; for shared_ptr&lt;cv void&gt;.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __shared_ptr_access&lt;_Tp, _Lp, false, true&gt;\n    {\n    public:\n      using element_type = _Tp;\n\n      element_type*\n      operator-&gt;() const noexcept\n      {\n\tauto __ptr = static_cast&lt;const __shared_ptr&lt;_Tp, _Lp&gt;*&gt;(this)-&gt;get();\n\t_GLIBCXX_DEBUG_PEDASSERT(__ptr != nullptr);\n\treturn __ptr;\n      }\n    };\n\n  // Define operator[] for shared_ptr&lt;T[]&gt; and shared_ptr&lt;T[N]&gt;.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __shared_ptr_access&lt;_Tp, _Lp, true, false&gt;\n    {\n    public:\n      using element_type = typename remove_extent&lt;_Tp&gt;::type;\n\n#if __cplusplus &lt;= 201402L\n      [[__deprecated__(&quot;shared_ptr&lt;T[]&gt;::operator* is absent from C++17&quot;)]]\n      element_type&amp;\n      operator*() const noexcept\n      {\n\t__glibcxx_assert(_M_get() != nullptr);\n\treturn *_M_get();\n      }\n\n      [[__deprecated__(&quot;shared_ptr&lt;T[]&gt;::operator-&gt; is absent from C++17&quot;)]]\n      element_type*\n      operator-&gt;() const noexcept\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_get() != nullptr);\n\treturn _M_get();\n      }\n#endif\n\n      element_type&amp;\n      operator[](ptrdiff_t __i) const\n      {\n\t__glibcxx_assert(_M_get() != nullptr);\n\t__glibcxx_assert(!extent&lt;_Tp&gt;::value || __i &lt; extent&lt;_Tp&gt;::value);\n\treturn _M_get()[__i];\n      }\n\n    private:\n      element_type*\n      _M_get() const noexcept\n      { return static_cast&lt;const __shared_ptr&lt;_Tp, _Lp&gt;*&gt;(this)-&gt;get(); }\n    };\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __shared_ptr\n    : public __shared_ptr_access&lt;_Tp, _Lp&gt;\n    {\n    public:\n      using element_type = typename remove_extent&lt;_Tp&gt;::type;\n\n    private:\n      // Constraint for taking ownership of a pointer of type _Yp*:\n      template&lt;typename _Yp&gt;\n\tusing _SafeConv\n\t  = typename enable_if&lt;__sp_is_constructible&lt;_Tp, _Yp&gt;::value&gt;::type;\n\n      // Constraint for construction from shared_ptr and weak_ptr:\n      template&lt;typename _Yp, typename _Res = void&gt;\n\tusing _Compatible = typename\n\t  enable_if&lt;__sp_compatible_with&lt;_Yp*, _Tp*&gt;::value, _Res&gt;::type;\n\n      // Constraint for assignment from shared_ptr and weak_ptr:\n      template&lt;typename _Yp&gt;\n\tusing _Assignable = _Compatible&lt;_Yp, __shared_ptr&amp;&gt;;\n\n      // Constraint for construction from unique_ptr:\n      template&lt;typename _Yp, typename _Del, typename _Res = void,\n\t       typename _Ptr = typename unique_ptr&lt;_Yp, _Del&gt;::pointer&gt;\n\tusing _UniqCompatible = __enable_if_t&lt;__and_&lt;\n\t  __sp_compatible_with&lt;_Yp*, _Tp*&gt;,\n\t  is_convertible&lt;_Ptr, element_type*&gt;,\n\t  is_move_constructible&lt;_Del&gt;\n\t  &gt;::value, _Res&gt;;\n\n      // Constraint for assignment from unique_ptr:\n      template&lt;typename _Yp, typename _Del&gt;\n\tusing _UniqAssignable = _UniqCompatible&lt;_Yp, _Del, __shared_ptr&amp;&gt;;\n\n    public:\n\n#if __cplusplus &gt; 201402L\n      using weak_type = __weak_ptr&lt;_Tp, _Lp&gt;;\n#endif\n\n      constexpr __shared_ptr() noexcept\n      : _M_ptr(0), _M_refcount()\n      { }\n\n      template&lt;typename _Yp, typename = _SafeConv&lt;_Yp&gt;&gt;\n\texplicit\n\t__shared_ptr(_Yp* __p)\n\t: _M_ptr(__p), _M_refcount(__p, typename is_array&lt;_Tp&gt;::type())\n\t{\n\t  static_assert( !is_void&lt;_Yp&gt;::value, &quot;incomplete type&quot; );\n\t  static_assert( sizeof(_Yp) &gt; 0, &quot;incomplete type&quot; );\n\t  _M_enable_shared_from_this_with(__p);\n\t}\n\n      template&lt;typename _Yp, typename _Deleter, typename = _SafeConv&lt;_Yp&gt;&gt;\n\t__shared_ptr(_Yp* __p, _Deleter __d)\n\t: _M_ptr(__p), _M_refcount(__p, std::move(__d))\n\t{\n\t  static_assert(__is_invocable&lt;_Deleter&amp;, _Yp*&amp;&gt;::value,\n\t      &quot;deleter expression d(p) is well-formed&quot;);\n\t  _M_enable_shared_from_this_with(__p);\n\t}\n\n      template&lt;typename _Yp, typename _Deleter, typename _Alloc,\n\t       typename = _SafeConv&lt;_Yp&gt;&gt;\n\t__shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)\n\t: _M_ptr(__p), _M_refcount(__p, std::move(__d), std::move(__a))\n\t{\n\t  static_assert(__is_invocable&lt;_Deleter&amp;, _Yp*&amp;&gt;::value,\n\t      &quot;deleter expression d(p) is well-formed&quot;);\n\t  _M_enable_shared_from_this_with(__p);\n\t}\n\n      template&lt;typename _Deleter&gt;\n\t__shared_ptr(nullptr_t __p, _Deleter __d)\n\t: _M_ptr(0), _M_refcount(__p, std::move(__d))\n\t{ }\n\n      template&lt;typename _Deleter, typename _Alloc&gt;\n        __shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)\n\t: _M_ptr(0), _M_refcount(__p, std::move(__d), std::move(__a))\n\t{ }\n\n      // Aliasing constructor\n      template&lt;typename _Yp&gt;\n\t__shared_ptr(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r,\n\t\t     element_type* __p) noexcept\n\t: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws\n\t{ }\n\n      // Aliasing constructor\n      template&lt;typename _Yp&gt;\n\t__shared_ptr(__shared_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r,\n\t\t     element_type* __p) noexcept\n\t: _M_ptr(__p), _M_refcount()\n\t{\n\t  _M_refcount._M_swap(__r._M_refcount);\n\t  __r._M_ptr = nullptr;\n\t}\n\n      __shared_ptr(const __shared_ptr&amp;) noexcept = default;\n      __shared_ptr&amp; operator=(const __shared_ptr&amp;) noexcept = default;\n      ~__shared_ptr() = default;\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__shared_ptr(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)\n\t{ }\n\n      __shared_ptr(__shared_ptr&amp;&amp; __r) noexcept\n      : _M_ptr(__r._M_ptr), _M_refcount()\n      {\n\t_M_refcount._M_swap(__r._M_refcount);\n\t__r._M_ptr = nullptr;\n      }\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__shared_ptr(__shared_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t: _M_ptr(__r._M_ptr), _M_refcount()\n\t{\n\t  _M_refcount._M_swap(__r._M_refcount);\n\t  __r._M_ptr = nullptr;\n\t}\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\texplicit __shared_ptr(const __weak_ptr&lt;_Yp, _Lp&gt;&amp; __r)\n\t: _M_refcount(__r._M_refcount) // may throw\n\t{\n\t  // It is now safe to copy __r._M_ptr, as\n\t  // _M_refcount(__r._M_refcount) did not throw.\n\t  _M_ptr = __r._M_ptr;\n\t}\n\n      // If an exception is thrown this constructor has no effect.\n      template&lt;typename _Yp, typename _Del,\n\t       typename = _UniqCompatible&lt;_Yp, _Del&gt;&gt;\n\t__shared_ptr(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t: _M_ptr(__r.get()), _M_refcount()\n\t{\n\t  auto __raw = __to_address(__r.get());\n\t  _M_refcount = __shared_count&lt;_Lp&gt;(std::move(__r));\n\t  _M_enable_shared_from_this_with(__raw);\n\t}\n\n#if __cplusplus &lt;= 201402L &amp;&amp; _GLIBCXX_USE_DEPRECATED\n    protected:\n      // If an exception is thrown this constructor has no effect.\n      template&lt;typename _Tp1, typename _Del,\n\t       typename enable_if&lt;__and_&lt;\n\t\t __not_&lt;is_array&lt;_Tp&gt;&gt;, is_array&lt;_Tp1&gt;,\n\t         is_convertible&lt;typename unique_ptr&lt;_Tp1, _Del&gt;::pointer, _Tp*&gt;\n\t       &gt;::value, bool&gt;::type = true&gt;\n\t__shared_ptr(unique_ptr&lt;_Tp1, _Del&gt;&amp;&amp; __r, __sp_array_delete)\n\t: _M_ptr(__r.get()), _M_refcount()\n\t{\n\t  auto __raw = __to_address(__r.get());\n\t  _M_refcount = __shared_count&lt;_Lp&gt;(std::move(__r));\n\t  _M_enable_shared_from_this_with(__raw);\n\t}\n    public:\n#endif\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      // Postcondition: use_count() == 1 and __r.get() == 0\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__shared_ptr(auto_ptr&lt;_Yp&gt;&amp;&amp; __r);\n#pragma GCC diagnostic pop\n#endif\n\n      constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { }\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r._M_ptr;\n\t  _M_refcount = __r._M_refcount; // __shared_count::op= doesn&#x27;t throw\n\t  return *this;\n\t}\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(auto_ptr&lt;_Yp&gt;&amp;&amp; __r)\n\t{\n\t  __shared_ptr(std::move(__r)).swap(*this);\n\t  return *this;\n\t}\n#pragma GCC diagnostic pop\n#endif\n\n      __shared_ptr&amp;\n      operator=(__shared_ptr&amp;&amp; __r) noexcept\n      {\n\t__shared_ptr(std::move(__r)).swap(*this);\n\treturn *this;\n      }\n\n      template&lt;class _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(__shared_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  __shared_ptr(std::move(__r)).swap(*this);\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp, typename _Del&gt;\n\t_UniqAssignable&lt;_Yp, _Del&gt;\n\toperator=(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t{\n\t  __shared_ptr(std::move(__r)).swap(*this);\n\t  return *this;\n\t}\n\n      void\n      reset() noexcept\n      { __shared_ptr().swap(*this); }\n\n      template&lt;typename _Yp&gt;\n\t_SafeConv&lt;_Yp&gt;\n\treset(_Yp* __p) // _Yp must be complete.\n\t{\n\t  // Catch self-reset errors.\n\t  __glibcxx_assert(__p == nullptr || __p != _M_ptr);\n\t  __shared_ptr(__p).swap(*this);\n\t}\n\n      template&lt;typename _Yp, typename _Deleter&gt;\n\t_SafeConv&lt;_Yp&gt;\n\treset(_Yp* __p, _Deleter __d)\n\t{ __shared_ptr(__p, std::move(__d)).swap(*this); }\n\n      template&lt;typename _Yp, typename _Deleter, typename _Alloc&gt;\n\t_SafeConv&lt;_Yp&gt;\n\treset(_Yp* __p, _Deleter __d, _Alloc __a)\n        { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }\n\n      /// Return the stored pointer.\n      element_type*\n      get() const noexcept\n      { return _M_ptr; }\n\n      /// Return true if the stored pointer is not null.\n      explicit operator bool() const noexcept\n      { return _M_ptr != nullptr; }\n\n      /// Return true if use_count() == 1.\n      bool\n      unique() const noexcept\n      { return _M_refcount._M_unique(); }\n\n      /// If *this owns a pointer, return the number of owners, otherwise zero.\n      long\n      use_count() const noexcept\n      { return _M_refcount._M_get_use_count(); }\n\n      /// Exchange both the owned pointer and the stored pointer.\n      void\n      swap(__shared_ptr&lt;_Tp, _Lp&gt;&amp; __other) noexcept\n      {\n\tstd::swap(_M_ptr, __other._M_ptr);\n\t_M_refcount._M_swap(__other._M_refcount);\n      }\n\n      /** @brief Define an ordering based on ownership.\n       *\n       * This function defines a strict weak ordering between two shared_ptr\n       * or weak_ptr objects, such that one object is less than the other\n       * unless they share ownership of the same pointer, or are both empty.\n       * @{\n      */\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(__shared_ptr&lt;_Tp1, _Lp&gt; const&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(__weak_ptr&lt;_Tp1, _Lp&gt; const&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n      /// @}\n\n    protected:\n      // This constructor is non-standard, it is used by allocate_shared.\n      template&lt;typename _Alloc, typename... _Args&gt;\n\t__shared_ptr(_Sp_alloc_shared_tag&lt;_Alloc&gt; __tag, _Args&amp;&amp;... __args)\n\t: _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward&lt;_Args&gt;(__args)...)\n\t{ _M_enable_shared_from_this_with(_M_ptr); }\n\n      template&lt;typename _Tp1, _Lock_policy _Lp1, typename _Alloc,\n\t       typename... _Args&gt;\n\tfriend __shared_ptr&lt;_Tp1, _Lp1&gt;\n\t__allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args);\n\n      // This constructor is used by __weak_ptr::lock() and\n      // shared_ptr::shared_ptr(const weak_ptr&amp;, std::nothrow_t).\n      __shared_ptr(const __weak_ptr&lt;_Tp, _Lp&gt;&amp; __r, std::nothrow_t) noexcept\n      : _M_refcount(__r._M_refcount, std::nothrow)\n      {\n\t_M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;\n      }\n\n      friend class __weak_ptr&lt;_Tp, _Lp&gt;;\n\n    private:\n\n      template&lt;typename _Yp&gt;\n\tusing __esft_base_t = decltype(__enable_shared_from_this_base(\n\t      std::declval&lt;const __shared_count&lt;_Lp&gt;&amp;&gt;(),\n\t      std::declval&lt;_Yp*&gt;()));\n\n      // Detect an accessible and unambiguous enable_shared_from_this base.\n      template&lt;typename _Yp, typename = void&gt;\n\tstruct __has_esft_base\n\t: false_type { };\n\n      template&lt;typename _Yp&gt;\n\tstruct __has_esft_base&lt;_Yp, __void_t&lt;__esft_base_t&lt;_Yp&gt;&gt;&gt;\n\t: __not_&lt;is_array&lt;_Tp&gt;&gt; { }; // No enable shared_from_this for arrays\n\n      template&lt;typename _Yp, typename _Yp2 = typename remove_cv&lt;_Yp&gt;::type&gt;\n\ttypename enable_if&lt;__has_esft_base&lt;_Yp2&gt;::value&gt;::type\n\t_M_enable_shared_from_this_with(_Yp* __p) noexcept\n\t{\n\t  if (auto __base = __enable_shared_from_this_base(_M_refcount, __p))\n\t    __base-&gt;_M_weak_assign(const_cast&lt;_Yp2*&gt;(__p), _M_refcount);\n\t}\n\n      template&lt;typename _Yp, typename _Yp2 = typename remove_cv&lt;_Yp&gt;::type&gt;\n\ttypename enable_if&lt;!__has_esft_base&lt;_Yp2&gt;::value&gt;::type\n\t_M_enable_shared_from_this_with(_Yp*) noexcept\n\t{ }\n\n      void*\n      _M_get_deleter(const std::type_info&amp; __ti) const noexcept\n      { return _M_refcount._M_get_deleter(__ti); }\n\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __shared_ptr;\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __weak_ptr;\n\n      template&lt;typename _Del, typename _Tp1, _Lock_policy _Lp1&gt;\n\tfriend _Del* get_deleter(const __shared_ptr&lt;_Tp1, _Lp1&gt;&amp;) noexcept;\n\n      template&lt;typename _Del, typename _Tp1&gt;\n\tfriend _Del* get_deleter(const shared_ptr&lt;_Tp1&gt;&amp;) noexcept;\n\n      element_type*\t   _M_ptr;         // Contained pointer.\n      __shared_count&lt;_Lp&gt;  _M_refcount;    // Reference counter.\n    };\n\n\n  // 20.7.2.2.7 shared_ptr comparisons\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator==(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return __a.get() == __b.get(); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator==(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return !__a; }\n\n#ifdef __cpp_lib_three_way_comparison\n  template&lt;typename _Tp, typename _Up, _Lock_policy _Lp&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a,\n\t\tconst __shared_ptr&lt;_Up, _Lp&gt;&amp; __b) noexcept\n    { return compare_three_way()(__a.get(), __b.get()); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using pointer = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type*;\n      return compare_three_way()(__a.get(), static_cast&lt;pointer&gt;(nullptr));\n    }\n#else\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator==(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return !__a; }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator!=(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return __a.get() != __b.get(); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator!=(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return (bool)__a; }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator!=(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return (bool)__a; }\n\n  template&lt;typename _Tp, typename _Up, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a,\n\t      const __shared_ptr&lt;_Up, _Lp&gt;&amp; __b) noexcept\n    {\n      using _Tp_elt = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type;\n      using _Up_elt = typename __shared_ptr&lt;_Up, _Lp&gt;::element_type;\n      using _Vp = typename common_type&lt;_Tp_elt*, _Up_elt*&gt;::type;\n      return less&lt;_Vp&gt;()(__a.get(), __b.get());\n    }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using _Tp_elt = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(__a.get(), nullptr);\n    }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    {\n      using _Tp_elt = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(nullptr, __a.get());\n    }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;=(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return !(__b &lt; __a); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;=(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(nullptr &lt; __a); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;=(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return !(__a &lt; nullptr); }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t      const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return (__b &lt; __a); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return nullptr &lt; __a; }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return __a &lt; nullptr; }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;=(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return !(__a &lt; __b); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;=(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(__a &lt; nullptr); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;=(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return !(nullptr &lt; __a); }\n#endif // three-way comparison\n\n  // 20.7.2.2.8 shared_ptr specialized algorithms.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline void\n    swap(__shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, __shared_ptr&lt;_Tp, _Lp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n  // 20.7.2.2.9 shared_ptr casts\n\n  // The seemingly equivalent code:\n  // shared_ptr&lt;_Tp, _Lp&gt;(static_cast&lt;_Tp*&gt;(__r.get()))\n  // will eventually result in undefined behaviour, attempting to\n  // delete the same object twice.\n  /// static_pointer_cast\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    static_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      return _Sp(__r, static_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  // The seemingly equivalent code:\n  // shared_ptr&lt;_Tp, _Lp&gt;(const_cast&lt;_Tp*&gt;(__r.get()))\n  // will eventually result in undefined behaviour, attempting to\n  // delete the same object twice.\n  /// const_pointer_cast\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    const_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      return _Sp(__r, const_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  // The seemingly equivalent code:\n  // shared_ptr&lt;_Tp, _Lp&gt;(dynamic_cast&lt;_Tp*&gt;(__r.get()))\n  // will eventually result in undefined behaviour, attempting to\n  // delete the same object twice.\n  /// dynamic_pointer_cast\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    dynamic_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      if (auto* __p = dynamic_cast&lt;typename _Sp::element_type*&gt;(__r.get()))\n\treturn _Sp(__r, __p);\n      return _Sp();\n    }\n\n#if __cplusplus &gt; 201402L\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    reinterpret_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      return _Sp(__r, reinterpret_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n#endif\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __weak_ptr\n    {\n      template&lt;typename _Yp, typename _Res = void&gt;\n\tusing _Compatible = typename\n\t  enable_if&lt;__sp_compatible_with&lt;_Yp*, _Tp*&gt;::value, _Res&gt;::type;\n\n      // Constraint for assignment from shared_ptr and weak_ptr:\n      template&lt;typename _Yp&gt;\n\tusing _Assignable = _Compatible&lt;_Yp, __weak_ptr&amp;&gt;;\n\n    public:\n      using element_type = typename remove_extent&lt;_Tp&gt;::type;\n\n      constexpr __weak_ptr() noexcept\n      : _M_ptr(nullptr), _M_refcount()\n      { }\n\n      __weak_ptr(const __weak_ptr&amp;) noexcept = default;\n\n      ~__weak_ptr() = default;\n\n      // The &quot;obvious&quot; converting constructor implementation:\n      //\n      //  template&lt;typename _Tp1&gt;\n      //    __weak_ptr(const __weak_ptr&lt;_Tp1, _Lp&gt;&amp; __r)\n      //    : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n      //    { }\n      //\n      // has a serious problem.\n      //\n      //  __r._M_ptr may already have been invalidated. The _M_ptr(__r._M_ptr)\n      //  conversion may require access to *__r._M_ptr (virtual inheritance).\n      //\n      // It is not possible to avoid spurious access violations since\n      // in multithreaded programs __r._M_ptr may be invalidated at any point.\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__weak_ptr(const __weak_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t: _M_refcount(__r._M_refcount)\n        { _M_ptr = __r.lock().get(); }\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__weak_ptr(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)\n\t{ }\n\n      __weak_ptr(__weak_ptr&amp;&amp; __r) noexcept\n      : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount))\n      { __r._M_ptr = nullptr; }\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__weak_ptr(__weak_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t: _M_ptr(__r.lock().get()), _M_refcount(std::move(__r._M_refcount))\n        { __r._M_ptr = nullptr; }\n\n      __weak_ptr&amp;\n      operator=(const __weak_ptr&amp; __r) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(const __weak_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r.lock().get();\n\t  _M_refcount = __r._M_refcount;\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r._M_ptr;\n\t  _M_refcount = __r._M_refcount;\n\t  return *this;\n\t}\n\n      __weak_ptr&amp;\n      operator=(__weak_ptr&amp;&amp; __r) noexcept\n      {\n\t_M_ptr = __r._M_ptr;\n\t_M_refcount = std::move(__r._M_refcount);\n\t__r._M_ptr = nullptr;\n\treturn *this;\n      }\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(__weak_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r.lock().get();\n\t  _M_refcount = std::move(__r._M_refcount);\n\t  __r._M_ptr = nullptr;\n\t  return *this;\n\t}\n\n      __shared_ptr&lt;_Tp, _Lp&gt;\n      lock() const noexcept\n      { return __shared_ptr&lt;element_type, _Lp&gt;(*this, std::nothrow); }\n\n      long\n      use_count() const noexcept\n      { return _M_refcount._M_get_use_count(); }\n\n      bool\n      expired() const noexcept\n      { return _M_refcount._M_get_use_count() == 0; }\n\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(const __weak_ptr&lt;_Tp1, _Lp&gt;&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n\n      void\n      reset() noexcept\n      { __weak_ptr().swap(*this); }\n\n      void\n      swap(__weak_ptr&amp; __s) noexcept\n      {\n\tstd::swap(_M_ptr, __s._M_ptr);\n\t_M_refcount._M_swap(__s._M_refcount);\n      }\n\n    private:\n      // Used by __enable_shared_from_this.\n      void\n      _M_assign(_Tp* __ptr, const __shared_count&lt;_Lp&gt;&amp; __refcount) noexcept\n      {\n\tif (use_count() == 0)\n\t  {\n\t    _M_ptr = __ptr;\n\t    _M_refcount = __refcount;\n\t  }\n      }\n\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __shared_ptr;\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __weak_ptr;\n      friend class __enable_shared_from_this&lt;_Tp, _Lp&gt;;\n      friend class enable_shared_from_this&lt;_Tp&gt;;\n\n      element_type*\t _M_ptr;         // Contained pointer.\n      __weak_count&lt;_Lp&gt;  _M_refcount;    // Reference counter.\n    };\n\n  // 20.7.2.3.6 weak_ptr specialized algorithms.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline void\n    swap(__weak_ptr&lt;_Tp, _Lp&gt;&amp; __a, __weak_ptr&lt;_Tp, _Lp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n  template&lt;typename _Tp, typename _Tp1&gt;\n    struct _Sp_owner_less : public binary_function&lt;_Tp, _Tp, bool&gt;\n    {\n      bool\n      operator()(const _Tp&amp; __lhs, const _Tp&amp; __rhs) const noexcept\n      { return __lhs.owner_before(__rhs); }\n\n      bool\n      operator()(const _Tp&amp; __lhs, const _Tp1&amp; __rhs) const noexcept\n      { return __lhs.owner_before(__rhs); }\n\n      bool\n      operator()(const _Tp1&amp; __lhs, const _Tp&amp; __rhs) const noexcept\n      { return __lhs.owner_before(__rhs); }\n    };\n\n  template&lt;&gt;\n    struct _Sp_owner_less&lt;void, void&gt;\n    {\n      template&lt;typename _Tp, typename _Up&gt;\n\tauto\n\toperator()(const _Tp&amp; __lhs, const _Up&amp; __rhs) const noexcept\n\t-&gt; decltype(__lhs.owner_before(__rhs))\n\t{ return __lhs.owner_before(__rhs); }\n\n      using is_transparent = void;\n    };\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    struct owner_less&lt;__shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    : public _Sp_owner_less&lt;__shared_ptr&lt;_Tp, _Lp&gt;, __weak_ptr&lt;_Tp, _Lp&gt;&gt;\n    { };\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    struct owner_less&lt;__weak_ptr&lt;_Tp, _Lp&gt;&gt;\n    : public _Sp_owner_less&lt;__weak_ptr&lt;_Tp, _Lp&gt;, __shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    { };\n\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __enable_shared_from_this\n    {\n    protected:\n      constexpr __enable_shared_from_this() noexcept { }\n\n      __enable_shared_from_this(const __enable_shared_from_this&amp;) noexcept { }\n\n      __enable_shared_from_this&amp;\n      operator=(const __enable_shared_from_this&amp;) noexcept\n      { return *this; }\n\n      ~__enable_shared_from_this() { }\n\n    public:\n      __shared_ptr&lt;_Tp, _Lp&gt;\n      shared_from_this()\n      { return __shared_ptr&lt;_Tp, _Lp&gt;(this-&gt;_M_weak_this); }\n\n      __shared_ptr&lt;const _Tp, _Lp&gt;\n      shared_from_this() const\n      { return __shared_ptr&lt;const _Tp, _Lp&gt;(this-&gt;_M_weak_this); }\n\n#if __cplusplus &gt; 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n      __weak_ptr&lt;_Tp, _Lp&gt;\n      weak_from_this() noexcept\n      { return this-&gt;_M_weak_this; }\n\n      __weak_ptr&lt;const _Tp, _Lp&gt;\n      weak_from_this() const noexcept\n      { return this-&gt;_M_weak_this; }\n#endif\n\n    private:\n      template&lt;typename _Tp1&gt;\n\tvoid\n\t_M_weak_assign(_Tp1* __p, const __shared_count&lt;_Lp&gt;&amp; __n) const noexcept\n\t{ _M_weak_this._M_assign(__p, __n); }\n\n      friend const __enable_shared_from_this*\n      __enable_shared_from_this_base(const __shared_count&lt;_Lp&gt;&amp;,\n\t\t\t\t     const __enable_shared_from_this* __p)\n      { return __p; }\n\n      template&lt;typename, _Lock_policy&gt;\n\tfriend class __shared_ptr;\n\n      mutable __weak_ptr&lt;_Tp, _Lp&gt;  _M_weak_this;\n    };\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy,\n\t   typename _Alloc, typename... _Args&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    __allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args)\n    {\n      static_assert(!is_array&lt;_Tp&gt;::value, &quot;make_shared&lt;T[]&gt; not supported&quot;);\n\n      return __shared_ptr&lt;_Tp, _Lp&gt;(_Sp_alloc_shared_tag&lt;_Alloc&gt;{__a},\n\t\t\t\t    std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy,\n\t   typename... _Args&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    __make_shared(_Args&amp;&amp;... __args)\n    {\n      typedef typename std::remove_const&lt;_Tp&gt;::type _Tp_nc;\n      return std::__allocate_shared&lt;_Tp, _Lp&gt;(std::allocator&lt;_Tp_nc&gt;(),\n\t\t\t\t\t      std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  /// std::hash specialization for __shared_ptr.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    struct hash&lt;__shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    : public __hash_base&lt;size_t, __shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    {\n      size_t\n      operator()(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __s) const noexcept\n      {\n\treturn hash&lt;typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type*&gt;()(\n\t    __s.get());\n      }\n    };\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif // _SHARED_PTR_BASE_H\n"}, "/usr/include/c++/11/bits/alloc_traits.h": {"id": "/usr/include/c++/11/bits/alloc_traits.h", "filePath": "/usr/include/c++/11/bits/alloc_traits.h", "content": "// Allocator traits -*- C++ -*-\n\n// Copyright (C) 2011-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n/** @file bits/alloc_traits.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _ALLOC_TRAITS_H\n#define _ALLOC_TRAITS_H 1\n\n#include &lt;bits/stl_construct.h&gt;\n#include &lt;bits/memoryfwd.h&gt;\n#if __cplusplus &gt;= 201103L\n# include &lt;bits/allocator.h&gt;\n# include &lt;bits/ptr_traits.h&gt;\n# include &lt;ext/numeric_traits.h&gt;\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#if __cplusplus &gt;= 201103L\n#define __cpp_lib_allocator_traits_is_always_equal 201411\n\n  /// @cond undocumented\n  struct __allocator_traits_base\n  {\n    template&lt;typename _Tp, typename _Up, typename = void&gt;\n      struct __rebind : __replace_first_arg&lt;_Tp, _Up&gt; { };\n\n    template&lt;typename _Tp, typename _Up&gt;\n      struct __rebind&lt;_Tp, _Up,\n\t\t      __void_t&lt;typename _Tp::template rebind&lt;_Up&gt;::other&gt;&gt;\n      { using type = typename _Tp::template rebind&lt;_Up&gt;::other; };\n\n  protected:\n    template&lt;typename _Tp&gt;\n      using __pointer = typename _Tp::pointer;\n    template&lt;typename _Tp&gt;\n      using __c_pointer = typename _Tp::const_pointer;\n    template&lt;typename _Tp&gt;\n      using __v_pointer = typename _Tp::void_pointer;\n    template&lt;typename _Tp&gt;\n      using __cv_pointer = typename _Tp::const_void_pointer;\n    template&lt;typename _Tp&gt;\n      using __pocca = typename _Tp::propagate_on_container_copy_assignment;\n    template&lt;typename _Tp&gt;\n      using __pocma = typename _Tp::propagate_on_container_move_assignment;\n    template&lt;typename _Tp&gt;\n      using __pocs = typename _Tp::propagate_on_container_swap;\n    template&lt;typename _Tp&gt;\n      using __equal = typename _Tp::is_always_equal;\n  };\n\n  template&lt;typename _Alloc, typename _Up&gt;\n    using __alloc_rebind\n      = typename __allocator_traits_base::template __rebind&lt;_Alloc, _Up&gt;::type;\n  /// @endcond\n\n  /**\n   * @brief  Uniform interface to all allocator types.\n   * @headerfile memory\n   * @ingroup allocators\n   * @since C++11\n  */\n  template&lt;typename _Alloc&gt;\n    struct allocator_traits : __allocator_traits_base\n    {\n      /// The allocator type\n      typedef _Alloc allocator_type;\n      /// The allocated type\n      typedef typename _Alloc::value_type value_type;\n\n      /**\n       * @brief   The allocator&#x27;s pointer type.\n       *\n       * @c Alloc::pointer if that type exists, otherwise @c value_type*\n      */\n      using pointer = __detected_or_t&lt;value_type*, __pointer, _Alloc&gt;;\n\n    private:\n      // Select _Func&lt;_Alloc&gt; or pointer_traits&lt;pointer&gt;::rebind&lt;_Tp&gt;\n      template&lt;template&lt;typename&gt; class _Func, typename _Tp, typename = void&gt;\n\tstruct _Ptr\n\t{\n\t  using type = typename pointer_traits&lt;pointer&gt;::template rebind&lt;_Tp&gt;;\n\t};\n\n      template&lt;template&lt;typename&gt; class _Func, typename _Tp&gt;\n\tstruct _Ptr&lt;_Func, _Tp, __void_t&lt;_Func&lt;_Alloc&gt;&gt;&gt;\n\t{\n\t  using type = _Func&lt;_Alloc&gt;;\n\t};\n\n      // Select _A2::difference_type or pointer_traits&lt;_Ptr&gt;::difference_type\n      template&lt;typename _A2, typename _PtrT, typename = void&gt;\n\tstruct _Diff\n\t{ using type = typename pointer_traits&lt;_PtrT&gt;::difference_type; };\n\n      template&lt;typename _A2, typename _PtrT&gt;\n\tstruct _Diff&lt;_A2, _PtrT, __void_t&lt;typename _A2::difference_type&gt;&gt;\n\t{ using type = typename _A2::difference_type; };\n\n      // Select _A2::size_type or make_unsigned&lt;_DiffT&gt;::type\n      template&lt;typename _A2, typename _DiffT, typename = void&gt;\n\tstruct _Size : make_unsigned&lt;_DiffT&gt; { };\n\n      template&lt;typename _A2, typename _DiffT&gt;\n\tstruct _Size&lt;_A2, _DiffT, __void_t&lt;typename _A2::size_type&gt;&gt;\n\t{ using type = typename _A2::size_type; };\n\n    public:\n      /**\n       * @brief   The allocator&#x27;s const pointer type.\n       *\n       * @c Alloc::const_pointer if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::rebind&lt;const value_type&gt; &lt;/tt&gt;\n      */\n      using const_pointer = typename _Ptr&lt;__c_pointer, const value_type&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s void pointer type.\n       *\n       * @c Alloc::void_pointer if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::rebind&lt;void&gt; &lt;/tt&gt;\n      */\n      using void_pointer = typename _Ptr&lt;__v_pointer, void&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s const void pointer type.\n       *\n       * @c Alloc::const_void_pointer if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::rebind&lt;const void&gt; &lt;/tt&gt;\n      */\n      using const_void_pointer = typename _Ptr&lt;__cv_pointer, const void&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s difference type\n       *\n       * @c Alloc::difference_type if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::difference_type &lt;/tt&gt;\n      */\n      using difference_type = typename _Diff&lt;_Alloc, pointer&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s size type\n       *\n       * @c Alloc::size_type if that type exists, otherwise\n       * &lt;tt&gt; make_unsigned&lt;difference_type&gt;::type &lt;/tt&gt;\n      */\n      using size_type = typename _Size&lt;_Alloc, difference_type&gt;::type;\n\n      /**\n       * @brief   How the allocator is propagated on copy assignment\n       *\n       * @c Alloc::propagate_on_container_copy_assignment if that type exists,\n       * otherwise @c false_type\n      */\n      using propagate_on_container_copy_assignment\n\t= __detected_or_t&lt;false_type, __pocca, _Alloc&gt;;\n\n      /**\n       * @brief   How the allocator is propagated on move assignment\n       *\n       * @c Alloc::propagate_on_container_move_assignment if that type exists,\n       * otherwise @c false_type\n      */\n      using propagate_on_container_move_assignment\n\t= __detected_or_t&lt;false_type, __pocma, _Alloc&gt;;\n\n      /**\n       * @brief   How the allocator is propagated on swap\n       *\n       * @c Alloc::propagate_on_container_swap if that type exists,\n       * otherwise @c false_type\n      */\n      using propagate_on_container_swap\n\t= __detected_or_t&lt;false_type, __pocs, _Alloc&gt;;\n\n      /**\n       * @brief   Whether all instances of the allocator type compare equal.\n       *\n       * @c Alloc::is_always_equal if that type exists,\n       * otherwise @c is_empty&lt;Alloc&gt;::type\n      */\n      using is_always_equal\n\t= __detected_or_t&lt;typename is_empty&lt;_Alloc&gt;::type, __equal, _Alloc&gt;;\n\n      template&lt;typename _Tp&gt;\n\tusing rebind_alloc = __alloc_rebind&lt;_Alloc, _Tp&gt;;\n      template&lt;typename _Tp&gt;\n\tusing rebind_traits = allocator_traits&lt;rebind_alloc&lt;_Tp&gt;&gt;;\n\n    private:\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr auto\n\t_S_allocate(_Alloc2&amp; __a, size_type __n, const_void_pointer __hint, int)\n\t-&gt; decltype(__a.allocate(__n, __hint))\n\t{ return __a.allocate(__n, __hint); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr pointer\n\t_S_allocate(_Alloc2&amp; __a, size_type __n, const_void_pointer, ...)\n\t{ return __a.allocate(__n); }\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstruct __construct_helper\n\t{\n\t  template&lt;typename _Alloc2,\n\t    typename = decltype(std::declval&lt;_Alloc2*&gt;()-&gt;construct(\n\t\t  std::declval&lt;_Tp*&gt;(), std::declval&lt;_Args&gt;()...))&gt;\n\t    static true_type __test(int);\n\n\t  template&lt;typename&gt;\n\t    static false_type __test(...);\n\n\t  using type = decltype(__test&lt;_Alloc&gt;(0));\n\t};\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tusing __has_construct\n\t  = typename __construct_helper&lt;_Tp, _Args...&gt;::type;\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstatic _GLIBCXX14_CONSTEXPR _Require&lt;__has_construct&lt;_Tp, _Args...&gt;&gt;\n\t_S_construct(_Alloc&amp; __a, _Tp* __p, _Args&amp;&amp;... __args)\n\tnoexcept(noexcept(__a.construct(__p, std::forward&lt;_Args&gt;(__args)...)))\n\t{ __a.construct(__p, std::forward&lt;_Args&gt;(__args)...); }\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstatic _GLIBCXX14_CONSTEXPR\n\t_Require&lt;__and_&lt;__not_&lt;__has_construct&lt;_Tp, _Args...&gt;&gt;,\n\t\t\t       is_constructible&lt;_Tp, _Args...&gt;&gt;&gt;\n\t_S_construct(_Alloc&amp;, _Tp* __p, _Args&amp;&amp;... __args)\n\tnoexcept(std::is_nothrow_constructible&lt;_Tp, _Args...&gt;::value)\n\t{\n#if __cplusplus &lt;= 201703L\n\t  ::new((void*)__p) _Tp(std::forward&lt;_Args&gt;(__args)...);\n#else\n\t  std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...);\n#endif\n\t}\n\n      template&lt;typename _Alloc2, typename _Tp&gt;\n\tstatic _GLIBCXX14_CONSTEXPR auto\n\t_S_destroy(_Alloc2&amp; __a, _Tp* __p, int)\n\tnoexcept(noexcept(__a.destroy(__p)))\n\t-&gt; decltype(__a.destroy(__p))\n\t{ __a.destroy(__p); }\n\n      template&lt;typename _Alloc2, typename _Tp&gt;\n\tstatic _GLIBCXX14_CONSTEXPR void\n\t_S_destroy(_Alloc2&amp;, _Tp* __p, ...)\n\tnoexcept(std::is_nothrow_destructible&lt;_Tp&gt;::value)\n\t{ std::_Destroy(__p); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr auto\n\t_S_max_size(_Alloc2&amp; __a, int)\n\t-&gt; decltype(__a.max_size())\n\t{ return __a.max_size(); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr size_type\n\t_S_max_size(_Alloc2&amp;, ...)\n\t{\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 2466. allocator_traits::max_size() default behavior is incorrect\n\t  return __gnu_cxx::__numeric_traits&lt;size_type&gt;::__max\n\t    / sizeof(value_type);\n\t}\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr auto\n\t_S_select(_Alloc2&amp; __a, int)\n\t-&gt; decltype(__a.select_on_container_copy_construction())\n\t{ return __a.select_on_container_copy_construction(); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr _Alloc2\n\t_S_select(_Alloc2&amp; __a, ...)\n\t{ return __a; }\n\n    public:\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *\n       *  Calls @c a.allocate(n)\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(_Alloc&amp; __a, size_type __n)\n      { return __a.allocate(__n); }\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *  @param  __hint Aid to locality.\n       *  @return Memory of suitable size and alignment for @a n objects\n       *          of type @c value_type\n       *\n       *  Returns &lt;tt&gt; a.allocate(n, hint) &lt;/tt&gt; if that expression is\n       *  well-formed, otherwise returns @c a.allocate(n)\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(_Alloc&amp; __a, size_type __n, const_void_pointer __hint)\n      { return _S_allocate(__a, __n, __hint, 0); }\n\n      /**\n       *  @brief  Deallocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the memory to deallocate.\n       *  @param  __n  The number of objects space was allocated for.\n       *\n       *  Calls &lt;tt&gt; a.deallocate(p, n) &lt;/tt&gt;\n      */\n      static _GLIBCXX20_CONSTEXPR void\n      deallocate(_Alloc&amp; __a, pointer __p, size_type __n)\n      { __a.deallocate(__p, __n); }\n\n      /**\n       *  @brief  Construct an object of type `_Tp`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to memory of suitable size and alignment for Tp\n       *  @param  __args Constructor arguments.\n       *\n       *  Calls &lt;tt&gt; __a.construct(__p, std::forward&lt;Args&gt;(__args)...) &lt;/tt&gt;\n       *  if that expression is well-formed, otherwise uses placement-new\n       *  to construct an object of type @a _Tp at location @a __p from the\n       *  arguments @a __args...\n      */\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstatic _GLIBCXX20_CONSTEXPR auto\n\tconstruct(_Alloc&amp; __a, _Tp* __p, _Args&amp;&amp;... __args)\n\tnoexcept(noexcept(_S_construct(__a, __p,\n\t\t\t\t       std::forward&lt;_Args&gt;(__args)...)))\n\t-&gt; decltype(_S_construct(__a, __p, std::forward&lt;_Args&gt;(__args)...))\n\t{ _S_construct(__a, __p, std::forward&lt;_Args&gt;(__args)...); }\n\n      /**\n       *  @brief  Destroy an object of type @a _Tp\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the object to destroy\n       *\n       *  Calls @c __a.destroy(__p) if that expression is well-formed,\n       *  otherwise calls @c __p-&gt;~_Tp()\n      */\n      template&lt;typename _Tp&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tdestroy(_Alloc&amp; __a, _Tp* __p)\n\tnoexcept(noexcept(_S_destroy(__a, __p, 0)))\n\t{ _S_destroy(__a, __p, 0); }\n\n      /**\n       *  @brief  The maximum supported allocation size\n       *  @param  __a  An allocator.\n       *  @return @c __a.max_size() or @c numeric_limits&lt;size_type&gt;::max()\n       *\n       *  Returns @c __a.max_size() if that expression is well-formed,\n       *  otherwise returns @c numeric_limits&lt;size_type&gt;::max()\n      */\n      static _GLIBCXX20_CONSTEXPR size_type\n      max_size(const _Alloc&amp; __a) noexcept\n      { return _S_max_size(__a, 0); }\n\n      /**\n       *  @brief  Obtain an allocator to use when copying a container.\n       *  @param  __rhs  An allocator.\n       *  @return @c __rhs.select_on_container_copy_construction() or @a __rhs\n       *\n       *  Returns @c __rhs.select_on_container_copy_construction() if that\n       *  expression is well-formed, otherwise returns @a __rhs\n      */\n      static _GLIBCXX20_CONSTEXPR _Alloc\n      select_on_container_copy_construction(const _Alloc&amp; __rhs)\n      { return _S_select(__rhs, 0); }\n    };\n\n#if __cplusplus &gt; 201703L\n# define __cpp_lib_constexpr_dynamic_alloc 201907L\n#endif\n\n  /// Partial specialization for std::allocator.\n  template&lt;typename _Tp&gt;\n    struct allocator_traits&lt;allocator&lt;_Tp&gt;&gt;\n    {\n      /// The allocator type\n      using allocator_type = allocator&lt;_Tp&gt;;\n\n      /// The allocated type\n      using value_type = _Tp;\n\n      /// The allocator&#x27;s pointer type.\n      using pointer = _Tp*;\n\n      /// The allocator&#x27;s const pointer type.\n      using const_pointer = const _Tp*;\n\n      /// The allocator&#x27;s void pointer type.\n      using void_pointer = void*;\n\n      /// The allocator&#x27;s const void pointer type.\n      using const_void_pointer = const void*;\n\n      /// The allocator&#x27;s difference type\n      using difference_type = std::ptrdiff_t;\n\n      /// The allocator&#x27;s size type\n      using size_type = std::size_t;\n\n      /// How the allocator is propagated on copy assignment\n      using propagate_on_container_copy_assignment = false_type;\n\n      /// How the allocator is propagated on move assignment\n      using propagate_on_container_move_assignment = true_type;\n\n      /// How the allocator is propagated on swap\n      using propagate_on_container_swap = false_type;\n\n      /// Whether all instances of the allocator type compare equal.\n      using is_always_equal = true_type;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_alloc = allocator&lt;_Up&gt;;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_traits = allocator_traits&lt;allocator&lt;_Up&gt;&gt;;\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *\n       *  Calls @c a.allocate(n)\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(allocator_type&amp; __a, size_type __n)\n      { return __a.allocate(__n); }\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *  @param  __hint Aid to locality.\n       *  @return Memory of suitable size and alignment for @a n objects\n       *          of type @c value_type\n       *\n       *  Returns &lt;tt&gt; a.allocate(n, hint) &lt;/tt&gt;\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(allocator_type&amp; __a, size_type __n, const_void_pointer __hint)\n      {\n#if __cplusplus &lt;= 201703L\n\treturn __a.allocate(__n, __hint);\n#else\n\treturn __a.allocate(__n);\n#endif\n      }\n\n      /**\n       *  @brief  Deallocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the memory to deallocate.\n       *  @param  __n  The number of objects space was allocated for.\n       *\n       *  Calls &lt;tt&gt; a.deallocate(p, n) &lt;/tt&gt;\n      */\n      static _GLIBCXX20_CONSTEXPR void\n      deallocate(allocator_type&amp; __a, pointer __p, size_type __n)\n      { __a.deallocate(__p, __n); }\n\n      /**\n       *  @brief  Construct an object of type `_Up`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to memory of suitable size and alignment for\n       *\t       an object of type `_Up`.\n       *  @param  __args Constructor arguments.\n       *\n       *  Calls `__a.construct(__p, std::forward&lt;_Args&gt;(__args)...)`\n       *  in C++11, C++14 and C++17. Changed in C++20 to call\n       *  `std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...)` instead.\n      */\n      template&lt;typename _Up, typename... _Args&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tconstruct(allocator_type&amp; __a __attribute__((__unused__)), _Up* __p,\n\t\t  _Args&amp;&amp;... __args)\n\tnoexcept(std::is_nothrow_constructible&lt;_Up, _Args...&gt;::value)\n\t{\n#if __cplusplus &lt;= 201703L\n\t  __a.construct(__p, std::forward&lt;_Args&gt;(__args)...);\n#else\n\t  std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...);\n#endif\n\t}\n\n      /**\n       *  @brief  Destroy an object of type @a _Up\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the object to destroy\n       *\n       *  Calls @c __a.destroy(__p).\n      */\n      template&lt;typename _Up&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tdestroy(allocator_type&amp; __a __attribute__((__unused__)), _Up* __p)\n\tnoexcept(is_nothrow_destructible&lt;_Up&gt;::value)\n\t{\n#if __cplusplus &lt;= 201703L\n\t  __a.destroy(__p);\n#else\n\t  std::destroy_at(__p);\n#endif\n\t}\n\n      /**\n       *  @brief  The maximum supported allocation size\n       *  @param  __a  An allocator.\n       *  @return @c __a.max_size()\n      */\n      static _GLIBCXX20_CONSTEXPR size_type\n      max_size(const allocator_type&amp; __a __attribute__((__unused__))) noexcept\n      {\n#if __cplusplus &lt;= 201703L\n\treturn __a.max_size();\n#else\n\treturn size_t(-1) / sizeof(value_type);\n#endif\n      }\n\n      /**\n       *  @brief  Obtain an allocator to use when copying a container.\n       *  @param  __rhs  An allocator.\n       *  @return @c __rhs\n      */\n      static _GLIBCXX20_CONSTEXPR allocator_type\n      select_on_container_copy_construction(const allocator_type&amp; __rhs)\n      { return __rhs; }\n    };\n\n  /// Explicit specialization for std::allocator&lt;void&gt;.\n  template&lt;&gt;\n    struct allocator_traits&lt;allocator&lt;void&gt;&gt;\n    {\n      /// The allocator type\n      using allocator_type = allocator&lt;void&gt;;\n\n      /// The allocated type\n      using value_type = void;\n\n      /// The allocator&#x27;s pointer type.\n      using pointer = void*;\n\n      /// The allocator&#x27;s const pointer type.\n      using const_pointer = const void*;\n\n      /// The allocator&#x27;s void pointer type.\n      using void_pointer = void*;\n\n      /// The allocator&#x27;s const void pointer type.\n      using const_void_pointer = const void*;\n\n      /// The allocator&#x27;s difference type\n      using difference_type = std::ptrdiff_t;\n\n      /// The allocator&#x27;s size type\n      using size_type = std::size_t;\n\n      /// How the allocator is propagated on copy assignment\n      using propagate_on_container_copy_assignment = false_type;\n\n      /// How the allocator is propagated on move assignment\n      using propagate_on_container_move_assignment = true_type;\n\n      /// How the allocator is propagated on swap\n      using propagate_on_container_swap = false_type;\n\n      /// Whether all instances of the allocator type compare equal.\n      using is_always_equal = true_type;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_alloc = allocator&lt;_Up&gt;;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_traits = allocator_traits&lt;allocator&lt;_Up&gt;&gt;;\n\n      /// allocate is ill-formed for allocator&lt;void&gt;\n      static void*\n      allocate(allocator_type&amp;, size_type, const void* = nullptr) = delete;\n\n      /// deallocate is ill-formed for allocator&lt;void&gt;\n      static void\n      deallocate(allocator_type&amp;, void*, size_type) = delete;\n\n      /**\n       *  @brief  Construct an object of type `_Up`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to memory of suitable size and alignment for\n       *\t       an object of type `_Up`.\n       *  @param  __args Constructor arguments.\n       *\n       *  Calls `__a.construct(__p, std::forward&lt;_Args&gt;(__args)...)`\n       *  in C++11, C++14 and C++17. Changed in C++20 to call\n       *  `std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...)` instead.\n      */\n      template&lt;typename _Up, typename... _Args&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tconstruct(allocator_type&amp;, _Up* __p, _Args&amp;&amp;... __args)\n\tnoexcept(std::is_nothrow_constructible&lt;_Up, _Args...&gt;::value)\n\t{ std::_Construct(__p, std::forward&lt;_Args&gt;(__args)...); }\n\n      /**\n       *  @brief  Destroy an object of type `_Up`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the object to destroy\n       *\n       *  Invokes the destructor for `*__p`.\n      */\n      template&lt;typename _Up&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tdestroy(allocator_type&amp;, _Up* __p)\n\tnoexcept(is_nothrow_destructible&lt;_Up&gt;::value)\n\t{ std::_Destroy(__p); }\n\n      /// max_size is ill-formed for allocator&lt;void&gt;\n      static size_type\n      max_size(const allocator_type&amp;) = delete;\n\n      /**\n       *  @brief  Obtain an allocator to use when copying a container.\n       *  @param  __rhs  An allocator.\n       *  @return `__rhs`\n      */\n      static _GLIBCXX20_CONSTEXPR allocator_type\n      select_on_container_copy_construction(const allocator_type&amp; __rhs)\n      { return __rhs; }\n    };\n\n#if __cplusplus &lt; 201703L\n  template&lt;typename _Alloc&gt;\n    inline void\n    __do_alloc_on_copy(_Alloc&amp; __one, const _Alloc&amp; __two, true_type)\n    { __one = __two; }\n\n  template&lt;typename _Alloc&gt;\n    inline void\n    __do_alloc_on_copy(_Alloc&amp;, const _Alloc&amp;, false_type)\n    { }\n#endif\n\n  template&lt;typename _Alloc&gt;\n    _GLIBCXX14_CONSTEXPR inline void\n    __alloc_on_copy(_Alloc&amp; __one, const _Alloc&amp; __two)\n    {\n      typedef allocator_traits&lt;_Alloc&gt; __traits;\n      typedef typename __traits::propagate_on_container_copy_assignment __pocca;\n#if __cplusplus &gt;= 201703L\n      if constexpr (__pocca::value)\n\t__one = __two;\n#else\n      __do_alloc_on_copy(__one, __two, __pocca());\n#endif\n    }\n\n  template&lt;typename _Alloc&gt;\n    constexpr _Alloc\n    __alloc_on_copy(const _Alloc&amp; __a)\n    {\n      typedef allocator_traits&lt;_Alloc&gt; __traits;\n      return __traits::select_on_container_copy_construction(__a);\n    }\n\n#if __cplusplus &lt; 201703L\n  template&lt;typename _Alloc&gt;\n    inline void __do_alloc_on_move(_Alloc&amp; __one, _Alloc&amp; __two, true_type)\n    { __one = std::move(__two); }\n\n  template&lt;typename _Alloc&gt;\n    inline void __do_alloc_on_move(_Alloc&amp;, _Alloc&amp;, false_type)\n    { }\n#endif\n\n  template&lt;typename _Alloc&gt;\n    _GLIBCXX14_CONSTEXPR inline void\n    __alloc_on_move(_Alloc&amp; __one, _Alloc&amp; __two)\n    {\n      typedef allocator_traits&lt;_Alloc&gt; __traits;\n      typedef typename __traits::propagate_on_container_move_assignment __pocma;\n#if __cplusplus &gt;= 201703L\n      if constexpr (__pocma::value)\n\t__one = std::move(__two);\n#else\n      __do_alloc_on_move(__one, __two, __pocma());\n#endif\n    }\n\n#if __cplusplus &lt; 201703L\n  template&lt;typename _Alloc&gt;\n    inline void __do_alloc_on_swap(_Alloc&amp; __one, _Alloc&amp; __two, true_type)\n    {\n      using std::swap;\n      swap(__one, __two);\n    }\n\n  template&lt;typename _Alloc&gt;\n    inline void __do_alloc_on_swap(_Alloc&amp;, _Alloc&amp;, false_type)\n    { }\n#endif\n\n  template&lt;typename _Alloc&gt;\n    _GLIBCXX14_CONSTEXPR inline void\n    __alloc_on_swap(_Alloc&amp; __one, _Alloc&amp; __two)\n    {\n      typedef allocator_traits&lt;_Alloc&gt; __traits;\n      typedef typename __traits::propagate_on_container_swap __pocs;\n#if __cplusplus &gt;= 201703L\n      if constexpr (__pocs::value)\n\t{\n\t  using std::swap;\n\t  swap(__one, __two);\n\t}\n#else\n      __do_alloc_on_swap(__one, __two, __pocs());\n#endif\n    }\n\n  template&lt;typename _Alloc, typename _Tp,\n\t   typename _ValueT = __remove_cvref_t&lt;typename _Alloc::value_type&gt;,\n\t   typename = void&gt;\n    struct __is_alloc_insertable_impl\n    : false_type\n    { };\n\n  template&lt;typename _Alloc, typename _Tp, typename _ValueT&gt;\n    struct __is_alloc_insertable_impl&lt;_Alloc, _Tp, _ValueT,\n      __void_t&lt;decltype(allocator_traits&lt;_Alloc&gt;::construct(\n\t\t   std::declval&lt;_Alloc&amp;&gt;(), std::declval&lt;_ValueT*&gt;(),\n\t\t   std::declval&lt;_Tp&gt;()))&gt;&gt;\n    : true_type\n    { };\n\n  // true if _Alloc::value_type is CopyInsertable into containers using _Alloc\n  // (might be wrong if _Alloc::construct exists but is not constrained,\n  // i.e. actually trying to use it would still be invalid. Use with caution.)\n  template&lt;typename _Alloc&gt;\n    struct __is_copy_insertable\n    : __is_alloc_insertable_impl&lt;_Alloc,\n\t\t\t\t typename _Alloc::value_type const&amp;&gt;::type\n    { };\n\n  // std::allocator&lt;_Tp&gt; just requires CopyConstructible\n  template&lt;typename _Tp&gt;\n    struct __is_copy_insertable&lt;allocator&lt;_Tp&gt;&gt;\n    : is_copy_constructible&lt;_Tp&gt;\n    { };\n\n  // true if _Alloc::value_type is MoveInsertable into containers using _Alloc\n  // (might be wrong if _Alloc::construct exists but is not constrained,\n  // i.e. actually trying to use it would still be invalid. Use with caution.)\n  template&lt;typename _Alloc&gt;\n    struct __is_move_insertable\n    : __is_alloc_insertable_impl&lt;_Alloc, typename _Alloc::value_type&gt;::type\n    { };\n\n  // std::allocator&lt;_Tp&gt; just requires MoveConstructible\n  template&lt;typename _Tp&gt;\n    struct __is_move_insertable&lt;allocator&lt;_Tp&gt;&gt;\n    : is_move_constructible&lt;_Tp&gt;\n    { };\n\n  // Trait to detect Allocator-like types.\n  template&lt;typename _Alloc, typename = void&gt;\n    struct __is_allocator : false_type { };\n\n  template&lt;typename _Alloc&gt;\n    struct __is_allocator&lt;_Alloc,\n      __void_t&lt;typename _Alloc::value_type,\n\t       decltype(std::declval&lt;_Alloc&amp;&gt;().allocate(size_t{}))&gt;&gt;\n    : true_type { };\n\n  template&lt;typename _Alloc&gt;\n    using _RequireAllocator\n      = typename enable_if&lt;__is_allocator&lt;_Alloc&gt;::value, _Alloc&gt;::type;\n\n  template&lt;typename _Alloc&gt;\n    using _RequireNotAllocator\n      = typename enable_if&lt;!__is_allocator&lt;_Alloc&gt;::value, _Alloc&gt;::type;\n\n#if __cpp_concepts &gt;= 201907L\n  template&lt;typename _Alloc&gt;\n    concept __allocator_like = requires (_Alloc&amp; __a) {\n      typename _Alloc::value_type;\n      __a.deallocate(__a.allocate(1u), 1u);\n    };\n#endif\n#endif // C++11\n\n  /**\n   * Destroy a range of objects using the supplied allocator.  For\n   * non-default allocators we do not optimize away invocation of\n   * destroy() even if _Tp has a trivial destructor.\n   */\n\n  template&lt;typename _ForwardIterator, typename _Allocator&gt;\n    void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n\t     _Allocator&amp; __alloc)\n    {\n      for (; __first != __last; ++__first)\n#if __cplusplus &lt; 201103L\n\t__alloc.destroy(std::__addressof(*__first));\n#else\n\tallocator_traits&lt;_Allocator&gt;::destroy(__alloc,\n\t\t\t\t\t      std::__addressof(*__first));\n#endif\n    }\n\n  template&lt;typename _ForwardIterator, typename _Tp&gt;\n    inline void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n\t     allocator&lt;_Tp&gt;&amp;)\n    {\n      _Destroy(__first, __last);\n    }\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n#endif // _ALLOC_TRAITS_H\n"}, "/usr/include/c++/11/ext/new_allocator.h": {"id": "/usr/include/c++/11/ext/new_allocator.h", "filePath": "/usr/include/c++/11/ext/new_allocator.h", "content": "// Allocator that wraps operator new -*- C++ -*-\n\n// Copyright (C) 2001-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n/** @file ext/new_allocator.h\n *  This file is a GNU extension to the Standard C++ Library.\n */\n\n#ifndef _NEW_ALLOCATOR_H\n#define _NEW_ALLOCATOR_H 1\n\n#include &lt;bits/c++config.h&gt;\n#include &lt;new&gt;\n#include &lt;bits/functexcept.h&gt;\n#include &lt;bits/move.h&gt;\n#if __cplusplus &gt;= 201103L\n#include &lt;type_traits&gt;\n#endif\n\nnamespace __gnu_cxx _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   *  @brief  An allocator that uses global new, as per C++03 [20.4.1].\n   *  @ingroup allocators\n   *\n   *  This is precisely the allocator defined in the C++ Standard.\n   *    - all allocation calls operator new\n   *    - all deallocation calls operator delete\n   *\n   *  @tparam  _Tp  Type of allocated object.\n   */\n  template&lt;typename _Tp&gt;\n    class new_allocator\n    {\n    public:\n      typedef _Tp        value_type;\n      typedef std::size_t     size_type;\n      typedef std::ptrdiff_t  difference_type;\n#if __cplusplus &lt;= 201703L\n      typedef _Tp*       pointer;\n      typedef const _Tp* const_pointer;\n      typedef _Tp&amp;       reference;\n      typedef const _Tp&amp; const_reference;\n\n      template&lt;typename _Tp1&gt;\n\tstruct rebind\n\t{ typedef new_allocator&lt;_Tp1&gt; other; };\n#endif\n\n#if __cplusplus &gt;= 201103L\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2103. propagate_on_container_move_assignment\n      typedef std::true_type propagate_on_container_move_assignment;\n#endif\n\n      _GLIBCXX20_CONSTEXPR\n      new_allocator() _GLIBCXX_USE_NOEXCEPT { }\n\n      _GLIBCXX20_CONSTEXPR\n      new_allocator(const new_allocator&amp;) _GLIBCXX_USE_NOEXCEPT { }\n\n      template&lt;typename _Tp1&gt;\n\t_GLIBCXX20_CONSTEXPR\n\tnew_allocator(const new_allocator&lt;_Tp1&gt;&amp;) _GLIBCXX_USE_NOEXCEPT { }\n\n#if __cplusplus &lt;= 201703L\n      ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }\n\n      pointer\n      address(reference __x) const _GLIBCXX_NOEXCEPT\n      { return std::__addressof(__x); }\n\n      const_pointer\n      address(const_reference __x) const _GLIBCXX_NOEXCEPT\n      { return std::__addressof(__x); }\n#endif\n\n      // NB: __n is permitted to be 0.  The C++ standard says nothing\n      // about what the return value is when __n == 0.\n      _GLIBCXX_NODISCARD _Tp*\n      allocate(size_type __n, const void* = static_cast&lt;const void*&gt;(0))\n      {\n#if __cplusplus &gt;= 201103L\n\t // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t // 3308. std::allocator&lt;void&gt;().allocate(n)\n\t static_assert(sizeof(_Tp) != 0, &quot;cannot allocate incomplete types&quot;);\n#endif\n\n\tif (__builtin_expect(__n &gt; this-&gt;_M_max_size(), false))\n\t  {\n\t    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t    // 3190. allocator::allocate sometimes returns too little storage\n\t    if (__n &gt; (std::size_t(-1) / sizeof(_Tp)))\n\t      std::__throw_bad_array_new_length();\n\t    std::__throw_bad_alloc();\n\t  }\n\n#if __cpp_aligned_new\n\tif (alignof(_Tp) &gt; __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n\t  {\n\t    std::align_val_t __al = std::align_val_t(alignof(_Tp));\n\t    return static_cast&lt;_Tp*&gt;(::operator new(__n * sizeof(_Tp), __al));\n\t  }\n#endif\n\treturn static_cast&lt;_Tp*&gt;(::operator new(__n * sizeof(_Tp)));\n      }\n\n      // __p is not permitted to be a null pointer.\n      void\n      deallocate(_Tp* __p, size_type __t __attribute__ ((__unused__)))\n      {\n#if __cpp_aligned_new\n\tif (alignof(_Tp) &gt; __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n\t  {\n\t    ::operator delete(__p,\n# if __cpp_sized_deallocation\n\t\t\t      __t * sizeof(_Tp),\n# endif\n\t\t\t      std::align_val_t(alignof(_Tp)));\n\t    return;\n\t  }\n#endif\n\t::operator delete(__p\n#if __cpp_sized_deallocation\n\t\t\t  , __t * sizeof(_Tp)\n#endif\n\t\t\t );\n      }\n\n#if __cplusplus &lt;= 201703L\n      size_type\n      max_size() const _GLIBCXX_USE_NOEXCEPT\n      { return _M_max_size(); }\n\n#if __cplusplus &gt;= 201103L\n      template&lt;typename _Up, typename... _Args&gt;\n\tvoid\n\tconstruct(_Up* __p, _Args&amp;&amp;... __args)\n\tnoexcept(std::is_nothrow_constructible&lt;_Up, _Args...&gt;::value)\n\t{ ::new((void *)__p) _Up(std::forward&lt;_Args&gt;(__args)...); }\n\n      template&lt;typename _Up&gt;\n\tvoid\n\tdestroy(_Up* __p)\n\tnoexcept(std::is_nothrow_destructible&lt;_Up&gt;::value)\n\t{ __p-&gt;~_Up(); }\n#else\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 402. wrong new expression in [some_] allocator::construct\n      void\n      construct(pointer __p, const _Tp&amp; __val)\n      { ::new((void *)__p) _Tp(__val); }\n\n      void\n      destroy(pointer __p) { __p-&gt;~_Tp(); }\n#endif\n#endif // ! C++20\n\n      template&lt;typename _Up&gt;\n\tfriend _GLIBCXX20_CONSTEXPR bool\n\toperator==(const new_allocator&amp;, const new_allocator&lt;_Up&gt;&amp;)\n\t_GLIBCXX_NOTHROW\n\t{ return true; }\n\n#if __cpp_impl_three_way_comparison &lt; 201907L\n      template&lt;typename _Up&gt;\n\tfriend _GLIBCXX20_CONSTEXPR bool\n\toperator!=(const new_allocator&amp;, const new_allocator&lt;_Up&gt;&amp;)\n\t_GLIBCXX_NOTHROW\n\t{ return false; }\n#endif\n\n    private:\n      _GLIBCXX_CONSTEXPR size_type\n      _M_max_size() const _GLIBCXX_USE_NOEXCEPT\n      {\n#if __PTRDIFF_MAX__ &lt; __SIZE_MAX__\n\treturn std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);\n#else\n\treturn std::size_t(-1) / sizeof(_Tp);\n#endif\n      }\n    };\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/key/evalkey.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/key/evalkey.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/key/evalkey.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_KEY_EVALKEY_H\n#define LBCRYPTO_CRYPTO_KEY_EVALKEY_H\n\n#include &quot;key/evalkey-fwd.h&quot;\n#include &quot;key/key.h&quot;\n\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\n\n/**\n * @brief Abstract interface for evaluation/proxy keys\n * @tparam Element a ring element.\n */\ntemplate &lt;class Element&gt;\nclass EvalKeyImpl : public Key&lt;Element&gt; {\npublic:\n    /**\n   * Basic constructor for setting crypto params\n   *\n   * @param &amp;cryptoParams is the reference to cryptoParams\n   */\n\n    explicit EvalKeyImpl(CryptoContext&lt;Element&gt; cc = 0) : Key&lt;Element&gt;(cc) {}\n\n    virtual ~EvalKeyImpl() {}\n\n    /**\n   * Setter function to store Relinearization Element Vector A.\n   * Throws exception, to be overridden by derived class.\n   *\n   * @param &amp;a is the Element vector to be copied.\n   */\n\n    virtual void SetAVector(const std::vector&lt;Element&gt;&amp; a) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;SetAVector copy operation not supported&quot;);\n    }\n\n    /**\n   * Setter function to store Relinearization Element Vector A.\n   * Throws exception, to be overridden by derived class.\n   *\n   * @param &amp;&amp;a is the Element vector to be moved.\n   */\n\n    virtual void SetAVector(std::vector&lt;Element&gt;&amp;&amp; a) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;SetAVector move operation not supported&quot;);\n    }\n\n    /**\n   * Getter function to access Relinearization Element Vector A.\n   * Throws exception, to be overridden by derived class.\n   *\n   * @return Element vector A.\n   */\n\n    virtual const std::vector&lt;Element&gt;&amp; GetAVector() const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;GetAVector operation not supported&quot;);\n    }\n\n    /**\n   * Setter function to store Relinearization Element Vector B.\n   * Throws exception, to be overridden by derived class.\n   *\n   * @param &amp;b is the Element vector to be copied.\n   */\n\n    virtual void SetBVector(const std::vector&lt;Element&gt;&amp; b) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;SetBVector copy operation not supported&quot;);\n    }\n\n    /**\n   * Setter function to store Relinearization Element Vector B.\n   * Throws exception, to be overridden by derived class.\n   *\n   * @param &amp;&amp;b is the Element vector to be moved.\n   */\n\n    virtual void SetBVector(std::vector&lt;Element&gt;&amp;&amp; b) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;SetBVector move operation not supported&quot;);\n    }\n\n    /**\n   * Getter function to access Relinearization Element Vector B.\n   * Throws exception, to be overridden by derived class.\n   *\n   * @return  Element vector B.\n   */\n\n    virtual const std::vector&lt;Element&gt;&amp; GetBVector() const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;GetBVector operation not supported&quot;);\n    }\n\n    /**\n   * Setter function to store key switch Element.\n   * Throws exception, to be overridden by derived class.\n   *\n   * @param &amp;a is the Element to be copied.\n   */\n\n    virtual void SetA(const Element&amp; a) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;SetA copy operation not supported&quot;);\n    }\n\n    /**\n   * Setter function to store key switch Element.\n   * Throws exception, to be overridden by derived class.\n   *\n   * @param &amp;&amp;a is the Element to be moved.\n   */\n    virtual void SetA(Element&amp;&amp; a) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;SetA move operation not supported&quot;);\n    }\n\n    /**\n   * Getter function to access key switch Element.\n   * Throws exception, to be overridden by derived class.\n   *\n   * @return  Element.\n   */\n\n    virtual const Element&amp; GetA() const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;GetA operation not supported&quot;);\n    }\n\n    /**\n   * Setter function to store key switch Element.\n   * Throws exception, to be overridden by derived class.\n   *\n   * @param &amp;a is the Element to be copied.\n   */\n\n    virtual void SetAinDCRT(const DCRTPoly&amp; a) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;SetAinDCRT copy operation not supported&quot;);\n    }\n\n    /**\n   * Setter function to store key switch Element.\n   * Throws exception, to be overridden by derived class.\n   *\n   * @param &amp;&amp;a is the Element to be moved.\n   */\n    virtual void SetAinDCRT(DCRTPoly&amp;&amp; a) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;SetAinDCRT move operation not supported&quot;);\n    }\n\n    /**\n   * Getter function to access key switch Element.\n   * Throws exception, to be overridden by derived class.\n   *\n   * @return  Element.\n   */\n\n    virtual const DCRTPoly&amp; GetAinDCRT() const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;GetAinDCRT operation not supported&quot;);\n    }\n\n    /**\n   * Setter function to store key switch Element.\n   * Throws exception, to be overridden by derived class.\n   *\n   * @param &amp;b is the Element to be copied.\n   */\n\n    virtual void SetBinDCRT(const DCRTPoly&amp; b) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;SetAinDCRT copy operation not supported&quot;);\n    }\n\n    /**\n   * Setter function to store key switch Element.\n   * Throws exception, to be overridden by derived class.\n   *\n   * @param &amp;&amp;b is the Element to be moved.\n   */\n    virtual void SetBinDCRT(DCRTPoly&amp;&amp; b) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;SetAinDCRT move operation not supported&quot;);\n    }\n\n    /**\n   * Getter function to access key switch Element.\n   * Throws exception, to be overridden by derived class.\n   *\n   * @return  Element.\n   */\n\n    virtual const DCRTPoly&amp; GetBinDCRT() const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;GetAinDCRT operation not supported&quot;);\n    }\n\n    virtual void ClearKeys() {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;ClearKeys operation is not supported&quot;);\n    }\n\n    friend bool operator==(const EvalKeyImpl&amp; a, const EvalKeyImpl&amp; b) {\n        return a.key_compare(b);\n    }\n\n    friend bool operator!=(const EvalKeyImpl&amp; a, EvalKeyImpl&amp; b) {\n        return !(a == b);\n    }\n\n    virtual bool key_compare(const EvalKeyImpl&amp; other) const {\n        return false;\n    }\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::base_class&lt;Key&lt;Element&gt;&gt;(this));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        ar(::cereal::base_class&lt;Key&lt;Element&gt;&gt;(this));\n    }\n    std::string SerializedObjectName() const {\n        return &quot;EvalKey&quot;;\n    }\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_RNS_CRYPTOPARAMETERS_H\n#define LBCRYPTO_CRYPTO_RNS_CRYPTOPARAMETERS_H\n\n#include &quot;lattice/lat-hal.h&quot;\n\n#include &quot;schemebase/rlwe-cryptoparameters.h&quot;\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\n\n/**\n * @brief main implementation class to capture essential cryptoparameters of\n * any LBC system.\n * As CryptoParametersRNS is not an abstract class and we don&#x27;t want to\n * instantiate, then we make all its constructors and the destructor protected\n * @tparam Element a ring element.\n */\nclass CryptoParametersRNS : public CryptoParametersRLWE&lt;DCRTPoly&gt; {\n    using ParmType = typename DCRTPoly::Params;\n\nprotected:\n    CryptoParametersRNS()\n        : CryptoParametersRLWE&lt;DCRTPoly&gt;(),\n          m_ksTechnique(BV),\n          m_scalTechnique(FIXEDMANUAL),\n          m_encTechnique(STANDARD),\n          m_multTechnique(HPS),\n          m_MPIntBootCiphertextCompressionLevel(SLACK) {}\n\n    CryptoParametersRNS(const CryptoParametersRNS&amp; rhs)\n        : CryptoParametersRLWE&lt;DCRTPoly&gt;(rhs),\n          m_ksTechnique(rhs.m_ksTechnique),\n          m_scalTechnique(rhs.m_scalTechnique),\n          m_encTechnique(rhs.m_encTechnique),\n          m_multTechnique(rhs.m_multTechnique),\n          m_MPIntBootCiphertextCompressionLevel(rhs.m_MPIntBootCiphertextCompressionLevel) {}\n\n    /**\n   * Constructor that initializes values.  Note that it is possible to set\n   * parameters in a way that is overall infeasible for actual use. There are\n   * fewer degrees of freedom than parameters provided.  Typically one chooses\n   * the basic noise, assurance and security parameters as the typical\n   * community-accepted values, then chooses the plaintext modulus and depth\n   * as needed.  The element parameters should then be choosen to provide\n   * correctness and security.  In some cases we would need to operate over\n   * already encrypted/provided ciphertext and the depth needs to be\n   * pre-computed for initial settings.\n   *\n   * @param params element parameters.\n   * @param &amp;plaintextModulus plaintext modulus.\n   * @param distributionParameter noise distribution parameter.\n   * @param assuranceMeasure assurance level.\n   * @param securityLevel security level.\n   * @param digitSize the size of the relinearization window.\n   * @param secretKeyDist sets the secretKeyDist of operation: GAUSSIAN or UNIFORM_TERNARY\n   * @param maxRelinSkDeg the maximum power of secret key for which the\n   * relinearization key is generated\n   * @param ksTech key switching method\n   * @param scalTech scaling method\n   * @param mPIntBootCiphertextCompressionLevel compression level\n   */\n    CryptoParametersRNS(std::shared_ptr&lt;ParmType&gt; params, const PlaintextModulus&amp; plaintextModulus,\n                        float distributionParameter, float assuranceMeasure, SecurityLevel securityLevel,\n                        usint digitSize, SecretKeyDist secretKeyDist, int maxRelinSkDeg = 2,\n                        KeySwitchTechnique ksTech = BV, ScalingTechnique scalTech = FIXEDMANUAL,\n                        EncryptionTechnique encTech = STANDARD, MultiplicationTechnique multTech = HPS,\n                        MultipartyMode multipartyMode                         = FIXED_NOISE_MULTIPARTY,\n                        ExecutionMode executionMode                           = EXEC_EVALUATION,\n                        DecryptionNoiseMode decryptionNoiseMode               = FIXED_NOISE_DECRYPT,\n                        COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel = COMPRESSION_LEVEL::SLACK)\n        : CryptoParametersRLWE&lt;DCRTPoly&gt;(std::move(params), EncodingParams(std::make_shared&lt;EncodingParamsImpl&gt;(plaintextModulus)),\n                                         distributionParameter, assuranceMeasure, securityLevel, digitSize,\n                                         maxRelinSkDeg, secretKeyDist, INDCPA, multipartyMode, executionMode,\n                                         decryptionNoiseMode) {\n        m_ksTechnique                         = ksTech;\n        m_scalTechnique                       = scalTech;\n        m_encTechnique                        = encTech;\n        m_multTechnique                       = multTech;\n        m_MPIntBootCiphertextCompressionLevel = mPIntBootCiphertextCompressionLevel;\n    }\n\n    CryptoParametersRNS(std::shared_ptr&lt;ParmType&gt; params, EncodingParams encodingParams, float distributionParameter,\n                        float assuranceMeasure, SecurityLevel securityLevel, usint digitSize,\n                        SecretKeyDist secretKeyDist, int maxRelinSkDeg = 2, KeySwitchTechnique ksTech = BV,\n                        ScalingTechnique scalTech = FIXEDMANUAL, EncryptionTechnique encTech = STANDARD,\n                        MultiplicationTechnique multTech = HPS, ProxyReEncryptionMode PREMode = INDCPA,\n                        MultipartyMode multipartyMode           = FIXED_NOISE_MULTIPARTY,\n                        ExecutionMode executionMode             = EXEC_EVALUATION,\n                        DecryptionNoiseMode decryptionNoiseMode = FIXED_NOISE_DECRYPT, PlaintextModulus noiseScale = 1,\n                        uint32_t statisticalSecurity = 30, uint32_t numAdversarialQueries = 1,\n                        uint32_t thresholdNumOfParties                        = 1,\n                        COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel = COMPRESSION_LEVEL::SLACK)\n        : CryptoParametersRLWE&lt;DCRTPoly&gt;(std::move(params), std::move(encodingParams), distributionParameter, assuranceMeasure, securityLevel,\n                                         digitSize, maxRelinSkDeg, secretKeyDist, PREMode, multipartyMode,\n                                         executionMode, decryptionNoiseMode, noiseScale, statisticalSecurity,\n                                         numAdversarialQueries, thresholdNumOfParties) {\n        m_ksTechnique                         = ksTech;\n        m_scalTechnique                       = scalTech;\n        m_encTechnique                        = encTech;\n        m_multTechnique                       = multTech;\n        m_MPIntBootCiphertextCompressionLevel = mPIntBootCiphertextCompressionLevel;\n    }\n\n    virtual ~CryptoParametersRNS() {}\n\npublic:\n    /**\n   * Computes all tables needed for decryption, homomorphic multiplication and key switching.\n   * Even though this is a pure virtual function and must be overriden in all derived classes,\n   * PrecomputeCRTTables() has its own implementation in the source file. It should be called from\n   * derived classes&#x27; PrecomputeCRTTables() only and must not be called from CryptoParametersRNS::load().\n   * @param ksTech the technique to use for key switching (e.g., BV or GHS).\n   * @param scalTech the technique to use for scaling (e.g., FLEXIBLEAUTO or FIXEDMANUAL).\n   */\n    virtual void PrecomputeCRTTables(KeySwitchTechnique ksTech, ScalingTechnique scalTech, EncryptionTechnique encTech,\n                                     MultiplicationTechnique multTech, uint32_t numPartQ, uint32_t auxBits,\n                                     uint32_t extraBits) = 0;\n\n    virtual uint64_t FindAuxPrimeStep() const;\n\n    /**\n   * == operator to compare to this instance of CryptoParametersBase object.\n   *\n   * @param &amp;rhs CryptoParameters to check equality against.\n   */\n    bool operator==(const CryptoParametersBase&lt;DCRTPoly&gt;&amp; rhs) const override {\n        const auto* el = dynamic_cast&lt;const CryptoParametersRNS*&gt;(&amp;rhs);\n\n        if (el == nullptr)\n            return false;\n\n        return CryptoParametersBase&lt;DCRTPoly&gt;::operator==(rhs) &amp;&amp; m_scalTechnique == el-&gt;GetScalingTechnique() &amp;&amp;\n               m_ksTechnique == el-&gt;GetKeySwitchTechnique() &amp;&amp; m_multTechnique == el-&gt;GetMultiplicationTechnique() &amp;&amp;\n               m_encTechnique == el-&gt;GetEncryptionTechnique() &amp;&amp; m_numPartQ == el-&gt;GetNumPartQ() &amp;&amp;\n               m_auxBits == el-&gt;GetAuxBits() &amp;&amp; m_extraBits == el-&gt;GetExtraBits() &amp;&amp; m_PREMode == el-&gt;GetPREMode() &amp;&amp;\n               m_multipartyMode == el-&gt;GetMultipartyMode() &amp;&amp; m_executionMode == el-&gt;GetExecutionMode();\n    }\n\n    void PrintParameters(std::ostream&amp; os) const override {\n        CryptoParametersBase&lt;DCRTPoly&gt;::PrintParameters(os);\n    }\n\n    /////////////////////////////////////\n    // PrecomputeCRTTables\n    /////////////////////////////////////\n\n    /**\n   * Method to retrieve the technique to be used for key switching.\n   *\n   * @return the key switching technique.\n   */\n    enum KeySwitchTechnique GetKeySwitchTechnique() const {\n        return m_ksTechnique;\n    }\n\n    /**\n   * Method to retrieve the technique to be used for scaling.\n   *\n   * @return the scaling technique.\n   */\n    enum ScalingTechnique GetScalingTechnique() const {\n        return m_scalTechnique;\n    }\n\n    /**\n   * Method to retrieve the technique to be used for rescaling.\n   *\n   * @return the rescaling technique.\n   */\n    enum EncryptionTechnique GetEncryptionTechnique() const {\n        return m_encTechnique;\n    }\n\n    /**\n   * Method to retrieve the technique to be used for rescaling.\n   *\n   * @return the rescaling technique.\n   */\n    enum MultiplicationTechnique GetMultiplicationTechnique() const {\n        return m_multTechnique;\n    }\n\n    uint32_t GetAuxBits() const {\n        return m_auxBits;\n    }\n\n    uint32_t GetExtraBits() const {\n        return m_extraBits;\n    }\n\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; GetParamsPK() const override {\n        if ((m_ksTechnique == HYBRID) &amp;&amp; (m_PREMode != NOT_SET))\n            return m_paramsQP;\n        if ((m_encTechnique == EXTENDED) &amp;&amp; (m_paramsQr != nullptr))\n            return m_paramsQr;\n        return m_params;\n    }\n\n    /////////////////////////////////////\n    // BGVrns : ModReduce\n    /////////////////////////////////////\n\n    /**\n   * Method that returns the NTL precomputions for [t]_{q_i}\n   *\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettModqPrecon() const {\n        return m_tModqPrecon;\n    }\n\n    /**\n   * Get the precomputed table of [-t^{-1}]_{q_i}\n   *\n   * @return the pre-computed values.\n   */\n    const NativeInteger&amp; GetNegtInvModq(usint l) const {\n        return m_negtInvModq[l];\n    }\n\n    /**\n   * Method that returns the NTL precomputions for [-t^{-1}]_{q_i}\n   *\n   * @return the pre-computed values.\n   */\n    const NativeInteger&amp; GetNegtInvModqPrecon(usint l) const {\n        return m_negtInvModqPrecon[l];\n    }\n\n    /////////////////////////////////////\n    // CKKSrns : DropLastElementAndScale\n    /////////////////////////////////////\n\n    /**\n   * Q^(l) = \\prod_{j=0}^{l-1}\n   * Gets the precomputed table of [Q^(l)*[Q^(l)^{-1}]_{q_l}/q_l]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetQlQlInvModqlDivqlModq(size_t i) const {\n        return m_QlQlInvModqlDivqlModq[i];\n    }\n\n    /**\n   * Q^(l) = \\prod_{j=0}^{l-1}\n   * Gets the NTL precomputions for [Q^(l)*[Q^(l)^{-1}]_{q_l}/q_l]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetQlQlInvModqlDivqlModqPrecon(size_t i) const {\n        return m_QlQlInvModqlDivqlModqPrecon[i];\n    }\n\n    /**\n   * Gets the precomputed table of [q_i^{-1}]_{q_j}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetqlInvModq(size_t i) const {\n        return m_qlInvModq[i];\n    }\n\n    /**\n   * Gets the NTL precomputions for [q_i^{-1}]_{q_j}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetqlInvModqPrecon(size_t i) const {\n        return m_qlInvModqPrecon[i];\n    }\n\n    /////////////////////////////////////\n    // KeySwitchHybrid : KeyGen\n    /////////////////////////////////////\n\n    /**\n   * Gets Q*P CRT basis\n   * Q*P = {q_1,...,q_l,p_1,...,p_k}\n   * Used in Hybrid key switch generation\n   *\n   * @return the precomputed CRT params\n   */\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; GetParamsQP() const {\n        return m_paramsQP;\n    }\n\n    /**\n   * Method that returns the number of digits.\n   * Used in Hybrid key switch generation\n   * @return the number of digits.\n   */\n    uint32_t GetNumPartQ() const {\n        return m_numPartQ;\n    }\n\n    /**\n   * Gets the precomputed table of [P]_{q_i}\n   * Used in Hybrid key switch generation.\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetPModq() const {\n        return m_PModq;\n    }\n\n    /////////////////////////////////////\n    // KeySwitchHybrid : KeySwitch\n    /////////////////////////////////////\n\n    /**\n   * Gets the Auxiliary CRT basis {P} = {p_1,...,p_k}\n   * Used in Hybrid key switching\n   *\n   * @return the parameters CRT params\n   */\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; GetParamsP() const {\n        return m_paramsP;\n    }\n\n    /**\n   * Method that returns the number of towers within every digit.\n   * This is the alpha parameter from the paper (see documentation\n   * for KeySwitchHHybrid).\n   * Used in Hybrid key switching\n   *\n   * @return the number of towers per digit.\n   */\n    uint32_t GetNumPerPartQ() const {\n        return m_numPerPartQ;\n    }\n\n    /*\n   * Method that returns the number of partitions.\n   * Used in Hybrid key switching\n   *\n   * @return the number of partitions.\n   */\n    uint32_t GetNumberOfQPartitions() const {\n        return m_paramsPartQ.size();\n    }\n\n    /**\n   * Method that returns the element parameters corresponding to\n   * partitions {Q_j} of Q.\n   * Used in Hybrid key switching\n   *\n   * @return the pre-computed values.\n   */\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt;&amp; GetParamsPartQ(uint32_t part) const {\n        return m_paramsPartQ[part];\n    }\n\n    /*\n   * Method that returns the element parameters corresponding to the\n   * complementary basis of a single digit j, i.e., the basis consisting of\n   * all other digits plus the special primes. Note that numTowers should be\n   * up to l (where l is the number of towers).\n   *\n   * @param numTowers is the total number of towers there are in the\n   * ciphertext.\n   * @param digit is the index of the digit we want to get the complementary\n   * partition from.\n   * @return the partitions.\n   */\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt;&amp; GetParamsComplPartQ(uint32_t numTowers, uint32_t digit) const {\n        return m_paramsComplPartQ[numTowers][digit];\n    }\n\n    /**\n   * Method that returns the precomputed values for QHat^-1 mod qj within a\n   * partition of towers, used in HYBRID.\n   *\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetPartQlHatInvModq(uint32_t part, uint32_t sublvl) const {\n        if (part &lt; m_PartQlHatInvModq.size() &amp;&amp; sublvl &lt; m_PartQlHatInvModq[part].size())\n            return m_PartQlHatInvModq[part][sublvl];\n\n        &quot;hey&quot;; OPENFHE_THROW(math_error,\n                      &quot;CryptoParametersCKKS::GetPartitionQHatInvModQTable - &quot;\n                      &quot;index out of bounds.&quot;);\n    }\n\n    /**\n   * Barrett multiplication precomputations getter.\n   *\n   * @param index The number of towers in the ciphertext.\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetPartQlHatInvModqPrecon(uint32_t part, uint32_t sublvl) const {\n        if (part &lt; m_PartQlHatInvModqPrecon.size() &amp;&amp; sublvl &lt; m_PartQlHatInvModqPrecon[part].size())\n            return m_PartQlHatInvModqPrecon[part][sublvl];\n\n        &quot;hey&quot;; OPENFHE_THROW(math_error,\n                      &quot;CryptoParametersCKKS::&quot;\n                      &quot;GetPartitionQHatInvModQPreconTable - index &quot;\n                      &quot;out of bounds.&quot;);\n    }\n\n    /**\n   * Barrett multiplication precomputations getter.\n   *\n   * @param index The table containing [PartQHat]_{p_j}\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GetPartQlHatModp(uint32_t lvl, uint32_t part) const {\n        if (lvl &lt; m_PartQlHatModp.size() &amp;&amp; part &lt; m_PartQlHatModp[lvl].size())\n            return m_PartQlHatModp[lvl][part];\n\n        &quot;hey&quot;; OPENFHE_THROW(math_error,\n                      &quot;CryptoParametersCKKS::GetPartitionQHatModPTable - &quot;\n                      &quot;index out of bounds.&quot;);\n    }\n\n    /**\n   * Barrett multiplication precomputations getter.\n   *\n   * @param index The number of towers in the ciphertext.\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;DoubleNativeInt&gt;&amp; GetmodComplPartqBarrettMu(uint32_t lvl, uint32_t part) const {\n        if (lvl &lt; m_modComplPartqBarrettMu.size() &amp;&amp; part &lt; m_modComplPartqBarrettMu[lvl].size())\n            return m_modComplPartqBarrettMu[lvl][part];\n\n        &quot;hey&quot;; OPENFHE_THROW(math_error,\n                      &quot;CryptoParametersCKKS::GetPartitionPrecon - index out &quot;\n                      &quot;of bounds.&quot;);\n    }\n\n    /**\n   * Gets the precomputed table of [P^{-1}]_{q_i}\n   * Used in GHS key switching\n   *\n   * See more in &quot;A full RNS variant of approximate homomorphic\n   * encryption&quot; by Cheon, et. al. Section 4.\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetPInvModq() const {\n        return m_PInvModq;\n    }\n\n    /**\n   * Gets the NTL precomputions for [P^{-1}]_{q_i}\n   * Used for speeding up GHS key switching.\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetPInvModqPrecon() const {\n        return m_PInvModqPrecon;\n    }\n\n    /**\n   * Get the precomputed table of [(P/p_j)^{-1}]_{p_j}\n   * Used in GHS key switching.\n   *\n   * See more in &quot;A full RNS variant of approximate homomorphic\n   * encryption&quot; by Cheon, et. al. Section 4.\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetPHatInvModp() const {\n        return m_PHatInvModp;\n    }\n\n    /**\n   * Get the NTL precomputions for [(P/p_j)^{-1}]_{p_j}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetPHatInvModpPrecon() const {\n        return m_PHatInvModpPrecon;\n    }\n\n    /**\n   * Gets the precomputed table of [P/p_j]_{q_i}\n   * Used in GHS key switching.\n   *\n   * See more in &quot;A full RNS variant of approximate homomorphic\n   * encryption&quot; by Cheon, et. al. Section 4.\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GetPHatModq() const {\n        return m_PHatModq;\n    }\n\n    /**\n   * Gets the Barrett modulo reduction precomputation for q_i\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;DoubleNativeInt&gt;&amp; GetModqBarrettMu() const {\n        return m_modqBarrettMu;\n    }\n\n    /**\n   * Method that returns the precomputed values for [t^(-1)]_{q_i}\n   * Used in ModulusSwitching.\n   *\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettInvModq() const {\n        return m_tInvModq;\n    }\n\n    /**\n   * Method that returns the NTL precomputions for [t^{-1}]_{q_i}\n   *\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettInvModqPrecon() const {\n        return m_tInvModqPrecon;\n    }\n\n    /**\n   * Method that returns the precomputed values for [t^(-1)]_{p_j}\n   * Used in KeySwitching.\n   *\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettInvModp() const {\n        return m_tInvModp;\n    }\n\n    /**\n   * Method that returns the NTL precomputions for [t^{-1}]_{p_j}\n   *\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettInvModpPrecon() const {\n        return m_tInvModpPrecon;\n    }\n\n    /////////////////////////////////////\n    // CKKSrns Scaling Factor\n    /////////////////////////////////////\n\n    /**\n   * Method to retrieve the scaling factor of level l.\n   * For FIXEDMANUAL scaling technique method always returns 2^p, where p corresponds to plaintext modulus\n   * @param l For FLEXIBLEAUTO scaling technique the level whose scaling factor we want to learn.\n   * Levels start from 0 (no scaling done - all towers) and go up to K-1, where K is the number of towers supported.\n   * @return the scaling factor.\n   */\n    double GetScalingFactorReal(uint32_t l = 0) const {\n        if (m_scalTechnique == FLEXIBLEAUTO || m_scalTechnique == FLEXIBLEAUTOEXT) {\n            if (l &gt;= m_scalingFactorsReal.size()) {\n                // TODO: Return an error here.\n                return m_approxSF;\n            }\n\n            return m_scalingFactorsReal[l];\n        }\n\n        return m_approxSF;\n    }\n\n    double GetScalingFactorRealBig(uint32_t l = 0) const {\n        if (m_scalTechnique == FLEXIBLEAUTO || m_scalTechnique == FLEXIBLEAUTOEXT) {\n            if (l &gt;= m_scalingFactorsRealBig.size()) {\n                // TODO: Return an error here.\n                return m_approxSF;\n            }\n\n            return m_scalingFactorsRealBig[l];\n        }\n\n        return m_approxSF;\n    }\n\n    /**\n   * Method to retrieve the modulus to be dropped of level l.\n   * For FIXEDMANUAL rescaling technique method always returns 2^p, where p corresponds to plaintext modulus\n   * @param l index of modulus to be dropped for FLEXIBLEAUTO scaling technique\n   * @return the precomputed table\n   */\n    double GetModReduceFactor(uint32_t l = 0) const {\n        if (m_scalTechnique == FLEXIBLEAUTO || m_scalTechnique == FLEXIBLEAUTOEXT) {\n            return m_dmoduliQ[l];\n        }\n\n        return m_approxSF;\n    }\n\n    /////////////////////////////////////\n    // BFVrns : Encrypt : POverQ\n    /////////////////////////////////////\n\n    const NativeInteger GetNegQModt() const {\n        return m_negQModt;\n    }\n\n    const NativeInteger GetNegQModtPrecon() const {\n        return m_negQModtPrecon;\n    }\n\n    const NativeInteger GetNegQrModt() const {\n        return m_negQrModt;\n    }\n\n    const NativeInteger GetNegQrModtPrecon() const {\n        return m_negQrModtPrecon;\n    }\n\n    /**\n   * Method that returns the precomputed values for [t^(-1)]_{a} where a is from {q_i} U r\n   * Used in ModulusSwitching.\n   *\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettInvModqr() const {\n        return m_tInvModqr;\n    }\n\n    /////////////////////////////////////\n    // BFVrns : Mult : ExpandCRTBasis\n    /////////////////////////////////////\n\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; GetParamsQl(usint l = 0) const {\n        return m_paramsQl[l];\n    }\n\n    const std::vector&lt;double&gt;&amp; GetQlQHatInvModqDivqFrac(usint l) const {\n        return m_QlQHatInvModqDivqFrac[l];\n    }\n\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GetQlQHatInvModqDivqModq(usint l) const {\n        return m_QlQHatInvModqDivqModq[l];\n    }\n\n    /**\n   * Gets the Auxiliary CRT basis {R} = {r_1,...,r_k}\n   * used in homomorphic multiplication\n   *\n   * @return the precomputed CRT params\n   */\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; GetParamsRl(usint l = 0) const {\n        return m_paramsRl[l];\n    }\n\n    /**\n   * Gets the Auxiliary expanded CRT basis {S} = {Q*R} =\n   * {{q_i},{r_k}} used in homomorphic multiplication\n   *\n   * @return the precomputed CRT params\n   */\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; GetParamsQlRl(usint l = 0) const {\n        return m_paramsQlRl[l];\n    }\n\n    /**\n   * Gets the precomputed table of [(Q/q_i)^{-1}]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetQlHatInvModq(usint l = 0) const {\n        return m_QlHatInvModq[l];\n    }\n\n    /**\n   * Gets the NTL precomputations for [(Q/q_i)^{-1}]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetQlHatInvModqPrecon(usint l = 0) const {\n        return m_QlHatInvModqPrecon[l];\n    }\n\n    /**\n   * Gets the precomputed table of [Q/q_i]_{r_k}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GetQlHatModr(usint l = 0) const {\n        return m_QlHatModr[l];\n    }\n\n    /**\n   * Gets the precomputed table of [\\alpha*Q]_{r_k}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GetalphaQlModr(usint l = 0) const {\n        return m_alphaQlModr[l];\n    }\n\n    const std::vector&lt;NativeInteger&gt;&amp; GetmNegRlQHatInvModq(usint l = 0) const {\n        return m_negRlQHatInvModq[l];\n    }\n\n    const std::vector&lt;NativeInteger&gt;&amp; GetmNegRlQHatInvModqPrecon(usint l = 0) const {\n        return m_negRlQHatInvModqPrecon[l];\n    }\n\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GetqInvModr() const {\n        return m_qInvModr;\n    }\n\n    /**\n   * Gets the Barrett modulo reduction precomputations for r_k\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;DoubleNativeInt&gt; const&amp; GetModrBarrettMu() const {\n        return m_modrBarrettMu;\n    }\n\n    /**\n   * Gets the precomputed table of 1./q_i\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;double&gt; const&amp; GetqInv() const {\n        return m_qInv;\n    }\n\n    /////////////////////////////////////\n    // BFVrns : Mult : ScaleAndRound\n    /////////////////////////////////////\n\n    /**\n   * For S = QR\n   * Gets the precomputed table of \\frac{[t*R*(S/s_m)^{-1}]_{s_m}/s_m}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;double&gt;&amp; GettRSHatInvModsDivsFrac() const {\n        return m_tRSHatInvModsDivsFrac;\n    }\n\n    /**\n   * For S = QR\n   * Gets the precomputed table of [\\floor{t*R*(S/s_m)^{-1}/s_m}]_{r_k}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GettRSHatInvModsDivsModr() const {\n        return m_tRSHatInvModsDivsModr;\n    }\n\n    /////////////////////////////////////\n    // BFVrns : Mult : SwitchCRTBasis\n    /////////////////////////////////////\n\n    /**\n   * Gets the precomputed table of [(R/r_k)^{-1}]_{r_k}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetRlHatInvModr(usint l = 0) const {\n        return m_RlHatInvModr[l];\n    }\n\n    /**\n   * Gets the NTL precomputation for [(R/r_k)^{-1}]_{r_k}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetRlHatInvModrPrecon(usint l = 0) const {\n        return m_RlHatInvModrPrecon[l];\n    }\n\n    /**\n   * Gets the precomputed table of [R/r_k]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GetRlHatModq(usint l = 0) const {\n        return m_RlHatModq[l];\n    }\n\n    /**\n   * Gets the precomputed table of [\\alpha*P]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GetalphaRlModq(usint l = 0) const {\n        return m_alphaRlModq[l];\n    }\n\n    const std::vector&lt;double&gt;&amp; GettQlSlHatInvModsDivsFrac(usint l) const {\n        return m_tQlSlHatInvModsDivsFrac[l];\n    }\n\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GettQlSlHatInvModsDivsModq(usint l) const {\n        return m_tQlSlHatInvModsDivsModq[l];\n    }\n\n    const std::vector&lt;NativeInteger&gt;&amp; GetQlHatModq(usint l) const {\n        return m_QlHatModq[l];\n    }\n\n    const std::vector&lt;NativeInteger&gt;&amp; GetQlHatModqPrecon(usint l) const {\n        return m_QlHatModqPrecon[l];\n    }\n\n    /**\n   * Gets the precomputed table of 1./p_j\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;double&gt; const&amp; GetrInv() const {\n        return m_rInv;\n    }\n\n    /////////////////////////////////////\n    // BFVrns : Decrypt : ScaleAndRound\n    /////////////////////////////////////\n\n    /**\n   * Gets the precomputed table of \\frac{t*{Q/q_i}^{-1}/q_i}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;double&gt;&amp; GettQHatInvModqDivqFrac() const {\n        return m_tQHatInvModqDivqFrac;\n    }\n\n    /**\n   * When log2(q_i) &gt;= 45 bits, B = \\floor[2^{\\ceil{log2(q_i)/2}}\n   * Gets the precomputed table of \\frac{t*{Q/q_i}^{-1}*B/q_i}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;double&gt;&amp; GettQHatInvModqBDivqFrac() const {\n        return m_tQHatInvModqBDivqFrac;\n    }\n\n    /**\n   * Gets the precomputed table of [\\floor{t*{Q/q_i}^{-1}/q_i}]_t\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettQHatInvModqDivqModt() const {\n        return m_tQHatInvModqDivqModt;\n    }\n\n    /**\n   * Gets the NTL precomputations for [\\floor{t*{Q/q_i}^{-1}/q_i}]_t\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettQHatInvModqDivqModtPrecon() const {\n        return m_tQHatInvModqDivqModtPrecon;\n    }\n\n    /**\n   * When log2(q_i) &gt;= 45 bits, B = \\floor[2^{\\ceil{log2(q_i)/2}}\n   * Gets the precomputed table of [\\floor{t*{Q/q_i}^{-1}*B/q_i}]_t\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettQHatInvModqBDivqModt() const {\n        return m_tQHatInvModqBDivqModt;\n    }\n\n    /**\n   * When log2(q_i) &gt;= 45 bits, B = \\floor[2^{\\ceil{log2(q_i)/2}}\n   * Gets the NTL precomputations for [\\floor{t*{Q/q_i}^{-1}*B/q_i}]_t\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettQHatInvModqBDivqModtPrecon() const {\n        return m_tQHatInvModqBDivqModtPrecon;\n    }\n\n    const NativeInteger&amp; GetScalingFactorInt(usint l) const {\n        if (m_scalTechnique == FLEXIBLEAUTO || m_scalTechnique == FLEXIBLEAUTOEXT) {\n            if (l &gt;= m_scalingFactorsInt.size()) {\n                // TODO: Return an error here.\n                return m_fixedSF;\n            }\n            return m_scalingFactorsInt[l];\n        }\n        return m_fixedSF;\n    }\n\n    const NativeInteger&amp; GetScalingFactorIntBig(usint l) const {\n        if (m_scalTechnique == FLEXIBLEAUTO || m_scalTechnique == FLEXIBLEAUTOEXT) {\n            if (l &gt;= m_scalingFactorsIntBig.size()) {\n                // TODO: Return an error here.\n                return m_fixedSF;\n            }\n            return m_scalingFactorsIntBig[l];\n        }\n        return m_fixedSF;\n    }\n\n    const NativeInteger&amp; GetModReduceFactorInt(uint32_t l = 0) const {\n        if (m_scalTechnique == FLEXIBLEAUTO || m_scalTechnique == FLEXIBLEAUTOEXT) {\n            return m_qModt[l];\n        }\n        return m_fixedSF;\n    }\n\n    /////////////////////////////////////\n    // BFVrns : Encrypt\n    /////////////////////////////////////\n\n    /**\n   * Gets the precomputed table of 1./p_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetrInvModq() const {\n        return m_rInvModq;\n    }\n\n    /**\n   * Gets the Auxiliary CRT basis {Qr} = {Q U r}\n   * used in BFV encryption in mode EXTENDED\n   *\n   * @return the precomputed CRT params\n   */\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; GetParamsQr() const {\n        return m_paramsQr;\n    }\n\n    /////////////////////////////////////\n    // BFVrnsB\n    /////////////////////////////////////\n\n    /**\n   * Gets the Auxiliary CRT basis {Bsk} = {B U msk}\n   * used in homomorphic multiplication\n   *\n   * @return the precomputed CRT params\n   */\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; GetParamsQBsk() const {\n        return m_paramsQBsk;\n    }\n\n    /**\n   * Gets the precomputed table of q_i\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetModuliQ() const {\n        return m_moduliQ;\n    }\n\n    /**\n   * Gets the precomputed table of bsk_j\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetModuliBsk() const {\n        return m_moduliBsk;\n    }\n\n    /**\n   * Gets the Barrett modulo reduction precomputation for bsk_j\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;DoubleNativeInt&gt; const&amp; GetModbskBarrettMu() const {\n        return m_modbskBarrettMu;\n    }\n\n    /**\n   * Gets the precomputed table of [mtilde*(Q/q_i)^{-1}]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetmtildeQHatInvModq() const {\n        return m_mtildeQHatInvModq;\n    }\n\n    /**\n   * Gets the NTL precomputations for [mtilde*(Q/q_i)^{-1}]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetmtildeQHatInvModqPrecon() const {\n        return m_mtildeQHatInvModqPrecon;\n    }\n\n    /**\n   * Gets the precomputed table of [Q/q_i]_{bsk_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; const&amp; GetQHatModbsk() const {\n        return m_QHatModbsk;\n    }\n\n    /**\n   * Gets the precomputed table of [(q_i)^{-1}]_{bsk_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; const&amp; GetqInvModbsk() const {\n        return m_qInvModbsk;\n    }\n\n    /**\n   * Gets the precomputed table of [Q/q_i]_{mtilde}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;uint64_t&gt; const&amp; GetQHatModmtilde() const {\n        return m_QHatModmtilde;\n    }\n\n    /**\n   * Gets the precomputed table of [Q]_{bsk_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetQModbsk() const {\n        return m_QModbsk;\n    }\n\n    /**\n   * Gets the NTL precomputations for [Q]_{bsk_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetQModbskPrecon() const {\n        return m_QModbskPrecon;\n    }\n\n    /**\n   * Gets the precomputed [-Q^{-1}]_{mtilde}\n   *\n   * @return the precomputed value\n   */\n    uint64_t const&amp; GetNegQInvModmtilde() const {\n        return m_negQInvModmtilde;\n    }\n\n    /**\n   * Gets the precomputed table of [mtilde^{-1}]_{bsk_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetmtildeInvModbsk() const {\n        return m_mtildeInvModbsk;\n    }\n\n    /**\n   * Gets the NTL precomputations for [mtilde^{-1}]_{bsk_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetmtildeInvModbskPrecon() const {\n        return m_mtildeInvModbskPrecon;\n    }\n\n    /**\n   * Gets the precomputed table of [t*(Q/q_i)^{-1}]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GettQHatInvModq() const {\n        return m_tQHatInvModq;\n    }\n\n    /**\n   * Gets the NTL precomputations for [t*(Q/q_i)^{-1}]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GettQHatInvModqPrecon() const {\n        return m_tQHatInvModqPrecon;\n    }\n\n    /**\n   * Gets the precomputed table of [t*gamma*(Q/q_i)^(-1)]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GettgammaQHatInvModq() const {\n        return m_tgammaQHatInvModq;\n    }\n\n    /**\n   * Gets the NTL precomputations for [t*gamma*(Q/q_i)^(-1)]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GettgammaQHatInvModqPrecon() const {\n        return m_tgammaQHatInvModqPrecon;\n    }\n\n    /**\n   * Gets the precomputed table of [t/Q]_{bsk_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GettQInvModbsk() const {\n        return m_tQInvModbsk;\n    }\n\n    /**\n   * Gets the NTL precomputations for [t/Q]_{bsk_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GettQInvModbskPrecon() const {\n        return m_tQInvModbskPrecon;\n    }\n\n    /**\n   * Gets the precomputed table of [(B/b_j)^{-1}]_{b_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetBHatInvModb() const {\n        return m_BHatInvModb;\n    }\n\n    /**\n   * Gets the NTL precomputations for [(B/b_j)^{-1}]_{b_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetBHatInvModbPrecon() const {\n        return m_BHatInvModbPrecon;\n    }\n\n    /**\n   * Gets the precomputed table of [B/b_j]_{msk}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetBHatModmsk() const {\n        return m_BHatModmsk;\n    }\n\n    /**\n   * Gets the precomputed [B^{-1}]_msk\n   *\n   * @return the precomputed value\n   */\n    NativeInteger const&amp; GetBInvModmsk() const {\n        return m_BInvModmsk;\n    }\n\n    /**\n   * Gets the NTL precomputions for [B^{-1}]_msk\n   *\n   * @return the precomputed value\n   */\n    NativeInteger const&amp; GetBInvModmskPrecon() const {\n        return m_BInvModmskPrecon;\n    }\n\n    /**\n   * Gets the precomputed table of [B/b_j]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; const&amp; GetBHatModq() const {\n        return m_BHatModq;\n    }\n\n    /**\n   * Gets the precomputed table of [B]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetBModq() const {\n        return m_BModq;\n    }\n\n    /**\n   * Gets the NTL precomputions for [B]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetBModqPrecon() const {\n        return m_BModqPrecon;\n    }\n\n    /**\n   * Gets auxiliary modulus gamma\n   *\n   * @return gamma\n   */\n    uint32_t const&amp; Getgamma() const {\n        return m_gamma;\n    }\n\n    // TODO: use 64 bit words in case NativeInteger uses smaller word size\n    /**\n   * Gets t*gamma where t - plaintext modulus, gamma - auxiliary modulus\n   *\n   * @return t*gamma\n   */\n    NativeInteger const&amp; Gettgamma() const {\n        return m_tgamma;\n    }\n\n    /**\n   * Gets the precomputed table of [-(q_i)^{-1}]_{t*gamma}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetNegInvqModtgamma() const {\n        return m_negInvqModtgamma;\n    }\n\n    /**\n   * Gets the NTL precomputations for [-(q_i)^{-1}]_{t*gamma}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetNegInvqModtgammaPrecon() const {\n        return m_negInvqModtgammaPrecon;\n    }\n\n    /**\n   * Gets the precomputed table of [*(Q/q_i/q_0)^{-1}]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetMultipartyQHatInvModqAtIndex(usint l) const {\n        return m_multipartyQHatInvModq[l];\n    }\n\n    /**\n   * Gets the NTL precomputations for [*(Q/q_i/q_0)^{-1}]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetMultipartyQHatInvModqPreconAtIndex(usint l) const {\n        return m_multipartyQHatInvModqPrecon[l];\n    }\n\n    /**\n   * Gets the precomputed table of [Q/q_i/q_0]_{q_0}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; const&amp; GetMultipartyQHatModq0AtIndex(usint l) const {\n        return m_multipartyQHatModq0[l];\n    }\n\n    /**\n   * Gets the precomputed table of [\\alpha*Q/q_0]_{q_0} for 0 &lt;= alpha &lt;= 1\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; const&amp; GetMultipartyAlphaQModq0AtIndex(usint l) const {\n        return m_multipartyAlphaQModq0[l];\n    }\n\n    /**\n   * Gets the Barrett modulo reduction precomputation for q_0\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;DoubleNativeInt&gt; const&amp; GetMultipartyModq0BarrettMu() const {\n        return m_multipartyModq0BarrettMu;\n    }\n\n    /**\n   * Gets the precomputed table of \\frac{1/q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;double&gt; const&amp; GetMultipartyQInv() const {\n        return m_multipartyQInv;\n    }\n\n    /////////////////////////////////////\n    // CKKS RNS MultiParty Bootstrapping Parameter\n    /////////////////////////////////////\n    /**\n   * Gets the Multi-Party Interactive Bootstrapping Ciphertext Compression Level\n   * @return m_MPIntBootCiphertextCompressionLevel\n   */\n    COMPRESSION_LEVEL GetMPIntBootCiphertextCompressionLevel() const {\n        return m_MPIntBootCiphertextCompressionLevel;\n    }\n\nprotected:\n    /////////////////////////////////////\n    // PrecomputeCRTTables\n    /////////////////////////////////////\n\n    // Stores the technique to use for key switching\n    enum KeySwitchTechnique m_ksTechnique;\n\n    enum ScalingTechnique m_scalTechnique;\n\n    enum EncryptionTechnique m_encTechnique;\n\n    enum MultiplicationTechnique m_multTechnique;\n\n    uint32_t m_auxBits = 0;\n\n    uint32_t m_extraBits = 0;\n\n    /////////////////////////////////////\n    // BGVrns ModReduce\n    /////////////////////////////////////\n\n    // Stores NTL precomputations for [t]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_tModqPrecon;\n\n    // Stores [-t^{-1}]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_negtInvModq;\n\n    // Stores NTL precomputations for [-t^{-1}]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_negtInvModqPrecon;\n\n    /////////////////////////////////////\n    // CKKSrns/BFVrns DropLastElementAndScale\n    /////////////////////////////////////\n\n    // Q^(l) = \\prod_{j=0}^{l-1}\n    // Stores [Q^(l)*[Q^(l)^{-1}]_{q_l}/q_l]_{q_i}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_QlQlInvModqlDivqlModq;\n\n    // Q^(l) = \\prod_{j=0}^{l-1}\n    // Stores NTL precomputations for [Q^(l)*[Q^(l)^{-1}]_{q_l}/q_l]_{q_i}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_QlQlInvModqlDivqlModqPrecon;\n\n    // Stores [q_l^{-1}]_{q_i}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_qlInvModq;\n\n    // Stores NTL precomputations for [q_l^{-1}]_{q_i}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_qlInvModqPrecon;\n\n    /////////////////////////////////////\n    // KeySwitchHybrid KeyGen\n    /////////////////////////////////////\n\n    // Params for Extended CRT basis {QP} = {q_1...q_l,p_1,...,p_k}\n    // used in GHS key switching\n    std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; m_paramsQP;\n\n    // Stores the partition size {PartQ} = {Q_1,...,Q_l}\n    // where each Q_i is the product of q_j\n    uint32_t m_numPartQ = 0;\n\n    // Stores [P]_{q_i}, used in GHS key switching\n    std::vector&lt;NativeInteger&gt; m_PModq;\n\n    /////////////////////////////////////\n    // KeySwitchHybrid KeySwitch\n    /////////////////////////////////////\n\n    // Params for Auxiliary CRT basis {P} = {p_1,...,p_k}\n    // used in GHS key switching\n    std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; m_paramsP;\n\n    // Stores the number of towers per Q_i\n    uint32_t m_numPerPartQ = 0;\n\n    // Stores the parameters for moduli Q_i\n    std::vector&lt;std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt;&gt; m_paramsPartQ;\n\n    // Stores the parameters for complementary {\\bar{Q_i},P}\n    std::vector&lt;std::vector&lt;std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt;&gt;&gt; m_paramsComplPartQ;\n\n    // Stores [{(Q_k)^(l)/q_i}^{-1}]_{q_i} for HYBRID\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_PartQlHatInvModq;\n\n    // Stores NTL precomputations for\n    // [{(Q_k)^(l)/q_i}^{-1}]_{q_i} for HYBRID\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_PartQlHatInvModqPrecon;\n\n    // Stores [QHat_i]_{p_j}\n    std::vector&lt;std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt;&gt; m_PartQlHatModp;\n\n    // Stores the Barrett mu for CompQBar_i\n    std::vector&lt;std::vector&lt;std::vector&lt;DoubleNativeInt&gt;&gt;&gt; m_modComplPartqBarrettMu;\n\n    // Stores [P^{-1}]_{q_i}, required for GHS key switching\n    std::vector&lt;NativeInteger&gt; m_PInvModq;\n\n    // Stores NTL precomputations for [P^{-1}]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_PInvModqPrecon;\n\n    // Stores [(P/p_j)^{-1}]_{p_j}, required for GHS key switching\n    std::vector&lt;NativeInteger&gt; m_PHatInvModp;\n\n    // Stores NTL precomputations for [(P/p_j)^{-1}]_{p_j}\n    std::vector&lt;NativeInteger&gt; m_PHatInvModpPrecon;\n\n    // Stores [P/p_j]_{q_i}, required for GHS key switching\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_PHatModq;\n\n    // Stores the BarrettUint128ModUint64 precomputations for q_j\n    std::vector&lt;DoubleNativeInt&gt; m_modqBarrettMu;\n\n    // Stores [t^{-1}]_{p_j}\n    std::vector&lt;NativeInteger&gt; m_tInvModp;\n\n    // Stores NTL precomputations for [t^{-1}]_{p_j}\n    std::vector&lt;NativeInteger&gt; m_tInvModpPrecon;\n\n    /////////////////////////////////////\n    // CKKS Scaling Factor\n    /////////////////////////////////////\n\n    // A vector holding the doubles that correspond to the exact\n    // scaling factor of each level, when FLEXIBLEAUTO is used.\n    std::vector&lt;double&gt; m_scalingFactorsReal;\n\n    std::vector&lt;double&gt; m_scalingFactorsRealBig;\n\n    // Stores q_i as doubles\n    std::vector&lt;double&gt; m_dmoduliQ;\n\n    // Stores 2^ptm where ptm - plaintext modulus\n    double m_approxSF = 0;\n\n    /////////////////////////////////////\n    // BFVrns : Encrypt\n    /////////////////////////////////////\n\n    std::vector&lt;NativeInteger&gt; m_scalingFactorsInt;\n\n    std::vector&lt;NativeInteger&gt; m_scalingFactorsIntBig;\n\n    std::vector&lt;NativeInteger&gt; m_qModt;\n\n    NativeInteger m_fixedSF = NativeInteger(1);\n\n    /////////////////////////////////////\n    // BFVrns : Encrypt\n    /////////////////////////////////////\n\n    NativeInteger m_negQModt;\n    NativeInteger m_negQModtPrecon;\n    std::vector&lt;NativeInteger&gt; m_tInvModq;\n    std::vector&lt;NativeInteger&gt; m_tInvModqPrecon;\n    std::vector&lt;NativeInteger&gt; m_tInvModqr;\n\n    /////////////////////////////////////\n    // BFVrns : Encrypt\n    /////////////////////////////////////\n\n    std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; m_paramsQr;\n    NativeInteger m_negQrModt;\n    NativeInteger m_negQrModtPrecon;\n    std::vector&lt;NativeInteger&gt; m_rInvModq;\n\n    /////////////////////////////////////\n    // BFVrns : Decrypt : ScaleAndRound\n    /////////////////////////////////////\n\n    // Stores \\frac{t*{Q/q_i}^{-1}/q_i}\n    std::vector&lt;double&gt; m_tQHatInvModqDivqFrac;\n\n    // when log2(q_i) &gt;= 45 bits, B = \\floor[2^{\\ceil{log2(q_i)/2}}\n    // Stores \\frac{t*{Q/q_i}^{-1}*B/q_i}\n    std::vector&lt;double&gt; m_tQHatInvModqBDivqFrac;\n\n    // Stores [\\floor{t*{Q/q_i}^{-1}/q_i}]_t\n    std::vector&lt;NativeInteger&gt; m_tQHatInvModqDivqModt;\n\n    // Stores NTL precomputations for [\\floor{t*{Q/q_i}^{-1}/q_i}]_t\n    std::vector&lt;NativeInteger&gt; m_tQHatInvModqDivqModtPrecon;\n\n    // when log2(q_i) &gt;= 45 bits, B = \\floor[2^{\\ceil{log2(q_i)/2}}\n    // Stores [\\floor{t*{Q/q_i}^{-1}*B/q_i}]_t\n    std::vector&lt;NativeInteger&gt; m_tQHatInvModqBDivqModt;\n\n    // when log2 q_i &gt;= 45 bits, B = \\floor[2^{\\ceil{log2(q_i)/2}}\n    // Stores NTL precomputations for [\\floor{t*{Q/q_i}^{-1}*B/q_i}]_t\n    std::vector&lt;NativeInteger&gt; m_tQHatInvModqBDivqModtPrecon;\n\n    /////////////////////////////////////\n    // BFVrns : Mult : ExpandCRTBasis\n    /////////////////////////////////////\n\n    // Auxiliary CRT basis {Ql} = {q_i}\n    // used in homomorphic multiplication\n    std::vector&lt;std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt;&gt; m_paramsQl;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; m_QlQHatInvModqDivqFrac;\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_QlQHatInvModqDivqModq;\n\n    // Auxiliary CRT basis {Rl} = {r_k}\n    // used in homomorphic multiplication\n    std::vector&lt;std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt;&gt; m_paramsRl;\n\n    // Auxiliary expanded CRT basis Ql*Rl = {s_m}\n    // used in homomorphic multiplication\n    std::vector&lt;std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt;&gt; m_paramsQlRl;\n\n    // Stores [(Ql/q_i)^{-1}]_{q_i}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_QlHatInvModq;\n\n    // Stores NTL precomputations for [(Ql/q_i)^{-1}]_{q_i}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_QlHatInvModqPrecon;\n\n    // Stores [Q/q_i]_{r_k}\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_QlHatModr;\n\n    // Stores [\\alpha*Ql]_{r_k} for 0 &lt;= alpha &lt;= sizeQl\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_alphaQlModr;\n\n    // Barrett modulo reduction precomputation for r_k\n    std::vector&lt;DoubleNativeInt&gt; m_modrBarrettMu;\n\n    // Stores \\frac{1/q_i}\n    std::vector&lt;double&gt; m_qInv;\n\n    /////////////////////////////////////\n    // BFVrns : Mult : ScaleAndRound\n    /////////////////////////////////////\n\n    // S = QR\n    // Stores \\frac{[t*R*(S/s_m)^{-1}]_{s_m}/s_m}\n    std::vector&lt;double&gt; m_tRSHatInvModsDivsFrac;\n\n    // S = QR\n    // Stores [\\floor{t*R*(S/s_m)^{-1}/s_m}]_{r_k}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_tRSHatInvModsDivsModr;\n\n    /////////////////////////////////////\n    // BFVrns : Mult : SwitchCRTBasis\n    /////////////////////////////////////\n\n    // Stores [(Rl/r_k)^{-1}]_{r_k}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_RlHatInvModr;\n\n    // Stores NTL precomputations for [(Rl/r_k)^{-1}]_{r_k}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_RlHatInvModrPrecon;\n\n    // Stores [Rl/r_k]_{q_i}\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_RlHatModq;\n\n    // Stores [\\alpha*Rl]_{q_i} for 0 &lt;= alpha &lt;= sizeR\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_alphaRlModq;\n\n    // Stores \\frac{1/r_k}\n    std::vector&lt;double&gt; m_rInv;\n\n    /////////////////////////////////////\n    // BFVrns : Mult : FastExpandCRTBasisPloverQ\n    /////////////////////////////////////\n\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_negRlQHatInvModq;\n\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_negRlQHatInvModqPrecon;\n\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_qInvModr;\n\n    /////////////////////////////////////\n    // BFVrns : Mult : ExpandCRTBasisQlHat\n    /////////////////////////////////////\n\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_QlHatModq;\n\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_QlHatModqPrecon;\n\n    /////////////////////////////////////\n    // BFVrns : Mult : ScaleAndRoundP\n    /////////////////////////////////////\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; m_tQlSlHatInvModsDivsFrac;\n\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_tQlSlHatInvModsDivsModq;\n\n    /////////////////////////////////////\n    // BFVrnsB\n    /////////////////////////////////////\n\n    // Auxiliary CRT basis {Bsk} = {B U msk} = {{b_j} U msk}\n    std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; m_paramsQBsk;\n\n    // number of moduli in the base {Q}\n    uint32_t m_numq = 0;\n\n    // number of moduli in the auxilliary base {B}\n    uint32_t m_numb = 0;\n\n    // mtilde = 2^16\n    NativeInteger m_mtilde = NativeInteger(BasicInteger(1) &lt;&lt; 16);\n\n    // Auxiliary modulus msk\n    NativeInteger m_msk;\n\n    // Stores q_i\n    std::vector&lt;NativeInteger&gt; m_moduliQ;\n\n    // Stores auxilliary base moduli b_j\n    std::vector&lt;NativeInteger&gt; m_moduliB;\n\n    // Stores the roots of unity modulo bsk_j\n    std::vector&lt;NativeInteger&gt; m_rootsBsk;\n\n    // Stores moduli {bsk_i} = {{b_j} U msk}\n    std::vector&lt;NativeInteger&gt; m_moduliBsk;\n\n    // Barrett modulo reduction precomputation for bsk_j\n    std::vector&lt;DoubleNativeInt&gt; m_modbskBarrettMu;\n\n    // Stores [mtilde*(Q/q_i)^{-1}]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_mtildeQHatInvModq;\n\n    // Stores NTL precomputations for [mtilde*(Q/q_i)^{-1}]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_mtildeQHatInvModqPrecon;\n\n    // Stores [Q/q_i]_{bsk_j}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_QHatModbsk;\n\n    // Stores [(q_i)^{-1}]_{bsk_j}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_qInvModbsk;\n\n    // Stores [Q/q_i]_{mtilde}\n    std::vector&lt;uint64_t&gt; m_QHatModmtilde;\n\n    // Stores [Q]_{bsk_j}\n    std::vector&lt;NativeInteger&gt; m_QModbsk;\n    // Stores NTL precomputations for [Q]_{bsk_j}\n    std::vector&lt;NativeInteger&gt; m_QModbskPrecon;\n\n    // Stores [-Q^{-1}]_{mtilde}\n    uint64_t m_negQInvModmtilde = 0;\n\n    // Stores [mtilde^{-1}]_{bsk_j}\n    std::vector&lt;NativeInteger&gt; m_mtildeInvModbsk;\n    // Stores NTL precomputations for [mtilde^{-1}]_{bsk_j}\n    std::vector&lt;NativeInteger&gt; m_mtildeInvModbskPrecon;\n\n    // Stores [t*(Q/q_i)^{-1}]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_tQHatInvModq;\n\n    // Stores NTL precomputations for [t*(Q/q_i)^{-1}]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_tQHatInvModqPrecon;\n\n    // Stores [t*gamma*(Q/q_i)^(-1)]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_tgammaQHatInvModq;\n    // Stores NTL precomputations for [t*gamma*(Q/q_i)^(-1)]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_tgammaQHatInvModqPrecon;\n\n    // Stores [t/Q]_{bsk_j}\n    std::vector&lt;NativeInteger&gt; m_tQInvModbsk;\n    // Stores NTL precomputations for [t/Q]_{bsk_j}\n    std::vector&lt;NativeInteger&gt; m_tQInvModbskPrecon;\n\n    // Stores [(B/b_j)^{-1}]_{b_j}\n    std::vector&lt;NativeInteger&gt; m_BHatInvModb;\n\n    // Stores NTL precomputations for [(B/b_j)^{-1}]_{b_j}\n    std::vector&lt;NativeInteger&gt; m_BHatInvModbPrecon;\n\n    // stores [B/b_j]_{msk}\n    std::vector&lt;NativeInteger&gt; m_BHatModmsk;\n\n    // Stores [B^{-1}]_msk\n    NativeInteger m_BInvModmsk;\n    // Stores NTL precomputations for [B^{-1}]_msk\n    NativeInteger m_BInvModmskPrecon;\n\n    // Stores [B/b_j]_{q_i}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_BHatModq;\n\n    // Stores [B]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_BModq;\n    // Stores NTL precomputations for [B]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_BModqPrecon;\n\n    // Stores gamma = 2^26;\n    uint32_t m_gamma = 1 &lt;&lt; 26;\n\n    // TODO: use 64 bit words in case NativeInteger uses smaller word size\n    // Stores t*gamma on a uint64_t word\n    NativeInteger m_tgamma;\n\n    // Stores [-(q_i)^{-1}]_{t*gamma}\n    std::vector&lt;NativeInteger&gt; m_negInvqModtgamma;\n    // Stores NTL precomputations for [-(q_i)^{-1}]_{t*gamma}\n    std::vector&lt;NativeInteger&gt; m_negInvqModtgammaPrecon;\n\n    /////////////////////////////////////\n    // BFVrns and BGVrns : Multiparty Decryption : ExpandCRTBasis\n    /////////////////////////////////////\n\n    // Stores [*(Q/q_i/q_0)^{-1}]_{q_i}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_multipartyQHatInvModq;\n\n    // Stores NTL precomputations for [*(Q/q_i/q_0)^{-1}]_{q_i}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_multipartyQHatInvModqPrecon;\n\n    // Stores [Q/q_i/q_0]_{q_0}\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_multipartyQHatModq0;\n\n    // Stores [\\alpha*Q/q_0]_{q_0} for 0 &lt;= alpha &lt;= 1\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_multipartyAlphaQModq0;\n\n    // Barrett modulo reduction precomputation for q_0\n    std::vector&lt;DoubleNativeInt&gt; m_multipartyModq0BarrettMu;\n\n    // Stores \\frac{1/q_i}\n    std::vector&lt;double&gt; m_multipartyQInv;\n\n    /////////////////////////////////////\n    // CKKS RNS MultiParty Bootstrapping Parameter\n    /////////////////////////////////////\n    COMPRESSION_LEVEL m_MPIntBootCiphertextCompressionLevel;\n\npublic:\n    /////////////////////////////////////\n    // SERIALIZATION\n    /////////////////////////////////////\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(cereal::base_class&lt;CryptoParametersRLWE&lt;DCRTPoly&gt;&gt;(this));\n        ar(cereal::make_nvp(&quot;ks&quot;, m_ksTechnique));\n        ar(cereal::make_nvp(&quot;rs&quot;, m_scalTechnique));\n        ar(cereal::make_nvp(&quot;encs&quot;, m_encTechnique));\n        ar(cereal::make_nvp(&quot;muls&quot;, m_multTechnique));\n        ar(cereal::make_nvp(&quot;dnum&quot;, m_numPartQ));\n        ar(cereal::make_nvp(&quot;ab&quot;, m_auxBits));\n        ar(cereal::make_nvp(&quot;eb&quot;, m_extraBits));\n        ar(cereal::make_nvp(&quot;ccl&quot;, m_MPIntBootCiphertextCompressionLevel));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            std::string errMsg(&quot;serialized object version &quot; + std::to_string(version) +\n                               &quot; is from a later version of the library&quot;);\n            &quot;hey&quot;; OPENFHE_THROW(deserialize_error, errMsg);\n        }\n        ar(cereal::base_class&lt;CryptoParametersRLWE&lt;DCRTPoly&gt;&gt;(this));\n        ar(cereal::make_nvp(&quot;ks&quot;, m_ksTechnique));\n        ar(cereal::make_nvp(&quot;rs&quot;, m_scalTechnique));\n        ar(cereal::make_nvp(&quot;encs&quot;, m_encTechnique));\n        ar(cereal::make_nvp(&quot;muls&quot;, m_multTechnique));\n        ar(cereal::make_nvp(&quot;dnum&quot;, m_numPartQ));\n        ar(cereal::make_nvp(&quot;ab&quot;, m_auxBits));\n        ar(cereal::make_nvp(&quot;eb&quot;, m_extraBits));\n        ar(cereal::make_nvp(&quot;ccl&quot;, m_MPIntBootCiphertextCompressionLevel));\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;SchemeParametersRNS&quot;;\n    }\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}}, "reports": [{"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "reportHash": "82b3965f46ac79ebebbac952a3eee5e1", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 148, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'i' is >= 'sizeQl'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 307, "column": 24}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 307, "column": 24}, {"message": "Calling 'make_shared<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, unsigned int, std::vector<intnat::NativeIntegerT<unsigned long>> &, std::vector<intnat::NativeIntegerT<unsigned long>> &>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 311, "column": 21}, {"message": "Entered call from 'KeySwitchHYBRID::KeySwitchDownFirstElement'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 874, "column": 5}, {"message": "Calling 'allocate_shared<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, std::allocator<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>>, unsigned int, std::vector<intnat::NativeIntegerT<unsigned long>> &, std::vector<intnat::NativeIntegerT<unsigned long>> &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 878, "column": 14}, {"message": "Entered call from 'make_shared<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, unsigned int, std::vector<intnat::NativeIntegerT<unsigned long>> &, std::vector<intnat::NativeIntegerT<unsigned long>> &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 857, "column": 5}, {"message": "Calling constructor for 'shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 862, "column": 14}, {"message": "Entered call from 'allocate_shared<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, std::allocator<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>>, unsigned int, std::vector<intnat::NativeIntegerT<unsigned long>> &, std::vector<intnat::NativeIntegerT<unsigned long>> &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 408, "column": 2}, {"message": "Calling constructor for '__shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 409, "column": 4}, {"message": "Entered call from constructor for 'shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1341, "column": 2}, {"message": "Calling constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1342, "column": 14}, {"message": "Entered call from constructor for '__shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 643, "column": 2}, {"message": "Calling constructor for '_Sp_counted_ptr_inplace<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, std::allocator<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 651, "column": 6}, {"message": "Entered call from constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 514, "column": 2}, {"message": "Calling 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 519, "column": 4}, {"message": "Entered call from constructor for '_Sp_counted_ptr_inplace<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, std::allocator<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 510, "column": 2}, {"message": "Calling 'new_allocator::construct'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 516, "column": 4}, {"message": "Entered call from 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 159, "column": 2}, {"message": "Calling constructor for 'ILDCRTParams<bigintdyn::ubint<unsigned long>>'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 162, "column": 23}, {"message": "Entered call from 'new_allocator::construct'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "line": 140, "column": 5}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "line": 147, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "line": 148, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/key/evalkey.h", "reportHash": "fca77b903858be64b535021054c94e0f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 128, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 216, "column": 50}, {"message": "Calling 'KeySwitchHYBRID::KeySwitchCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 216, "column": 95}, {"message": "Entered call from 'KeySwitchHYBRID::KeySwitchInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 324, "column": 1}, {"message": "Calling 'KeySwitchHYBRID::EvalFastKeySwitchCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 326, "column": 12}, {"message": "Entered call from 'KeySwitchHYBRID::KeySwitchCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 416, "column": 1}, {"message": "Calling 'KeySwitchHYBRID::EvalFastKeySwitchCoreExt'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 421, "column": 53}, {"message": "Entered call from 'KeySwitchHYBRID::EvalFastKeySwitchCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 440, "column": 1}, {"message": "Calling 'EvalKeyImpl::GetBVector'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 444, "column": 39}, {"message": "Entered call from 'KeySwitchHYBRID::EvalFastKeySwitchCoreExt'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/key/evalkey.h", "line": 127, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/key/evalkey.h", "line": 128, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "reportHash": "91264b75115e428b6c03790562d20c23", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 416, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 216, "column": 50}, {"message": "Calling 'KeySwitchHYBRID::KeySwitchCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 216, "column": 95}, {"message": "Entered call from 'KeySwitchHYBRID::KeySwitchInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 324, "column": 1}, {"message": "Calling 'KeySwitchHYBRID::EvalKeySwitchPrecomputeCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 326, "column": 34}, {"message": "Entered call from 'KeySwitchHYBRID::KeySwitchCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 330, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 345, "column": 9}, {"message": "Assuming 'part' is < 'numPartQl'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 352, "column": 29}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 352, "column": 29}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 353, "column": 13}, {"message": "Assuming 'i' is >= 'sizePartQl'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 361, "column": 34}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 361, "column": 34}, {"message": "Assuming 'i' is >= 'sizePartQl'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 376, "column": 50}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 376, "column": 50}, {"message": "Looping back to the head of the loop", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 352, "column": 5}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 384, "column": 29}, {"message": "Calling 'CryptoParametersRNS::GetPartQlHatInvModq'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 391, "column": 14}, {"message": "Entered call from 'KeySwitchHYBRID::EvalKeySwitchPrecomputeCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 412, "column": 5}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 413, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 416, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "reportHash": "7acd6a905b30f0cd53b4299dd4847aa2", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 431, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 216, "column": 50}, {"message": "Calling 'KeySwitchHYBRID::KeySwitchCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 216, "column": 95}, {"message": "Entered call from 'KeySwitchHYBRID::KeySwitchInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 324, "column": 1}, {"message": "Calling 'KeySwitchHYBRID::EvalKeySwitchPrecomputeCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 326, "column": 34}, {"message": "Entered call from 'KeySwitchHYBRID::KeySwitchCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 330, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 345, "column": 9}, {"message": "Assuming 'part' is < 'numPartQl'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 352, "column": 29}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 352, "column": 29}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 353, "column": 13}, {"message": "Assuming 'i' is >= 'sizePartQl'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 361, "column": 34}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 361, "column": 34}, {"message": "Assuming 'i' is >= 'sizePartQl'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 376, "column": 50}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 376, "column": 50}, {"message": "Looping back to the head of the loop", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 352, "column": 5}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 384, "column": 29}, {"message": "Calling 'CryptoParametersRNS::GetPartQlHatInvModqPrecon'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 392, "column": 14}, {"message": "Entered call from 'KeySwitchHYBRID::EvalKeySwitchPrecomputeCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 427, "column": 5}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 428, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 431, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "reportHash": "f4192b21a0a2df1c97449e2c11c158fa", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 447, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 216, "column": 50}, {"message": "Calling 'KeySwitchHYBRID::KeySwitchCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 216, "column": 95}, {"message": "Entered call from 'KeySwitchHYBRID::KeySwitchInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 324, "column": 1}, {"message": "Calling 'KeySwitchHYBRID::EvalKeySwitchPrecomputeCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 326, "column": 34}, {"message": "Entered call from 'KeySwitchHYBRID::KeySwitchCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 330, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 345, "column": 9}, {"message": "Assuming 'part' is < 'numPartQl'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 352, "column": 29}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 352, "column": 29}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 353, "column": 13}, {"message": "Assuming 'i' is >= 'sizePartQl'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 361, "column": 34}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 361, "column": 34}, {"message": "Assuming 'i' is >= 'sizePartQl'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 376, "column": 50}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 376, "column": 50}, {"message": "Looping back to the head of the loop", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 352, "column": 5}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 384, "column": 29}, {"message": "Calling 'CryptoParametersRNS::GetPartQlHatModp'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 393, "column": 14}, {"message": "Entered call from 'KeySwitchHYBRID::EvalKeySwitchPrecomputeCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 443, "column": 5}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 444, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 447, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "reportHash": "9535836242d2d52bf265e98a8506c4a1", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 462, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 216, "column": 50}, {"message": "Calling 'KeySwitchHYBRID::KeySwitchCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 216, "column": 95}, {"message": "Entered call from 'KeySwitchHYBRID::KeySwitchInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 324, "column": 1}, {"message": "Calling 'KeySwitchHYBRID::EvalKeySwitchPrecomputeCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 326, "column": 34}, {"message": "Entered call from 'KeySwitchHYBRID::KeySwitchCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 330, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 345, "column": 9}, {"message": "Assuming 'part' is < 'numPartQl'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 352, "column": 29}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 352, "column": 29}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 353, "column": 13}, {"message": "Assuming 'i' is >= 'sizePartQl'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 361, "column": 34}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 361, "column": 34}, {"message": "Assuming 'i' is >= 'sizePartQl'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 376, "column": 50}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 376, "column": 50}, {"message": "Looping back to the head of the loop", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 352, "column": 5}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 384, "column": 29}, {"message": "Calling 'CryptoParametersRNS::GetmodComplPartqBarrettMu'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/keyswitch/keyswitch-hybrid.cpp", "line": 394, "column": 14}, {"message": "Entered call from 'KeySwitchHYBRID::EvalKeySwitchPrecomputeCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 458, "column": 5}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 459, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 462, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>

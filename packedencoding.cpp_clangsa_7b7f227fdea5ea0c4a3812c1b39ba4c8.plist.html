<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijn@haverbeke.berlin> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report.events;
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report.events;
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setChecker(report.checker);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.fileId]);
    this.drawBugPath();

    this.jumpTo(event.line, 0);
    this.highlightBugEvent(idx);
  },

  highlightBugEvent : function (idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setChecker : function (checker) {
    var content = checker.name;
    if (checker.url) {
      content = '<a href="' + checker.url + '" target="_blank">' +
        checker.name + '</a>';
    }

    this._checkerName.innerHTML = content;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.filePath;
    let e = document.createElement('div');
    e.innerHTML = file.content;
    this._codeMirror.doc.setValue(e.innerText);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.fileId !== that._currentBugEvent.fileId) {
        return;
      }

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.fileId !== that._currentBugEvent.fileId)
        return;

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/intnat/mubintvecnat.cpp": {"id": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/intnat/mubintvecnat.cpp", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/intnat/mubintvecnat.cpp", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  This code provides basic arithmetic functionality for vectors of native integers\n */\n\n#include &quot;math/math-hal.h&quot;\n#include &quot;math/hal/intnat/mubintvecnat.h&quot;\n#include &quot;math/nbtheory-impl.h&quot;\n\n#include &quot;utils/exception.h&quot;\n\nnamespace intnat {\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt;::NativeVectorT(usint length, const IntegerType&amp; modulus,\n                                          std::initializer_list&lt;std::string&gt; rhs) noexcept\n    : m_modulus{modulus}, m_data(length) {\n    const size_t len = (rhs.size() &lt; m_data.size()) ? rhs.size() : m_data.size();\n    for (size_t i = 0; i &lt; len; ++i)\n        m_data[i] = *(rhs.begin() + i) % m_modulus;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt;::NativeVectorT(usint length, const IntegerType&amp; modulus,\n                                          std::initializer_list&lt;uint64_t&gt; rhs) noexcept\n    : m_modulus{modulus}, m_data(length) {\n    const size_t len = (rhs.size() &lt; m_data.size()) ? rhs.size() : m_data.size();\n    for (size_t i = 0; i &lt; len; ++i)\n        m_data[i].m_value = BasicInt(*(rhs.begin() + i)) % m_modulus.m_value;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt;&amp; NativeVectorT&lt;IntegerType&gt;::operator=(std::initializer_list&lt;std::string&gt; rhs) noexcept {\n    const size_t len = rhs.size();\n    if (m_data.size() &lt; len)\n        m_data.resize(len);\n    for (size_t i = 0; i &lt; m_data.size(); ++i) {\n        if (i &lt; len) {\n            m_data[i] = *(rhs.begin() + i);\n            if (m_modulus.m_value != 0)\n                m_data[i].m_value = m_data[i].m_value % m_modulus.m_value;\n        }\n        else {\n            m_data[i].m_value = 0;\n        }\n    }\n    return *this;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt;&amp; NativeVectorT&lt;IntegerType&gt;::operator=(std::initializer_list&lt;uint64_t&gt; rhs) noexcept {\n    const size_t len = rhs.size();\n    if (m_data.size() &lt; len)\n        m_data.resize(len);\n    for (size_t i = 0; i &lt; m_data.size(); ++i) {\n        if (i &lt; len) {\n            m_data[i].m_value = BasicInt(*(rhs.begin() + i));\n            if (m_modulus.m_value != 0)\n                m_data[i].m_value = m_data[i].m_value % m_modulus.m_value;\n        }\n        else {\n            m_data[i].m_value = 0;\n        }\n    }\n    return *this;\n}\n\n/**Switches the integers in the vector to values corresponding to the new\n * modulus.\n * Algorithm: Integer i, Old Modulus om, New Modulus nm,\n * delta = abs(om-nm):\n *  Case 1: om &lt; nm\n *    if i &gt; om/2\n *      i&#x27; = i + delta\n *  Case 2: om &gt; nm\n *    i &gt; om/2 i&#x27; = i-delta\n */\ntemplate &lt;class IntegerType&gt;\nvoid NativeVectorT&lt;IntegerType&gt;::SwitchModulus(const IntegerType&amp; modulus) {\n    // TODO: #ifdef NATIVEINT_BARRET_MOD\n    auto size{m_data.size()};\n    auto halfQ{m_modulus.m_value &gt;&gt; 1};\n    auto om{m_modulus.m_value};\n    this-&gt;NativeVectorT::SetModulus(modulus);\n    auto nm{modulus.m_value};\n    if (nm &gt; om) {\n        auto diff{nm - om};\n        for (size_t i = 0; i &lt; size; ++i) {\n            auto&amp; v = m_data[i].m_value;\n            if (v &gt; halfQ)\n                v = v + diff;\n        }\n    }\n    else {\n        auto diff{nm - (om % nm)};\n        for (size_t i = 0; i &lt; size; ++i) {\n            auto&amp; v = m_data[i].m_value;\n            if (v &gt; halfQ)\n                v = v + diff;\n            if (v &gt;= nm)\n                v = v % nm;\n        }\n    }\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt; NativeVectorT&lt;IntegerType&gt;::Mod(const IntegerType&amp; modulus) const {\n    auto ans(*this);\n    if (modulus.m_value == 2)\n        return ans.ModByTwoEq();\n    auto nm{modulus.m_value};\n    auto halfQ{m_modulus.m_value &gt;&gt; 1};\n    auto om{m_modulus.m_value};\n    auto size{m_data.size()};\n    if (nm &gt; om) {\n        auto diff{nm - om};\n        for (size_t i = 0; i &lt; size; ++i) {\n            auto&amp; v = ans.m_data[i].m_value;\n            if (v &gt; halfQ)\n                v = v + diff;\n        }\n    }\n    else {\n        auto diff{nm - (om % nm)};\n        for (size_t i = 0; i &lt; size; ++i) {\n            auto&amp; v = ans.m_data[i].m_value;\n            if (v &gt; halfQ)\n                v = v + diff;\n            if (v &gt;= nm)\n                v = v % nm;\n        }\n    }\n    return ans;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt;&amp; NativeVectorT&lt;IntegerType&gt;::ModEq(const IntegerType&amp; modulus) {\n    if (modulus.m_value == 2)\n        return this-&gt;NativeVectorT::ModByTwoEq();\n    auto nm{modulus.m_value};\n    auto halfQ{m_modulus.m_value &gt;&gt; 1};\n    auto om{m_modulus.m_value};\n    auto size{m_data.size()};\n    if (nm &gt; om) {\n        auto diff{nm - om};\n        for (size_t i = 0; i &lt; size; ++i) {\n            auto&amp; v = m_data[i].m_value;\n            if (v &gt; halfQ)\n                v = v + diff;\n        }\n    }\n    else {\n        auto diff{nm - (om % nm)};\n        for (size_t i = 0; i &lt; size; ++i) {\n            auto&amp; v = m_data[i].m_value;\n            if (v &gt; halfQ)\n                v = v + diff;\n            if (v &gt;= nm)\n                v = v % nm;\n        }\n    }\n    return *this;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt; NativeVectorT&lt;IntegerType&gt;::ModAdd(const IntegerType&amp; b) const {\n    auto ans(*this);\n    auto mv{m_modulus};\n    auto bv{b};\n    if (bv.m_value &gt;= mv.m_value)\n        bv.ModEq(mv);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans.m_data[i] = ans.m_data[i].ModAddFast(bv, mv);\n    return ans;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt;&amp; NativeVectorT&lt;IntegerType&gt;::ModAddEq(const IntegerType&amp; b) {\n    auto mv{m_modulus};\n    auto bv{b};\n    if (bv.m_value &gt;= mv.m_value)\n        bv.ModEq(mv);\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i] = m_data[i].ModAddFast(bv, mv);\n    return *this;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt; NativeVectorT&lt;IntegerType&gt;::ModAddAtIndex(size_t i, const IntegerType&amp; b) const {\n    auto ans(*this);\n    ans.at(i).ModAddEq(b, m_modulus);\n    return ans;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt;&amp; NativeVectorT&lt;IntegerType&gt;::ModAddAtIndexEq(size_t i, const IntegerType&amp; b) {\n    this-&gt;NativeVectorT::at(i).ModAddEq(b, m_modulus);\n    return *this;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt; NativeVectorT&lt;IntegerType&gt;::ModAdd(const NativeVectorT&amp; b) const {\n    if (m_modulus != b.m_modulus || m_data.size() != b.m_data.size())\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;ModAdd called on NativeVectorT&#x27;s with different parameters.&quot;);\n    auto mv{m_modulus};\n    auto ans(*this);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans.m_data[i].ModAddFastEq(b[i], mv);\n    return ans;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt;&amp; NativeVectorT&lt;IntegerType&gt;::ModAddEq(const NativeVectorT&amp; b) {\n    if (m_data.size() != b.m_data.size() || m_modulus != b.m_modulus)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;ModAddEq called on NativeVectorT&#x27;s with different parameters.&quot;);\n    auto mv{m_modulus};\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModAddFastEq(b[i], mv);\n    return *this;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt; NativeVectorT&lt;IntegerType&gt;::ModSub(const IntegerType&amp; b) const {\n    auto mv{m_modulus};\n    auto bv{b};\n    auto ans(*this);\n    if (bv.m_value &gt;= mv.m_value)\n        bv.ModEq(mv);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModSubFastEq(bv, mv);\n    return ans;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt;&amp; NativeVectorT&lt;IntegerType&gt;::ModSubEq(const IntegerType&amp; b) {\n    auto mv{m_modulus};\n    auto bv{b};\n    if (bv.m_value &gt;= mv.m_value)\n        bv.ModEq(mv);\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModSubFastEq(bv, mv);\n    return *this;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt; NativeVectorT&lt;IntegerType&gt;::ModSub(const NativeVectorT&amp; b) const {\n    if (m_data.size() != b.m_data.size() || m_modulus != b.m_modulus)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;ModSub called on NativeVectorT&#x27;s with different parameters.&quot;);\n    auto mv{m_modulus};\n    auto ans(*this);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModSubFastEq(b[i], mv);\n    return ans;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt;&amp; NativeVectorT&lt;IntegerType&gt;::ModSubEq(const NativeVectorT&amp; b) {\n    if (m_data.size() != b.m_data.size() || m_modulus != b.m_modulus)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;ModSubEq called on NativeVectorT&#x27;s with different parameters.&quot;);\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModSubFastEq(b[i], m_modulus);\n    return *this;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt; NativeVectorT&lt;IntegerType&gt;::ModMul(const IntegerType&amp; b) const {\n    auto mv{m_modulus};\n    auto bv{b};\n    auto ans(*this);\n    if (bv.m_value &gt;= mv.m_value)\n        bv.ModEq(mv);\n    auto bconst{bv.PrepModMulConst(mv)};\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModMulFastConstEq(bv, mv, bconst);\n    return ans;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt;&amp; NativeVectorT&lt;IntegerType&gt;::ModMulEq(const IntegerType&amp; b) {\n    auto mv{m_modulus};\n    auto bv{b};\n    if (bv.m_value &gt;= mv.m_value)\n        bv.ModEq(mv);\n    auto bconst{bv.PrepModMulConst(mv)};\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModMulFastConstEq(bv, mv, bconst);\n    return *this;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt; NativeVectorT&lt;IntegerType&gt;::ModMul(const NativeVectorT&amp; b) const {\n    if (m_data.size() != b.m_data.size() || m_modulus != b.m_modulus)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;ModMul called on NativeVectorT&#x27;s with different parameters.&quot;);\n    auto ans(*this);\n    uint32_t size(m_data.size());\n    auto mv{m_modulus};\n#ifdef NATIVEINT_BARRET_MOD\n    auto mu{m_modulus.ComputeMu()};\n    for (uint32_t i = 0; i &lt; size; ++i)\n        ans[i].ModMulFastEq(b[i], mv, mu);\n#else\n    for (uint32_t i = 0; i &lt; size; ++i)\n        ans[i].ModMulFastEq(b[i], mv);\n#endif\n    return ans;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt;&amp; NativeVectorT&lt;IntegerType&gt;::ModMulEq(const NativeVectorT&amp; b) {\n    if (m_data.size() != b.m_data.size() || m_modulus != b.m_modulus)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;ModMulEq called on NativeVectorT&#x27;s with different parameters.&quot;);\n    auto mv{m_modulus};\n    size_t size{m_data.size()};\n#ifdef NATIVEINT_BARRET_MOD\n    auto mu{m_modulus.ComputeMu()};\n    for (size_t i = 0; i &lt; size; ++i)\n        m_data[i].ModMulFastEq(b[i], mv, mu);\n#else\n    for (size_t i = 0; i &lt; size; ++i)\n        m_data[i].ModMulFastEq(b[i], mv);\n#endif\n    return *this;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt; NativeVectorT&lt;IntegerType&gt;::ModByTwo() const {\n    auto ans(*this);\n    auto halfQ{m_modulus.m_value &gt;&gt; 1};\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].m_value = 0x1 &amp; (ans[i].m_value ^ (ans[i].m_value &gt; halfQ));\n    return ans;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt;&amp; NativeVectorT&lt;IntegerType&gt;::ModByTwoEq() {\n    auto halfQ{m_modulus.m_value &gt;&gt; 1};\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].m_value = 0x1 &amp; (m_data[i].m_value ^ (m_data[i].m_value &gt; halfQ));\n    return *this;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt; NativeVectorT&lt;IntegerType&gt;::ModExp(const IntegerType&amp; b) const {\n    auto mv{m_modulus};\n    auto bv{b};\n    auto ans(*this);\n    if (bv.m_value &gt;= mv.m_value)\n        bv.ModEq(mv);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i] = ans[i].ModExp(bv, mv);\n    return ans;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt;&amp; NativeVectorT&lt;IntegerType&gt;::ModExpEq(const IntegerType&amp; b) {\n    auto mv{m_modulus};\n    auto bv{b};\n    if (bv.m_value &gt;= mv.m_value)\n        bv.ModEq(mv);\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i] = m_data[i].ModExp(bv, mv);\n    return *this;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt; NativeVectorT&lt;IntegerType&gt;::MultWithOutMod(const NativeVectorT&amp; b) const {\n    if (m_data.size() != b.m_data.size() || m_modulus != b.m_modulus)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;ModMul called on NativeVectorT&#x27;s with different parameters.&quot;);\n    auto ans(*this);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].m_value = ans[i].m_value * b[i].m_value;\n    return ans;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt; NativeVectorT&lt;IntegerType&gt;::MultiplyAndRound(const IntegerType&amp; p,\n                                                                        const IntegerType&amp; q) const {\n    auto halfQ{m_modulus.m_value &gt;&gt; 1};\n    auto mv{m_modulus};\n    auto ans(*this);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i) {\n        if (ans[i].m_value &gt; halfQ) {\n            auto&amp;&amp; tmp{mv - ans[i]};\n            ans[i] = mv - tmp.MultiplyAndRound(p, q);\n        }\n        else {\n            ans[i] = ans[i].MultiplyAndRound(p, q).Mod(mv);\n        }\n    }\n    return ans;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt;&amp; NativeVectorT&lt;IntegerType&gt;::MultiplyAndRoundEq(const IntegerType&amp; p, const IntegerType&amp; q) {\n    auto halfQ{m_modulus.m_value &gt;&gt; 1};\n    auto mv{m_modulus};\n    for (size_t i = 0; i &lt; m_data.size(); ++i) {\n        if (m_data[i].m_value &gt; halfQ) {\n            auto&amp;&amp; tmp{mv - m_data[i]};\n            m_data[i] = mv - tmp.MultiplyAndRound(p, q);\n        }\n        else {\n            m_data[i] = m_data[i].MultiplyAndRound(p, q).Mod(mv);\n        }\n    }\n    return *this;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt; NativeVectorT&lt;IntegerType&gt;::DivideAndRound(const IntegerType&amp; q) const {\n    auto halfQ{m_modulus.m_value &gt;&gt; 1};\n    auto mv{m_modulus};\n    auto ans(*this);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i) {\n        if (ans[i].m_value &gt; halfQ) {\n            auto&amp;&amp; tmp{mv - ans[i]};\n            ans[i] = mv - tmp.DivideAndRound(q);\n        }\n        else {\n            ans[i] = ans[i].DivideAndRound(q);\n        }\n    }\n    return ans;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt;&amp; NativeVectorT&lt;IntegerType&gt;::DivideAndRoundEq(const IntegerType&amp; q) {\n    auto halfQ{m_modulus.m_value &gt;&gt; 1};\n    auto mv{m_modulus};\n    for (size_t i = 0; i &lt; m_data.size(); ++i) {\n        if (m_data[i].m_value &gt; halfQ) {\n            auto&amp;&amp; tmp{mv - m_data[i]};\n            m_data[i] = mv - tmp.DivideAndRound(q);\n        }\n        else {\n            m_data[i] = m_data[i].DivideAndRound(q);\n        }\n    }\n    return *this;\n}\n\ntemplate &lt;class IntegerType&gt;\nNativeVectorT&lt;IntegerType&gt; NativeVectorT&lt;IntegerType&gt;::GetDigitAtIndexForBase(usint index, usint base) const {\n    auto ans(*this);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].m_value = static_cast&lt;BasicInt&gt;(ans[i].GetDigitAtIndexForBase(index, base));\n    return ans;\n}\n\ntemplate class NativeVectorT&lt;NativeInteger&gt;;\n\n}  // namespace intnat\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/vector.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/vector.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/vector.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  This file contains the interfaces for the math vector data types\n */\n\n#ifndef LBCRYPTO_MATH_VECTOR_H\n#define LBCRYPTO_MATH_VECTOR_H\n\n#include &quot;utils/inttypes.h&quot;\n\n#include &lt;string&gt;\n\nnamespace lbcrypto {\n\ntemplate &lt;typename T, typename I&gt;\nclass BigVectorInterface {\npublic:\n    typedef I Integer;\n\n    // CONSTRUCTORS\n\n    // Constructors should be implemented in the derived classes\n    // The derived classes should implement constructors from initializer lists of\n    // integers and strings\n\n    // ASSIGNMENT OPERATORS\n\n    /**\n   * Copy assignment operator.\n   *\n   * @param &amp;vec is the vector to be assigned from.\n   * @return assigned vector ref.\n   */\n    T&amp; operator=(const T&amp; vec);\n\n    /**\n   * Move assignment operator.\n   *\n   * @param &amp;vec is the vector to be assigned from.\n   * @return assigned vector ref.\n   */\n    T&amp; operator=(T&amp;&amp; vec);\n\n    /**\n   * Assignment operator from initializer list of strings.\n   *\n   * @param &amp;&amp;strvec is the list of strings.\n   * @return assigned vector ref.\n   */\n    T&amp; operator=(std::initializer_list&lt;std::string&gt; strvec);\n\n    /**\n   * Assignment operator from initializer list of unsigned integers.\n   *\n   * @param &amp;&amp;vec is the list of integers.\n   * @return assigned vector ref.\n   */\n    T&amp; operator=(std::initializer_list&lt;uint64_t&gt; vec);\n\n    /**\n   * Assignment operator to assign value val to first entry, 0 for the rest of\n   * entries.\n   *\n   * @param val is the unsigned integer the first entry to be assigned from.\n   * @return assigned vector ref.\n   */\n    T&amp; operator=(uint64_t val);\n\n    // EQUALS OPERATORS\n\n    /**\n   * Equals to operator.\n   *\n   * @param &amp;b is vector to be compared.\n   * @return true if equal and false otherwise.\n   */\n    friend inline bool operator==(const T&amp; a, const T&amp; b) {\n        if ((a.GetLength() != b.GetLength()) || (a.GetModulus() != b.GetModulus())) {\n            return false;\n        }\n        for (usint i = 0; i &lt; a.GetLength(); ++i) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n   * Not equal to operator.\n   *\n   * @param b is vector to be compared.\n   * @return true if not equal and false otherwise.\n   */\n    friend inline bool operator!=(const T&amp; a, const T&amp; b) {\n        return !(a == b);\n    }\n\n    // ACCESSORS\n\n    // The derived class must implement at and operator[]\n    I&amp; at(size_t idx);\n    const I&amp; at(size_t idx) const;\n    I&amp; operator[](size_t idx);\n    const I&amp; operator[](size_t idx) const;\n\n    /**\n   * Sets the vector modulus.\n   *\n   * @param value is the value to set.\n   * @param value is the modulus value to set.\n   */\n    void SetModulus(const I&amp; value);\n\n    /**\n   * Sets the vector modulus and changes the values to match the new modulus.\n   *\n   * @param value is the value to set.\n   */\n    void SwitchModulus(const I&amp; value);\n\n    /**\n   * Gets the vector modulus.\n   *\n   * @return the vector modulus.\n   */\n    const I&amp; GetModulus() const;\n\n    /**\n   * Gets the vector length.\n   *\n   * @return vector length.\n   */\n    size_t GetLength() const;\n\n    // MODULUS ARITHMETIC OPERATIONS\n\n    /**\n   * Vector modulus operator.\n   *\n   * @param &amp;modulus is the modulus to perform on the current vector entries.\n   * @return is the result of the modulus operation on current vector.\n   */\n    T Mod(const I&amp; modulus) const;\n\n    /**\n   * Vector modulus operator. In-place variant.\n   *\n   * @param &amp;modulus is the modulus to perform on the current vector entries.\n   * @return is the result of the modulus operation on current vector.\n   */\n    T&amp; ModEq(const I&amp; modulus);\n\n    /// inline operators for the modulus operations.\n    friend T operator%(const T&amp; a, const I&amp; b) {\n        return a.Mod(b);\n    }\n    friend T&amp; operator%=(T&amp; a, const I&amp; b) {\n        return a.ModEq(b);\n    }\n\n    /**\n   * Scalar-to-vector modulus addition operation.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus addition operation.\n   */\n    T ModAdd(const I&amp; b) const;\n\n    /**\n   * Scalar-to-vector modulus addition operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus addition operation.\n   */\n    T&amp; ModAddEq(const I&amp; b);\n\n    /// inline operators for the scara-to-vector modulus addition operations.\n    friend T operator+(const T&amp; a, const I&amp; b) {\n        return a.ModAdd(b);\n    }\n    friend T&amp; operator+=(T&amp; a, const I&amp; b) {\n        return a.ModAddEq(b);\n    }\n\n    /**\n   * Scalar modulus addition at a particular index.\n   *\n   * @param i is the index of the entry to add.\n   * @param &amp;b is the scalar to add.\n   * @return is the result of the modulus addition operation.\n   */\n    T ModAddAtIndex(usint i, const I&amp; b) const;\n\n    /**\n   * Scalar modulus addition at a particular index. In-place variant.\n   *\n   * @param i is the index of the entry to add.\n   * @param &amp;b is the scalar to add.\n   * @return is the result of the modulus addition operation.\n   */\n    T&amp; ModAddAtIndexEq(usint i, const I&amp; b);\n\n    /**\n   * Vector component wise modulus addition.\n   *\n   * @param &amp;b is the vector to perform operation with.\n   * @return is the result of the component wise modulus addition operation.\n   */\n    T ModAdd(const T&amp; b) const;\n\n    /**\n   * Vector component wise modulus addition. In-place variant.\n   *\n   * @param &amp;b is the vector to perform operation with.\n   * @return is the result of the component wise modulus addition operation.\n   */\n    T&amp; ModAddEq(const T&amp; b);\n    T&amp; ModAddNoCheckEq(const T&amp; b);\n\n    /// inline operators for the vector component wise modulus addition\n    /// operations.\n    friend T operator+(const T&amp; a, const T&amp; b) {\n        return a.ModAdd(b);\n    }\n    friend T&amp; operator+=(T&amp; a, const T&amp; b) {\n        return a.ModAddEq(b);\n    }\n\n    /**\n   * Scalar-from-vector modulus subtraction operation.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    T ModSub(const I&amp; b) const;\n\n    /**\n   * Scalar-from-vector modulus subtraction operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    T&amp; ModSubEq(const I&amp; b);\n\n    /// inline operators for the scalar-from-vector modulus subtraction\n    /// operations.\n    friend T operator-(const T&amp; a, const I&amp; b) {\n        return a.ModSub(b);\n    }\n    friend T&amp; operator-=(T&amp; a, const I&amp; b) {\n        return a.ModSubEq(b);\n    }\n\n    /**\n   * Vector component wise modulus subtraction.\n   *\n   * @param &amp;b is the vector to perform operation with.\n   * @return is the result of the component wise modulus subtraction operation.\n   */\n    T ModSub(const T&amp; b) const;\n\n    /**\n   * Vector component wise modulus subtraction. In-place variant.\n   *\n   * @param &amp;b is the vector to perform operation with.\n   * @return is the result of the component wise modulus subtraction operation.\n   */\n    T&amp; ModSubEq(const T&amp; b);\n\n    /// inline operators for the vector component wise modulus subtraction\n    /// operations.\n    inline friend T operator-(const T&amp; a, const T&amp; b) {\n        return a.ModSub(b);\n    }\n    inline friend const T&amp; operator-=(T&amp; a, const T&amp; b) {\n        return a.ModSubEq(b);\n    }\n\n    /// inline operator for the unary minus\n    inline friend T operator-(const T&amp; a) {\n        return a.ModMul(a.GetModulus() - I(1));\n    }\n\n    /**\n   * Scalar-to-vector modulus multiplication operation.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    T ModMul(const I&amp; b) const;\n\n    /**\n   * Scalar-to-vector modulus multiplication operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    T&amp; ModMulEq(const I&amp; b);\n\n    /// inline operators for the scalar-to-vector modulus multiplication\n    /// operations.\n    friend T operator*(const T&amp; a, const I&amp; b) {\n        return a.ModMul(b);\n    }\n    friend T&amp; operator*=(T&amp; a, const I&amp; b) {\n        return a.ModMulEq(b);\n    }\n\n    /**\n   * Vector component wise modulus multiplication.\n   *\n   * @param &amp;b is the vector to perform operation with.\n   * @return is the result of the component wise modulus multiplication\n   * operation.\n   */\n    T ModMul(const T&amp; b) const;\n\n    /**\n   * Vector component wise modulus multiplication. In-place variant.\n   *\n   * @param &amp;b is the vector to perform operation with.\n   * @return is the result of the component wise modulus multiplication\n   * operation.\n   */\n    T&amp; ModMulEq(const T&amp; b);\n    T&amp; ModMulNoCheckEq(const T&amp; b);\n\n    /// inline operators for the vector component wise modulus multiplication\n    /// operations.\n    friend T operator*(const T&amp; a, const T&amp; b) {\n        return a.ModMul(b);\n    }\n    friend T&amp; operator*=(T&amp; a, const T&amp; b) {\n        return a.ModMulEq(b);\n    }\n\n    /**\n   * Scalar modulus exponentiation operation.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus exponentiation operation.\n   */\n    T ModExp(const I&amp; b) const;\n\n    /**\n   * Scalar modulus exponentiation operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus exponentiation operation.\n   */\n    T&amp; ModExpEq(const I&amp; b);\n\n    /**\n   * Modulus inverse operation.\n   *\n   * @return is the result of the component wise modulus inverse operation.\n   */\n    T ModInverse() const;\n\n    /**\n   * Modulus inverse operation. In-place variant.\n   *\n   * @return is the result of the component wise modulus inverse operation.\n   */\n    T&amp; ModInverseEq();\n\n    /**\n   * Modulus 2 operation, also a least significant bit.\n   *\n   * @return is the result of the component wise modulus 2 operation, also a\n   * least significant bit.\n   */\n    T ModByTwo() const;\n\n    /**\n   * Modulus 2 operation, also a least significant bit. In-place variant.\n   *\n   * @return is the result of the component wise modulus 2 operation, also a\n   * least significant bit.\n   */\n    T&amp; ModByTwoEq();\n\n    /**\n   * Multiply and Rounding operation. Returns [x*p/q] where [] is the rounding\n   * operation.\n   *\n   * @param &amp;p is the numerator to be multiplied.\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of multiply and round operation.\n   */\n    T MultiplyAndRound(const I&amp; p, const I&amp; q) const;\n\n    /**\n   * Multiply and Rounding operation. Returns [x*p/q] where [] is the rounding\n   * operation. In-place variant.\n   *\n   * @param &amp;p is the numerator to be multiplied.\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of multiply and round operation.\n   */\n    T&amp; MultiplyAndRoundEq(const I&amp; p, const I&amp; q);\n\n    /**\n   * Divide and Rounding operation. Returns [x/q] where [] is the rounding\n   * operation.\n   *\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of divide and round operation.\n   */\n    T DivideAndRound(const I&amp; q) const;\n\n    /**\n   * Divide and Rounding operation. Returns [x/q] where [] is the rounding\n   * operation. In-place variant.\n   *\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of divide and round operation.\n   */\n    T&amp; DivideAndRoundEq(const I&amp; q);\n\n    // OTHER FUNCTIONS\n\n    /**\n   * Digit vector at a specific index for all entries for a given number base.\n   * Example: for vector (83, 1, 45), index 2 and base 4 we have:\n   *\n   *                           index:0,1,2,3\n   * |83|                           |3,0,1,1|                 |1|\n   * |1 | --base 4 decomposition--&gt; |1,0,0,0| --at index 2--&gt; |0|\n   * |45|                           |1,3,2,0|                 |2|\n   *\n   * The return vector is (1,0,2)\n   *\n   * @param index is the index to return the digit from in all entries.\n   * @param base is the base to use for the operation.\n   * @return is the digit at a specific index for all entries for a given number\n   * base\n   */\n    T GetDigitAtIndexForBase(usint index, usint base) const;\n\nprotected:\n    ~BigVectorInterface() = default;\n\n    // STRINGS &amp; STREAMS\n\n    // SERIALIZATION\n};\n\n}  // namespace lbcrypto\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp": {"id": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  This file contains the main class for unsigned big integers: ubint. Big integers are represented as arrays of\n  machine native unsigned integers. The native integer type is supplied as a template parameter.\n  Currently implementation based on uint32_t and uint64_t is supported. a native double the base integer size is also needed.\n */\n\n#include &quot;config_core.h&quot;\n#ifdef WITH_BE4\n\n    #include &quot;math/math-hal.h&quot;\n\n    #include &quot;utils/exception.h&quot;\n    #include &quot;utils/inttypes.h&quot;\n    #include &quot;utils/serializable.h&quot;\n\n    #include &lt;iostream&gt;\n    #include &lt;string&gt;\n    #include &lt;vector&gt;\n\nnamespace bigintdyn {\n\n// Sum and Carry algorithm with radix 2^m_bitLength.\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::Add(const ubint&amp; b) const {\n    const ubint* A = this;\n    auto sizeA     = m_value.size();\n    const ubint* B = &amp;b;\n    auto sizeB     = b.m_value.size();\n    if (sizeA &lt; sizeB) {\n        std::swap(A, B);\n        std::swap(sizeA, sizeB);\n    }\n\n    if (B-&gt;m_MSB == 0)\n        return *A;\n\n    std::vector&lt;limb_t&gt; r(sizeA + 1);\n    Dlimb_t c{0};\n    for (size_t i = 0; i &lt; sizeA; ++i, c &gt;&gt;= m_limbBitLength) {\n        auto av = static_cast&lt;Dlimb_t&gt;(A-&gt;m_value[i]);\n        auto bv = static_cast&lt;Dlimb_t&gt;(i &lt; sizeB ? B-&gt;m_value[i] : 0);\n        r[i]    = static_cast&lt;limb_t&gt;(c += av + bv);\n    }\n    r[sizeA] = static_cast&lt;limb_t&gt;(c);\n    return ubint(std::move(r));\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::AddEq(const ubint&amp; b) {\n    const ubint* A = this;\n    auto sizeA     = m_value.size();\n    const ubint* B = &amp;b;\n    auto sizeB     = B-&gt;m_value.size();\n    if (sizeA &lt; sizeB) {\n        std::swap(A, B);\n        std::swap(sizeA, sizeB);\n    }\n\n    if (B-&gt;m_MSB == 0)\n        return *this = *A;\n\n    std::vector&lt;limb_t&gt; r(sizeA + 1);\n    Dlimb_t c{0};\n    for (size_t i = 0; i &lt; sizeA; ++i, c &gt;&gt;= m_limbBitLength) {\n        auto av = static_cast&lt;Dlimb_t&gt;(A-&gt;m_value[i]);\n        auto bv = static_cast&lt;Dlimb_t&gt;(i &lt; sizeB ? B-&gt;m_value[i] : 0);\n        r[i]    = static_cast&lt;limb_t&gt;(c += av + bv);\n    }\n    r[sizeA] = static_cast&lt;limb_t&gt;(c);\n    m_value  = std::move(r);\n    ubint&lt;limb_t&gt;::NormalizeLimbs();\n    return *this;\n}\n\n// TODO: convert to vector constructor method\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::Sub(const ubint&amp; b) const {\n    // return 0 if b is higher than *this as there is no support for negative numbers\n    if (*this &lt;= b)\n        return ubint();\n    ubint result(*this);\n    for (size_t i = 0; i &lt; b.m_value.size(); ++i) {\n        if (result.m_value[i] &lt; b.m_value[i]) {  // carryover condition need to\n                                                 // borrow from higher limbs.\n            size_t cntr{i};\n            result.m_value[cntr] += (m_MaxLimb - b.m_value[cntr]) + 1;\n            // set all the zero limbs to all FFs (propagate the 1)\n            while (0 == result.m_value[++cntr])\n                result.m_value[cntr] = m_MaxLimb;\n            // and eventually borrow 1 from the first nonzero limb we find\n            result.m_value[cntr]--;\n        }\n        else {  // usual subtraction condition\n            result.m_value[i] -= b.m_value[i];\n        }\n    }\n    result.NormalizeLimbs();\n    return result;\n}\n\n// TODO: convert to vector constructor method\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::SubEq(const ubint&amp; b) {\n    if (*this &lt;= b) {\n        m_MSB      = 0;\n        m_value[0] = 0;\n        m_value.resize(1);\n        return *this;\n    }\n    for (size_t i = 0; i &lt; b.m_value.size(); ++i) {\n        if (m_value[i] &lt; b.m_value[i]) {\n            size_t cntr{i};\n            m_value[cntr] += (m_MaxLimb - b.m_value[cntr]) + 1;\n            while (0 == m_value[++cntr])\n                m_value[cntr] = m_MaxLimb;\n            m_value[cntr]--;\n        }\n        else {\n            m_value[i] -= b.m_value[i];\n        }\n    }\n    ubint&lt;limb_t&gt;::NormalizeLimbs();\n    return *this;\n}\n\n// Multiply operation: usual school book shift and add after multiplication\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::Mul(const ubint&amp; b) const {\n    if (m_MSB == 0 || b.m_MSB == 0)\n        return ubint();\n    if (b.m_MSB == 1)\n        return *this;\n    if (m_MSB == 1)\n        return b;\n\n    const ubint* A = this;\n    auto aSize     = m_value.size();\n    const ubint* B = &amp;b;\n    auto bSize     = b.m_value.size();\n    if (aSize &lt; bSize) {\n        std::swap(A, B);\n        std::swap(aSize, bSize);\n    }\n\n    ubint ans;\n    for (size_t i = 0; i &lt; bSize; ++i) {\n        std::vector&lt;limb_t&gt; c(i + aSize + 1);\n        Dlimb_t limbb = static_cast&lt;Dlimb_t&gt;(B-&gt;m_value[i]);\n        Dlimb_t ofl{0};\n        for (size_t j = 0; j &lt; aSize; ++j, ofl &gt;&gt;= m_limbBitLength)\n            c[i + j] = static_cast&lt;limb_t&gt;(ofl += limbb * A-&gt;m_value[j]);\n        c[i + aSize] = static_cast&lt;limb_t&gt;(ofl);\n\n        ans = std::move(ans.Add(ubint(std::move(c))));\n    }\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::DividedBy(const ubint&amp; b) const {\n    if (b.m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Divisor is zero&quot;);\n    if (b.m_MSB &gt; m_MSB)\n        return ubint();\n    if ((b.m_MSB == m_MSB) &amp;&amp; (b.m_value.back() == m_value.back()))\n        return ubint(1);\n    ubint ans;\n    divq_vect(ans, *this, b);\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::DividedByEq(const ubint&amp; b) {\n    if (b.m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Divisor is zero&quot;);\n    if (b.m_MSB &gt; m_MSB) {\n        m_MSB = 0;\n        m_value.resize(1);\n        m_value[0] = 0;\n        return *this;\n    }\n    if ((b.m_MSB == m_MSB) &amp;&amp; (b.m_value.back() == m_value.back())) {\n        m_MSB = 1;\n        m_value.resize(1);\n        m_value[0] = 1;\n        return *this;\n    }\n    ubint ans;\n    divq_vect(ans, *this, b);\n    return *this = std::move(ans);\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::Exp(usint p) const {\n    if (p == 0)\n        return ubint(1);\n    if (p == 1)\n        return *this;\n    ubint tmp{ubint&lt;limb_t&gt;::Exp(p &gt;&gt; 1)};\n    tmp = tmp.Mul(tmp);\n    if (p &amp; 0x1)\n        return tmp.Mul(*this);\n    return tmp;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::MultiplyAndRound(const ubint&amp; p, const ubint&amp; q) const {\n    if (q.m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;MultiplyAndRound() Divisor is zero&quot;);\n    auto t{ubint&lt;limb_t&gt;::Mul(p)};\n    ubint halfQ(q &gt;&gt; 1);\n    if (t &lt;= halfQ)\n        return ubint();\n    if ((t.m_MSB == halfQ.m_MSB) || ((t.m_MSB == q.m_MSB) &amp;&amp; (t.m_value.back() &lt; q.m_value.back())))\n        return ubint(1);\n    ubint ans, rv;\n    divqr_vect(ans, rv, t, q);\n    if (rv &gt; halfQ)\n        return ans.Add(ubint(1));\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::DivideAndRound(const ubint&amp; q) const {\n    if (q.m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;DivideAndRound() Divisor is zero&quot;);\n    ubint halfQ(q &gt;&gt; 1);\n    if (*this &lt;= halfQ)\n        return ubint();\n    if ((m_MSB == halfQ.m_MSB) || ((m_MSB == q.m_MSB) &amp;&amp; (m_value.back() &lt; q.m_value.back())))\n        return ubint(1);\n    ubint ans, rv;\n    divqr_vect(ans, rv, *this, q);\n    if (rv &gt; halfQ)\n        return ans.Add(ubint(1));\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::Mod(const ubint&amp; modulus) const {\n    if (modulus.m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Mod() using zero modulus&quot;);\n    if (*this &lt; modulus)\n        return *this;\n    if (modulus.m_MSB == 2 &amp;&amp; modulus.m_value[0] == 2)\n        return ubint(m_value[0] &amp; 0x1);\n    ubint ans;\n    divr_vect(ans, *this, modulus);\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::ModEq(const ubint&amp; modulus) {\n    if (modulus.m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Mod() using zero modulus&quot;);\n    if (*this &lt; modulus)\n        return *this;\n    if (modulus.m_MSB == 2 &amp;&amp; modulus.m_value[0] == 2) {\n        m_value.resize(1);\n        m_value[0] &amp;= 0x1;\n        m_MSB = m_value[0];\n        return *this;\n    }\n    ubint ans;\n    divr_vect(ans, *this, modulus);\n    return *this = std::move(ans);\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModAdd(const ubint&amp; b, const ubint&amp; modulus) const {\n    ubint bv(b);\n    if (bv &gt;= modulus)\n        bv.ModEq(modulus);\n    ubint av(*this);\n    if (av &gt;= modulus)\n        av.ModEq(modulus);\n    av = av.Add(bv);\n    if (av &gt;= modulus)\n        return av.Sub(modulus);\n    return av;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::ModAddEq(const ubint&amp; b, const ubint&amp; modulus) {\n    ubint bv(b);\n    if (bv &gt;= modulus)\n        bv.ModEq(modulus);\n    if (*this &gt;= modulus)\n        ubint&lt;limb_t&gt;::ModEq(modulus);\n    *this = bv.Add(*this);\n    if (*this &gt;= modulus)\n        return ubint&lt;limb_t&gt;::SubEq(modulus);\n    return *this;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModAddFast(const ubint&amp; b, const ubint&amp; modulus) const {\n    ubint ans(b.Add(*this));\n    if (ans &gt;= modulus)\n        return ans.Sub(modulus);\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::ModAddFastEq(const ubint&amp; b, const ubint&amp; modulus) {\n    *this = b.Add(*this);\n    if (*this &gt;= modulus)\n        return ubint&lt;limb_t&gt;::SubEq(modulus);\n    return *this;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModSub(const ubint&amp; b, const ubint&amp; modulus) const {\n    auto av(*this);\n    auto bv(b);\n    if (bv &gt;= modulus)\n        bv.ModEq(modulus);\n    if (av &gt;= modulus)\n        av.ModEq(modulus);\n    if (av &lt; bv)\n        av = modulus.Add(av);\n    return av.Sub(bv);\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::ModSubEq(const ubint&amp; b, const ubint&amp; modulus) {\n    auto bv(b);\n    if (bv &gt;= modulus)\n        bv.ModEq(modulus);\n    if (*this &gt;= modulus)\n        ubint&lt;limb_t&gt;::ModEq(modulus);\n    if (*this &lt; bv)\n        *this = modulus.Add(*this);\n    return ubint&lt;limb_t&gt;::SubEq(bv);\n}\n\ntemplate &lt;typename limb_t&gt;\ninline ubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModSubFast(const ubint&amp; b, const ubint&amp; modulus) const {\n    if (*this &lt; b)\n        return modulus.Add(*this).Sub(b);\n    return ubint&lt;limb_t&gt;::Sub(b);\n}\n\ntemplate &lt;typename limb_t&gt;\ninline ubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::ModSubFastEq(const ubint&amp; b, const ubint&amp; modulus) {\n    if (*this &lt; b)\n        return *this = std::move(modulus.Add(*this).Sub(b));\n    return ubint&lt;limb_t&gt;::SubEq(b);\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModMulFast(const ubint&amp; b, const ubint&amp; modulus) const {\n    if (m_MSB == 0 || b.m_MSB == 0)\n        return ubint();\n    if (b.m_MSB == 1)\n        return *this;\n    if (m_MSB == 1)\n        return b;\n\n    const ubint* A = this;\n    auto aSize     = m_value.size();\n    const ubint* B = &amp;b;\n    auto bSize     = b.m_value.size();\n    if (aSize &lt; bSize) {\n        std::swap(A, B);\n        std::swap(aSize, bSize);\n    }\n\n    ubint ans;\n    for (size_t i = 0; i &lt; bSize; ++i) {\n        std::vector&lt;limb_t&gt; c(i + aSize + 1);\n        Dlimb_t limbb = static_cast&lt;Dlimb_t&gt;(B-&gt;m_value[i]);\n        Dlimb_t ofl{0};\n        for (size_t j = 0; j &lt; aSize; ++j, ofl &gt;&gt;= m_limbBitLength)\n            c[i + j] = static_cast&lt;limb_t&gt;(ofl += limbb * A-&gt;m_value[j]);\n        c[i + aSize] = static_cast&lt;limb_t&gt;(ofl);\n\n        ans = std::move(ans.Add(ubint(std::move(c))));\n    }\n    if (ans &gt;= modulus)\n        return ans.Mod(modulus);\n    return ans;\n}\n\n// Extended Euclid algorithm used to find the multiplicative inverse\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModInverse(const ubint&amp; modulus) const {\n    if (m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Zero has no inverse&quot;);\n\n    ubint second(*this);\n    if (second &gt;= modulus)\n        second = second.Mod(modulus);\n    if (second.m_MSB == 1)\n        return second;\n\n    // NORTH ALGORITHM\n    ubint first(modulus);\n    std::vector&lt;ubint&gt; quotient;\n    quotient.reserve(8);  // TODO\n\n    ubint q, mod_back;\n    divqr_vect(q, mod_back, first, second);\n    quotient.emplace_back(std::move(q));\n\n    if (mod_back.m_MSB == 0) {\n        std::string msg = ubint&lt;limb_t&gt;::ToString() + &quot; does not have a ModInverse using &quot; + modulus.ToString();\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, msg);\n    }\n\n    // max number of iterations should be &lt; 2^k where k == min(bitsize(inputs))\n    // TODO: consider breaking out of the loop if this limit exceeded.\n    //       loop counter would need to be a ubint.\n    while (mod_back.m_MSB != 1) {\n        first  = second;\n        second = mod_back;\n\n        ubint q;\n        divqr_vect(q, mod_back, first, second);\n        quotient.emplace_back(std::move(q));\n    }\n\n    // SOUTH ALGORITHM\n    first  = ubint();\n    second = ubint(1);\n    for (auto it = quotient.rbegin(); it != quotient.rend(); ++it) {\n        mod_back = *it * second + first;\n        first    = second;\n        second   = mod_back;\n    }\n    if (quotient.size() &amp; 0x1)\n        return modulus - mod_back;\n    return mod_back;\n}\n\n// Modular Exponentiation using Square and Multiply Algorithm\n// reference:http://guan.cse.nsysu.edu.tw/note/expn.pdf\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModExp(const ubint&amp; b, const ubint&amp; modulus) const {\n    ubint t(this-&gt;Mod(modulus));\n    ubint p(b);\n    ubint r(1);\n    if (p.m_value[0] &amp; 0x1)\n        r = r.ModMulFast(t, modulus);\n    while ((p &gt;&gt;= 1).m_MSB) {\n        t = t.ModMulFast(t, modulus);\n        if (p.m_value[0] &amp; 0x1)\n            r = r.ModMulFast(t, modulus);\n    }\n    return r;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::LShift(usshort shift) const {\n    static constexpr usshort mask{m_limbBitLength - 1};\n    if (m_MSB == 0)\n        return ubint();\n    auto ans(*this);\n    ans.m_MSB += shift;\n    size_t shiftByLimb{static_cast&lt;size_t&gt;(shift) &gt;&gt; m_log2LimbBitLength};\n    shift &amp;= mask;\n    if (shift) {\n        Dlimb_t ofl{0};\n        for (auto&amp; v : ans.m_value) {\n            ofl |= static_cast&lt;Dlimb_t&gt;(v) &lt;&lt; shift;\n            v = static_cast&lt;limb_t&gt;(ofl);\n            ofl &gt;&gt;= m_limbBitLength;\n        }\n        if (ofl)\n            ans.m_value.push_back(static_cast&lt;limb_t&gt;(ofl));\n    }\n    if (shiftByLimb) {\n        size_t j = ans.m_value.size();\n        size_t i = j + shiftByLimb;\n        ans.m_value.resize(i);\n        while (i &gt; 0)\n            ans.m_value[--i] = (j &gt; 0) ? ans.m_value[--j] : 0;\n    }\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::LShiftEq(usshort shift) {\n    static constexpr usshort mask{m_limbBitLength - 1};\n    if (m_MSB == 0)\n        return *this;\n    m_MSB += shift;\n    size_t shiftByLimb{static_cast&lt;size_t&gt;(shift) &gt;&gt; m_log2LimbBitLength};\n    shift &amp;= mask;\n    if (shift) {\n        Dlimb_t ofl{0};\n        for (auto&amp; v : m_value) {\n            ofl |= static_cast&lt;Dlimb_t&gt;(v) &lt;&lt; shift;\n            v = static_cast&lt;limb_t&gt;(ofl);\n            ofl &gt;&gt;= m_limbBitLength;\n        }\n        if (ofl)\n            m_value.push_back(static_cast&lt;limb_t&gt;(ofl));\n    }\n    if (shiftByLimb) {\n        size_t j = m_value.size();\n        size_t i = j + shiftByLimb;\n        m_value.resize(i);\n        while (i &gt; 0)\n            m_value[--i] = (j &gt; 0) ? m_value[--j] : 0;\n    }\n    return *this;\n}\n\n/**Right Shift is done by splitting the number of shifts into\n *1. Multiple of the bit length of limb data type.\n *  Shifting is done by the shifting the limb type numbers in the array to\n *the right.\n *2. Shifts between 1 to bit length of limb data type.\n *   Shifting is done by using bit shift operations and carry over propagation.\n */\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::RShift(usshort shift) const {\n    static constexpr usshort mask{m_limbBitLength - 1};\n    if (m_MSB &lt;= shift)\n        return ubint(0);\n    ubint ans(*this);\n    ans.m_MSB -= shift;\n    size_t shiftByLimb{static_cast&lt;size_t&gt;(shift) &gt;&gt; m_log2LimbBitLength};\n    shift &amp;= mask;\n    Dlimb_t tmp{ans.m_value[shiftByLimb++] &gt;&gt; shift};\n    usint lshift{m_limbBitLength - shift};\n    size_t size{ans.m_value.size() - shiftByLimb};\n    for (size_t i = 0; i &lt; size; ++i, tmp &gt;&gt;= m_limbBitLength) {\n        tmp |= static_cast&lt;Dlimb_t&gt;(ans.m_value[i + shiftByLimb]) &lt;&lt; lshift;\n        ans.m_value[i] = static_cast&lt;limb_t&gt;(tmp);\n    }\n    ans.m_value.resize(size);\n    if (tmp)\n        ans.m_value.push_back(static_cast&lt;limb_t&gt;(tmp));\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::RShiftEq(usshort shift) {\n    static constexpr usshort mask{m_limbBitLength - 1};\n    if (m_MSB &lt;= shift) {\n        m_MSB = 0;\n        m_value.resize(1);\n        m_value[0] = 0;\n        return *this;\n    }\n    m_MSB -= shift;\n    size_t shiftByLimb{static_cast&lt;size_t&gt;(shift) &gt;&gt; m_log2LimbBitLength};\n    shift &amp;= mask;\n    Dlimb_t tmp{m_value[shiftByLimb++] &gt;&gt; shift};\n    usint lshift{m_limbBitLength - shift};\n    size_t size{m_value.size() - shiftByLimb};\n    for (size_t i = 0; i &lt; size; ++i, tmp &gt;&gt;= m_limbBitLength) {\n        tmp |= static_cast&lt;Dlimb_t&gt;(m_value[i + shiftByLimb]) &lt;&lt; lshift;\n        m_value[i] = static_cast&lt;limb_t&gt;(tmp);\n    }\n    m_value.resize(size);\n    if (tmp)\n        m_value.push_back(static_cast&lt;limb_t&gt;(tmp));\n    return *this;\n}\n\n// Converts the ubint to float using the std library functions.\ntemplate &lt;typename limb_t&gt;\nfloat ubint&lt;limb_t&gt;::ConvertToFloat() const {\n    float ans{-1.0f};\n    try {\n        ans = std::stof(ubint&lt;limb_t&gt;::ToString());\n    }\n    catch (const std::exception&amp; e) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::type_error, &quot;ConvertToFloat() parse error converting to float&quot;);\n    }\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\ndouble ubint&lt;limb_t&gt;::ConvertToDouble() const {\n    double ans{-1.0};\n    try {\n        // ans = std::stod(this-&gt;ToString());\n        usint ceilInt = MSBToLimbs(m_MSB);\n        double factor = pow(2, m_limbBitLength);\n        double power  = 1.0;\n\n        ans = 0.0;\n        for (usint i = 0; i &lt; ceilInt; ++i, power *= factor)\n            ans += power * m_value[i];\n    }\n    catch (const std::exception&amp; e) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::type_error, &quot;ConvertToDouble() parse error converting to double&quot;);\n    }\n    return ans;\n}\n\n// Converts the ubint to long double using the std library functions.\ntemplate &lt;typename limb_t&gt;\nlong double ubint&lt;limb_t&gt;::ConvertToLongDouble() const {\n    long double ans{-1.0};\n    try {\n        ans = std::stold(ubint&lt;limb_t&gt;::ToString());\n    }\n    catch (const std::exception&amp; e) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::type_error, &quot;ConvertToLongDouble() parse error converting to long double&quot;);\n    }\n    return ans;\n}\n\n// TODO\n// Splits binary string to equi sized chunks then populates internal array values\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::FromBinaryString(const std::string&amp; vin) {\n    std::string v = vin;\n    // v.erase(0, v.find_first_not_of(&#x27; &#x27;));\n    v.erase(0, v.find_first_not_of(&#x27;0&#x27;));\n    if (v.size() == 0)\n        return ubint();\n    ubint value;\n    value.m_value.clear();\n    usint len  = v.length();\n    usint cntr = MSBToLimbs(len);\n    std::string val;\n    Dlimb_t partial_value = 0;\n    for (usint i = 0; i &lt; cntr; i++) {\n        if (len &gt; ((i + 1) * m_limbBitLength)) {\n            val = v.substr((len - (i + 1) * m_limbBitLength), m_limbBitLength);\n        }\n        else {\n            val = v.substr(0, len % m_limbBitLength);\n        }\n        for (usint j = 0; j &lt; val.length(); j++) {\n            partial_value += std::stoi(val.substr(j, 1));\n            partial_value &lt;&lt;= 1;\n        }\n        partial_value &gt;&gt;= 1;\n        value.m_value.push_back((limb_t)partial_value);\n        partial_value = 0;\n    }\n    value.SetMSB();\n    return value;\n}\n\n// TODO: * i to &lt;&lt; i\ntemplate &lt;typename limb_t&gt;\nusint ubint&lt;limb_t&gt;::GetDigitAtIndexForBase(usint index, usint base) const {\n    usint DigitLen = ceil(log2(base));\n    usint digit    = 0;\n    usint newIndex = 1 + (index - 1) * DigitLen;\n    for (usint i = 1; i &lt; base; i &lt;&lt;= 1) {\n        digit += GetBitAtIndex(newIndex++) * i;\n    }\n    return digit;\n}\n\ntemplate &lt;typename limb_t&gt;\nconst std::string ubint&lt;limb_t&gt;::ToString() const {\n    std::vector&lt;uschar&gt; val{0};\n    val.reserve(m_MSB &gt;&gt; 1);\n    for (usint i = m_MSB; i &gt; 0; --i) {\n        auto ofl = GetBitAtIndex(i);  // TODO: needlessly expensive here\n        for (auto&amp; a : val) {\n            a = (a &lt;&lt; 1) + ofl;\n            if ((ofl = (a &gt; 9)))\n                a -= 10;\n        }\n        if (ofl)\n            val.push_back(1);\n    }\n    for (auto&amp; a : val)\n        a += &#x27;0&#x27;;\n    return std::string(val.rbegin(), val.rend());\n}\n\n/* q[0], r[0], u[0], and v[0] contain the LEAST significant words.\n (The sequence is in little-endian order).\n\n This is a fairly precise implementation of Knuth&#x27;s Algorithm D, for a\n binary computer with base b = 2**(32|64). The caller supplies:\n 1. Space q for the quotient, m - n + 1 words (at least one).\n 2. Space r for the remainder (optional), n words.\n 3. The dividend u, m words, m &gt;= 1.\n 4. The divisor v, n words, n &gt;= 2.\n The most significant digit of the divisor, v[n-1], must be nonzero.  The\n dividend u may have leading zeros; this just makes the algorithm take\n longer and makes the quotient contain more leading zeros.  A value of\n nullptr may be given for the address of the remainder to signify that the\n caller does not want the remainder.\n The program does not alter the input parameters u and v.\n The quotient and remainder returned may have leading zeros.  The\n function itself returns a value of 0 for success and 1 for invalid\n parameters (e.g., division by 0).\n For now, we must have m &gt;= n.  Knuth&#x27;s Algorithm D also requires\n that the dividend be at least as long as the divisor.  (In his terms,\n m &gt;= 0 (unstated).  Therefore m+n &gt;= n.) */\n\ntemplate &lt;typename limb_t&gt;\nvoid ubint&lt;limb_t&gt;::divqr_vect(ubint&amp; qin, ubint&amp; rin, const ubint&amp; uin, const ubint&amp; vin) const noexcept {\n    auto&amp; u = uin.m_value;\n    int m   = u.size();\n    auto&amp; v = vin.m_value;\n    int n   = v.size();\n    auto&amp; q = qin.m_value;\n    q.resize(m - n + 1);\n    auto&amp; r = rin.m_value;\n    Dlimb_t ofl{0};\n\n    if (n == 1) {\n        for (int i = m - 1; i &gt;= 0; --i) {\n            ofl  = (ofl &lt;&lt; m_limbBitLength) | u[i];\n            q[i] = static_cast&lt;limb_t&gt;(ofl / v[0]);\n            ofl %= v[0];\n        }\n        qin.NormalizeLimbs();\n\n        r.resize(1);\n        r[0]      = static_cast&lt;limb_t&gt;(ofl);\n        rin.m_MSB = lbcrypto::GetMSB(r[0]);\n        return;\n    }\n\n    // Normalize by shifting v left just enough so that its high-order\n    // bit is set, and shift u left the same amount. We may have to append a\n    // high-order digit on the dividend; we do that unconditionally.\n\n    auto sl{m_limbBitLength - lbcrypto::GetMSB(v.back())};\n    std::vector&lt;limb_t&gt; vn(n);\n    ofl = 0;\n    for (int i = 0; i &lt; n; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(v[i]) &lt;&lt; sl;\n        vn[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    std::vector&lt;limb_t&gt; un(m + 1);\n    ofl = 0;\n    for (int i = 0; i &lt; m; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(u[i]) &lt;&lt; sl;\n        un[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    un[m] = static_cast&lt;limb_t&gt;(ofl);\n    Dlimb_t qhat, rhat, p;\n    for (int j = m - n; j &gt;= 0; --j) {\n        ofl  = (static_cast&lt;Dlimb_t&gt;(un[j + n]) &lt;&lt; m_limbBitLength) | un[j + n - 1];\n        qhat = ofl / vn[n - 1];\n        rhat = ofl % vn[n - 1];\n        while ((qhat &gt;&gt; m_limbBitLength) || ((qhat * vn[n - 2]) &gt; ((rhat &lt;&lt; m_limbBitLength) | un[j + n - 2]))) {\n            qhat -= 1;\n            rhat += vn[n - 1];\n            if (rhat &gt;&gt; m_limbBitLength)\n                break;\n        }\n        SDlimb_t k{0}, t;\n        for (int i = 0; i &lt; n; ++i) {\n            p         = qhat * vn[i];\n            t         = un[i + j] - k - (p &amp; m_MaxLimb);\n            un[i + j] = static_cast&lt;limb_t&gt;(t);\n            k         = (p &gt;&gt; m_limbBitLength) - (t &gt;&gt; m_limbBitLength);\n        }\n        t         = un[j + n] - k;\n        un[j + n] = static_cast&lt;limb_t&gt;(t);\n        q[j]      = qhat;\n        if (t &lt; 0) {\n            q[j] -= 1;\n            k = 0;\n            for (int i = 0; i &lt; n; ++i) {\n                t         = static_cast&lt;Dlimb_t&gt;(un[i + j]) + vn[i] + k;\n                un[i + j] = static_cast&lt;limb_t&gt;(t);\n                k         = t &gt;&gt; m_limbBitLength;\n            }\n            un[j + n] += k;\n        }\n    }\n    qin.NormalizeLimbs();\n\n    ofl = un[0] &gt;&gt; sl;\n    auto sr{m_limbBitLength - sl};\n    r.resize(n--);\n    for (int i = 0; i &lt; n; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(un[i + 1]) &lt;&lt; sr;\n        r[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    r[n] = un[n] &gt;&gt; sl;\n    rin.NormalizeLimbs();\n}\n\ntemplate &lt;typename limb_t&gt;\nvoid ubint&lt;limb_t&gt;::divq_vect(ubint&amp; qin, const ubint&amp; uin, const ubint&amp; vin) const noexcept {\n    auto&amp; u = uin.m_value;\n    int m   = u.size();\n    auto&amp; v = vin.m_value;\n    int n   = v.size();\n    auto&amp; q = qin.m_value;\n    q.resize(m - n + 1);\n    Dlimb_t ofl{0};\n\n    if (n == 1) {\n        for (int i = m - 1; i &gt;= 0; --i) {\n            ofl  = (ofl &lt;&lt; m_limbBitLength) | u[i];\n            q[i] = static_cast&lt;limb_t&gt;(ofl / v[0]);\n            ofl %= v[0];\n        }\n        qin.NormalizeLimbs();\n        return;\n    }\n\n    auto sl{m_limbBitLength - lbcrypto::GetMSB(v.back())};\n    std::vector&lt;limb_t&gt; vn(n);\n    ofl = 0;\n    for (int i = 0; i &lt; n; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(v[i]) &lt;&lt; sl;\n        vn[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    std::vector&lt;limb_t&gt; un(m + 1);\n    ofl = 0;\n    for (int i = 0; i &lt; m; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(u[i]) &lt;&lt; sl;\n        un[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    un[m] = static_cast&lt;limb_t&gt;(ofl);\n    Dlimb_t qhat, rhat, p;\n    for (int j = m - n; j &gt;= 0; --j) {\n        ofl  = (static_cast&lt;Dlimb_t&gt;(un[j + n]) &lt;&lt; m_limbBitLength) | un[j + n - 1];\n        qhat = ofl / vn[n - 1];\n        rhat = ofl % vn[n - 1];\n        while ((qhat &gt;&gt; m_limbBitLength) || ((qhat * vn[n - 2]) &gt; ((rhat &lt;&lt; m_limbBitLength) | un[j + n - 2]))) {\n            qhat -= 1;\n            rhat += vn[n - 1];\n            if (rhat &gt;&gt; m_limbBitLength)\n                break;\n        }\n        SDlimb_t k{0}, t;\n        for (int i = 0; i &lt; n; ++i) {\n            p         = qhat * vn[i];\n            t         = un[i + j] - k - (p &amp; m_MaxLimb);\n            un[i + j] = static_cast&lt;limb_t&gt;(t);\n            k         = (p &gt;&gt; m_limbBitLength) - (t &gt;&gt; m_limbBitLength);\n        }\n        t         = un[j + n] - k;\n        un[j + n] = static_cast&lt;limb_t&gt;(t);\n        q[j]      = qhat;\n        if (t &lt; 0) {\n            q[j] -= 1;\n            k = 0;\n            for (int i = 0; i &lt; n; ++i) {\n                t         = static_cast&lt;Dlimb_t&gt;(un[i + j]) + vn[i] + k;\n                un[i + j] = static_cast&lt;limb_t&gt;(t);\n                k         = t &gt;&gt; m_limbBitLength;\n            }\n            un[j + n] += k;\n        }\n    }\n    qin.NormalizeLimbs();\n}\n\ntemplate &lt;typename limb_t&gt;\nvoid ubint&lt;limb_t&gt;::divr_vect(ubint&amp; rin, const ubint&amp; uin, const ubint&amp; vin) const noexcept {\n    auto&amp; u = uin.m_value;\n    int m   = u.size();\n    auto&amp; v = vin.m_value;\n    int n   = v.size();\n    auto&amp; r = rin.m_value;\n    Dlimb_t ofl{0};\n\n    if (n == 1) {\n        std::vector&lt;limb_t&gt; q(m - n + 1);\n        for (int i = m - 1; i &gt;= 0; --i) {\n            ofl  = (ofl &lt;&lt; m_limbBitLength) | u[i];\n            q[i] = static_cast&lt;limb_t&gt;(ofl / v[0]);\n            ofl %= v[0];\n        }\n        r[0]      = static_cast&lt;limb_t&gt;(ofl);\n        rin.m_MSB = lbcrypto::GetMSB(r[0]);\n        return;\n    }\n\n    auto sl{m_limbBitLength - lbcrypto::GetMSB(v.back())};\n    std::vector&lt;limb_t&gt; vn(n);\n    ofl = 0;\n    for (int i = 0; i &lt; n; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(v[i]) &lt;&lt; sl;\n        vn[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    std::vector&lt;limb_t&gt; un(m + 1);\n    ofl = 0;\n    for (int i = 0; i &lt; m; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(u[i]) &lt;&lt; sl;\n        un[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    un[m] = static_cast&lt;limb_t&gt;(ofl);\n    Dlimb_t qhat, rhat, p;\n    for (int j = m - n; j &gt;= 0; --j) {\n        ofl  = (static_cast&lt;Dlimb_t&gt;(un[j + n]) &lt;&lt; m_limbBitLength) | un[j + n - 1];\n        qhat = ofl / vn[n - 1];\n        rhat = ofl % vn[n - 1];\n        while ((qhat &gt;&gt; m_limbBitLength) || ((qhat * vn[n - 2]) &gt; ((rhat &lt;&lt; m_limbBitLength) | un[j + n - 2]))) {\n            qhat -= 1;\n            rhat += vn[n - 1];\n            if (rhat &gt;&gt; m_limbBitLength)\n                break;\n        }\n        SDlimb_t k{0}, t;\n        for (int i = 0; i &lt; n; ++i) {\n            p         = qhat * vn[i];\n            t         = un[i + j] - k - (p &amp; m_MaxLimb);\n            un[i + j] = static_cast&lt;limb_t&gt;(t);\n            k         = (p &gt;&gt; m_limbBitLength) - (t &gt;&gt; m_limbBitLength);\n        }\n        t         = un[j + n] - k;\n        un[j + n] = static_cast&lt;limb_t&gt;(t);\n        if (t &lt; 0) {\n            k = 0;\n            for (int i = 0; i &lt; n; ++i) {\n                t         = static_cast&lt;Dlimb_t&gt;(un[i + j]) + vn[i] + k;\n                un[i + j] = static_cast&lt;limb_t&gt;(t);\n                k         = t &gt;&gt; m_limbBitLength;\n            }\n            un[j + n] += k;\n        }\n    }\n\n    r.resize(n--);\n    ofl = un[0] &gt;&gt; sl;\n    auto sr{m_limbBitLength - sl};\n    for (int i = 0; i &lt; n; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(un[i + 1]) &lt;&lt; sr;\n        r[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    r[n] = un[n] &gt;&gt; sl;\n    rin.NormalizeLimbs();\n}\n\n// Initializes the vector of limbs from the string equivalent of ubint\n// Algorithm used is repeated division by 2\n// Reference:http://pctechtips.org/convert-from-decimal-to-binary-with-recursion-in-java/\ntemplate &lt;typename limb_t&gt;\nvoid ubint&lt;limb_t&gt;::SetValue(const std::string&amp; vin) {\n    std::string v{vin};\n    // v.erase(0, v.find_first_not_of(&#x27; &#x27;));\n    v.erase(0, v.find_first_not_of(&#x27;0&#x27;));\n    if (v.size() == 0)\n        v = &quot;0&quot;;\n\n    size_t arrSize = v.length() - 1;\n    for (size_t i = 0; i &lt;= arrSize; ++i)\n        v[i] -= &#x27;0&#x27;;\n\n    m_value.clear();\n    //    m_value.reserve(MSBToLimbs(arrSize &lt;&lt; 2));\n    usint cnt{0};\n    limb_t val{0};\n    size_t zptr{0};\n    while (zptr &lt;= arrSize) {\n        val |= static_cast&lt;limb_t&gt;(v[arrSize] &amp; 0x1) &lt;&lt; cnt++;\n        for (size_t i = zptr; i &lt; arrSize; ++i) {\n            v[i + 1] += (v[i] &amp; 0x1) * 10;\n            v[i] &gt;&gt;= 1;\n        }\n        v[arrSize] &gt;&gt;= 1;\n        if (v[zptr] == 0)\n            zptr++;\n\n        if ((cnt == m_limbBitLength) || (zptr &gt; arrSize)) {\n            m_value.push_back(val);\n            cnt = val = 0;\n        }\n    }\n    ubint&lt;limb_t&gt;::NormalizeLimbs();\n}\n\ntemplate &lt;typename limb_t&gt;\nuschar ubint&lt;limb_t&gt;::GetBitAtIndex(usint index) const {\n    constexpr usint mask{m_limbBitLength - 1};\n    if (index &gt; m_MSB)\n        return 0;\n    size_t idx{MSBToLimbs(index) - 1};\n    index &amp;= mask;\n    return static_cast&lt;uschar&gt;((m_value[idx] &gt;&gt; (index ? index - 1 : mask)) &amp; 0x1);\n}\n\ntemplate class bigintdyn::ubint&lt;expdtype&gt;;\n\n    #if 0\n// to stream internal representation\ntemplate std::ostream&amp; operator&lt;&lt;&lt;expdtype&gt;(std::ostream&amp; os, const std::vector&lt;expdtype&gt;&amp; v);\n    #endif\n\n}  // namespace bigintdyn\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Creates Represents integer lattice elements\n */\n\n#ifndef LBCRYPTO_INC_LATTICE_HAL_DEFAULT_POLY_H\n#define LBCRYPTO_INC_LATTICE_HAL_DEFAULT_POLY_H\n\n#include &quot;lattice/hal/poly-interface.h&quot;\n#include &quot;lattice/ildcrtparams.h&quot;\n#include &quot;lattice/ilparams.h&quot;\n\n#include &quot;math/distrgen.h&quot;\n#include &quot;math/math-hal.h&quot;\n#include &quot;math/nbtheory.h&quot;\n\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/inttypes.h&quot;\n\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\nnamespace lbcrypto {\n\n/**\n * @class PolyImpl\n * @file poly.h\n * @brief Ideal lattice using a vector representation\n */\ntemplate &lt;typename VecType&gt;\nclass PolyImpl final : public PolyInterface&lt;PolyImpl&lt;VecType&gt;, VecType, PolyImpl&gt; {\npublic:\n    using Vector            = VecType;\n    using Integer           = typename VecType::Integer;\n    using Params            = ILParamsImpl&lt;Integer&gt;;\n    using PolyNative        = PolyImpl&lt;NativeVector&gt;;\n    using PolyType          = PolyImpl&lt;VecType&gt;;\n    using PolyLargeType     = PolyImpl&lt;VecType&gt;;\n    using PolyInterfaceType = PolyInterface&lt;PolyImpl&lt;VecType&gt;, VecType, PolyImpl&gt;;\n    using DggType           = typename PolyInterfaceType::DggType;\n    using DugType           = typename PolyInterfaceType::DugType;\n    using TugType           = typename PolyInterfaceType::TugType;\n    using BugType           = typename PolyInterfaceType::BugType;\n\n    constexpr PolyImpl() = default;\n\n    PolyImpl(const std::shared_ptr&lt;Params&gt;&amp; params, Format format = Format::EVALUATION,\n             bool initializeElementToZero = false)\n        : m_format{format}, m_params{params} {\n        if (initializeElementToZero)\n            PolyImpl::SetValuesToZero();\n    }\n    PolyImpl(const std::shared_ptr&lt;ILDCRTParams&lt;Integer&gt;&gt;&amp; params, Format format = Format::EVALUATION,\n             bool initializeElementToZero = false);\n\n    PolyImpl(bool initializeElementToMax, const std::shared_ptr&lt;Params&gt;&amp; params, Format format = Format::EVALUATION)\n        : m_format{format}, m_params{params} {\n        if (initializeElementToMax)\n            PolyImpl::SetValuesToMax();\n    }\n    PolyImpl(const DggType&amp; dgg, const std::shared_ptr&lt;Params&gt;&amp; params, Format format = Format::EVALUATION);\n    PolyImpl(DugType&amp; dug, const std::shared_ptr&lt;Params&gt;&amp; params, Format format = Format::EVALUATION);\n    PolyImpl(const BugType&amp; bug, const std::shared_ptr&lt;Params&gt;&amp; params, Format format = Format::EVALUATION);\n    PolyImpl(const TugType&amp; tug, const std::shared_ptr&lt;Params&gt;&amp; params, Format format = Format::EVALUATION,\n             uint32_t h = 0);\n\n    template &lt;typename T = VecType&gt;\n    PolyImpl(const PolyNative&amp; rhs, Format format,\n             typename std::enable_if_t&lt;std::is_same_v&lt;T, NativeVector&gt;, bool&gt; = true)\n        : m_format{rhs.m_format},\n          m_params{rhs.m_params},\n          m_values{rhs.m_values ? std::make_unique&lt;VecType&gt;(*rhs.m_values) : nullptr} {\n        PolyImpl&lt;VecType&gt;::SetFormat(format);\n    }\n\n    template &lt;typename T = VecType&gt;\n    PolyImpl(const PolyNative&amp; rhs, Format format,\n             typename std::enable_if_t&lt;!std::is_same_v&lt;T, NativeVector&gt;, bool&gt; = true)\n        : m_format{rhs.GetFormat()} {\n        auto c{rhs.GetParams()-&gt;GetCyclotomicOrder()};\n        auto m{rhs.GetParams()-&gt;GetModulus().ConvertToInt()};\n        auto r{rhs.GetParams()-&gt;GetRootOfUnity().ConvertToInt()};\n        m_params = std::make_shared&lt;PolyImpl::Params&gt;(c, m, r);\n\n        const auto&amp; v{rhs.GetValues()};\n        uint32_t vlen{m_params-&gt;GetRingDimension()};\n        VecType tmp(vlen);\n        tmp.SetModulus(m_params-&gt;GetModulus());\n        for (uint32_t i{0}; i &lt; vlen; ++i)\n            tmp[i] = Integer(v[i]);\n        m_values = std::make_unique&lt;VecType&gt;(tmp);\n        PolyImpl&lt;VecType&gt;::SetFormat(format);\n    }\n\n    PolyImpl(const PolyType&amp; p) noexcept\n        : m_format{p.m_format},\n          m_params{p.m_params},\n          m_values{p.m_values ? std::make_unique&lt;VecType&gt;(*p.m_values) : nullptr} {}\n\n    PolyImpl(PolyType&amp;&amp; p) noexcept\n        : m_format{p.m_format}, m_params{std::move(p.m_params)}, m_values{std::move(p.m_values)} {}\n\n    PolyType&amp; operator=(const PolyType&amp; rhs) noexcept override;\n    PolyType&amp; operator=(PolyType&amp;&amp; rhs) noexcept override {\n        m_format = std::move(rhs.m_format);\n        m_params = std::move(rhs.m_params);\n        m_values = std::move(rhs.m_values);\n        return *this;\n    }\n    PolyType&amp; operator=(const std::vector&lt;int32_t&gt;&amp; rhs);\n    PolyType&amp; operator=(const std::vector&lt;int64_t&gt;&amp; rhs);\n    PolyType&amp; operator=(std::initializer_list&lt;uint64_t&gt; rhs) override;\n    PolyType&amp; operator=(std::initializer_list&lt;std::string&gt; rhs);\n    PolyType&amp; operator=(uint64_t val);\n\n    PolyNative DecryptionCRTInterpolate(PlaintextModulus ptm) const override;\n    PolyNative ToNativePoly() const final {\n        usint vlen{m_params-&gt;GetRingDimension()};\n        auto c{m_params-&gt;GetCyclotomicOrder()};\n        NativeInteger m{std::numeric_limits&lt;BasicInteger&gt;::max()};\n        auto params{std::make_shared&lt;ILParamsImpl&lt;NativeInteger&gt;&gt;(c, m, 1)};\n        typename PolyImpl&lt;VecType&gt;::PolyNative tmp(params, m_format, true);\n        for (usint i = 0; i &lt; vlen; ++i)\n            tmp[i] = NativeInteger((*m_values)[i]);\n        return tmp;\n    }\n\n    void SetValues(const VecType&amp; values, Format format) override;\n    void SetValues(VecType&amp;&amp; values, Format format) override;\n\n    void SetValuesToZero() override {\n        usint r{m_params-&gt;GetRingDimension()};\n        m_values = std::make_unique&lt;VecType&gt;(r, m_params-&gt;GetModulus());\n    }\n\n    void SetValuesToMax() override {\n        usint r{m_params-&gt;GetRingDimension()};\n        auto max{m_params-&gt;GetModulus() - Integer(1)};\n        m_values = std::make_unique&lt;VecType&gt;(r, m_params-&gt;GetModulus(), max);\n    }\n\n    inline Format GetFormat() const final {\n        return m_format;\n    }\n\n    void OverrideFormat(const Format f) final {\n        m_format = f;\n    }\n\n    inline const std::shared_ptr&lt;Params&gt;&amp; GetParams() const {\n        return m_params;\n    }\n\n    inline const VecType&amp; GetValues() const final {\n        if (m_values == nullptr)\n            &quot;hey&quot;; OPENFHE_THROW(not_available_error, &quot;No values in PolyImpl&quot;);\n        return *m_values;\n    }\n\n    inline bool IsEmpty() const final {\n        return m_values == nullptr;\n    }\n\n    inline Integer&amp; at(usint i) final {\n        if (m_values == nullptr)\n            &quot;hey&quot;; OPENFHE_THROW(not_available_error, &quot;No values in PolyImpl&quot;);\n        return m_values-&gt;at(i);\n    }\n\n    inline const Integer&amp; at(usint i) const final {\n        if (m_values == nullptr)\n            &quot;hey&quot;; OPENFHE_THROW(not_available_error, &quot;No values in PolyImpl&quot;);\n        return m_values-&gt;at(i);\n    }\n\n    inline Integer&amp; operator[](usint i) final {\n        return (*m_values)[i];\n    }\n\n    inline const Integer&amp; operator[](usint i) const final {\n        return (*m_values)[i];\n    }\n\n    PolyImpl Plus(const PolyImpl&amp; rhs) const override {\n        if (m_params-&gt;GetRingDimension() != rhs.m_params-&gt;GetRingDimension())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;RingDimension missmatch&quot;);\n        if (m_params-&gt;GetModulus() != rhs.m_params-&gt;GetModulus())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Modulus missmatch&quot;);\n        if (m_format != rhs.m_format)\n            &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;Format missmatch&quot;);\n        auto tmp(*this);\n        tmp.m_values-&gt;ModAddNoCheckEq(*rhs.m_values);\n        return tmp;\n    }\n    PolyImpl PlusNoCheck(const PolyImpl&amp; rhs) const {\n        auto tmp(*this);\n        tmp.m_values-&gt;ModAddNoCheckEq(*rhs.m_values);\n        return tmp;\n    }\n    PolyImpl&amp; operator+=(const PolyImpl&amp; element) override;\n\n    PolyImpl Plus(const Integer&amp; element) const override;\n    PolyImpl&amp; operator+=(const Integer&amp; element) override {\n        return *this = this-&gt;Plus(element);  // don&#x27;t change this\n    }\n\n    PolyImpl Minus(const PolyImpl&amp; element) const override;\n    PolyImpl&amp; operator-=(const PolyImpl&amp; element) override;\n\n    PolyImpl Minus(const Integer&amp; element) const override;\n    PolyImpl&amp; operator-=(const Integer&amp; element) override {\n        m_values-&gt;ModSubEq(element);\n        return *this;\n    }\n\n    PolyImpl Times(const PolyImpl&amp; rhs) const override {\n        if (m_params-&gt;GetRingDimension() != rhs.m_params-&gt;GetRingDimension())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;RingDimension missmatch&quot;);\n        if (m_params-&gt;GetModulus() != rhs.m_params-&gt;GetModulus())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Modulus missmatch&quot;);\n        if (m_format != Format::EVALUATION || rhs.m_format != Format::EVALUATION)\n            &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;operator* for PolyImpl supported only in Format::EVALUATION&quot;);\n        auto tmp(*this);\n        tmp.m_values-&gt;ModMulNoCheckEq(*rhs.m_values);\n        return tmp;\n    }\n    PolyImpl TimesNoCheck(const PolyImpl&amp; rhs) const {\n        auto tmp(*this);\n        tmp.m_values-&gt;ModMulNoCheckEq(*rhs.m_values);\n        return tmp;\n    }\n    PolyImpl&amp; operator*=(const PolyImpl&amp; rhs) override {\n        if (m_params-&gt;GetRingDimension() != rhs.m_params-&gt;GetRingDimension())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;RingDimension missmatch&quot;);\n        if (m_params-&gt;GetModulus() != rhs.m_params-&gt;GetModulus())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Modulus missmatch&quot;);\n        if (m_format != Format::EVALUATION || rhs.m_format != Format::EVALUATION)\n            &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;operator* for PolyImpl supported only in Format::EVALUATION&quot;);\n        if (m_values) {\n            m_values-&gt;ModMulNoCheckEq(*rhs.m_values);\n            return *this;\n        }\n        m_values = std::make_unique&lt;VecType&gt;(m_params-&gt;GetRingDimension(), m_params-&gt;GetModulus());\n        return *this;\n    }\n\n    PolyImpl Times(const Integer&amp; element) const override;\n    PolyImpl&amp; operator*=(const Integer&amp; element) override {\n        m_values-&gt;ModMulEq(element);\n        return *this;\n    }\n\n    PolyImpl Times(NativeInteger::SignedNativeInt element) const override;\n#if NATIVEINT != 64\n    inline PolyImpl Times(int64_t element) const {\n        return this-&gt;Times(static_cast&lt;NativeInteger::SignedNativeInt&gt;(element));\n    }\n#endif\n\n    PolyImpl MultiplyAndRound(const Integer&amp; p, const Integer&amp; q) const override;\n    PolyImpl DivideAndRound(const Integer&amp; q) const override;\n\n    PolyImpl Negate() const override;\n    inline PolyImpl operator-() const override {\n        return PolyImpl(m_params, m_format, true) -= *this;\n    }\n\n    inline bool operator==(const PolyImpl&amp; rhs) const override {\n        return ((m_format == rhs.GetFormat()) &amp;&amp; (m_params-&gt;GetRootOfUnity() == rhs.GetRootOfUnity()) &amp;&amp;\n                (this-&gt;GetValues() == rhs.GetValues()));\n    }\n\n    void AddILElementOne() override;\n    PolyImpl AutomorphismTransform(uint32_t k) const override;\n    PolyImpl AutomorphismTransform(uint32_t k, const std::vector&lt;uint32_t&gt;&amp; vec) const override;\n    PolyImpl MultiplicativeInverse() const override;\n    PolyImpl ModByTwo() const override;\n    PolyImpl Mod(const Integer&amp; modulus) const override;\n\n    void SwitchModulus(const Integer&amp; modulus, const Integer&amp; rootOfUnity, const Integer&amp; modulusArb,\n                       const Integer&amp; rootOfUnityArb) override;\n    void SwitchFormat() override;\n    void MakeSparse(uint32_t wFactor) override;\n    bool InverseExists() const override;\n    double Norm() const override;\n    std::vector&lt;PolyImpl&gt; BaseDecompose(usint baseBits, bool evalModeAnswer) const override;\n    std::vector&lt;PolyImpl&gt; PowersOfBase(usint baseBits) const override;\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::make_nvp(&quot;v&quot;, m_values));\n        ar(::cereal::make_nvp(&quot;f&quot;, m_format));\n        ar(::cereal::make_nvp(&quot;p&quot;, m_params));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                 &quot; is from a later version of the library&quot;);\n        }\n        ar(::cereal::make_nvp(&quot;v&quot;, m_values));\n        ar(::cereal::make_nvp(&quot;f&quot;, m_format));\n        ar(::cereal::make_nvp(&quot;p&quot;, m_params));\n    }\n\n    static const std::string GetElementName() {\n        return &quot;PolyImpl&quot;;\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;Poly&quot;;\n    }\n\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\nprotected:\n    Format m_format{Format::EVALUATION};\n    std::shared_ptr&lt;Params&gt; m_params{nullptr};\n    std::unique_ptr&lt;VecType&gt; m_values{nullptr};\n    void ArbitrarySwitchFormat();\n};\n\n// TODO: fix issue with pke build system so this can be moved back to implementation file\ntemplate &lt;&gt;\ninline PolyImpl&lt;BigVector&gt;::PolyImpl(const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt;&amp; params, Format format,\n                                     bool initializeElementToZero)\n    : m_format(format), m_params(nullptr), m_values(nullptr) {\n    const auto c = params-&gt;GetCyclotomicOrder();\n    const auto m = params-&gt;GetModulus();\n    m_params     = std::make_shared&lt;ILParams&gt;(c, m, 1);\n    if (initializeElementToZero)\n        this-&gt;SetValuesToZero();\n}\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp": {"id": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  This file contains the cpp implementation of  mubintvec, a &lt;vector&gt; of ubint, with associated math operators\n */\n\n#include &quot;config_core.h&quot;\n#ifdef WITH_BE4\n\n    #include &quot;math/math-hal.h&quot;\n    #include &quot;math/hal/bigintdyn/mubintvecdyn.h&quot;\n\n    #include &quot;utils/exception.h&quot;\n    #include &quot;utils/inttypes.h&quot;\n    #include &quot;utils/serializable.h&quot;\n\n//    #include &quot;time.h&quot;\n//    #include &lt;chrono&gt;\n    #include &lt;initializer_list&gt;\n    #include &lt;string&gt;\n    #include &lt;vector&gt;\n\nnamespace bigintdyn {\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;::mubintvec(usint length, const ubint_el_t&amp; modulus,\n                                 std::initializer_list&lt;std::string&gt; rhs) noexcept\n    : m_modulus{modulus}, m_modulus_state{State::INITIALIZED}, m_data(length) {\n    const size_t len = (rhs.size() &lt; m_data.size()) ? rhs.size() : m_data.size();\n    for (size_t i = 0; i &lt; len; ++i)\n        m_data[i] = ubint_el_t(*(rhs.begin() + i)) % m_modulus;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;::mubintvec(usint length, const ubint_el_t&amp; modulus, std::initializer_list&lt;uint64_t&gt; rhs) noexcept\n    : m_modulus{modulus}, m_modulus_state{State::INITIALIZED}, m_data(length) {\n    const size_t len = (rhs.size() &lt; m_data.size()) ? rhs.size() : m_data.size();\n    for (size_t i = 0; i &lt; len; ++i)\n        m_data[i] = ubint_el_t(*(rhs.begin() + i)) % m_modulus;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;::mubintvec(const std::vector&lt;std::string&gt;&amp; s, const ubint_el_t&amp; modulus) noexcept\n    : m_modulus{modulus}, m_modulus_state{State::INITIALIZED}, m_data(s.size()) {\n    for (size_t i = 0; i &lt; s.size(); ++i)\n        m_data[i] = ubint_el_t(s[i]) % m_modulus;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;::mubintvec(const std::vector&lt;std::string&gt;&amp; s, const std::string&amp; modulus) noexcept\n    : m_modulus{modulus}, m_modulus_state{State::INITIALIZED}, m_data(s.size()) {\n    for (size_t i = 0; i &lt; s.size(); ++i)\n        m_data[i] = ubint_el_t(s[i]) % m_modulus;\n}\n\n// if two vectors are different sized, then it will resize target vector\n// will overwrite target modulus\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::operator=(const mubintvec&amp; rhs) noexcept {\n    m_modulus       = rhs.m_modulus;\n    m_modulus_state = rhs.m_modulus_state;\n    if (rhs.m_data.size() &gt; m_data.size()) {\n        m_data = rhs.m_data;\n        return *this;\n    }\n    std::copy(rhs.m_data.begin(), rhs.m_data.end(), m_data.begin());\n    if (m_data.size() &gt; rhs.m_data.size())\n        m_data.resize(rhs.m_data.size());\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::operator=(std::initializer_list&lt;std::string&gt; rhs) noexcept {\n    const size_t len = rhs.size();\n    if (m_data.size() &lt; len)\n        m_data.resize(len);\n    const auto reduce = (m_modulus_state == State::INITIALIZED &amp;&amp; m_modulus);\n    for (size_t i = 0; i &lt; m_data.size(); ++i) {\n        if (i &lt; len) {\n            m_data[i] = ubint_el_t(*(rhs.begin() + i));\n            if (reduce)\n                m_data[i].ModEq(m_modulus);\n        }\n        else {\n            m_data[i] = 0;\n        }\n    }\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::operator=(std::initializer_list&lt;uint64_t&gt; rhs) noexcept {\n    const size_t len = rhs.size();\n    if (m_data.size() &lt; len)\n        m_data.resize(len);\n    const auto reduce = (m_modulus_state == State::INITIALIZED &amp;&amp; m_modulus);\n    for (size_t i = 0; i &lt; m_data.size(); ++i) {\n        if (i &lt; len) {\n            m_data[i] = ubint_el_t(*(rhs.begin() + i));\n            if (reduce)\n                m_data[i].ModEq(m_modulus);\n        }\n        else {\n            m_data[i] = 0;\n        }\n    }\n    return *this;\n}\n\n/**Switches the integers in the vector to values corresponding to the new\n * modulus Algorithm: Integer i, Old Modulus om, New Modulus nm, delta =\n * abs(om-nm): Case 1: om &lt; nm if i &gt; i &gt; om/2 i&#x27; = i + delta Case 2: om &gt; nm i\n * &gt; om/2 i&#x27; = i-delta\n */\ntemplate &lt;class ubint_el_t&gt;\nvoid mubintvec&lt;ubint_el_t&gt;::SwitchModulus(const ubint_el_t&amp; modulus) {\n    auto size{m_data.size()};\n    auto halfQ{m_modulus &gt;&gt; 1};\n    if (modulus &gt; m_modulus) {\n        auto diff{modulus - m_modulus};\n        for (size_t i = 0; i &lt; size; ++i) {\n            if (m_data[i] &gt; halfQ)\n                m_data[i] += diff;\n        }\n    }\n    else {\n        auto diff{modulus - (m_modulus % modulus)};\n        for (size_t i = 0; i &lt; size; ++i) {\n            if (m_data[i] &gt; halfQ)\n                m_data[i] += diff;\n            if (m_data[i] &gt;= modulus)\n                m_data[i] %= modulus;\n        }\n    }\n    this-&gt;SetModulus(modulus);\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::Mod(const ubint_el_t&amp; modulus) const {\n    auto ans(*this);\n    if (modulus == 2)\n        return ans.ModByTwoEq();\n    auto size{m_data.size()};\n    auto halfQ{m_modulus &gt;&gt; 1};\n    if (modulus &gt; m_modulus) {\n        auto diff{modulus - m_modulus};\n        for (size_t i = 0; i &lt; size; ++i) {\n            if (ans.m_data[i] &gt; halfQ)\n                ans.m_data[i] += diff;\n        }\n    }\n    else {\n        auto diff{modulus - (m_modulus % modulus)};\n        for (size_t i = 0; i &lt; size; ++i) {\n            if (ans.m_data[i] &gt; halfQ)\n                ans.m_data[i] += diff;\n            if (ans.m_data[i] &gt;= modulus)\n                ans.m_data[i] %= modulus;\n        }\n    }\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModEq(const ubint_el_t&amp; modulus) {\n    if (modulus == 2)\n        return this-&gt;ModByTwoEq();\n    auto size{m_data.size()};\n    auto halfQ{m_modulus &gt;&gt; 1};\n    if (modulus &gt; m_modulus) {\n        auto diff{modulus - m_modulus};\n        for (size_t i = 0; i &lt; size; ++i) {\n            if (m_data[i] &gt; halfQ)\n                m_data[i] += diff;\n        }\n    }\n    else {\n        auto diff{modulus - (m_modulus % modulus)};\n        for (size_t i = 0; i &lt; size; ++i) {\n            if (m_data[i] &gt; halfQ)\n                m_data[i] += diff;\n            if (m_data[i] &gt;= modulus)\n                m_data[i] %= modulus;\n        }\n    }\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModAdd(const ubint_el_t&amp; b) const {\n    auto ans(*this);\n    auto modulus(m_modulus);\n    auto bLocal(b);\n    if (bLocal &gt;= modulus)\n        bLocal.ModEq(modulus);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModAddFastEq(bLocal, modulus);\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModAddEq(const ubint_el_t&amp; b) {\n    auto modulus{m_modulus};\n    auto bLocal{b};\n    if (bLocal &gt;= modulus)\n        bLocal.ModEq(modulus);\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModAddFastEq(bLocal, modulus);\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModAddAtIndex(size_t i, const ubint_el_t&amp; b) const {\n    auto ans(*this);\n    ans.at(i).ModAddEq(b, m_modulus);\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModAddAtIndexEq(size_t i, const ubint_el_t&amp; b) {\n    this-&gt;mubintvec::at(i).ModAddEq(b, m_modulus);\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModAdd(const mubintvec&amp; b) const {\n    if (m_modulus != b.m_modulus)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec adding vectors of different moduli&quot;);\n    if (m_data.size() != b.m_data.size())\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec adding vectors of different lengths&quot;);\n    auto ans(*this);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModAddEq(b.m_data[i], ans.m_modulus);\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModAddEq(const mubintvec&amp; b) {\n    if (m_modulus != b.m_modulus)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec adding vectors of different moduli&quot;);\n    if (m_data.size() != b.m_data.size())\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec adding vectors of different lengths&quot;);\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModAddEq(b.m_data[i], m_modulus);\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModAddNoCheckEq(const mubintvec&amp; b) {\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModAddEq(b.m_data[i], m_modulus);\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModSub(const ubint_el_t&amp; b) const {\n    auto ans(*this);\n    auto modulus{m_modulus};\n    auto bLocal{b};\n    if (bLocal &gt;= modulus)\n        bLocal.ModEq(modulus);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModSubFastEq(bLocal, modulus);\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModSubEq(const ubint_el_t&amp; b) {\n    auto modulus{m_modulus};\n    auto bLocal{b};\n    if (bLocal &gt;= modulus)\n        bLocal.ModEq(modulus);\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModSubFastEq(bLocal, modulus);\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModSub(const mubintvec&amp; b) const {\n    if (m_modulus != b.m_modulus)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec subtractiong vectors of different moduli&quot;);\n    if (m_data.size() != b.m_data.size())\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec subtractiong vectors of different lengths&quot;);\n    auto ans(*this);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModSubEq(b.m_data[i], ans.m_modulus);\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModSubEq(const mubintvec&amp; b) {\n    if (m_modulus != b.m_modulus)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec subtractiong vectors of different moduli&quot;);\n    if (m_data.size() != b.m_data.size())\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec subtractiong vectors of different lengths&quot;);\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModSubEq(b.m_data[i], m_modulus);\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModMul(const ubint_el_t&amp; b) const {\n    auto ans(*this);\n    auto bLocal{b};\n    if (bLocal &gt;= ans.m_modulus)\n        bLocal.ModEq(ans.m_modulus);\n    #ifdef NO_BARRETT\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModMulFastEq(bLocal, ans.m_modulus);\n    #else\n    auto mu(ans.m_modulus.ComputeMu());\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModMulFastEq(bLocal, ans.m_modulus, mu);\n    #endif\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModMulEq(const ubint_el_t&amp; b) {\n    auto bLocal(b);\n    if (bLocal &gt;= m_modulus)\n        bLocal.ModEq(m_modulus);\n    #ifdef NO_BARRETT\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModMulFastEq(bLocal, m_modulus);\n    #else\n    auto mu(m_modulus.ComputeMu());\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModMulFastEq(bLocal, m_modulus, mu);\n    #endif\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModMul(const mubintvec&amp; b) const {\n    if (m_modulus != b.m_modulus)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec multiplying vectors of different moduli&quot;);\n    if (m_data.size() != b.m_data.size())\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec multiplying vectors of different lengths&quot;);\n    auto ans(*this);\n    #ifdef NO_BARRETT\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        ans[i].ModMulFastEq(b[i], ans.m_modulus);\n    #else\n    auto mu(ans.m_modulus.ComputeMu());\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModMulFastEq(b[i], ans.m_modulus, mu);\n    #endif\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModMulEq(const mubintvec&amp; b) {\n    if (m_modulus != b.m_modulus)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec multiplying vectors of different moduli&quot;);\n    if (m_data.size() != b.m_data.size())\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec multiplying vectors of different lengths&quot;);\n    #ifdef NO_BARRETT\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModMulFastEq(b[i], m_modulus);\n    #else\n    auto mu(m_modulus.ComputeMu());\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModMulFastEq(b[i], m_modulus, mu);\n    #endif\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModMulNoCheckEq(const mubintvec&amp; b) {\n    #ifdef NO_BARRETT\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModMulFastEq(b[i], m_modulus);\n    #else\n    auto mu(m_modulus.ComputeMu());\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModMulFastEq(b[i], m_modulus, mu);\n    #endif\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModExp(const ubint_el_t&amp; b) const {\n    auto ans(*this);\n    auto modulus{m_modulus};\n    auto bLocal{b};\n    if (bLocal &gt;= modulus)\n        bLocal.ModEq(modulus);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModExpEq(bLocal, modulus);\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModExpEq(const ubint_el_t&amp; b) {\n    auto modulus{m_modulus};\n    auto bLocal{b};\n    if (bLocal &gt;= modulus)\n        bLocal.ModEq(modulus);\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModExpEq(bLocal, modulus);\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModInverse() const {\n    auto ans(*this);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModInverseEq(ans.m_modulus);\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModInverseEq() {\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModInverseEq(m_modulus);\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModByTwo() const {\n    auto ans(*this);\n    auto halfQ{m_modulus &gt;&gt; 1};\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i] = ubint_el_t((ans[i].m_value[0] &amp; 0x1) ^ (ans[i] &gt; halfQ));\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModByTwoEq() {\n    auto halfQ{m_modulus &gt;&gt; 1};\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i] = ubint_el_t((m_data[i].m_value[0] &amp; 0x1) ^ (m_data[i] &gt; halfQ));\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::MultiplyAndRound(const ubint_el_t&amp; p, const ubint_el_t&amp; q) const {\n    auto ans(*this);\n    auto mv(m_modulus);\n    auto halfQ{m_modulus &gt;&gt; 1};\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i) {\n        if (ans.m_data[i] &gt; halfQ) {\n            auto&amp;&amp; tmp{mv - ans[i]};\n            ans[i] = mv - tmp.MultiplyAndRound(p, q);\n        }\n        else {\n            ans[i] = ans[i].MultiplyAndRound(p, q).Mod(mv);\n        }\n    }\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::MultiplyAndRoundEq(const ubint_el_t&amp; p, const ubint_el_t&amp; q) {\n    auto mv{m_modulus};\n    auto halfQ{m_modulus &gt;&gt; 1};\n    for (size_t i = 0; i &lt; m_data.size(); ++i) {\n        if (m_data[i] &gt; halfQ) {\n            auto&amp;&amp; tmp{mv - m_data[i]};\n            m_data[i] = mv - tmp.MultiplyAndRound(p, q);\n        }\n        else {\n            m_data[i] = m_data[i].MultiplyAndRound(p, q).Mod(mv);\n        }\n    }\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::DivideAndRound(const ubint_el_t&amp; q) const {\n    auto ans(*this);\n    auto mv{m_modulus};\n    auto halfQ{m_modulus &gt;&gt; 1};\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i) {\n        if (ans[i] &gt; halfQ) {\n            auto&amp;&amp; tmp{mv - ans[i]};\n            ans[i] = mv - tmp.DivideAndRound(q);\n        }\n        else {\n            ans[i] = ans[i].DivideAndRoundEq(q);\n        }\n    }\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::DivideAndRoundEq(const ubint_el_t&amp; q) {\n    auto mv{m_modulus};\n    auto halfQ{m_modulus &gt;&gt; 1};\n    for (size_t i = 0; i &lt; m_data.size(); ++i) {\n        if (m_data[i] &gt; halfQ) {\n            auto&amp;&amp; tmp{mv - m_data[i]};\n            m_data[i] = mv - tmp.DivideAndRound(q);\n        }\n        else {\n            m_data[i] = m_data[i].DivideAndRound(q);\n        }\n    }\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::GetDigitAtIndexForBase(usint index, usint base) const {\n    auto ans(*this);\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        ans[i] = static_cast&lt;ubint_el_t&gt;(ans[i].GetDigitAtIndexForBase(index, base));\n    return ans;\n}\n\ntemplate class mubintvec&lt;BigInteger&gt;;\n\n}  // namespace bigintdyn\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/bigintdyn/ubintdyn.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/bigintdyn/ubintdyn.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/bigintdyn/ubintdyn.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  This file contains the main class for unsigned big integers: ubint. Big integers are\n  represented as arrays of machine native unsigned integers. The native integer type is\n  supplied as a template parameter. Currently implementation based on uint32_t and uint64_t is\n  supported. a native double the base integer size is also needed.\n */\n\n#include &quot;config_core.h&quot;\n#ifdef WITH_BE4\n\n    #ifndef LBCRYPTO_MATH_HAL_BIGINTDYN_UBINTDYN_H\n        #define LBCRYPTO_MATH_HAL_BIGINTDYN_UBINTDYN_H\n\n        #include &quot;math/hal/basicint.h&quot;\n        #include &quot;math/hal/integer.h&quot;\n        #include &quot;math/nbtheory.h&quot;\n\n        #include &quot;utils/exception.h&quot;\n        #include &quot;utils/inttypes.h&quot;\n        #include &quot;utils/serializable.h&quot;\n        #include &quot;utils/utilities.h&quot;\n\n        // #include &lt;fstream&gt;\n        #include &lt;functional&gt;\n        #include &lt;iostream&gt;\n        #include &lt;limits&gt;\n        // #include &lt;memory&gt;\n        #include &lt;string&gt;\n        #include &lt;type_traits&gt;\n        // #include &lt;typeinfo&gt;\n        #include &lt;utility&gt;\n        #include &lt;vector&gt;\n\n        #if NATIVEINT &gt;= 64\n// TODO: fix shifting issues with expdtype = uint128_t\n// using expdtype = BasicInteger;\nusing expdtype = uint64_t;\n        #elif NATIVEINT == 32\nusing expdtype = BasicInteger;\n        #endif\n\n        #define _SECURE_SCL 0  // to speed up VS\n        #define NO_BARRETT     // currently barrett is slower than mod\n\nnamespace bigintdyn {\n\ntemplate &lt;typename limb_t&gt;\nclass ubint;\n\n/** Define the mapping for ExpBigInteger (experimental) */\nusing xubint     = ubint&lt;expdtype&gt;;\nusing BigInteger = xubint;\n\ntemplate &lt;class ubint_el_t&gt;\nclass mubintvec;\n\n/**\n * @brief Struct to find log 2 value of N.\n * Used in preprocessing of ubint to determine bitwidth.\n */\ntemplate &lt;usint N&gt;\nstruct Log2 {\n    static constexpr usint value = 1 + Log2&lt;N / 2&gt;::value;\n};\ntemplate &lt;&gt;\nstruct Log2&lt;2&gt; {\n    static constexpr usint value = 1;\n};\n\n// @brief A pre-computed constant of Log base 2 of 10.\n// constexpr double LOG2_10 = 3.32192809489;\n\n/**\n * @brief Struct to determine other datatyps based on utype.\n * @tparam utype primitive integer data type.\n */\ntemplate &lt;typename utype&gt;\nstruct DataTypes {\n    using SignedType       = void;\n    using DoubleType       = void;\n    using SignedDoubleType = void;\n};\ntemplate &lt;&gt;\nstruct DataTypes&lt;uint32_t&gt; {\n    using SignedType       = int32_t;\n    using DoubleType       = uint64_t;\n    using SignedDoubleType = int64_t;\n};\ntemplate &lt;&gt;\nstruct DataTypes&lt;uint64_t&gt; {\n    using SignedType = int64_t;\n        #if defined(HAVE_INT128)\n    using DoubleType       = uint128_t;\n    using SignedDoubleType = int128_t;\n        #else\n    using DoubleType       = uint64_t;\n    using SignedDoubleType = int64_t;\n        #endif\n};\n        #if defined(HAVE_INT128)\ntemplate &lt;&gt;\nstruct DataTypes&lt;uint128_t&gt; {\n    using SignedType       = int128_t;\n    using DoubleType       = uint128_t;\n    using SignedDoubleType = int128_t;\n};\n        #endif\n\ntemplate &lt;typename limb_t&gt;\nclass ubint final : public lbcrypto::BigIntegerInterface&lt;ubint&lt;limb_t&gt;&gt; {\nprivate:\n    // variable that stores the MOST SIGNIFICANT BIT position in the\n    usint m_MSB{0};\n    // vector storing the native integers. stored little endian\n    std::vector&lt;limb_t&gt; m_value{0};\n    // variable to store the maximum value of the limb data type\n    static constexpr limb_t m_MaxLimb{std::numeric_limits&lt;limb_t&gt;::max()};\n    // variable to store the bitlength of the limb data type\n    static constexpr usint m_limbBitLength{sizeof(limb_t) * 8};\n    // variable to store the log2 of the number of bits in the limb data type\n    static constexpr usint m_log2LimbBitLength{Log2&lt;sizeof(limb_t) * 8&gt;::value};\n\n    friend class mubintvec&lt;ubint&lt;limb_t&gt;&gt;;\n\npublic:\n    using Integer  = limb_t;\n    using Slimb_t  = typename DataTypes&lt;limb_t&gt;::SignedType;\n    using Dlimb_t  = typename DataTypes&lt;limb_t&gt;::DoubleType;\n    using SDlimb_t = typename DataTypes&lt;limb_t&gt;::SignedDoubleType;\n\n    ubint() = default;\n\n    explicit operator bool() noexcept {\n        return m_MSB != 0;\n    }\n\n    /**\n   * Copy constructor.\n   * @param &amp;val is the ubint to be copied.\n   */\n    ubint(const ubint&amp; val) noexcept : m_MSB{val.m_MSB}, m_value{val.m_value} {}\n\n    ubint(const std::vector&lt;limb_t&gt;&amp; v) noexcept : m_value{v} {\n        this-&gt;ubint::NormalizeLimbs();\n    }\n\n    /**\n   * Move constructor.\n   * @param &amp;&amp;val is the ubint to be copied.\n   */\n    ubint(ubint&amp;&amp; val) noexcept : m_MSB{std::move(val.m_MSB)}, m_value{std::move(val.m_value)} {}\n\n    ubint(std::vector&lt;limb_t&gt;&amp;&amp; v) noexcept : m_value{std::move(v)} {\n        this-&gt;ubint::NormalizeLimbs();\n    }\n\n    /**\n   * Constructor from a string.\n   * @param &amp;strval is the initial integer represented as a string.\n   */\n    explicit ubint(const std::string&amp; strval) {\n        this-&gt;ubint::SetValue(strval);\n    }\n    explicit ubint(const char* strval) {\n        this-&gt;ubint::SetValue(std::string(strval));\n    }\n    explicit ubint(const char strval) : ubint(limb_t(strval - &#x27;0&#x27;)) {}\n\n    /**\n   * Constructor from an unsigned integer.\n   * @param val is the initial integer represented as a uint64_t.\n   */\n    template &lt;typename T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, bool&gt; = true&gt;\n    ubint(T val) : m_MSB{lbcrypto::GetMSB(val)}, m_value{limb_t(val)} {\n        if constexpr (sizeof(T) &gt; sizeof(limb_t)) {\n            if ((val &gt;&gt;= m_limbBitLength) &gt; 0) {\n                m_value.resize(ubint::MSBToLimbs(m_MSB));\n                for (size_t i{1}; i &lt; m_value.size(); ++i, val &gt;&gt;= m_limbBitLength)\n                    m_value[i] = limb_t(val);\n            }\n        }\n    }\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;, bool&gt; = true&gt;\n    ubint(T val) = delete;\n\n    template &lt;typename T, std::enable_if_t&lt;!std::is_integral_v&lt;T&gt; &amp;&amp; !std::is_floating_point_v&lt;T&gt;, bool&gt; = true&gt;\n    ubint(T val) : ubint(BasicInteger(val)) {}\n\n    /**\n   * Copy assignment operator\n   *\n   * @param &amp;val is the ubint to be assigned from.\n   * @return assigned ubint ref.\n   */\n    ubint&amp; operator=(const ubint&amp; val) noexcept {\n        m_MSB   = val.m_MSB;\n        m_value = val.m_value;\n        return *this;\n    }\n\n    ubint&amp; operator=(const limb_t&amp; val) noexcept {\n        m_MSB = lbcrypto::GetMSB(val);\n        m_value.resize(1);\n        m_value[0] = val;\n        return *this;\n    }\n\n    ubint&amp; operator=(ubint&amp;&amp; val) noexcept {\n        if (this != &amp;val) {\n            m_MSB   = std::move(val.m_MSB);\n            m_value = std::move(val.m_value);\n        }\n        return *this;\n    }\n\n    /**\n   * Assignment operator for all other types that have not already got their own\n   * assignment operators.\n   * @param &amp;val is the value to be assign from\n   * @return the assigned BigInteger ref.\n   */\n    template &lt;typename T, std::enable_if_t&lt;!std::is_same_v&lt;T, const ubint&gt;, bool&gt; = true&gt;\n    ubint&amp; operator=(T val) {\n        return *this = ubint(val);\n    }\n\n    /**\n   * Basic set method for setting the value of a ubint\n   * @param strval is the string representation of the ubint to be copied.\n   */\n    void SetValue(const std::string&amp; strval);\n\n    /**\n   * Basic set method for setting the value of a ubint\n   * @param val is the ubint representation of the ubint to be assigned.\n   */\n    void SetValue(const ubint&amp; val) noexcept {\n        m_MSB   = val.m_MSB;\n        m_value = val.m_value;\n    }\n\n    void SetIdentity() noexcept {\n        m_MSB = 1;\n        m_value.resize(1);\n        m_value[0] = 1;\n    }\n\n    /**\n   * Addition operation.\n   *\n   * @param &amp;b is the value to add.\n   * @return result of the addition operation.\n   */\n    ubint Add(const ubint&amp; b) const;\n    ubint&amp; AddEq(const ubint&amp; b);\n\n    /**\n   * Subtraction operation.\n   *\n   * @param &amp;b is the value to subtract.\n   * @return is the result of the subtraction operation.\n   */\n    ubint Sub(const ubint&amp; b) const;\n    ubint&amp; SubEq(const ubint&amp; b);\n\n    // this is a negation operator which really doesn&#x27;t make sense for ubint\n    // TODO: returns zero due to saturated subtraction\n    ubint operator-() const {\n        // return ubint().Sub(*this);\n        return ubint();\n    }\n\n    /**\n   * Multiplication operation.\n   *\n   * @param &amp;b is the value to multiply with.\n   * @return is the result of the multiplication operation.\n   */\n    ubint Mul(const ubint&amp; b) const;\n    ubint&amp; MulEq(const ubint&amp; b) {\n        return *this = this-&gt;ubint::Mul(b);\n    }\n\n    /**\n   * Division operation.\n   *\n   * @param &amp;b is the value to divide by.\n   * @return is the result of the division operation.\n   */\n    ubint DividedBy(const ubint&amp; b) const;\n    ubint&amp; DividedByEq(const ubint&amp; b);\n\n    /**\n   * Exponentiation operation. Returns x^p.\n   *\n   * @param p the exponent.\n   * @return is the result of the exponentiation operation.\n   */\n    ubint Exp(usint p) const;\n    ubint&amp; ExpEq(usint p) {\n        return *this = this-&gt;ubint::Exp(p);\n    }\n\n    /**\n   * Multiply and Rounding operation. Returns [x*p/q] where [] is the rounding\n   * operation.\n   *\n   * @param &amp;p is the numerator to be multiplied.\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of multiply and round operation.\n   */\n    ubint MultiplyAndRound(const ubint&amp; p, const ubint&amp; q) const;\n    ubint&amp; MultiplyAndRoundEq(const ubint&amp; p, const ubint&amp; q) {\n        return *this = this-&gt;ubint::MultiplyAndRound(p, q);\n    }\n\n    /**\n   * Divide and Rounding operation. Returns [x/q] where [] is the rounding\n   * operation.\n   *\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of divide and round operation.\n   */\n    ubint DivideAndRound(const ubint&amp; q) const;\n    ubint&amp; DivideAndRoundEq(const ubint&amp; q) {\n        return *this = this-&gt;ubint::DivideAndRound(q);\n    }\n\n    /**\n   * Naive modulus operation.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @return is the result of the modulus operation.\n   */\n    ubint Mod(const ubint&amp; modulus) const;\n    ubint&amp; ModEq(const ubint&amp; modulus);\n\n    /**\n   * Pre-computes the mu factor that is used in Barrett modulo reduction\n   *\n   * @return the value of mu\n   */\n    ubint ComputeMu() const {\n        return (ubint(1) &lt;&lt; (2 * m_MSB + 3)).DividedBy(*this);\n    }\n\n    /**\n   * Barrett modulus operation.\n   * Implements generalized Barrett modular reduction algorithm. Uses one\n   * precomputed value of mu.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus operation.\n   */\n    template &lt;typename T = limb_t&gt;\n    ubint Mod(const ubint&amp; modulus, const ubint&amp; mu,\n              typename std::enable_if_t&lt;!std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) const {\n        return this-&gt;ubint::Mod(modulus);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint Mod(const ubint&amp; modulus, const ubint&amp; mu,\n              typename std::enable_if_t&lt;std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) const {\n        if (*this &lt; modulus)\n            return *this;\n        int n(modulus.m_MSB);\n        int alpha(n + 3);\n        int beta(-2);\n        ubint q(mu * this-&gt;ubint::RShift(n + beta));\n        q &gt;&gt;= alpha - beta;\n        ubint z(this-&gt;ubint::Sub(q * modulus));\n        if (z &gt;= modulus)\n            return z.Sub(modulus);\n        return z;\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint&amp; ModEq(const ubint&amp; modulus, const ubint&amp; mu,\n                 typename std::enable_if_t&lt;!std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) {\n        return this-&gt;ubint::ModEq(modulus);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint&amp; ModEq(const ubint&amp; modulus, const ubint&amp; mu,\n                 typename std::enable_if_t&lt;std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) {\n        if (*this &lt; modulus)\n            return *this;\n        int n(modulus.m_MSB);\n        int alpha(n + 3);\n        int beta(-2);\n        ubint q(mu * this-&gt;ubint::RShift(n + beta));\n        q &gt;&gt;= alpha - beta;\n        this-&gt;ubint::SubEq(q * modulus);\n        if (*this &gt;= modulus)\n            return this-&gt;ubint::SubEq(modulus);\n        return *this;\n    }\n\n    /**\n   * Modulus addition operation.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus addition operation.\n   */\n    ubint ModAdd(const ubint&amp; b, const ubint&amp; modulus) const;\n    ubint&amp; ModAddEq(const ubint&amp; b, const ubint&amp; modulus);\n\n    /**\n   * Modulus addition where operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus addition operation.\n   */\n    ubint ModAddFast(const ubint&amp; b, const ubint&amp; modulus) const;\n    ubint&amp; ModAddFastEq(const ubint&amp; b, const ubint&amp; modulus);\n\n    /**\n   * Barrett modulus addition operation.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus addition operation.\n   */\n    template &lt;typename T = limb_t&gt;\n    ubint ModAdd(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu,\n                 typename std::enable_if_t&lt;!std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) const {\n        return b.ModAdd(*this, modulus);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint ModAdd(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu,\n                 typename std::enable_if_t&lt;std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) const {\n        return b.Add(*this).Mod(modulus, mu);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint&amp; ModAddEq(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu,\n                    typename std::enable_if_t&lt;!std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) {\n        return this-&gt;ubint::ModAddEq(b, modulus);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint&amp; ModAddEq(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu,\n                    typename std::enable_if_t&lt;std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) {\n        return *this = b.Add(*this).Mod(modulus, mu);\n    }\n\n    /**\n   * Modulus subtraction operation.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    ubint ModSub(const ubint&amp; b, const ubint&amp; modulus) const;\n    ubint&amp; ModSubEq(const ubint&amp; b, const ubint&amp; modulus);\n\n    /**\n   * Modulus subtraction where operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    ubint ModSubFast(const ubint&amp; b, const ubint&amp; modulus) const;\n    ubint&amp; ModSubFastEq(const ubint&amp; b, const ubint&amp; modulus);\n\n    /**\n   * Barrett modulus subtraction operation.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus subtraction operation.\n   */\n    template &lt;typename T = limb_t&gt;\n    ubint ModSub(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu,\n                 typename std::enable_if_t&lt;!std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) const {\n        return this-&gt;ubint::ModSub(b, modulus);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint ModSub(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu,\n                 typename std::enable_if_t&lt;std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) const {\n        auto bv(b);\n        auto av(*this);\n        if (bv &gt;= modulus)\n            bv.ModEq(modulus, mu);\n        if (av &gt;= modulus)\n            av.ModEq(modulus, mu);\n        if (av &lt; bv)\n            av = modulus.Add(av);\n        return av.SubEq(bv);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint&amp; ModSubEq(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu,\n                    typename std::enable_if_t&lt;!std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) {\n        return this-&gt;ubint::ModSubEq(b, modulus);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint&amp; ModSubEq(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu,\n                    typename std::enable_if_t&lt;std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) {\n        auto bv(b);\n        if (bv &gt;= modulus)\n            bv.ModEq(modulus, mu);\n        if (*this &gt;= modulus)\n            this-&gt;ubint::ModEq(modulus, mu);\n        if (*this &lt; bv)\n            *this = modulus.Add(*this);\n        return this-&gt;ubint::SubEq(bv);\n    }\n\n    /**\n   * Modulus multiplication operation.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = limb_t&gt;\n    ubint ModMul(const ubint&amp; b, const ubint&amp; modulus,\n                 typename std::enable_if_t&lt;!std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) const {\n        auto bv(b);\n        auto av(*this);\n        if (bv &gt;= modulus)\n            bv.ModEq(modulus);\n        if (av &gt;= modulus)\n            av.ModEq(modulus);\n        return av.ModMulFast(bv, modulus);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint ModMul(const ubint&amp; b, const ubint&amp; modulus,\n                 typename std::enable_if_t&lt;std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) const {\n        return b.ModMul(*this, modulus, modulus.ComputeMu());\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint&amp; ModMulEq(const ubint&amp; b, const ubint&amp; modulus,\n                    typename std::enable_if_t&lt;!std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) {\n        auto bv(b);\n        if (bv &gt;= modulus)\n            bv.ModEq(modulus);\n        if (*this &gt;= modulus)\n            this-&gt;ubint::ModEq(modulus);\n        return *this = bv.ModMulFast(*this, modulus);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint&amp; ModMulEq(const ubint&amp; b, const ubint&amp; modulus,\n                    typename std::enable_if_t&lt;std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) {\n        return *this = b.ModMul(*this, modulus, modulus.ComputeMu());\n    }\n\n    /**\n   * Barrett modulus multiplication.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus multiplication operation.\n   */\n    ubint ModMul(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu) const {\n        auto bv(b);\n        auto av(*this);\n        if (bv &gt;= modulus)\n            bv.ModEq(modulus, mu);\n        if (av &gt;= modulus)\n            av.ModEq(modulus, mu);\n        return av.Mul(bv).Mod(modulus, mu);\n    }\n\n    ubint&amp; ModMulEq(const ubint&amp; b, const ubint&amp; modulus, ubint&amp; mu) {\n        auto bv(b);\n        if (bv &gt;= modulus)\n            bv.ModEq(modulus, mu);\n        if (*this &gt;= modulus)\n            this-&gt;ubint::ModEq(modulus, mu);\n        return *this = bv.Mul(*this).Mod(modulus, mu);\n    }\n\n    /**\n   * Modulus multiplication that assumes the operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    ubint ModMulFast(const ubint&amp; b, const ubint&amp; modulus) const;\n    ubint&amp; ModMulFastEq(const ubint&amp; b, const ubint&amp; modulus) {\n        return *this = this-&gt;ubint::ModMulFast(b, modulus);\n    }\n\n    /**\n   * Barrett modulus multiplication that assumes the operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus multiplication operation.\n   */\n    ubint ModMulFast(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu) const {\n        return b.Mul(*this).Mod(modulus, mu);\n    }\n\n    ubint&amp; ModMulFastEq(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu) {\n        return *this = b.Mul(*this).Mod(modulus, mu);\n    }\n\n    ubint ModMulFastConst(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; bInv) const {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::not_implemented_error, &quot;ModMulFastConst is not implemented for backend 4&quot;);\n    }\n    ubint&amp; ModMulFastConstEq(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; bInv) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::not_implemented_error, &quot;ModMulFastConstEq is not implemented for backend 4&quot;);\n    }\n\n    /**\n   * Modulus exponentiation operation. Square-and-multiply algorithm is used.\n   *\n   * @param &amp;b is the scalar to exponentiate at all locations.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus exponentiation operation.\n   */\n    ubint ModExp(const ubint&amp; b, const ubint&amp; modulus) const;\n    ubint&amp; ModExpEq(const ubint&amp; b, const ubint&amp; modulus) {\n        return *this = this-&gt;ubint::ModExp(b, modulus);\n    }\n\n    /**\n   * Modulus inverse operation.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @return is the result of the modulus inverse operation.\n   */\n    ubint ModInverse(const ubint&amp; modulus) const;\n    ubint&amp; ModInverseEq(const ubint&amp; modulus) {\n        return *this = this-&gt;ubint::ModInverse(modulus);\n    }\n\n    /**\n   * Left shift operation.\n   *\n   * @param shift # of bits.\n   * @return result of the shift operation.\n   */\n    ubint LShift(usshort shift) const;\n    ubint&amp; LShiftEq(usshort shift);\n\n    /**\n   * Right shift operation.\n   *\n   * @param shift # of bits.\n   * @return result of the shift operation.\n   */\n    ubint RShift(usshort shift) const;\n    ubint&amp; RShiftEq(usshort shift);\n\n    /**\n   * Compares the current ubint to ubint a.\n   *\n   * @param a is the ubint to be compared with.\n   * @return  -1 for strictly less than, 0 for equal to and 1 for strictly\n   * greater than conditons.\n   */\n    int Compare(const ubint&amp; a) const noexcept {\n        if (m_MSB &lt; a.m_MSB)\n            return -1;\n        if (m_MSB &gt; a.m_MSB)\n            return 1;\n        for (int i = m_value.size() - 1; i &gt;= 0; --i) {\n            if (m_value[i] &lt; a.m_value[i])\n                return -1;\n            if (m_value[i] &gt; a.m_value[i])\n                return 1;\n        }\n        return 0;\n    }\n\n    template &lt;typename T = BasicInteger&gt;\n    T ConvertToInt() const noexcept {\n        constexpr usint limblen{sizeof(T) * 8};\n        if constexpr (m_limbBitLength &gt;= limblen) {\n            return static_cast&lt;T&gt;(m_value[0]);\n        }\n        if constexpr (m_limbBitLength &lt; limblen) {\n            auto ceilInt = MSBToLimbs(limblen &gt; m_MSB ? m_MSB : limblen);\n            auto result  = static_cast&lt;T&gt;(m_value[0]);\n            for (usint i{1}; i &lt; ceilInt; ++i)\n                result |= static_cast&lt;T&gt;(m_value[i]) &lt;&lt; (i * m_limbBitLength);\n            return result;\n        }\n    }\n\n    /**\n   * Converts the value to a float\n   * if the ubint is uninitialized error is thrown\n   * if the ubint is larger than the max value representable\n   * or if conversion fails, and error is reported to cerr\n   */\n    float ConvertToFloat() const;\n    double ConvertToDouble() const;\n    long double ConvertToLongDouble() const;\n\n    /**\n   * Convert a string representation of a binary number to a ubint.\n   * @param bitString the binary num in string.\n   * @return the  number represented as a ubint.\n   */\n    static ubint FromBinaryString(const std::string&amp; bitString);\n\n    /**\n   * Returns the MSB location of the value.\n   * @return the index of the most significant bit.\n   */\n    usint GetMSB() const {\n        return m_MSB;\n    }\n\n    /**\n   * Returns the size of the underlying vector of Limbs\n   * @return the size\n   */\n    size_t GetNumberOfLimbs() const {\n        return m_value.size();\n    }\n\n    /**\n   * Tests whether the ubint is a power of 2.\n   *\n   * @param x is the value to check.\n   * @return true if the input is a power of 2, false otherwise.\n   */\n    /*\n    static bool isPowerOfTwo(const ubint&amp; x) {\n        if (x.m_MSB == 0)\n            return false;\n        const size_t limbs{x.m_value.size() - 1};\n        for (size_t i = 0; i &lt; limbs; ++i) {\n            if (0 != x.m_value[i])\n                return false;\n        }\n        auto msb{lbcrypto::GetMSB(x.m_value[limbs]) - 1};\n        auto mask{(1 &lt;&lt; msb) - 1};\n        return (0 == (x.m_value[limbs] &amp; mask));\n    }\n*/\n\n    /**\n   * Get the number of digits using a specific base - support for arbitrary base\n   * may be needed.\n   *\n   * @param base is the base with which to determine length in.\n   * @return the length of the representation in a specific base.\n   */\n\n    // TODO hardcoded for base 2?\n    usint GetLengthForBase(usint base) const {\n        return GetMSB();\n    }\n\n    /**\n   * Get the number of digits using a specific base.\n   * Warning: only power-of-2 bases are currently supported.\n   * Example: for number 83, index 2 and base 4 we have:\n   *\n   *                         index:0,1,2,3\n   * 83 --base 4 decomposition--&gt; (3,0,1,1) --at index 2--&gt; 1\n   *\n   * The return number is 1.\n   *\n   * @param index is the location to return value from in the specific base.\n   * @param base is the base with which to determine length in.\n   * @return the length of the representation in a specific base.\n   */\n    usint GetDigitAtIndexForBase(usint index, usint base) const;\n\n    /**\n   * Gets the bit at the specified index.\n   *\n   * @param index is the index of the bit to get.\n   * @return resulting bit.\n   */\n    uschar GetBitAtIndex(usint index) const;\n\n    /**\n   * A zero allocator that is called by the Matrix class. It is used to\n   * initialize a Matrix of ubint objects.\n   */\n    static ubint Allocator() noexcept {\n        return ubint();\n    }\n\n    // STRINGS &amp; STREAMS\n\n    /**\n   * Stores the based 10 equivalent/Decimal value of the ubint in a string\n   * object and returns it.\n   *\n   * @return value of this ubint in base 10 represented as a string.\n   */\n    const std::string ToString() const;\n\n    static const std::string IntegerTypeName() {\n        if constexpr (std::is_same_v&lt;limb_t, uint32_t&gt;)\n            return &quot;UBDYNINT_32&quot;;\n        if constexpr (std::is_same_v&lt;limb_t, uint64_t&gt;)\n            return &quot;UBDYNINT_64&quot;;\n        if constexpr (std::is_same_v&lt;limb_t, uint128_t&gt;)\n            return &quot;UBDYNINT_128&quot;;\n        static_assert(true, &quot;Configuration Error: ubintdyn.h&quot;);\n    }\n\n    /**\n   * Delivers value of the internal limb storage\n   * Used primarily for debugging\n   * @return STL vector of uint_type\n   */\n    std::string GetInternalRepresentation() const {\n        std::string ret{};\n        for (size_t i = 0; i &lt; m_value.size(); i++) {\n            ret += std::to_string(m_value[i]);\n            if (i &lt; (m_value.size() - 1)) {\n                ret += &quot; &quot;;\n            }\n        }\n        return ret;\n    }\n\n    /**\n   * ostream output &lt;&lt; operator\n   * Algorithm used is double and add\n   * http://www.wikihow.com/Convert-from-Binary-to-Decimal\n   *\n   * @param os is the std ostream object.\n   * @param ptr_obj is ubint to be printed.\n   * @return is the returned ostream object.\n   */\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ubint&amp; ptr_obj) {\n        os &lt;&lt; ptr_obj.ToString();\n        return os;\n    }\n\n    /**\n   * documentation function, prints sizes of constats.\n   */\n    static void PrintIntegerConstants() {\n        std::cout &lt;&lt; &quot;sizeof UINT8_C  &quot; &lt;&lt; sizeof(UINT8_C(1)) &lt;&lt; std::endl;\n        std::cout &lt;&lt; &quot;sizeof UINT16_C &quot; &lt;&lt; sizeof(UINT16_C(1)) &lt;&lt; std::endl;\n        std::cout &lt;&lt; &quot;sizeof UINT32_C &quot; &lt;&lt; sizeof(UINT32_C(1)) &lt;&lt; std::endl;\n        std::cout &lt;&lt; &quot;sizeof UINT64_C &quot; &lt;&lt; sizeof(UINT64_C(1)) &lt;&lt; std::endl;\n        std::cout &lt;&lt; &quot;sizeof uint8_t  &quot; &lt;&lt; sizeof(uint8_t) &lt;&lt; std::endl;\n        std::cout &lt;&lt; &quot;sizeof uint16_t &quot; &lt;&lt; sizeof(uint16_t) &lt;&lt; std::endl;\n        std::cout &lt;&lt; &quot;sizeof uint32_t &quot; &lt;&lt; sizeof(uint32_t) &lt;&lt; std::endl;\n        std::cout &lt;&lt; &quot;sizeof uint64_t &quot; &lt;&lt; sizeof(uint64_t) &lt;&lt; std::endl;\n        #if defined(HAVE_INT128)\n        // std::cout &lt;&lt; &quot;sizeof UINT128_C &quot;&lt;&lt; sizeof (UINT128_C(1)) &lt;&lt; std::endl;\n        // dbc commented out  unsupported on some machines\n        std::cout &lt;&lt; &quot;sizeof uint128_t &quot; &lt;&lt; sizeof(uint128_t) &lt;&lt; std::endl;\n        #endif\n    }\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::make_nvp(&quot;v&quot;, m_value));\n        ar(::cereal::make_nvp(&quot;m&quot;, m_MSB));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                           &quot; is from a later version of the library&quot;);\n        }\n        ar(::cereal::make_nvp(&quot;v&quot;, m_value));\n        ar(::cereal::make_nvp(&quot;m&quot;, m_MSB));\n    }\n\n    std::string SerializedObjectName() const {\n        return &quot;DYNInteger&quot;;\n    }\n\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\nprivate:\n    /**\n   * Sets the MSB to the correct value as computed from the internal value.\n   */\n    void SetMSB() {\n        m_MSB = m_limbBitLength * static_cast&lt;usint&gt;(m_value.size() - 1);\n        m_MSB += lbcrypto::GetMSB(m_value.back());\n    }\n\n    /**\n   * Normalize limb storage of the ubint by making sure the most\n   * significant limb is non-zero (all higher zero limbs are\n   * removed).\n   *\n   * @return resulting bit.\n   */\n    void NormalizeLimbs() {\n        auto size = m_value.size() - 1;\n        while (size &gt; 0 &amp;&amp; m_value[size--] == 0)\n            m_value.pop_back();\n        m_MSB = m_limbBitLength * static_cast&lt;usint&gt;(m_value.size() - 1);\n        m_MSB += lbcrypto::GetMSB(m_value.back());\n    }\n\n    /**\n   * helper function for Div\n   * @param defined in ubint.cpp\n   */\n    void divqr_vect(ubint&amp; q, ubint&amp; r, const ubint&amp; u, const ubint&amp; v) const noexcept;\n    void divq_vect(ubint&amp; q, const ubint&amp; u, const ubint&amp; v) const noexcept;\n    void divr_vect(ubint&amp; r, const ubint&amp; u, const ubint&amp; v) const noexcept;\n\n    /**\n   * function to return the ceiling of the input number divided by\n   * the number of bits in the limb data type.  DBC this is to\n   * determine how many limbs are needed for an input bitsize.\n   * @param Number is the number to be divided.\n   * @return the ceiling of Number/(bits in the limb data type)\n   */\n    static constexpr usint MSBToLimbs(usint msb) noexcept {\n        constexpr usint mask{m_limbBitLength - 1};\n        if (msb == 0)\n            return 1;\n        return (msb &gt;&gt; m_log2LimbBitLength) + ((msb &amp; mask) != 0);\n    }\n};\n\n        #if 0\n// stream helper function for vector of objects\ntemplate &lt;typename limb_t&gt;\nstd::ostream &amp;operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;limb_t&gt;&amp; v) {\n  os &lt;&lt; &quot;[&quot;;\n  for (auto&amp;&amp; itr : v)\n    os &lt;&lt; &quot; &quot; &lt;&lt; itr;\n  os &lt;&lt; &quot; ]&quot;;\n  return os;\n}\n        #endif\n\n}  // namespace bigintdyn\n\n    #endif  // LBCRYPTO_MATH_HAL_BIGINTDYN_UBINTDYN_H\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n This file contains the main class for native integers. It implements the same methods as other mathematical backends.\n*/\n\n#ifndef LBCRYPTO_MATH_HAL_INTNAT_UBINTNAT_H\n#define LBCRYPTO_MATH_HAL_INTNAT_UBINTNAT_H\n\n#include &quot;math/hal/basicint.h&quot;\n#include &quot;math/hal/bigintbackend.h&quot;\n#include &quot;math/hal/integer.h&quot;\n#include &quot;math/nbtheory.h&quot;\n\n#include &quot;utils/debug.h&quot;\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/inttypes.h&quot;\n#include &quot;utils/openfhebase64.h&quot;\n#include &quot;utils/serializable.h&quot;\n\n#include &lt;cstdint&gt;\n// #include &lt;cstdlib&gt;\n// #include &lt;fstream&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n// #include &lt;memory&gt;\n// #include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n// #include &lt;typeinfo&gt;\n#include &lt;vector&gt;\n#include &lt;utility&gt;\n\n// the default behavior of the native integer layer is\n// to assume that the user does not need bounds/range checks\n// in the native integer code\n// if you want them, change this #define to true\n// we use a #define to resolve which to use at compile time\n// sadly, making the choice according to some setting that\n// is checked at runtime has awful performance; using this\n// #define in a simple expression causes the compiler to\n// optimize away the test\n#define NATIVEINT_DO_CHECKS false\n#define NATIVEINT_BARRET_MOD\n\n// TODO: remove these?\nusing U32BITS = uint32_t;\nusing U64BITS = uint64_t;\n#if defined(HAVE_INT128)\nusing U128BITS = uint128_t;\n#endif\n\nnamespace intnat {\n\n// Forward declare class and give it an alias for the expected type\ntemplate &lt;typename IntType&gt;\nclass NativeIntegerT;\nusing NativeInteger = NativeIntegerT&lt;BasicInteger&gt;;\n\ntemplate &lt;typename IntType&gt;\nclass NativeVectorT;\n\n// constexpr double LOG2_10 = 3.32192809;  //!&lt; @brief A pre-computed  constant of Log base 2 of 10.\n// constexpr usint BARRETT_LEVELS = 8;  //!&lt; @brief The number of levels (precomputed\n//!&lt; values) used in the Barrett reductions.\n\n/**\n * @brief Struct to determine other datatyps based on utype.\n * @tparam utype primitive integer data type.\n */\ntemplate &lt;typename utype&gt;\nstruct DataTypes {\n    using SignedType       = void;\n    using DoubleType       = void;\n    using SignedDoubleType = void;\n};\ntemplate &lt;&gt;\nstruct DataTypes&lt;uint32_t&gt; {\n    using SignedType       = int32_t;\n    using DoubleType       = uint64_t;\n    using SignedDoubleType = int64_t;\n};\ntemplate &lt;&gt;\nstruct DataTypes&lt;uint64_t&gt; {\n    using SignedType = int64_t;\n#if defined(HAVE_INT128)\n    using DoubleType       = uint128_t;\n    using SignedDoubleType = int128_t;\n#else\n    using DoubleType       = uint64_t;\n    using SignedDoubleType = int64_t;\n#endif\n};\n#if defined(HAVE_INT128)\ntemplate &lt;&gt;\nstruct DataTypes&lt;uint128_t&gt; {\n    using SignedType       = int128_t;\n    using DoubleType       = uint128_t;\n    using SignedDoubleType = int128_t;\n};\n#endif\n\n/**\n * @brief Main class for big integers represented as an array of native\n * (primitive) unsigned integers\n * @tparam NativeInt native unsigned integer type\n */\ntemplate &lt;typename NativeInt&gt;\nclass NativeIntegerT final : public lbcrypto::BigIntegerInterface&lt;NativeIntegerT&lt;NativeInt&gt;&gt; {\nprivate:\n    NativeInt m_value{0};\n\n    // variable to store the maximum value of the integral data type.\n    static constexpr NativeInt m_uintMax{std::numeric_limits&lt;NativeInt&gt;::max()};\n    // variable to store the bit width of the integral data type.\n    //    static constexpr usint m_uintBitLength{sizeof(NativeInt) * 8};\n    static constexpr usint m_uintBitLength{std::numeric_limits&lt;NativeInt&gt;::digits};\n\n    friend class NativeVectorT&lt;NativeIntegerT&lt;NativeInt&gt;&gt;;\n\npublic:\n    using Integer         = NativeInt;\n    using SignedNativeInt = typename DataTypes&lt;NativeInt&gt;::SignedType;\n    using DNativeInt      = typename DataTypes&lt;NativeInt&gt;::DoubleType;\n    using SDNativeInt     = typename DataTypes&lt;NativeInt&gt;::SignedDoubleType;\n\n    // data structure to represent a double-word integer as two single-word integers\n    struct typeD {\n        NativeInt hi{0};\n        NativeInt lo{0};\n        inline std::string ConvertToString() const {\n            return std::string(&quot;hi [&quot; + toString(hi) + &quot;], lo [&quot; + toString(lo) + &quot;]&quot;);\n        }\n    };\n\n    explicit operator NativeInt() const {\n        return m_value;\n    }\n    explicit operator bool() const {\n        return m_value != 0;\n    }\n\n    constexpr NativeIntegerT() = default;\n    constexpr NativeIntegerT(const NativeIntegerT&amp; val) noexcept : m_value{val.m_value} {}\n    constexpr NativeIntegerT(NativeIntegerT&amp;&amp; val) noexcept : m_value{std::move(val.m_value)} {}\n\n    NativeIntegerT(const std::string&amp; val) {\n        this-&gt;NativeIntegerT::SetValue(val);\n    }\n\n    explicit NativeIntegerT(const char* strval) {\n        this-&gt;NativeIntegerT::SetValue(std::string(strval));\n    }\n    // explicit NativeIntegerT(const char strval) : m_value{NativeInt(strval - &#x27;0&#x27;)} {}\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, bool&gt; = true&gt;\n    constexpr NativeIntegerT(T val) noexcept : m_value(val) {}\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_same_v&lt;T, M2Integer&gt; || std::is_same_v&lt;T, M4Integer&gt; ||\n                                               std::is_same_v&lt;T, M6Integer&gt;,\n                                           bool&gt; = true&gt;\n    constexpr NativeIntegerT(T val) noexcept : m_value{val.template ConvertToInt&lt;NativeInt&gt;()} {}\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;, bool&gt; = true&gt;\n    NativeIntegerT(T val) = delete;\n\n    constexpr NativeIntegerT&amp; operator=(const NativeIntegerT&amp; val) noexcept {\n        m_value = val.m_value;\n        return *this;\n    }\n\n    constexpr NativeIntegerT&amp; operator=(NativeIntegerT&amp;&amp; val) noexcept {\n        m_value = std::move(val.m_value);\n        return *this;\n    }\n\n    NativeIntegerT&amp; operator=(const std::string&amp; val) {\n        this-&gt;NativeIntegerT::SetValue(val);\n        return *this;\n    }\n\n    NativeIntegerT&amp; operator=(const char* strval) {\n        this-&gt;NativeIntegerT::SetValue(std::string(strval));\n        return *this;\n    }\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, bool&gt; = true&gt;\n    constexpr NativeIntegerT&amp; operator=(T val) noexcept {\n        m_value = val;\n        return *this;\n    }\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_same_v&lt;T, M2Integer&gt; || std::is_same_v&lt;T, M4Integer&gt; ||\n                                               std::is_same_v&lt;T, M6Integer&gt;,\n                                           bool&gt; = true&gt;\n    constexpr NativeIntegerT&amp; operator=(T val) noexcept {\n        m_value = val.template ConvertToInt&lt;NativeInt&gt;();\n        return *this;\n    }\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;, bool&gt; = true&gt;\n    NativeIntegerT&amp; operator=(T val) = delete;\n\n    /**\n   * Basic set method for setting the value of a native integer\n   *\n   * @param &amp;strval is the string representation of the native integer to be\n   * copied.\n   */\n    void SetValue(const std::string&amp; str) {\n        NativeInt acc{0}, tst{0};\n        for (auto c : str) {\n            if ((c - &#x27;0&#x27;) &gt; 9)\n                &quot;hey&quot;; OPENFHE_THROW(lbcrypto::type_error, &quot;String contains a non-digit&quot;);\n            if ((acc = (10 * acc) + static_cast&lt;NativeInt&gt;(c - &#x27;0&#x27;)) &lt; tst)\n                &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, str + &quot; is too large to fit in this native integer object&quot;);\n            tst = acc;\n        }\n        m_value = acc;\n    }\n\n    /**\n   * Basic set method for setting the value of a native integer\n   *\n   * @param &amp;val is the big binary integer representation of the native\n   * integer to be assigned.\n   */\n    void SetValue(const NativeIntegerT&amp; val) {\n        m_value = val.m_value;\n    }\n\n    /**\n   *  Set this int to 1.\n   */\n    void SetIdentity() {\n        m_value = static_cast&lt;NativeInt&gt;(1);\n    }\n\n    /**\n   * Addition operation.\n   *\n   * @param &amp;b is the value to add.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT Add(const NativeIntegerT&amp; b) const {\n        return NATIVEINT_DO_CHECKS ? AddCheck(b) : AddFast(b);\n    }\n\n    /**\n   * AddCheck is the addition operation with bounds checking.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT AddCheck(const NativeIntegerT&amp; b) const {\n        auto r{m_value + b.m_value};\n        if (r &lt; m_value || r &lt; b.m_value)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT AddCheck: Overflow&quot;);\n        return {r};\n    }\n\n    /**\n   * AddFast is the addition operation without bounds checking.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT AddFast(const NativeIntegerT&amp; b) const {\n        return {b.m_value + m_value};\n    }\n\n    /**\n   * Addition operation. In-place variant.\n   *\n   * @param &amp;b is the value to add.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT&amp; AddEq(const NativeIntegerT&amp; b) {\n        return NATIVEINT_DO_CHECKS ? AddEqCheck(b) : AddEqFast(b);\n    }\n\n    /**\n   * AddEqCheck is the addition in place operation with bounds checking.\n   * In-place variant.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT&amp; AddEqCheck(const NativeIntegerT&amp; b) {\n        auto oldv{m_value};\n        if ((m_value += b.m_value) &lt; oldv)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT AddEqCheck: Overflow&quot;);\n        return *this;\n    }\n\n    /**\n   * AddEqFast is the addition in place operation without bounds checking.\n   * In-place variant.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT&amp; AddEqFast(const NativeIntegerT&amp; b) {\n        return *this = b.m_value + m_value;\n    }\n\n    /**\n   * Subtraction operation.\n   *\n   * @param &amp;b is the value to subtract.\n   * @return is the result of the subtraction operation.\n   */\n    NativeIntegerT Sub(const NativeIntegerT&amp; b) const {\n        return NATIVEINT_DO_CHECKS ? SubCheck(b) : SubFast(b);\n    }\n\n    /**\n   * SubCheck is the subtraction operation with bounds checking.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT SubCheck(const NativeIntegerT&amp; b) const {\n        return {m_value &lt;= b.m_value ? 0 : m_value - b.m_value};\n    }\n\n    /**\n   * SubFast is the subtraction operation without bounds checking.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    // no saturated subtraction? functionality differs from BigInteger Backends\n    NativeIntegerT SubFast(const NativeIntegerT&amp; b) const {\n        return {m_value - b.m_value};\n    }\n\n    /**\n   * Subtraction operation. In-place variant.\n   *\n   * @param &amp;b is the value to subtract.\n   * @return is the result of the subtraction operation.\n   */\n    NativeIntegerT&amp; SubEq(const NativeIntegerT&amp; b) {\n        return NATIVEINT_DO_CHECKS ? SubEqCheck(b) : SubEqFast(b);\n    }\n\n    /**\n   * SubEqCheck is the subtraction in place operation with bounds checking.\n   * In-place variant.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT&amp; SubEqCheck(const NativeIntegerT&amp; b) {\n        if (m_value &lt; b.m_value)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT SubEqCheck: neg value&quot;);\n        return *this = m_value - b.m_value;\n    }\n\n    /**\n   * SubEqFast is the subtraction in place operation without bounds checking.\n   * In-place variant.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT&amp; SubEqFast(const NativeIntegerT&amp; b) {\n        return *this = m_value - b.m_value;\n    }\n\n    // overloaded binary operators based on integer arithmetic and comparison\n    // functions.\n    NativeIntegerT operator-() const {\n        return NativeIntegerT().Sub(*this);\n    }\n\n    /**\n   * Multiplication operation.\n   *\n   * @param &amp;b is the value to multiply with.\n   * @return is the result of the multiplication operation.\n   */\n    NativeIntegerT Mul(const NativeIntegerT&amp; b) const {\n        return NATIVEINT_DO_CHECKS ? MulCheck(b) : MulFast(b);\n    }\n\n    /**\n   * MulCheck is the multiplication operation with bounds checking.\n   *\n   * @param b is the value to multiply with\n   * @return result of the multiplication operation\n   */\n    NativeIntegerT MulCheck(const NativeIntegerT&amp; b) const {\n        auto p{b.m_value * m_value};\n        if (p &lt; m_value || p &lt; b.m_value)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT MulCheck: Overflow&quot;);\n        return {p};\n    }\n\n    /**\n   * MulFast is the multiplication operation without bounds checking.\n   *\n   * @param b is the value to multiply with.\n   * @return result of the multiplication operation.\n   */\n    NativeIntegerT MulFast(const NativeIntegerT&amp; b) const {\n        return {b.m_value * m_value};\n    }\n\n    /**\n   * Multiplication operation. In-place variant.\n   *\n   * @param &amp;b is the value to multiply with.\n   * @return is the result of the multiplication operation.\n   */\n    NativeIntegerT&amp; MulEq(const NativeIntegerT&amp; b) {\n        return NATIVEINT_DO_CHECKS ? MulEqCheck(b) : MulEqFast(b);\n    }\n\n    /**\n   * MulEqCheck is the multiplication in place operation with bounds checking.\n   * In-place variant.\n   *\n   * @param b is the value to multiply with\n   * @return result of the multiplication operation\n   */\n    NativeIntegerT&amp; MulEqCheck(const NativeIntegerT&amp; b) {\n        auto oldv{m_value};\n        if ((m_value *= b.m_value) &lt; oldv)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT MulEqCheck: Overflow&quot;);\n        return *this;\n    }\n\n    /**\n   * MulEqFast is the multiplication in place operation without bounds\n   * checking. In-place variant.\n   *\n   * @param b is the value to multiply with\n   * @return result of the multiplication operation\n   */\n    NativeIntegerT&amp; MulEqFast(const NativeIntegerT&amp; b) {\n        return *this = b.m_value * m_value;\n    }\n\n    /**\n   * Division operation.\n   *\n   * @param &amp;b is the value to divide by.\n   * @return is the result of the division operation.\n   */\n    NativeIntegerT DividedBy(const NativeIntegerT&amp; b) const {\n        if (b.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT DividedBy: zero&quot;);\n        return {m_value / b.m_value};\n    }\n\n    /**\n   * Division operation. In-place variant.\n   *\n   * @param &amp;b is the value to divide by.\n   * @return is the result of the division operation.\n   */\n    NativeIntegerT&amp; DividedByEq(const NativeIntegerT&amp; b) {\n        if (b.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT DividedByEq: zero&quot;);\n        return *this = m_value / b.m_value;\n    }\n\n    /**\n   * Exponentiation operation. Returns x^p.\n   *\n   * @param p the exponent.\n   * @return is the result of the exponentiation operation.\n   */\n    NativeIntegerT Exp(usint p) const {\n        NativeInt r{1};\n        for (auto x = m_value; p &gt; 0; p &gt;&gt;= 1, x *= x)\n            r *= (p &amp; 0x1) ? x : 1;\n        return {r};\n    }\n\n    /**\n   * Exponentiation operation. Returns x^p. In-place variant.\n   *\n   * @param p the exponent.\n   * @return is the result of the exponentiation operation.\n   */\n    NativeIntegerT&amp; ExpEq(usint p) {\n        auto x{m_value};\n        m_value = 1;\n        for (; p &gt; 0; p &gt;&gt;= 1, x *= x)\n            m_value *= (p &amp; 0x1) ? x : 1;\n        return *this;\n    }\n\n    /**\n   * Multiply and Rounding operation. Returns [x*p/q] where [] is the rounding\n   * operation.\n   *\n   * @param &amp;p is the numerator to be multiplied.\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of multiply and round operation.\n   */\n    NativeIntegerT MultiplyAndRound(const NativeIntegerT&amp; p, const NativeIntegerT&amp; q) const {\n        if (q.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT MultiplyAndRound: Divide by zero&quot;);\n        return static_cast&lt;NativeInt&gt;(p.ConvertToDouble() * (this-&gt;ConvertToDouble() / q.ConvertToDouble()) + 0.5);\n    }\n\n    /**\n   * Multiply and Rounding operation. Returns [x*p/q] where [] is the rounding\n   * operation. In-place variant.\n   *\n   * @param &amp;p is the numerator to be multiplied.\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of multiply and round operation.\n   */\n    NativeIntegerT&amp; MultiplyAndRoundEq(const NativeIntegerT&amp; p, const NativeIntegerT&amp; q) {\n        if (q.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT MultiplyAndRoundEq: Divide by zero&quot;);\n        return *this =\n                   static_cast&lt;NativeInt&gt;(p.ConvertToDouble() * (this-&gt;ConvertToDouble() / q.ConvertToDouble()) + 0.5);\n    }\n\n    /**\n   * Computes the quotient of x*p/q, where x,p,q are all NativeInt numbers, x\n   * is the current value; uses DNativeInt arithmetic\n   *\n   * @param p is the multiplicand\n   * @param q is the divisor\n   * @return the quotient\n   */\n    //    template &lt;typename T = NativeInt&gt;\n    //    NativeIntegerT MultiplyAndDivideQuotient(const NativeIntegerT&amp; p, const NativeIntegerT&amp; q) const {\n    //        DNativeInt xD{m_value};\n    //        DNativeInt pD{p.m_value};\n    //        DNativeInt qD{q.m_value};\n    //        return static_cast&lt;NativeIntegerT&gt;(xD * pD / qD);\n    //    }\n\n    /**\n   * Computes the remainder of x*p/q, where x,p,q are all NativeInt numbers, x\n   * is the current value; uses DNativeInt arithmetic. In-place variant.\n   *\n   * @param p is the multiplicand\n   * @param q is the divisor\n   * @return the remainder\n   */\n    //    template &lt;typename T = NativeInt&gt;\n    //    NativeIntegerT MultiplyAndDivideRemainder(const NativeIntegerT&amp; p, const NativeIntegerT&amp; q) const {\n    //        DNativeInt xD{m_value};\n    //        DNativeInt pD{p.m_value};\n    //        DNativeInt qD{q.m_value};\n    //        return static_cast&lt;NativeIntegerT&gt;(xD * pD % qD);\n    //    }\n\n    /**\n   * Divide and Rounding operation. Returns [x/q] where [] is the rounding\n   * operation.\n   *\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of divide and round operation.\n   */\n    NativeIntegerT DivideAndRound(const NativeIntegerT&amp; q) const {\n        if (q.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT DivideAndRound: zero&quot;);\n        auto ans{m_value / q.m_value};\n        auto rem{m_value % q.m_value};\n        auto halfQ{q.m_value &gt;&gt; 1};\n        if (rem &gt; halfQ)\n            return {ans + 1};\n        return {ans};\n    }\n\n    /**\n   * Divide and Rounding operation. Returns [x/q] where [] is the rounding\n   * operation. In-place variant.\n   *\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of divide and round operation.\n   */\n    NativeIntegerT&amp; DivideAndRoundEq(const NativeIntegerT&amp; q) {\n        if (q.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT DivideAndRoundEq: zero&quot;);\n        auto ans{m_value / q.m_value};\n        auto rem{m_value % q.m_value};\n        auto halfQ{q.m_value &gt;&gt; 1};\n        if (rem &gt; halfQ)\n            return *this = ans + 1;\n        return *this = ans;\n    }\n\n    /**\n   * Naive modulus operation.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @return is the result of the modulus operation.\n   */\n    NativeIntegerT Mod(const NativeIntegerT&amp; modulus) const {\n        return {m_value % modulus.m_value};\n    }\n\n    /**\n   * Naive modulus operation. In-place variant.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @return is the result of the modulus operation.\n   */\n    NativeIntegerT&amp; ModEq(const NativeIntegerT&amp; modulus) {\n        return *this = m_value % modulus.m_value;\n    }\n\n    /**\n   * Precomputes a parameter mu for Barrett modular reduction.\n   *\n   * @return the precomputed parameter mu.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ComputeMu(typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        if (m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT ComputeMu: Divide by zero&quot;);\n        auto&amp;&amp; tmp{DNativeInt{1} &lt;&lt; (2 * lbcrypto::GetMSB(m_value) + 3)};\n        return {tmp / DNativeInt(m_value)};\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ComputeMu(typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        if (m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT ComputeMu: Divide by zero&quot;);\n        auto&amp;&amp; tmp{bigintbackend::BigInteger{1} &lt;&lt; (2 * lbcrypto::GetMSB(m_value) + 3)};\n        return {(tmp / bigintbackend::BigInteger(m_value)).template ConvertToInt&lt;NativeInt&gt;()};\n    }\n\n    /**\n   * Barrett modulus operation.\n   * Implements generalized Barrett modular reduction algorithm. Uses one\n   * precomputed value of mu.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus operation.\n   */\n    // TODO: pass modulus.GetMSB() with mu for faster vector ops?\n    NativeIntegerT Mod(const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu) const {\n        typeD tmp;\n        NativeIntegerT ans{*this};\n        ModMu(tmp, ans, modulus.m_value, mu.m_value, modulus.GetMSB() - 2);\n        return ans;\n    }\n\n    /**\n   * Barrett modulus operation. In-place variant.\n   * Implements generalized Barrett modular reduction algorithm. Uses one\n   * precomputed value of mu.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus operation.\n   */\n    NativeIntegerT&amp; ModEq(const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu) {\n        typeD tmp;\n        ModMu(tmp, *this, modulus.m_value, mu.m_value, modulus.GetMSB() - 2);\n        return *this;\n    }\n\n    /**\n   * Modulus addition operation.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeIntegerT ModAdd(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) const {\n        auto av{m_value};\n        auto bv{b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (av &gt;= mv)\n            av %= mv;\n        if (bv &gt;= mv)\n            bv %= mv;\n        av += bv;\n        if (av &gt;= mv)\n            av -= mv;\n        return {av};\n    }\n\n    /**\n   * Modulus addition operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeIntegerT&amp; ModAddEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) {\n        auto bv{b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (m_value &gt;= mv)\n            m_value = m_value % mv;\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        m_value += bv;\n        if (m_value &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /**\n   * Modulus addition where operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeIntegerT ModAddFast(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) const {\n        auto r{m_value + b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (r &gt;= mv)\n            r -= mv;\n        return {r};\n    }\n    /**\n   * Modulus addition where operands are &lt; modulus. In-place variant.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeIntegerT&amp; ModAddFastEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) {\n        auto&amp; mv{modulus.m_value};\n        m_value += b.m_value;\n        if (m_value &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /**\n   * Barrett modulus addition operation.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus addition operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModAdd(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                          typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        auto&amp; mv{modulus.m_value};\n#ifdef NATIVEINT_BARRET_MOD\n        auto av{*this};\n        auto bv{b};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        av.m_value += bv.m_value;\n        if (av.m_value &gt;= mv)\n            av.m_value -= mv;\n        return av;\n#else\n        auto bv{b.m_value};\n        auto av{m_value};\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &gt;= mv)\n            av = av % mv;\n        av = av + bv;\n        if (av &gt;= mv)\n            return {av - mv};\n        return {av};\n#endif\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModAdd(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                          typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        auto av{*this};\n        auto bv{b};\n        auto&amp; mv{modulus.m_value};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        av.m_value += bv.m_value;\n        if (av.m_value &gt;= mv)\n            av.m_value -= mv;\n        return av;\n    }\n\n    /**\n   * Barrett modulus addition operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus addition operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModAddEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                             typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        auto&amp; mv{modulus.m_value};\n#ifdef NATIVEINT_BARRET_MOD\n        auto av{*this};\n        auto bv{b};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        m_value = av.m_value + bv.m_value;\n        if (m_value &gt;= mv)\n            m_value -= mv;\n        return *this;\n#else\n        auto bv{b.m_value};\n        auto av{m_value};\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &gt;= mv)\n            av = av % mv;\n        av = av + bv;\n        if (av &gt;= mv)\n            return *this = av - mv;\n        return *this = av;\n#endif\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModAddEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                             typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        auto av{*this};\n        auto bv{b};\n        auto&amp; mv{modulus.m_value};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        m_value = av.m_value + bv.m_value;\n        if (m_value &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /**\n   * Modulus subtraction operation.\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    NativeIntegerT ModSub(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) const {\n        auto av{m_value};\n        auto bv{b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (av &gt;= mv)\n            av %= mv;\n        if (bv &gt;= mv)\n            bv %= mv;\n        if (av &lt; bv)\n            return {av + mv - bv};\n        return {av - bv};\n    }\n\n    /**\n   * Modulus subtraction operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    NativeIntegerT&amp; ModSubEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) {\n        auto av{m_value};\n        auto bv{b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (av &gt;= mv)\n            av = av % mv;\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &lt; bv)\n            return *this = av + mv - bv;\n        return *this = av - bv;\n    }\n\n    /**\n   * Modulus subtraction where operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    NativeIntegerT ModSubFast(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) const {\n        if (m_value &lt; b.m_value)\n            return {m_value + modulus.m_value - b.m_value};\n        return {m_value - b.m_value};\n    }\n\n    /**\n   * Modulus subtraction where operands are &lt; modulus. In-place variant.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    NativeIntegerT&amp; ModSubFastEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) {\n        if (m_value &lt; b.m_value)\n            return *this = m_value + modulus.m_value - b.m_value;\n        return *this = m_value - b.m_value;\n    }\n\n    /**\n   * Barrett modulus subtraction operation.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus subtraction operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModSub(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                          typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        auto&amp; mv{modulus.m_value};\n#ifdef NATIVEINT_BARRET_MOD\n        auto av{*this};\n        auto bv{b};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        if (av.m_value &lt; bv.m_value)\n            return {av.m_value + mv - bv.m_value};\n        return {av.m_value - bv.m_value};\n#else\n        auto av{m_value};\n        auto bv{b.m_value};\n        if (av &gt;= mv)\n            av = av % mv;\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &lt; bv)\n            return {av + mv - bv};\n        return {av - bv};\n#endif\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModSub(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                          typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        auto av{*this};\n        auto bv{b};\n        auto&amp; mv{modulus.m_value};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        if (av.m_value &lt; bv.m_value)\n            return {av.m_value + mv - bv.m_value};\n        return {av.m_value - bv.m_value};\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModSubEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                             typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        auto&amp; mv{modulus.m_value};\n#ifdef NATIVEINT_BARRET_MOD\n        auto av{*this};\n        auto bv{b};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        if (av.m_value &lt; bv.m_value)\n            return *this = av.m_value + mv - bv.m_value;\n        return *this = av.m_value - bv.m_value;\n#else\n        auto bv{b.m_value};\n        auto av{m_value};\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &gt;= mv)\n            av = av % mv;\n        if (av &lt; bv)\n            return *this = av + mv - bv;\n        return *this = av - bv;\n#endif\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModSubEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                             typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        auto av{*this};\n        auto bv{b};\n        auto&amp; mv{modulus.m_value};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        if (av.m_value &lt; bv.m_value)\n            return *this = av.m_value + mv - bv.m_value;\n        return *this = av.m_value - bv.m_value;\n    }\n\n    /**\n   * Modulus multiplication operation.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMul(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                          typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        auto av{m_value};\n        auto bv{b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (av &gt;= mv)\n            av = av % mv;\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        DNativeInt rv{static_cast&lt;DNativeInt&gt;(av) * bv};\n        DNativeInt dmv{mv};\n        if (rv &gt;= dmv)\n            rv %= dmv;\n        return {rv};\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMul(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                          typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        typeD tmp;\n        auto av{*this};\n        auto&amp; mv{modulus.m_value};\n        auto mu{modulus.ComputeMu().m_value};\n        int64_t n{modulus.GetMSB() - 2};\n        if (av.m_value &gt;= mv)\n            ModMu(tmp, av, mv, mu, n);\n        auto bv{b};\n        if (bv.m_value &gt;= mv)\n            ModMu(tmp, bv, mv, mu, n);\n        MultD(av.m_value, bv.m_value, tmp);\n        typeD r{tmp};\n        MultD(RShiftD(tmp, n), mu, tmp);\n        MultD(RShiftD(tmp, n + 7), mv, tmp);\n        SubtractD(r, tmp);\n        if (r.lo &gt;= mv)\n            r.lo -= mv;\n        return {r.lo};\n    }\n\n    /**\n   * Modulus multiplication operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModMulEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                             typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        auto av{m_value};\n        auto bv{b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (av &gt;= mv)\n            av = av % mv;\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        DNativeInt rv{static_cast&lt;DNativeInt&gt;(av) * bv};\n        DNativeInt dmv{mv};\n        if (rv &gt;= dmv)\n            rv %= dmv;\n        return *this = static_cast&lt;NativeInt&gt;(rv);\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModMulEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                             typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        auto av{*this};\n        auto&amp; mv{modulus.m_value};\n        typeD tmp;\n        auto mu{modulus.ComputeMu().m_value};\n        int64_t n{modulus.GetMSB() - 2};\n        if (av.m_value &gt;= mv)\n            ModMu(tmp, av, mv, mu, n);\n        auto bv{b};\n        if (bv.m_value &gt;= mv)\n            ModMu(tmp, bv, mv, mu, n);\n        MultD(av.m_value, bv.m_value, tmp);\n        typeD r = tmp;\n        MultD(RShiftD(tmp, n), mu, tmp);\n        MultD(RShiftD(tmp, n + 7), mv, tmp);\n        SubtractD(r, tmp);\n        m_value = r.lo;\n        if (r.lo &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /**\n   * Barrett modulus multiplication.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMul(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                          typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n#ifdef NATIVEINT_BARRET_MOD\n        auto av{*this};\n        auto&amp; mv{modulus.m_value};\n        typeD tmp;\n        int64_t n{modulus.GetMSB() - 2};\n        if (av.m_value &gt;= mv)\n            ModMu(tmp, av, mv, mu.m_value, n);\n        auto bv{b};\n        if (bv.m_value &gt;= mv)\n            ModMu(tmp, bv, mv, mu.m_value, n);\n        MultD(av.m_value, bv.m_value, tmp);\n        auto rv = GetD(tmp);\n        MultD(RShiftD(tmp, n), mu.m_value, tmp);\n        rv -= DNativeInt(mv) * (GetD(tmp) &gt;&gt; n + 7);\n        NativeIntegerT r(rv);\n        if (r.m_value &gt;= mv)\n            r.m_value -= mv;\n        return r;\n#else\n        auto&amp; mv{modulus.m_value};\n        auto bv{b.m_value};\n        auto av{m_value};\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &gt;= mv)\n            av = av % mv;\n        DNativeInt rv{static_cast&lt;DNativeInt&gt;(av) * bv};\n        DNativeInt dmv{mv};\n        if (rv &gt;= dmv)\n            return {rv % dmv};\n        return {rv};\n#endif\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMul(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                          typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        auto av{*this};\n        auto&amp; mv{modulus.m_value};\n        typeD tmp;\n        int64_t n{modulus.GetMSB() - 2};\n        if (av.m_value &gt;= mv)\n            ModMu(tmp, av, mv, mu.m_value, n);\n        auto bv{b};\n        if (bv.m_value &gt;= mv)\n            ModMu(tmp, bv, mv, mu.m_value, n);\n        MultD(av.m_value, bv.m_value, tmp);\n        typeD r = tmp;\n        MultD(RShiftD(tmp, n), mu.m_value, tmp);\n        MultD(RShiftD(tmp, n + 7), mv, tmp);\n        SubtractD(r, tmp);\n        if (r.lo &gt;= mv)\n            r.lo -= mv;\n        return {r.lo};\n    }\n\n    /**\n   * Barrett modulus multiplication. In-place variant.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModMulEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                             typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n#ifdef NATIVEINT_BARRET_MOD\n        auto av{*this};\n        auto bv{b};\n        auto&amp; mv{modulus.m_value};\n        typeD tmp;\n        auto&amp; muv{mu.m_value};\n        int64_t n{modulus.GetMSB() - 2};\n        if (av.m_value &gt;= mv)\n            ModMu(tmp, av, mv, muv, n);\n        if (bv.m_value &gt;= mv)\n            ModMu(tmp, bv, mv, muv, n);\n        MultD(av.m_value, bv.m_value, tmp);\n        auto rv = GetD(tmp);\n        MultD(RShiftD(tmp, n), muv, tmp);\n        rv -= DNativeInt(mv) * (GetD(tmp) &gt;&gt; n + 7);\n        m_value = static_cast&lt;NativeInt&gt;(rv);\n        if (m_value &gt;= mv)\n            m_value -= mv;\n        return *this;\n#else\n        auto&amp; mv{modulus.m_value};\n        auto bv{b.m_value};\n        auto av{m_value};\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &gt;= mv)\n            av = av % mv;\n        DNativeInt rv{static_cast&lt;DNativeInt&gt;(av) * bv};\n        DNativeInt dmv{mv};\n        if (rv &gt;= dmv)\n            return *this = static_cast&lt;NativeInt&gt;(rv % dmv);\n        return *this = static_cast&lt;NativeInt&gt;(rv);\n#endif\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModMulEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                             typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        int64_t n{modulus.GetMSB() - 2};\n        auto av{*this};\n        auto bv{b};\n        auto&amp; mv{modulus.m_value};\n        typeD tmp;\n        if (av.m_value &gt;= mv)\n            ModMu(tmp, av, mv, mu.m_value, n);\n        if (bv.m_value &gt;= mv)\n            ModMu(tmp, bv, mv, mu.m_value, n);\n        MultD(av.m_value, bv.m_value, tmp);\n        typeD r = tmp;\n        MultD(RShiftD(tmp, n), mu.m_value, tmp);\n        MultD(RShiftD(tmp, n + 7), mv, tmp);\n        SubtractD(r, tmp);\n        m_value = r.lo;\n        if (r.lo &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /**\n   * Modulus multiplication that assumes the operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMulFast(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                              typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        DNativeInt rv{static_cast&lt;DNativeInt&gt;(m_value) * b.m_value};\n        DNativeInt dmv{modulus.m_value};\n        if (rv &gt;= dmv)\n            rv %= dmv;\n        return {rv};\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMulFast(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                              typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        int64_t n = modulus.GetMSB() - 2;\n        auto&amp; mv{modulus.m_value};\n        typeD prod;\n        MultD(m_value, b.m_value, prod);\n        typeD r = prod;\n        MultD(RShiftD(prod, n), modulus.ComputeMu().m_value, prod);\n        MultD(RShiftD(prod, n + 7), mv, prod);\n        SubtractD(r, prod);\n        if (r.lo &gt;= mv)\n            r.lo -= mv;\n        return {r.lo};\n    }\n\n    /**\n   * Modulus multiplication that assumes the operands are &lt; modulus. In-place\n   * variant.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    // TODO: find what in Matrix&lt;DCRTPoly&gt; is calling ModMulFastEq incorrectly\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMulFastEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                                typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        DNativeInt rv{static_cast&lt;DNativeInt&gt;(m_value) * b.m_value};\n        DNativeInt dmv{modulus.m_value};\n        if (rv &gt;= dmv)\n            rv %= dmv;\n        return *this = static_cast&lt;NativeInt&gt;(rv);\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMulFastEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                                typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        int64_t n = modulus.GetMSB() - 2;\n        auto&amp; mv{modulus.m_value};\n        typeD prod;\n        MultD(m_value, b.m_value, prod);\n        typeD r = prod;\n        MultD(RShiftD(prod, n), modulus.ComputeMu().m_value, prod);\n        MultD(RShiftD(prod, n + 7), mv, prod);\n        SubtractD(r, prod);\n        m_value = r.lo;\n        if (r.lo &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /**\n   * Barrett modulus multiplication that assumes the operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus multiplication operation.\n   */\n    /* Source: http://homes.esat.kuleuven.be/~fvercaut/papers/bar_mont.pdf\n    @article{knezevicspeeding,\n    title={Speeding Up Barrett and Montgomery Modular Multiplications},\n    author={Knezevic, Miroslav and Vercauteren, Frederik and Verbauwhede,\n    Ingrid}\n    }\n    We use the Generalized Barrett modular reduction algorithm described in\n    Algorithm 2 of the Source. The algorithm was originally proposed in J.-F.\n    Dhem. Modified version of the Barrett algorithm. Technical report, 1994\n    and described in more detail in the PhD thesis of the author published at\n    http://users.belgacom.net/dhem/these/these_public.pdf (Section 2.2.4).\n    We take \\alpha equal to n + 3. So in our case, \\mu = 2^(n + \\alpha) =\n    2^(2*n + 3). Generally speaking, the value of \\alpha should be \\ge \\gamma\n    + 1, where \\gamma + n is the number of digits in the dividend. We use the\n    upper bound of dividend assuming that none of the dividends will be larger\n    than 2^(2*n + 3). The value of \\mu is computed by NativeVector::ComputeMu.\n    */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMulFast(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                              typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        int64_t n = modulus.GetMSB() - 2;\n        auto&amp; mv{modulus.m_value};\n        typeD tmp;\n        MultD(m_value, b.m_value, tmp);\n        auto rv = GetD(tmp);\n        MultD(RShiftD(tmp, n), mu.m_value, tmp);\n        rv -= DNativeInt(mv) * (GetD(tmp) &gt;&gt; n + 7);\n        NativeIntegerT r(rv);\n        if (r.m_value &gt;= mv)\n            r.m_value -= mv;\n        return r;\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMulFast(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                              typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        int64_t n = modulus.GetMSB() - 2;\n        auto&amp; mv{modulus.m_value};\n        typeD prod;\n        MultD(m_value, b.m_value, prod);\n        typeD r = prod;\n        MultD(RShiftD(prod, n), mu.m_value, prod);\n        MultD(RShiftD(prod, n + 7), mv, prod);\n        SubtractD(r, prod);\n        if (r.lo &gt;= mv)\n            r.lo -= mv;\n        return {r.lo};\n    }\n\n    /**\n   * Barrett modulus multiplication that assumes the operands are &lt; modulus.\n   * In-place variant.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModMulFastEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                                 typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        typeD tmp;\n        MultD(m_value, b.m_value, tmp);\n        auto rv{GetD(tmp)};\n        int64_t n{modulus.GetMSB() - 2};\n        MultD(RShiftD(tmp, n), mu.m_value, tmp);\n        auto&amp; mv{modulus.m_value};\n        rv -= DNativeInt(mv) * (GetD(tmp) &gt;&gt; n + 7);\n        m_value = NativeInt(rv);\n        if (m_value &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModMulFastEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                                 typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        int64_t n{modulus.GetMSB() - 2};\n        typeD prod;\n        MultD(m_value, b.m_value, prod);\n        typeD r{prod};\n        auto&amp; mv{modulus.m_value};\n        MultD(RShiftD(prod, n), mu.m_value, prod);\n        MultD(RShiftD(prod, n + 7), mv, prod);\n        SubtractD(r, prod);\n        m_value = r.lo;\n        if (r.lo &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /*  The next three subroutines implement the modular multiplication\n    algorithm for the case when the multiplicand is used multiple times (known\n    in advance), as in NTT. The algorithm is described in\n    https://arxiv.org/pdf/1205.2926.pdf (Dave Harvey, FASTER ARITHMETIC FOR\n    NUMBER-THEORETIC TRANSFORMS). The algorithm is described in lines 5-7 of\n    Algorithm 2. The algorithm was originally proposed and implemented in NTL\n    (https://www.shoup.net/ntl/) by Victor Shoup.\n    */\n\n    /**\n   * Precomputation for a multiplicand.\n   *\n   * @param modulus is the modulus to perform operations with.\n   * @return the precomputed factor.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT PrepModMulConst(\n        const NativeIntegerT&amp; modulus,\n        typename std::enable_if&lt;!std::is_same&lt;T, DNativeInt&gt;::value, bool&gt;::type = true) const {\n        if (modulus.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Divide by zero&quot;);\n        auto&amp;&amp; w{DNativeInt(m_value) &lt;&lt; NativeIntegerT::MaxBits()};\n        return {w / DNativeInt(modulus.m_value)};\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT PrepModMulConst(\n        const NativeIntegerT&amp; modulus,\n        typename std::enable_if&lt;std::is_same&lt;T, DNativeInt&gt;::value, bool&gt;::type = true) const {\n        if (modulus.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Divide by zero&quot;);\n        auto&amp;&amp; w{bigintbackend::BigInteger(m_value) &lt;&lt; NativeIntegerT::MaxBits()};\n        return {(w / bigintbackend::BigInteger(modulus.m_value)).template ConvertToInt&lt;NativeInt&gt;()};\n    }\n\n    /**\n   * Modular multiplication using a precomputation for the multiplicand.\n   *\n   * @param &amp;b is the NativeIntegerT to multiply.\n   * @param modulus is the modulus to perform operations with.\n   * @param &amp;bInv precomputation for b.\n   * @return is the result of the modulus multiplication operation.\n   */\n    NativeIntegerT ModMulFastConst(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                                   const NativeIntegerT&amp; bInv) const {\n        NativeInt q = MultDHi(m_value, bInv.m_value) + 1;\n        auto yprime = static_cast&lt;SignedNativeInt&gt;(m_value * b.m_value - q * modulus.m_value);\n        return {yprime &gt;= 0 ? yprime : yprime + modulus.m_value};\n    }\n\n    /**\n   * Modular multiplication using a precomputation for the multiplicand.\n   * In-place variant.\n   *\n   * @param &amp;b is the NativeIntegerT to multiply.\n   * @param modulus is the modulus to perform operations with.\n   * @param &amp;bInv precomputation for b.\n   * @return is the result of the modulus multiplication operation.\n   */\n    NativeIntegerT&amp; ModMulFastConstEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                                      const NativeIntegerT&amp; bInv) {\n        NativeInt q = MultDHi(m_value, bInv.m_value) + 1;\n        auto yprime = static_cast&lt;SignedNativeInt&gt;(m_value * b.m_value - q * modulus.m_value);\n        m_value     = static_cast&lt;NativeInt&gt;(yprime &gt;= 0 ? yprime : yprime + modulus.m_value);\n        return *this;\n    }\n\n    /**\n   * Modulus exponentiation operation.\n   *\n   * @param &amp;b is the scalar to exponentiate at all locations.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus exponentiation operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModExp(const NativeIntegerT&amp; b, const NativeIntegerT&amp; mod,\n                          typename std::enable_if&lt;!std::is_same&lt;T, DNativeInt&gt;::value, bool&gt;::type = true) const {\n        DNativeInt t{m_value};\n        DNativeInt p{b.m_value};\n        DNativeInt m{mod.m_value};\n        DNativeInt r{1};\n        if (p &amp; 0x1) {\n            r = r * t;\n            if (r &gt;= m)\n                r = r % m;\n        }\n        while (p &gt;&gt;= 1) {\n            t = t * t;\n            if (t &gt;= m)\n                t = t % m;\n            if (p &amp; 0x1) {\n                r = r * t;\n                if (r &gt;= m)\n                    r = r % m;\n            }\n        }\n        return {r};\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModExp(const NativeIntegerT&amp; b, const NativeIntegerT&amp; mod,\n                          typename std::enable_if&lt;std::is_same&lt;T, DNativeInt&gt;::value, bool&gt;::type = true) const {\n        NativeIntegerT t{m_value % mod.m_value};\n        NativeIntegerT p{b.m_value};\n        NativeIntegerT mu{mod.ComputeMu()};\n        NativeIntegerT r{1};\n        if (p.m_value &amp; 0x1)\n            r.ModMulFastEq(t, mod, mu);\n        while (p.m_value &gt;&gt;= 1) {\n            t.ModMulFastEq(t, mod, mu);\n            if (p.m_value &amp; 0x1)\n                r.ModMulFastEq(t, mod, mu);\n        }\n        return {r};\n    }\n\n    /**\n   * Modulus exponentiation operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to exponentiate at all locations.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus exponentiation operation.\n   */\n    NativeIntegerT&amp; ModExpEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; mod) {\n        return *this = this-&gt;NativeIntegerT::ModExp(b, mod);\n    }\n\n    /**\n   * Modulus inverse operation.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @return is the result of the modulus inverse operation.\n   */\n    NativeIntegerT ModInverse(const NativeIntegerT&amp; mod) const {\n        SignedNativeInt modulus(mod.m_value);\n        SignedNativeInt a(m_value % mod.m_value);\n        if (a == 0) {\n            std::string msg = NativeIntegerT::toString(m_value) + &quot; does not have a ModInverse using &quot; +\n                              NativeIntegerT::toString(mod.m_value);\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, msg);\n        }\n        if (modulus == 1)\n            return NativeIntegerT();\n\n        SignedNativeInt y{0};\n        SignedNativeInt x{1};\n        while (a &gt; 1) {\n            auto t  = modulus;\n            auto q  = a / t;\n            modulus = a % t;\n            a       = t;\n            t       = y;\n            y       = x - q * y;\n            x       = t;\n        }\n        if (x &lt; 0)\n            x += mod.m_value;\n        return {x};\n    }\n\n    /**\n   * Modulus inverse operation. In-place variant.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @return is the result of the modulus inverse operation.\n   */\n    NativeIntegerT&amp; ModInverseEq(const NativeIntegerT&amp; mod) {\n        return *this = this-&gt;NativeIntegerT::ModInverse(mod);\n    }\n\n    /**\n   * Left shift operation.\n   *\n   * @param shift # of bits.\n   * @return result of the shift operation.\n   */\n    NativeIntegerT LShift(usshort shift) const {\n        return {m_value &lt;&lt; shift};\n    }\n\n    /**\n   * Left shift operation. In-place variant.\n   *\n   * @param shift # of bits.\n   * @return result of the shift operation.\n   */\n    NativeIntegerT&amp; LShiftEq(usshort shift) {\n        return *this = m_value &lt;&lt; shift;\n    }\n\n    /**\n   * Right shift operation.\n   *\n   * @param shift # of bits.\n   * @return result of the shift operation.\n   */\n    NativeIntegerT RShift(usshort shift) const {\n        return {m_value &gt;&gt; shift};\n    }\n\n    /**\n   * Right shift operation. In-place variant.\n   *\n   * @param shift # of bits.\n   * @return result of the shift operation.\n   */\n    NativeIntegerT&amp; RShiftEq(usshort shift) {\n        return *this = m_value &gt;&gt; shift;\n    }\n\n    /**\n   * Compares the current NativeIntegerT to NativeIntegerT a.\n   *\n   * @param a is the NativeIntegerT to be compared with.\n   * @return  -1 for strictly less than, 0 for equal to and 1 for strictly\n   * greater than conditons.\n   */\n    int Compare(const NativeIntegerT&amp; a) const {\n        return (m_value &lt; a.m_value) ? -1 : (m_value &gt; a.m_value) ? 1 : 0;\n    }\n\n    /**\n   * Converts the value to an int.\n   *\n   * @return the int representation of the value as usint.\n   */\n    template &lt;typename T = NativeInt, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, bool&gt; = true&gt;\n    constexpr T ConvertToInt() const noexcept {\n        // static_assert(sizeof(T) &gt;= sizeof(m_value), &quot;ConvertToInt(): Narrowing Conversion&quot;);\n        return static_cast&lt;T&gt;(m_value);\n    }\n\n    /**\n   * Converts the value to an double.\n   *\n   * @return double representation of the value.\n   */\n    constexpr double ConvertToDouble() const noexcept {\n        return static_cast&lt;double&gt;(m_value);\n    }\n\n    /**\n   * Convert a string representation of a binary number to a NativeIntegerT.\n   *\n   * @param bitString the binary num in string.\n   * @return the binary number represented as a big binary int.\n   */\n    static NativeIntegerT FromBinaryString(const std::string&amp; bitString) {\n        if (bitString.length() &gt; NativeIntegerT::MaxBits())\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Bit string is too long to fit in an intnat&quot;);\n        NativeInt v{0};\n        for (size_t i = 0; i &lt; bitString.length(); ++i) {\n            auto n = bitString[i] - &#x27;0&#x27;;\n            if (n &lt; 0 || n &gt; 1)\n                &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Bit string must contain only 0 or 1&quot;);\n            v = (v &lt;&lt; 1) | static_cast&lt;NativeInt&gt;(n);\n        }\n        return {v};\n    }\n\n    /**\n   * Returns the MSB location of the value.\n   *\n   * @return the index of the most significant bit.\n   */\n    usint GetMSB() const {\n        return lbcrypto::GetMSB(m_value);\n    }\n\n    /**\n   * Get the number of digits using a specific base - support for arbitrary\n   * base may be needed.\n   *\n   * @param base is the base with which to determine length in.\n   * @return the length of the representation in a specific base.\n   */\n\n    // TODO: only base 2?\n    usint GetLengthForBase(usint base) const {\n        return NativeIntegerT::GetMSB();\n    }\n\n    /**\n   * Get a specific digit at &quot;digit&quot; index; big integer is seen as an array of\n   * digits, where a 0 &lt;= digit &lt; base Warning: only power-of-2 bases are\n   * currently supported. Example: for number 83, index 2 and base 4 we have:\n   *\n   *                         index:0,1,2,3\n   * 83 --base 4 decomposition--&gt; (3,0,1,1) --at index 2--&gt; 1\n   *\n   * The return number is 1.\n   *\n   * @param index is the &quot;digit&quot; index of the requested digit\n   * @param base is the base with which to determine length in.\n   * @return is the requested digit\n   */\n\n    // TODO: * i to &lt;&lt; i\n    usint GetDigitAtIndexForBase(usint index, usint base) const {\n        usint DigitLen = ceil(log2(base));\n        usint digit    = 0;\n        usint newIndex = 1 + (index - 1) * DigitLen;\n        for (usint i = 1; i &lt; base; i &lt;&lt;= 1) {\n            digit += GetBitAtIndex(newIndex++) * i;\n        }\n        return digit;\n    }\n\n    /**\n   * Gets the bit at the specified index.\n   *\n   * @param index is the index of the bit to get.\n   * @return resulting bit.\n   */\n    uschar GetBitAtIndex(usint index) const {\n        if (index == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Zero index in GetBitAtIndex&quot;);\n        return static_cast&lt;uschar&gt;((m_value &gt;&gt; (index - 1)) &amp; 0x1);\n    }\n\n    /**\n   * A zero allocator that is called by the Matrix class.\n   * It is used to initialize a Matrix of NativeIntegerT objects.\n   */\n    static constexpr NativeIntegerT Allocator() noexcept {\n        return NativeIntegerT();\n    }\n\n    // STRINGS &amp; STREAMS\n\n    /**\n   * Stores the based 10 equivalent/Decimal value of the NativeIntegerT in a\n   * string object and returns it.\n   *\n   * @return value of this NativeIntegerT in base 10 represented as a string.\n   */\n    std::string ToString() const {\n        return toString(m_value);\n    }\n\n    static const std::string IntegerTypeName() {\n        return &quot;UBNATINT&quot;;\n    }\n\n    /**\n   * Console output operation.\n   *\n   * @param os is the std ostream object.\n   * @param ptr_obj is NativeIntegerT to be printed.\n   * @return is the ostream object.\n   */\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const NativeIntegerT&amp; ptr_obj) {\n        os &lt;&lt; ptr_obj.ToString();\n        return os;\n    }\n\n    template &lt;class Archive, typename T = void&gt;\n    typename std::enable_if_t&lt;std::is_same_v&lt;NativeInt, U64BITS&gt; || std::is_same_v&lt;NativeInt, U32BITS&gt;, T&gt; load(\n        Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                           &quot; is from a later version of the library&quot;);\n        }\n        ar(::cereal::make_nvp(&quot;v&quot;, m_value));\n    }\n\n#if defined(HAVE_INT128)\n    template &lt;class Archive&gt;\n    typename std::enable_if_t&lt;std::is_same_v&lt;NativeInt, U128BITS&gt; &amp;&amp; !cereal::traits::is_text_archive&lt;Archive&gt;::value,\n                              void&gt;\n    load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                           &quot; is from a later version of the library&quot;);\n        }\n        // get an array with 2 unint64_t values for m_value\n        uint64_t vec[2];\n        ar(::cereal::binary_data(vec, sizeof(vec)));  // 2*8 - size in bytes\n        m_value = vec[1];                             // most significant word\n        m_value &lt;&lt;= 64;\n        m_value += vec[0];  // least significant word\n    }\n\n    template &lt;class Archive&gt;\n    typename std::enable_if_t&lt;std::is_same_v&lt;NativeInt, U128BITS&gt; &amp;&amp; cereal::traits::is_text_archive&lt;Archive&gt;::value,\n                              void&gt;\n    load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                           &quot; is from a later version of the library&quot;);\n        }\n        // get an array with 2 unint64_t values for m_value\n        uint64_t vec[2];\n        ar(::cereal::make_nvp(&quot;i&quot;, vec));\n        m_value = vec[1];  // most significant word\n        m_value &lt;&lt;= 64;\n        m_value += vec[0];  // least significant word\n    }\n#endif\n\n    template &lt;class Archive, typename T = void&gt;\n    typename std::enable_if_t&lt;std::is_same_v&lt;NativeInt, U64BITS&gt; || std::is_same&lt;NativeInt, U32BITS&gt;::value, T&gt; save(\n        Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::make_nvp(&quot;v&quot;, m_value));\n    }\n\n#if defined(HAVE_INT128)\n    template &lt;class Archive&gt;\n    typename std::enable_if_t&lt;std::is_same_v&lt;NativeInt, U128BITS&gt; &amp;&amp; !cereal::traits::is_text_archive&lt;Archive&gt;::value,\n                              void&gt;\n    save(Archive&amp; ar, std::uint32_t const version) const {\n        // save 2 unint64_t values instead of uint128_t\n        constexpr U128BITS mask = (static_cast&lt;U128BITS&gt;(1) &lt;&lt; 64) - 1;\n        uint64_t vec[2];\n        vec[0] = m_value &amp; mask;  // least significant word\n        vec[1] = m_value &gt;&gt; 64;   // most significant word\n        ar(::cereal::binary_data(vec, sizeof(vec)));\n    }\n\n    template &lt;class Archive&gt;\n    typename std::enable_if_t&lt;std::is_same_v&lt;NativeInt, U128BITS&gt; &amp;&amp; cereal::traits::is_text_archive&lt;Archive&gt;::value,\n                              void&gt;\n    save(Archive&amp; ar, std::uint32_t const version) const {\n        // save 2 unint64_t values instead of uint128_t\n        constexpr U128BITS mask = (static_cast&lt;U128BITS&gt;(1) &lt;&lt; 64) - 1;\n        uint64_t vec[2];\n        vec[0] = m_value &amp; mask;  // least significant word\n        vec[1] = m_value &gt;&gt; 64;   // most significant word\n        ar(::cereal::make_nvp(&quot;i&quot;, vec));\n    }\n#endif\n\n    std::string SerializedObjectName() const {\n        return &quot;NATInteger&quot;;\n    }\n\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\n    static constexpr usint MaxBits() noexcept {\n        return m_uintBitLength;\n    }\n\n    static constexpr bool IsNativeInt() noexcept {\n        return true;\n    }\n\nprivate:\n    // Computes res -= a;\n    static void SubtractD(typeD&amp; res, const typeD&amp; a) {\n        if (res.lo &lt; a.lo) {\n            res.lo += m_uintMax + 1 - a.lo;\n            res.hi--;\n        }\n        else {\n            res.lo -= a.lo;\n        }\n        res.hi -= a.hi;\n    }\n\n    /**\n   * Right shifts a typeD integer by a specific number of bits\n   * and stores the result as a single-word integer.\n   *\n   * @param &amp;x double-word input\n   * @param shift the number of bits to shift by\n   * @return the result of right-shifting\n   */\n    static NativeInt RShiftD(const typeD&amp; x, int64_t shift) {\n        return (x.lo &gt;&gt; shift) | (x.hi &lt;&lt; (NativeIntegerT::MaxBits() - shift));\n    }\n\n    /**\n   * Multiplies two single-word integers and stores the result in a\n   * typeD data structure.\n   *\n   * @param a multiplier\n   * @param b multiplicand\n   * @param &amp;x result of multiplication\n   */\n    static void MultD(U32BITS a, U32BITS b, typeD&amp; res) {\n        U64BITS c{static_cast&lt;U64BITS&gt;(a) * b};\n        res.hi = static_cast&lt;U32BITS&gt;(c &gt;&gt; 32);\n        res.lo = static_cast&lt;U32BITS&gt;(c);\n    }\n\n    static void MultD(U64BITS a, U64BITS b, typeD&amp; res) {\n#if defined(__x86_64__)\n    #if defined(HAVE_INT128)\n        U128BITS c{static_cast&lt;U128BITS&gt;(a) * b};\n        res.hi = static_cast&lt;U64BITS&gt;(c &gt;&gt; 64);\n        res.lo = static_cast&lt;U64BITS&gt;(c);\n    #else\n        // clang-format off\n    __asm__(&quot;mulq %[b]&quot;\n            : [ lo ] &quot;=a&quot;(res.lo), [ hi ] &quot;=d&quot;(res.hi)\n            : [ a ] &quot;%[lo]&quot;(a), [ b ] &quot;rm&quot;(b)\n            : &quot;cc&quot;);\n                // clang-format on\n    #endif\n#elif defined(__aarch64__)\n        typeD x;\n        x.hi = 0;\n        x.lo = a;\n        U64BITS y(b);\n        res.lo = x.lo * y;\n        asm(&quot;umulh %0, %1, %2\\n\\t&quot; : &quot;=r&quot;(res.hi) : &quot;r&quot;(x.lo), &quot;r&quot;(y));\n        res.hi += x.hi * y;\n#elif defined(__arm__)  // 32 bit processor\n        uint64_t wres(0), wa(a), wb(b);\n        wres   = wa * wb;\n        res.hi = wres &gt;&gt; 32;\n        res.lo = (uint32_t)wres &amp; 0xFFFFFFFF;\n#elif __riscv\n        U128BITS wres(0), wa(a), wb(b);\n        wres   = wa * wb;\n        res.hi = (uint64_t)(wres &gt;&gt; 64);\n        res.lo = (uint64_t)wres;\n#elif defined(__EMSCRIPTEN__)  // web assembly\n        U64BITS a1 = a &gt;&gt; 32;\n        U64BITS a2 = (uint32_t)a;\n        U64BITS b1 = b &gt;&gt; 32;\n        U64BITS b2 = (uint32_t)b;\n\n        // use schoolbook multiplication\n        res.hi            = a1 * b1;\n        res.lo            = a2 * b2;\n        U64BITS lowBefore = res.lo;\n\n        U64BITS p1   = a2 * b1;\n        U64BITS p2   = a1 * b2;\n        U64BITS temp = p1 + p2;\n        res.hi += temp &gt;&gt; 32;\n        res.lo += U64BITS((uint32_t)temp) &lt;&lt; 32;\n\n        // adds the carry to the high word\n        if (lowBefore &gt; res.lo)\n            res.hi++;\n\n        // if there is an overflow in temp, add 2^32\n        if ((temp &lt; p1) || (temp &lt; p2))\n            res.hi += (U64BITS)1 &lt;&lt; 32;\n#else\n    #error Architecture not supported for MultD()\n#endif\n    }\n\n#if defined(HAVE_INT128)\n    static void MultD(U128BITS a, U128BITS b, typeD&amp; res) {\n        static constexpr U128BITS masklo = (static_cast&lt;U128BITS&gt;(1) &lt;&lt; 64) - 1;\n        static constexpr U128BITS onehi  = static_cast&lt;U128BITS&gt;(1) &lt;&lt; 64;\n\n        U128BITS a1{a &gt;&gt; 64};\n        U128BITS a2{a &amp; masklo};\n        U128BITS b1{b &gt;&gt; 64};\n        U128BITS b2{b &amp; masklo};\n        U128BITS a1b2{a1 * b2};\n        U128BITS a2b1{a2 * b1};\n        U128BITS tmp{a1b2 + a2b1};\n        U128BITS lo{a2 * b2};\n\n        res = {a1 * b1, lo};\n        res.lo += tmp &lt;&lt; 64;\n        if (lo &gt; res.lo)\n            ++res.hi;\n        if ((tmp &lt; a1b2) || (tmp &lt; a2b1))\n            res.hi += onehi;\n        res.hi += tmp &gt;&gt; 64;\n    }\n#endif\n\n    /**\n   * Multiplies two single-word integers and stores the high word of the\n   * result\n   *\n   * @param a multiplier\n   * @param b multiplicand\n   * @return the high word of the result\n   */\n    static NativeInt MultDHi(NativeInt a, NativeInt b) {\n        typeD x;\n        MultD(a, b, x);\n        return x.hi;\n    }\n\n    /**\n   * Converts a double-word integer from typeD representation\n   * to DNativeInt.\n   *\n   * @param &amp;x double-word input\n   * @return the result as DNativeInt\n   */\n    static DNativeInt GetD(const typeD&amp; x) {\n        return (DNativeInt(x.hi) &lt;&lt; NativeIntegerT::MaxBits()) | x.lo;\n    }\n\n    static std::string toString(uint32_t value) noexcept {\n        return std::to_string(value);\n    }\n\n    static std::string toString(uint64_t value) noexcept {\n        return std::to_string(value);\n    }\n\n#if defined(HAVE_INT128)\n    // TODO\n    static std::string toString(uint128_t value) noexcept {\n        constexpr size_t maxChars = 15;\n        constexpr uint128_t divisor{0x38d7ea4c68000};  // 10**15\n        std::string tmp(46, &#x27;0&#x27;);\n        auto msd_it = tmp.end() - 1;\n        auto it     = tmp.end();\n        for (auto i = 3; i != 0; --i, it -= maxChars) {\n            auto part = static_cast&lt;uint64_t&gt;(value % divisor);\n            value /= divisor;\n            if (part) {\n                auto s{std::to_string(part)};\n                msd_it = it - s.size();\n                tmp.replace(it - s.size(), it, s.begin(), s.end());\n            }\n        }\n        return std::string(msd_it, tmp.end());\n    }\n#endif\n\n    template &lt;typename T = NativeInt&gt;\n    static void ModMu(typeD&amp; prod, NativeIntegerT&amp; a, const T&amp; mv, const T&amp; mu, int64_t n,\n                      typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        prod = {0, a.m_value};\n        MultD(RShiftD(prod, n), mu, prod);\n        a.m_value -= static_cast&lt;NativeInt&gt;((GetD(prod) &gt;&gt; n + 7) * mv);\n        if (a.m_value &gt;= mv)\n            a.m_value -= mv;\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    static void ModMu(typeD&amp; prod, NativeIntegerT&amp; a, const T&amp; mv, const T&amp; mu, int64_t n,\n                      typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        prod = {0, a.m_value};\n        MultD(RShiftD(prod, n), mu, prod);\n        MultD(RShiftD(prod, n + 7), mv, prod);\n        a.m_value -= prod.lo;\n        if (a.m_value &gt;= mv)\n            a.m_value -= mv;\n    }\n};\n\n// helper template to stream vector contents provided T has an stream operator&lt;&lt;\ntemplate &lt;typename T&gt;\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;T&gt;&amp; v) {\n    os &lt;&lt; &quot;[&quot;;\n    //    for (const auto&amp; i : v)\n    for (auto&amp;&amp; i : v)\n        os &lt;&lt; &quot; &quot; &lt;&lt; i;\n    os &lt;&lt; &quot; ]&quot;;\n    return os;\n}\n// to stream internal representation\ntemplate std::ostream&amp; operator&lt;&lt; &lt;uint64_t&gt;(std::ostream&amp; os, const std::vector&lt;uint64_t&gt;&amp; v);\n\n}  // namespace intnat\n\n#endif  // LBCRYPTO_MATH_HAL_INTNAT_UBINTNAT_H\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Represents and defines plaintext encodings in OpenFHE with bit packing capabilities\n */\n\n#include &quot;encoding/packedencoding.h&quot;\n#include &quot;math/math-hal.h&quot;\n#include &quot;utils/utilities.h&quot;\n\nnamespace lbcrypto {\n\n// TODO (dsuponit): we should not have globals!\nstd::map&lt;ModulusM, NativeInteger&gt; PackedEncoding::m_initRoot;\nstd::map&lt;ModulusM, NativeInteger&gt; PackedEncoding::m_bigModulus;\nstd::map&lt;ModulusM, NativeInteger&gt; PackedEncoding::m_bigRoot;\n\nstd::map&lt;usint, usint&gt; PackedEncoding::m_automorphismGenerator;\nstd::map&lt;usint, std::vector&lt;usint&gt;&gt; PackedEncoding::m_toCRTPerm;\nstd::map&lt;usint, std::vector&lt;usint&gt;&gt; PackedEncoding::m_fromCRTPerm;\n\nbool PackedEncoding::Encode() {\n    if (this-&gt;isEncoded)\n        return true;\n    auto mod = this-&gt;encodingParams-&gt;GetPlaintextModulus();\n\n    if ((this-&gt;typeFlag == IsNativePoly) || (this-&gt;typeFlag == IsDCRTPoly)) {\n        NativeInteger q;\n\n        NativeVector temp;\n        if (this-&gt;typeFlag == IsNativePoly) {\n            q    = this-&gt;GetElementModulus().ConvertToInt();\n            temp = NativeVector(this-&gt;GetElementRingDimension(), this-&gt;GetElementModulus().ConvertToInt());\n        }\n        else {\n            q    = this-&gt;encodedVectorDCRT.GetParams()-&gt;GetParams()[0]-&gt;GetModulus().ConvertToInt();\n            temp = NativeVector(this-&gt;GetElementRingDimension(), q);\n            if (q &lt; mod)\n                &quot;hey&quot;; OPENFHE_THROW(config_error,\n                              &quot;the plaintext modulus size is larger than the size of &quot;\n                              &quot;CRT moduli; either decrease the plaintext modulus or &quot;\n                              &quot;increase the CRT moduli.&quot;);\n        }\n\n        size_t i;\n\n        NativeInteger originalSF = scalingFactorInt;\n        for (size_t j = 1; j &lt; noiseScaleDeg; j++) {\n            scalingFactorInt = scalingFactorInt.ModMul(originalSF, mod);\n        }\n\n        for (i = 0; i &lt; value.size(); i++) {\n            NativeInteger entry;\n\n            if ((PlaintextModulus)llabs(value[i]) &gt;= mod)\n                &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Cannot encode integer &quot; + std::to_string(value[i]) + &quot; at position &quot; +\n                                              std::to_string(i) + &quot; that is &gt; plaintext modulus &quot; +\n                                              std::to_string(mod));\n\n            if (value[i] &lt; 0) {\n                // It is more efficient to encode negative numbers using the ciphertext\n                // modulus no noise growth occurs\n                entry = NativeInteger(mod) - NativeInteger((uint64_t)llabs(value[i]));\n            }\n            else {\n                entry = NativeInteger(value[i]);\n            }\n\n            temp[i] = entry.ModMul(scalingFactorInt, mod);\n        }\n\n        for (; i &lt; this-&gt;GetElementRingDimension(); i++)\n            temp[i] = NativeInteger(0);\n        this-&gt;isEncoded = true;\n\n        if (this-&gt;typeFlag == IsNativePoly) {\n            // the input plaintext data is in the evaluation format\n            this-&gt;GetElement&lt;NativePoly&gt;().SetValues(std::move(temp), Format::EVALUATION);\n            // ilVector coefficients are packed and resulting ilVector is in\n            // COEFFICIENT form.\n            this-&gt;Pack(&amp;this-&gt;GetElement&lt;NativePoly&gt;(), this-&gt;encodingParams-&gt;GetPlaintextModulus());\n        }\n        else {\n            NativePoly firstElement = this-&gt;GetElement&lt;DCRTPoly&gt;().GetElementAtIndex(0);\n            // the input plaintext data is in the evaluation format\n            firstElement.SetValues(std::move(temp), Format::EVALUATION);\n            // ilVector coefficients are packed and resulting ilVector is in\n            // COEFFICIENT form.\n            this-&gt;Pack(&amp;firstElement, this-&gt;encodingParams-&gt;GetPlaintextModulus());\n            this-&gt;encodedVectorDCRT.SetElementAtIndex(0, firstElement);\n\n            const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; params           = this-&gt;encodedVectorDCRT.GetParams();\n            const std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt;&amp; nativeParams = params-&gt;GetParams();\n\n            for (size_t ii = 1; ii &lt; nativeParams.size(); ii++) {\n                NativePoly temp(firstElement);\n\n                temp.SwitchModulus(nativeParams[ii]-&gt;GetModulus(), nativeParams[ii]-&gt;GetRootOfUnity(),\n                                   nativeParams[ii]-&gt;GetBigModulus(), nativeParams[ii]-&gt;GetBigRootOfUnity());\n\n                this-&gt;encodedVectorDCRT.SetElementAtIndex(ii, std::move(temp));\n            }\n        }\n    }\n    else {\n        BigVector temp(this-&gt;GetElementRingDimension(), BigInteger(this-&gt;GetElementModulus()));\n\n        BigInteger q = this-&gt;GetElementModulus();\n\n        size_t i;\n        for (i = 0; i &lt; value.size(); i++) {\n            BigInteger entry;\n\n            if ((PlaintextModulus)llabs(value[i]) &gt;= mod)\n                &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Cannot encode integer &quot; + std::to_string(value[i]) + &quot; at position &quot; +\n                                              std::to_string(i) + &quot; that is &gt; plaintext modulus &quot; +\n                                              std::to_string(mod));\n\n            if (value[i] &lt; 0) {\n                // It is more efficient to encode negative numbers using the ciphertext\n                // modulus no noise growth occurs\n                entry = BigInteger(mod) - BigInteger((uint64_t)llabs(value[i]));\n            }\n            else {\n                entry = BigInteger(value[i]);\n            }\n\n            temp[i] = entry;\n        }\n\n        for (; i &lt; this-&gt;GetElementRingDimension(); i++)\n            temp[i] = BigInteger(0);\n        this-&gt;isEncoded = true;\n\n        // the input plaintext data is in the evaluation format\n        this-&gt;GetElement&lt;Poly&gt;().SetValues(std::move(temp), Format::EVALUATION);\n\n        // ilVector coefficients are packed and resulting ilVector is in COEFFICIENT\n        // form.\n        this-&gt;Pack(&amp;this-&gt;GetElement&lt;Poly&gt;(), this-&gt;encodingParams-&gt;GetPlaintextModulus());\n    }\n\n    return true;\n}\n\ntemplate &lt;typename T&gt;\nstatic void fillVec(const T&amp; poly, const PlaintextModulus&amp; mod, std::vector&lt;int64_t&gt;&amp; vec) {\n    vec.clear();\n\n    int64_t half = int64_t(mod) / 2;\n    // const typename T::Integer &amp;q = poly.GetModulus();\n    // typename T::Integer qHalf = q&gt;&gt;1;\n\n    for (size_t i = 0; i &lt; poly.GetLength(); i++) {\n        int64_t val = poly[i].ConvertToInt();\n        /*if (poly[i] &gt; qHalf)\n            val = (-(q-poly[i]).ConvertToInt());\n    else\n            val = poly[i].ConvertToInt();*/\n        if (val &gt; half)\n            val -= mod;\n        vec.push_back(val);\n    }\n}\n\nbool PackedEncoding::Decode() {\n    auto ptm = this-&gt;encodingParams-&gt;GetPlaintextModulus();\n\n    if ((this-&gt;typeFlag == IsNativePoly) || (this-&gt;typeFlag == IsDCRTPoly)) {\n        NativeInteger scfInv = scalingFactorInt.ModInverse(ptm);\n        if (this-&gt;typeFlag == IsNativePoly) {\n            this-&gt;Unpack(&amp;this-&gt;GetElement&lt;NativePoly&gt;(), ptm);\n            NativePoly firstElement = encodedNativeVector;\n            firstElement            = firstElement.Times(scfInv);\n            firstElement            = firstElement.Mod(ptm);\n            fillVec(firstElement, ptm, this-&gt;value);\n        }\n        else {\n            NativePoly firstElement = this-&gt;GetElement&lt;DCRTPoly&gt;().GetElementAtIndex(0);\n            this-&gt;Unpack(&amp;firstElement, ptm);\n            firstElement = firstElement.Times(scfInv);\n            firstElement = firstElement.Mod(ptm);\n            fillVec(firstElement, ptm, this-&gt;value);\n        }\n    }\n    else {\n        this-&gt;Unpack(&amp;this-&gt;GetElement&lt;Poly&gt;(), ptm);\n        fillVec(this-&gt;encodedVector, ptm, this-&gt;value);\n    }\n\n    return true;\n}\n\nvoid PackedEncoding::Destroy() {\n    m_initRoot.clear();\n    m_bigModulus.clear();\n    m_bigRoot.clear();\n\n    m_automorphismGenerator.clear();\n    m_toCRTPerm.clear();\n    m_fromCRTPerm.clear();\n}\n\nvoid PackedEncoding::SetParams(usint m, EncodingParams params) {\n    NativeInteger modulusNI(params-&gt;GetPlaintextModulus());  // native int modulus\n    std::string exception_message;\n    bool hadEx = false;\n\n    // initialize the CRT coefficients if not initialized\n    try {\n        if (IsPowerOfTwo(m)) {\n#pragma omp critical\n            { SetParams_2n(m, params); }\n        }\n        else {\n#pragma omp critical\n            {\n                const ModulusM modulusM = {modulusNI, m};\n                // Arbitrary: Bluestein based CRT Arb. So we need the 2mth root of unity\n                if (params-&gt;GetPlaintextRootOfUnity() == 0) {\n                    NativeInteger initRoot = RootOfUnity&lt;NativeInteger&gt;(2 * m, modulusNI);\n                    m_initRoot[modulusM]   = initRoot;\n                    params-&gt;SetPlaintextRootOfUnity(m_initRoot[modulusM].ConvertToInt());\n                }\n                else {\n                    m_initRoot[modulusM] = params-&gt;GetPlaintextRootOfUnity();\n                }\n\n                // Find a compatible big-modulus and root of unity for CRTArb\n                if (params-&gt;GetPlaintextBigModulus() == 0) {\n                    usint nttDim = pow(2, ceil(log2(2 * m - 1)));\n                    if ((modulusNI.ConvertToInt() - 1) % nttDim == 0) {\n                        m_bigModulus[modulusM] = modulusNI;\n                    }\n                    else {\n                        usint bigModulusSize   = ceil(log2(2 * m - 1)) + 2 * modulusNI.GetMSB() + 1;\n                        m_bigModulus[modulusM] = FirstPrime&lt;NativeInteger&gt;(bigModulusSize, nttDim);\n                    }\n                    m_bigRoot[modulusM] = RootOfUnity&lt;NativeInteger&gt;(nttDim, m_bigModulus[modulusM]);\n                    params-&gt;SetPlaintextBigModulus(m_bigModulus[modulusM]);\n                    params-&gt;SetPlaintextBigRootOfUnity(m_bigRoot[modulusM]);\n                }\n                else {\n                    m_bigModulus[modulusM] = params-&gt;GetPlaintextBigModulus();\n                    m_bigRoot[modulusM]    = params-&gt;GetPlaintextBigRootOfUnity();\n                }\n\n                // Find a generator for the automorphism group\n                if (params-&gt;GetPlaintextGenerator() == 0) {\n                    NativeInteger M(m);  // Hackish typecast\n                    NativeInteger automorphismGenerator = FindGeneratorCyclic&lt;NativeInteger&gt;(M);\n                    m_automorphismGenerator[m]          = automorphismGenerator.ConvertToInt();\n                    params-&gt;SetPlaintextGenerator(m_automorphismGenerator[m]);\n                }\n                else {\n                    m_automorphismGenerator[m] = params-&gt;GetPlaintextGenerator();\n                }\n\n                // Create the permutations that interchange the automorphism and crt\n                // ordering\n                usint phim = GetTotient(m);\n                auto tList = GetTotientList(m);\n                auto tIdx  = std::vector&lt;usint&gt;(m, -1);\n                for (usint i = 0; i &lt; phim; i++) {\n                    tIdx[tList[i]] = i;\n                }\n\n                m_toCRTPerm[m]   = std::vector&lt;usint&gt;(phim);\n                m_fromCRTPerm[m] = std::vector&lt;usint&gt;(phim);\n\n                usint curr_index = 1;\n                for (usint i = 0; i &lt; phim; i++) {\n                    m_toCRTPerm[m][tIdx[curr_index]] = i;\n                    m_fromCRTPerm[m][i]              = tIdx[curr_index];\n\n                    curr_index = curr_index * m_automorphismGenerator[m] % m;\n                }\n            }\n        }\n    }\n    catch (std::exception&amp; e) {\n        exception_message = e.what();\n        hadEx             = true;\n    }\n\n    if (hadEx)\n        &quot;hey&quot;; OPENFHE_THROW(openfhe_error, exception_message);\n}\n\ntemplate &lt;typename P&gt;\nvoid PackedEncoding::Pack(P* ring, const PlaintextModulus&amp; modulus) const {\n    OPENFHE_DEBUG_FLAG(false);\n\n    usint m = ring-&gt;GetCyclotomicOrder();  // cyclotomic order\n    NativeInteger modulusNI(modulus);      // native int modulus\n\n    const ModulusM modulusM = {modulusNI, m};\n\n    // Do the precomputation if not initialized\n    if (this-&gt;m_initRoot[modulusM].GetMSB() == 0) {\n        SetParams(m, EncodingParams(std::make_shared&lt;EncodingParamsImpl&gt;(modulus)));\n    }\n\n    usint phim = ring-&gt;GetRingDimension();\n\n    OPENFHE_DEBUG(&quot;Pack for order &quot; &lt;&lt; m &lt;&lt; &quot; phim &quot; &lt;&lt; phim &lt;&lt; &quot; modulus &quot; &lt;&lt; modulusNI);\n\n    // copy values from ring to the vector\n    NativeVector slotValues(phim, modulusNI);\n    for (usint i = 0; i &lt; phim; i++) {\n        slotValues[i] = (*ring)[i].ConvertToInt();\n    }\n\n    OPENFHE_DEBUG(*ring);\n    OPENFHE_DEBUG(slotValues);\n\n    // Transform Eval to Coeff\n    if (IsPowerOfTwo(m)) {\n        if (m_toCRTPerm[m].size() &gt; 0) {\n            // Permute to CRT Order\n            NativeVector permutedSlots(phim, modulusNI);\n\n            for (usint i = 0; i &lt; phim; i++) {\n                permutedSlots[i] = slotValues[m_toCRTPerm[m][i]];\n            }\n            ChineseRemainderTransformFTT&lt;NativeVector&gt;().InverseTransformFromBitReverse(\n                permutedSlots, m_initRoot[modulusM], m, &amp;slotValues);\n        }\n        else {\n            ChineseRemainderTransformFTT&lt;NativeVector&gt;().InverseTransformFromBitReverse(\n                slotValues, m_initRoot[modulusM], m, &amp;slotValues);\n        }\n    }\n    else {  // Arbitrary cyclotomic\n        // Permute to CRT Order\n        NativeVector permutedSlots(phim, modulusNI);\n        for (usint i = 0; i &lt; phim; i++) {\n            permutedSlots[i] = slotValues[m_toCRTPerm[m][i]];\n        }\n\n        OPENFHE_DEBUG(&quot;permutedSlots &quot; &lt;&lt; permutedSlots);\n        OPENFHE_DEBUG(&quot;m_initRoot[modulusM] &quot; &lt;&lt; m_initRoot[modulusM]);\n        OPENFHE_DEBUG(&quot;m_bigModulus[modulusM] &quot; &lt;&lt; m_bigModulus[modulusM]);\n        OPENFHE_DEBUG(&quot;m_bigRoot[modulusM] &quot; &lt;&lt; m_bigRoot[modulusM]);\n\n        slotValues = ChineseRemainderTransformArb&lt;NativeVector&gt;().InverseTransform(\n            permutedSlots, m_initRoot[modulusM], m_bigModulus[modulusM], m_bigRoot[modulusM], m);\n    }\n\n    OPENFHE_DEBUG(&quot;slotvalues now &quot; &lt;&lt; slotValues);\n    // copy values into the slotValuesRing\n    typename P::Vector slotValuesRing(phim, ring-&gt;GetModulus());\n    for (usint i = 0; i &lt; phim; i++) {\n        slotValuesRing[i] = typename P::Integer(slotValues[i].ConvertToInt());\n    }\n\n    ring-&gt;SetValues(std::move(slotValuesRing), Format::COEFFICIENT);\n    OPENFHE_DEBUG(*ring);\n}\n\ntemplate &lt;typename P&gt;\nvoid PackedEncoding::Unpack(P* ring, const PlaintextModulus&amp; modulus) const {\n    OPENFHE_DEBUG_FLAG(false);\n\n    usint m = ring-&gt;GetCyclotomicOrder();  // cyclotomic order\n    NativeInteger modulusNI(modulus);      // native int modulus\n\n    const ModulusM modulusM = {modulusNI, m};\n\n    // Do the precomputation if not initialized\n    if (this-&gt;m_initRoot[modulusM].GetMSB() == 0) {\n        SetParams(m, EncodingParams(std::make_shared&lt;EncodingParamsImpl&gt;(modulus)));\n    }\n\n    usint phim = ring-&gt;GetRingDimension();  // ring dimension\n\n    OPENFHE_DEBUG(&quot;Unpack for order &quot; &lt;&lt; m &lt;&lt; &quot; phim &quot; &lt;&lt; phim &lt;&lt; &quot; modulus &quot; &lt;&lt; modulusNI);\n\n    // copy aggregate plaintext values\n    NativeVector packedVector(phim, modulusNI);\n    for (usint i = 0; i &lt; phim; i++) {\n        packedVector[i] = NativeInteger((*ring)[i].ConvertToInt());\n    }\n\n    OPENFHE_DEBUG(packedVector);\n\n    // Transform Coeff to Eval\n    NativeVector permutedSlots(phim, modulusNI);\n    if (IsPowerOfTwo(m)) {\n        ChineseRemainderTransformFTT&lt;NativeVector&gt;().ForwardTransformToBitReverse(packedVector, m_initRoot[modulusM], m,\n                                                                                  &amp;permutedSlots);\n    }\n    else {  // Arbitrary cyclotomic\n        permutedSlots = ChineseRemainderTransformArb&lt;NativeVector&gt;().ForwardTransform(\n            packedVector, m_initRoot[modulusM], m_bigModulus[modulusM], m_bigRoot[modulusM], m);\n    }\n\n    if (m_fromCRTPerm[m].size() &gt; 0) {\n        // Permute to automorphism Order\n        for (usint i = 0; i &lt; phim; i++) {\n            packedVector[i] = permutedSlots[m_fromCRTPerm[m][i]];\n        }\n    }\n    else {\n        packedVector = permutedSlots;\n    }\n\n    OPENFHE_DEBUG(packedVector);\n\n    // copy values into the slotValuesRing\n    typename P::Vector packedVectorRing(phim, ring-&gt;GetModulus());\n    for (usint i = 0; i &lt; phim; i++) {\n        packedVectorRing[i] = typename P::Integer(packedVector[i].ConvertToInt());\n    }\n\n    ring-&gt;SetValues(std::move(packedVectorRing), Format::COEFFICIENT);\n}\n\nvoid PackedEncoding::SetParams_2n(usint m, const NativeInteger&amp; modulusNI) {\n    if (!MillerRabinPrimalityTest(modulusNI)) {\n        &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;The modulus value is [&quot; + modulusNI.ToString() + &quot;]. It must be prime.&quot;);\n    }\n\n    const ModulusM modulusM = {modulusNI, m};\n\n    // Power of two: m/2-point FTT. So we need the mth root of unity\n    m_initRoot[modulusM] = RootOfUnity&lt;NativeInteger&gt;(m, modulusNI);\n\n    // Create the permutations that interchange the automorphism and crt ordering\n    // First we create the cyclic group generated by 5 and then adjoin the\n    // co-factor by multiplying by (-1)\n\n    usint phim      = (m &gt;&gt; 1);\n    usint phim_by_2 = (m &gt;&gt; 2);\n\n    m_toCRTPerm[m]   = std::vector&lt;usint&gt;(phim);\n    m_fromCRTPerm[m] = std::vector&lt;usint&gt;(phim);\n\n    usint curr_index = 1;\n    usint logn       = std::round(log2(m / 2));\n    for (usint i = 0; i &lt; phim_by_2; i++) {\n        m_toCRTPerm[m][ReverseBits((curr_index - 1) / 2, logn)] = i;\n        m_fromCRTPerm[m][i]                                     = ReverseBits((curr_index - 1) / 2, logn);\n\n        usint cofactor_index = curr_index * (m - 1) % m;\n\n        m_toCRTPerm[m][ReverseBits((cofactor_index - 1) / 2, logn)] = i + phim_by_2;\n        m_fromCRTPerm[m][i + phim_by_2]                             = ReverseBits((cofactor_index - 1) / 2, logn);\n\n        curr_index = curr_index * 5 % m;\n    }\n}\n\nvoid PackedEncoding::SetParams_2n(usint m, EncodingParams params) {\n    NativeInteger modulusNI(params-&gt;GetPlaintextModulus());  // native int modulus\n\n    if (!MillerRabinPrimalityTest(modulusNI)) {\n        &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;The modulus value is [&quot; + modulusNI.ToString() + &quot;]. It must be prime.&quot;);\n    }\n\n    const ModulusM modulusM = {modulusNI, m};\n\n    // Power of two: m/2-point FTT. So we need the mth root of unity\n    if (params-&gt;GetPlaintextRootOfUnity() == 0) {\n        m_initRoot[modulusM] = RootOfUnity&lt;NativeInteger&gt;(m, modulusNI);\n        params-&gt;SetPlaintextRootOfUnity(m_initRoot[modulusM]);\n    }\n    else {\n        m_initRoot[modulusM] = params-&gt;GetPlaintextRootOfUnity();\n    }\n\n    // Create the permutations that interchange the automorphism and crt ordering\n    // First we create the cyclic group generated by 5 and then adjoin the\n    // co-factor by multiplying by (-1)\n    usint phim      = (m &gt;&gt; 1);\n    usint phim_by_2 = (m &gt;&gt; 2);\n\n    m_toCRTPerm[m]   = std::vector&lt;usint&gt;(phim);\n    m_fromCRTPerm[m] = std::vector&lt;usint&gt;(phim);\n\n    usint curr_index = 1;\n    usint logn       = std::round(log2(m &gt;&gt; 1));\n    for (usint i = 0; i &lt; phim_by_2; i++) {\n        m_toCRTPerm[m][ReverseBits((curr_index - 1) / 2, logn)] = i;\n        m_fromCRTPerm[m][i]                                     = ReverseBits((curr_index - 1) / 2, logn);\n\n        usint cofactor_index = curr_index * (m - 1) % m;\n\n        m_toCRTPerm[m][ReverseBits((cofactor_index - 1) / 2, logn)] = i + phim_by_2;\n        m_fromCRTPerm[m][i + phim_by_2]                             = ReverseBits((cofactor_index - 1) / 2, logn);\n\n        curr_index = curr_index * 5 % m;\n    }\n}\n}  // namespace lbcrypto\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  This code provides number theory utilities\n */\n\n#ifndef LBCRYPTO_INC_MATH_NBTHEORY_IMPL_H\n#define LBCRYPTO_INC_MATH_NBTHEORY_IMPL_H\n\n#define _USE_MATH_DEFINES\n\n#include &quot;math/distributiongenerator.h&quot;\n#include &quot;math/nbtheory.h&quot;\n\n#include &quot;utils/debug.h&quot;\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/inttypes.h&quot;\n\n#include &lt;cmath&gt;\n#include &lt;limits&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n#include &lt;vector&gt;\n\nnamespace lbcrypto {\n\n/*\n Generates a random number between 0 and n.\n Input: BigInteger n.\n Output: Randomly generated BigInteger  between 0 and n.\n */\ntemplate &lt;typename IntType&gt;\nstatic IntType RNG(const IntType&amp; modulus) {\n    static constexpr uint32_t chunk_min{0};\n    static constexpr uint32_t chunk_max{std::numeric_limits&lt;uint32_t&gt;::max()};\n    static constexpr uint32_t chunk_width{std::numeric_limits&lt;uint32_t&gt;::digits};\n    static std::uniform_int_distribution&lt;uint32_t&gt; distribution(chunk_min, chunk_max);\n\n    uint32_t chunksPerValue{(modulus.GetMSB() - 1) / chunk_width};\n    uint32_t shiftChunk{chunksPerValue * chunk_width};\n    std::uniform_int_distribution&lt;uint32_t&gt;::param_type bound(chunk_min, (modulus &gt;&gt; shiftChunk).ConvertToInt());\n\n    while (true) {\n        IntType result{};\n        for (uint32_t i{0}, shift{0}; i &lt; chunksPerValue; ++i, shift += chunk_width)\n            result += IntType{distribution(PseudoRandomNumberGenerator::GetPRNG())} &lt;&lt; shift;\n        result += IntType{distribution(PseudoRandomNumberGenerator::GetPRNG(), bound)} &lt;&lt; shiftChunk;\n        if (result &lt; modulus)\n            return result;\n    }\n}\n/*\n A witness function used for the Miller-Rabin Primality test.\n Inputs: a is a randomly generated witness between 2 and p-1,\n p is the number to be tested for primality,\n s and d satisfy p-1 = ((2^s) * d), d is odd.\n Output: true if p is composite,\n false if p is likely prime\n */\ntemplate &lt;typename IntType&gt;\nstatic bool WitnessFunction(const IntType&amp; a, const IntType&amp; d, usint s, const IntType&amp; p) {\n    IntType mod  = a.ModExp(d, p);\n    bool prevMod = false;\n    for (usint i = 0; i &lt; s; ++i) {\n        prevMod = (mod != IntType(1) &amp;&amp; mod != p - IntType(1));\n        mod.ModMulFastEq(mod, p);\n        if (mod == IntType(1) &amp;&amp; prevMod)\n            return true;\n    }\n    return (mod != IntType(1));\n}\n\n/*\n A helper function to RootOfUnity function. This finds a generator for a given\n prime q. Input: BigInteger q which is a prime. Output: A generator of prime q\n */\ntemplate &lt;typename IntType&gt;\nstatic IntType FindGenerator(const IntType&amp; q) {\n    IntType qm1(q - IntType(1));\n    IntType qm2(q - IntType(2));\n    std::set&lt;IntType&gt; primeFactors;\n    PrimeFactorize&lt;IntType&gt;(qm1, primeFactors);\n    usint cnt;\n    IntType gen;\n    do {\n        cnt = 0;\n        gen = RNG(qm2) + IntType(1);\n        for (auto it = primeFactors.begin(); it != primeFactors.end(); ++it, ++cnt) {\n            if (gen.ModExp(qm1 / (*it), q) == IntType(1))\n                break;\n        }\n    } while (cnt != primeFactors.size());\n    return gen;\n}\n\n/*\n A helper function for arbitrary cyclotomics. This finds a generator for any\n composite q (cyclic group). Input: BigInteger q (cyclic group). Output: A\n generator of q\n */\ntemplate &lt;typename IntType&gt;\nIntType FindGeneratorCyclic(const IntType&amp; q) {\n    IntType phi_q(GetTotient(q.ConvertToInt()));\n    IntType phi_q_m1(GetTotient(q.ConvertToInt()));\n    std::set&lt;IntType&gt; primeFactors;\n    PrimeFactorize&lt;IntType&gt;(phi_q, primeFactors);\n    usint cnt;\n    IntType gen;\n    do {\n        cnt = 0;\n        gen = RNG(phi_q_m1) + IntType(1);  // gen is random in [1, phi(q)]\n\n        // Generator must lie in the group!\n        if (GreatestCommonDivisor&lt;IntType&gt;(gen, q) != IntType(1))\n            continue;\n\n        // Order of a generator cannot divide any co-factor\n        for (auto it = primeFactors.begin(); it != primeFactors.end(); ++it, ++cnt) {\n            if (gen.ModExp(phi_q / (*it), q) == IntType(1))\n                break;\n        }\n    } while (cnt != primeFactors.size());\n    return gen;\n}\n\n/*\n A helper function for arbitrary cyclotomics. Checks if g is a generator of q\n (supports any cyclic group, not just prime-modulus groups) Input: Candidate\n generator g and modulus q Output: returns true if g is a generator for q\n */\ntemplate &lt;typename IntType&gt;\nbool IsGenerator(const IntType&amp; g, const IntType&amp; q) {\n    IntType qm1(GetTotient(q.ConvertToInt()));\n    std::set&lt;IntType&gt; primeFactors;\n    PrimeFactorize&lt;IntType&gt;(qm1, primeFactors);\n    usint cnt = 0;\n    for (auto it = primeFactors.begin(); it != primeFactors.end(); ++it, ++cnt) {\n        if (g.ModExp(qm1 / (*it), q) == IntType(1))\n            break;\n    }\n    return cnt == primeFactors.size();\n}\n\n/*\n finds roots of unity for given input.  Assumes the the input is a power of two.\n Mostly likely does not give correct results otherwise. input:  m as number\n which is cyclotomic(in format of int), modulo which is used to find generator\n (in format of BigInteger)\n\n output:  root of unity (in format of BigInteger)\n */\ntemplate &lt;typename IntType&gt;\nIntType RootOfUnity(usint m, const IntType&amp; modulo) {\n    IntType M(m);\n    if ((modulo - IntType(1)).Mod(M) != IntType(0)) {\n        std::string errMsg =\n            &quot;Please provide a primeModulus(q) and a cyclotomic number(m) &quot;\n            &quot;satisfying the condition: (q-1)/m is an integer. The values of &quot;\n            &quot;primeModulus = &quot; +\n            modulo.ToString() + &quot; and m = &quot; + std::to_string(m) + &quot; do not satisfy this condition&quot;;\n        &quot;hey&quot;; OPENFHE_THROW(math_error, errMsg);\n    }\n\n    IntType gen    = FindGenerator(modulo);\n    IntType result = gen.ModExp((modulo - IntType(1)).DividedBy(M), modulo);\n    if (result == IntType(1))\n        result = RootOfUnity(m, modulo);\n\n    /*\n   * At this point, result contains a primitive root of unity. However,\n   * we want to return the minimum root of unity, to avoid different\n   * crypto contexts having different roots of unity for the same\n   * cyclotomic order and moduli. Therefore, we are going to cycle over\n   * all primitive roots of unity and select the smallest one (minRU).\n   *\n   * To cycle over all primitive roots of unity, we raise the root of\n   * unity in result to all the powers that are co-prime to the\n   * cyclotomic order. In power-of-two cyclotomics, this will be the\n   * set of all odd powers, but here we use a more general routine\n   * to support arbitrary cyclotomics.\n   *\n   */\n\n    IntType mu(modulo.ComputeMu());\n    IntType x(1);\n    x.ModMulEq(result, modulo, mu);\n\n    std::vector&lt;IntType&gt; coprimes = GetTotientList&lt;IntType&gt;(m);\n    IntType minRU(x);\n    IntType curPowIdx(1);\n    for (size_t i = 0; i &lt; coprimes.size(); ++i) {\n        auto nextPowIdx = coprimes[i];\n        IntType diffPow(nextPowIdx - curPowIdx);\n        for (IntType j(0); j &lt; diffPow; j += IntType(1))\n            x.ModMulEq(result, modulo, mu);\n        if (x &lt; minRU &amp;&amp; x != IntType(1))\n            minRU = x;\n        curPowIdx = nextPowIdx;\n    }\n    return minRU;\n}\n\ntemplate &lt;typename IntType&gt;\nstd::vector&lt;IntType&gt; RootsOfUnity(usint m, const std::vector&lt;IntType&gt; moduli) {\n    std::vector&lt;IntType&gt; rootsOfUnity(moduli.size());\n    for (size_t i = 0; i &lt; moduli.size(); ++i)\n        rootsOfUnity[i] = RootOfUnity(m, moduli[i]);\n    return rootsOfUnity;\n}\n\ntemplate &lt;typename IntType&gt;\nIntType GreatestCommonDivisor(const IntType&amp; a, const IntType&amp; b) {\n    static const IntType ZERO(0);\n    auto m_a(a);\n    auto m_b(b);\n    while (m_b != ZERO) {\n        auto tmp(m_b);\n        m_b = m_a % m_b;\n        m_a = tmp;\n    }\n    return m_a;\n}\n\n/*\n The Miller-Rabin Primality Test\n Input: p the number to be tested for primality.\n Output: true if p is prime,\n false if p is not prime\n */\ntemplate &lt;typename IntType&gt;\nbool MillerRabinPrimalityTest(const IntType&amp; p, const usint niter) {\n    //    constexpr IntType ZERO(0);\n    //    constexpr IntType TWO(2);\n    //    constexpr IntType THREE(3);\n    //    constexpr IntType FIVE(5);\n    static const IntType ZERO(0);\n    static const IntType TWO(2);\n    static const IntType THREE(3);\n    static const IntType FIVE(5);\n\n    if (p == TWO || p == THREE || p == FIVE)\n        return true;\n    if (p &lt; TWO || (p.Mod(TWO) == ZERO))\n        return false;\n\n    IntType d(p - IntType(1));\n    usint s(0);\n    while (d.Mod(TWO) == ZERO) {\n        // d.DividedByEq(TWO);\n        d.RShiftEq(1);\n        ++s;\n    }\n    for (usint i = 0; i &lt; niter; ++i) {\n        if (WitnessFunction(RNG(p - THREE).ModAdd(TWO, p), d, s, p))\n            return false;\n    }\n    return true;\n}\n\n/*\n The Pollard Rho factorization of a number n.\n Input: n the number to be factorized.\n Output: a factor of n.\n */\ntemplate &lt;typename IntType&gt;\nconst IntType PollardRhoFactorization(const IntType&amp; n) {\n    if (n.Mod(IntType(2)) == IntType(0))\n        return IntType(2);\n    IntType divisor(1);\n    IntType c(RNG(n));\n    IntType x(RNG(n));\n    IntType xx(x);\n    IntType mu(n.ComputeMu());\n    do {\n        x       = x.ModMul(x, n, mu).ModAdd(c, n, mu);\n        xx      = xx.ModMul(xx, n, mu).ModAdd(c, n, mu);\n        xx      = xx.ModMul(xx, n, mu).ModAdd(c, n, mu);\n        divisor = GreatestCommonDivisor((x &gt; xx) ? x - xx : xx - x, n);\n    } while (divisor == IntType(1));\n    return divisor;\n}\n\n/*\n Recursively factorizes and find the distinct primefactors of a number\n Input: n is the number to be prime factorized,\n primeFactors is a set of prime factors of n.\n */\ntemplate &lt;typename IntType&gt;\nvoid PrimeFactorize(IntType n, std::set&lt;IntType&gt;&amp; primeFactors) {\n    if (n == IntType(0) || n == IntType(1))\n        return;\n    if (MillerRabinPrimalityTest(n)) {\n        primeFactors.insert(n);\n        return;\n    }\n\n    IntType divisor(PollardRhoFactorization(n));\n    PrimeFactorize(divisor, primeFactors);\n    PrimeFactorize(n / divisor, primeFactors);\n}\n\n// issue-881: make sure we don&#x27;t overflow an IntType\ntemplate &lt;typename IntType&gt;\nIntType FirstPrime(uint64_t nBits, uint64_t m) {\n    if constexpr (std::is_same_v&lt;IntType, NativeInteger&gt;) {\n        if (nBits &gt; MAX_MODULUS_SIZE)\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Requested bit length &quot; + std::to_string(nBits) +\n                                          &quot; exceeds maximum allowed length &quot; + std::to_string(MAX_MODULUS_SIZE));\n    }\n    try {\n        IntType mi(m);\n        IntType qNew(IntType(1) &lt;&lt; nBits);\n        IntType r(qNew.Mod(mi));\n        IntType qNew2(qNew + IntType(1));\n        if (r &gt; IntType(0))\n            qNew2 += (mi - r);\n        if (qNew2 &lt; qNew)\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;FirstPrime parameters overflow this integer implementation&quot;);\n        while (!MillerRabinPrimalityTest((qNew = qNew2))) {\n            qNew2 = qNew + mi;\n            if (qNew2 &lt; qNew)\n                &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;FirstPrime overflow growing candidate&quot;);\n        }\n        return qNew;\n    }\n    catch (...) {\n        &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;FirstPrime math exception&quot;);\n    }\n}\n\ntemplate &lt;typename IntType&gt;\nIntType NextPrime(const IntType&amp; q, uint64_t m) {\n    IntType M(m), qNew(q + M);\n    while (!MillerRabinPrimalityTest(qNew)) {\n        if ((qNew += M) &lt; q)\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;NextPrime overflow growing candidate&quot;);\n    }\n    return qNew;\n}\n\ntemplate &lt;typename IntType&gt;\nIntType PreviousPrime(const IntType&amp; q, uint64_t m) {\n    IntType M(m), qNew(q - M);\n    while (!MillerRabinPrimalityTest(qNew)) {\n        if ((qNew -= M) &gt; q)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Moduli size is not sufficient! Must be increased.&quot;);\n    }\n    return qNew;\n}\n\ntemplate &lt;typename IntType&gt;\nIntType NextPowerOfTwo(IntType n) {\n    usint result = ceil(log2(n));\n    return result;\n}\n\n/*Naive Loop to find coprimes to n*/\ntemplate &lt;typename IntType&gt;\nstd::vector&lt;IntType&gt; GetTotientList(const IntType&amp; n) {\n    std::vector&lt;IntType&gt; result;\n    static const IntType one(1);\n    for (IntType i = one; i &lt; n; i = i + one) {\n        if (GreatestCommonDivisor(i, n) == one)\n            result.push_back(i);\n    }\n    return result;\n}\n\n/* Calculate the remainder from polynomial division */\ntemplate &lt;typename IntVector&gt;\nIntVector PolyMod(const IntVector&amp; dividend, const IntVector&amp; divisor, const typename IntVector::Integer&amp; modulus) {\n    auto mu(modulus.ComputeMu());\n    usint divisorLength(divisor.GetLength());\n    usint dividendLength(dividend.GetLength());\n    usint runs(dividendLength - divisorLength + 1);\n    IntVector runningDividend(dividend);\n    for (usint i = 0; i &lt; runs; ++i) {\n        // get the highest degree coeff\n        auto divConst(runningDividend[dividendLength - 1]);\n        usint divisorPtr(divisorLength - 1);\n        for (usint j = 0; j &lt; dividendLength - i - 1; j++) {\n            auto&amp; rdtmp1 = runningDividend[dividendLength - 1 - j];\n            rdtmp1       = runningDividend[dividendLength - 2 - j];\n            if (divisorPtr &gt; j)\n                rdtmp1.ModSubEq(divisor[divisorPtr - 1 - j] * divConst, modulus, mu);\n        }\n    }\n\n    IntVector result(divisorLength - 1, modulus);\n    for (usint i = 0, j = runs; i &lt; divisorLength - 1; ++i, ++j)\n        result[i] = runningDividend[j];\n    return result;\n}\n\ntemplate &lt;typename IntVector&gt;\nIntVector PolynomialMultiplication(const IntVector&amp; a, const IntVector&amp; b) {\n    usint degreeA(a.GetLength());\n    usint degreeB(b.GetLength());\n    usint degreeResultant(degreeA + degreeB - 1);\n    const auto&amp; modulus = a.GetModulus();\n    IntVector result(degreeResultant, modulus);\n    for (usint i = 0; i &lt; degreeA; i++) {\n        for (usint j = 0; j &lt; degreeB; j++) {\n            result[i + j].ModAddEq(a[i] * b[j], modulus);\n        }\n    }\n    return result;\n}\n\ntemplate &lt;typename IntVector&gt;\nIntVector GetCyclotomicPolynomial(usint m, const typename IntVector::Integer&amp; modulus) {\n    auto intCP = GetCyclotomicPolynomialRecursive(m);\n    IntVector result(intCP.size(), modulus);\n    for (usint i = 0; i &lt; intCP.size(); i++) {\n        auto val = intCP[i];\n        if (val &gt; -1) {\n            result[i] = typename IntVector::Integer(val);\n        }\n        else {\n            result[i] = modulus - typename IntVector::Integer(-val);\n        }\n    }\n    return result;\n}\n\ntemplate &lt;typename IntVector&gt;\ntypename IntVector::Integer SyntheticRemainder(const IntVector&amp; dividend, const typename IntVector::Integer&amp; a,\n                                               const typename IntVector::Integer&amp; modulus) {\n    auto mu  = modulus.ComputeMu();\n    auto val = dividend[dividend.GetLength() - 1];\n    for (int i = dividend.GetLength() - 2; i &gt;= 0; --i)\n        val = (dividend[i] + a * val).Mod(modulus, mu);\n    return val;\n}\n\ntemplate &lt;typename IntVector&gt;\nIntVector SyntheticPolyRemainder(const IntVector&amp; dividend, const IntVector&amp; aList,\n                                 const typename IntVector::Integer&amp; modulus) {\n    IntVector result(aList.GetLength(), modulus);\n    for (usint i = 0; i &lt; aList.GetLength(); ++i)\n        result[i] = SyntheticRemainder(dividend, aList[i], modulus);\n    return result;\n}\n\ntemplate &lt;typename IntVector&gt;\nIntVector PolynomialPower(const IntVector&amp; input, usint power) {\n    usint finalDegree = (input.GetLength() - 1) * power;\n    IntVector finalPoly(finalDegree + 1, input.GetModulus());\n    for (usint i = 0; i &lt; input.GetLength(); ++i)\n        finalPoly[i * power] = input[i];\n    return finalPoly;\n}\n\ntemplate &lt;typename IntVector&gt;\nIntVector SyntheticPolynomialDivision(const IntVector&amp; dividend, const typename IntVector::Integer&amp; a,\n                                      const typename IntVector::Integer&amp; modulus) {\n    auto mu(modulus.ComputeMu());\n    usint n(dividend.GetLength() - 1);\n    IntVector result(n, modulus);\n    result[n - 1] = dividend[n];\n    auto val(dividend[n]);\n    for (int i = n - 1; i &gt; 0; i--) {\n        val           = (val * a + dividend[i]).Mod(modulus, mu);\n        result[i - 1] = val;\n    }\n    return result;\n}\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/mubintvecnat.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/mubintvecnat.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/mubintvecnat.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n * This file contains the vector manipulation functionality for native integers\n */\n\n#ifndef LBCRYPTO_INC_MATH_HAL_INTNAT_MUBINTVECNAT_H\n#define LBCRYPTO_INC_MATH_HAL_INTNAT_MUBINTVECNAT_H\n\n#include &quot;math/hal/basicint.h&quot;\n#include &quot;math/hal/intnat/ubintnat.h&quot;\n#include &quot;math/hal/vector.h&quot;\n\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/inttypes.h&quot;\n#include &quot;utils/serializable.h&quot;\n\n#include &lt;algorithm&gt;\n#include &lt;initializer_list&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\n// the following should be set to 1 in order to have native vector use block\n// allocations then determine if you want dynamic or static allocations by\n// settingdefining STAIC_POOLS on line 24 of\n// xallocator.cpp\n#define BLOCK_VECTOR_ALLOCATION 0  // set to 1 to use block allocations\n\n/**\n * @namespace intnat\n * The namespace of intnat\n */\nnamespace intnat {\n\n// Forward declare class and give it an alias for the expected type\ntemplate &lt;typename IntType&gt;\nclass NativeVectorT;\nusing NativeVector = NativeVectorT&lt;NativeInteger&gt;;\n\n/**\n * @brief The class for representing vectors of native integers.\n */\n\n#if 0  // allocator that reports bytes used.\ntemplate &lt;class Tp&gt;\nstruct NAlloc {\n    typedef Tp value_type;\n    NAlloc() = default;\n    template &lt;class T&gt; NAlloc(const NAlloc&lt;T&gt;&amp;) {}\n    Tp* allocate(std::size_t n) {\n        n *= sizeof(Tp);\n        return static_cast&lt;Tp*&gt;(::operator new(n));\n    }\n    void deallocate(Tp* p, std::size_t n) {\n        std::cout &lt;&lt; &quot;deallocating &quot; &lt;&lt; n*sizeof*p &lt;&lt; &quot; bytes\\n&quot;;\n        ::operator delete(p);\n    }\n};\ntemplate &lt;class T, class U&gt;\nbool operator==(const NAlloc&lt;T&gt;&amp;, const NAlloc&lt;U&gt;&amp;) { return true; }\ntemplate &lt;class T, class U&gt;\nbool operator!=(const NAlloc&lt;T&gt;&amp;, const NAlloc&lt;U&gt;&amp;) { return false; }\n#endif\n\n#if 0  // allocator that reports bytes used.\ntemplate &lt;class Tp&gt;\nstruct NAlloc {\n    typedef Tp value_type;\n    NAlloc() = default;\n    template &lt;class T&gt; NAlloc(const NAlloc&lt;T&gt;&amp;) {}\n    Tp* allocate(std::size_t n) {\n        n *= sizeof(Tp);\n        std::cout &lt;&lt; &quot;allocating   &quot; &lt;&lt; n &lt;&lt; &quot; bytes\\n&quot;;\n        return static_cast&lt;Tp*&gt;(::operator new(n));\n    }\n    void deallocate(Tp* p, std::size_t n) {\n        std::cout &lt;&lt; &quot;deallocating &quot; &lt;&lt; n*sizeof*p &lt;&lt; &quot; bytes\\n&quot;;\n        ::operator delete(p);\n    }\n};\ntemplate &lt;class T, class U&gt;\nbool operator==(const NAlloc&lt;T&gt;&amp;, const NAlloc&lt;U&gt;&amp;) { return true; }\ntemplate &lt;class T, class U&gt;\nbool operator!=(const NAlloc&lt;T&gt;&amp;, const NAlloc&lt;U&gt;&amp;) { return false; }\n#endif\n\ntemplate &lt;class IntegerType&gt;\nclass NativeVectorT final : public lbcrypto::BigVectorInterface&lt;NativeVectorT&lt;IntegerType&gt;, IntegerType&gt;,\n                            public lbcrypto::Serializable {\nprivate:\n    // m_modulus stores the internal modulus of the vector.\n    IntegerType m_modulus{0};\n\n#if BLOCK_VECTOR_ALLOCATION != 1\n    std::vector&lt;IntegerType&gt; m_data{};\n#else\n    xvector&lt;IntegerType&gt; m_data;\n#endif\n\n    // function to check if the index is a valid index.\n    bool IndexCheck(size_t length) const {\n        return length &lt; m_data.size();\n    }\n\npublic:\n    using BasicInt = typename IntegerType::Integer;\n\n    constexpr NativeVectorT() = default;\n\n    static constexpr NativeVectorT Single(const IntegerType&amp; val, const IntegerType&amp; modulus) noexcept {\n        return NativeVectorT(1, modulus, val);\n    }\n\n    /**\n   * Basic constructor for specifying the length of the vector.\n   *\n   * @param length is the length of the native vector, in terms of the number of\n   * entries.\n   */\n    explicit constexpr NativeVectorT(usint length) noexcept : m_data(length) {}\n\n    /**\n   * Basic constructor for specifying the length of the vector and the modulus.\n   *\n   * @param length is the length of the native vector, in terms of the number of\n   * entries.\n   * @param modulus is the modulus of the ring.\n   */\n    constexpr NativeVectorT(usint length, const IntegerType&amp; modulus) noexcept : m_modulus{modulus}, m_data(length) {\n        // TODO: better performance if this check is done at poly level\n        //        if (modulus.GetMSB() &gt; MAX_MODULUS_SIZE)\n        //            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::not_available_error, std::to_string(modulus.GetMSB()) +\n        //                              &quot; bits larger than max modulus bits &quot; + std::to_string(MAX_MODULUS_SIZE));\n    }\n\n    constexpr NativeVectorT(usint length, const IntegerType&amp; modulus, const IntegerType&amp; val) noexcept\n        : m_modulus{modulus}, m_data(length, val.Mod(modulus)) {\n        // TODO: better performance if this check is done at poly level\n        //        if (modulus.GetMSB() &gt; MAX_MODULUS_SIZE)\n        //            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::not_available_error, std::to_string(modulus.GetMSB()) +\n        //                              &quot; bits larger than max modulus bits &quot; + std::to_string(MAX_MODULUS_SIZE));\n    }\n\n    /**\n   * Basic constructor for copying a vector\n   *\n   * @param bigVector is the native vector to be copied.\n   */\n    constexpr NativeVectorT(const NativeVectorT&amp; v) noexcept : m_modulus{v.m_modulus}, m_data{v.m_data} {}\n\n    /**\n   * Basic move constructor for moving a vector\n   *\n   * @param &amp;&amp;bigVector is the native vector to be moved.\n   */\n    constexpr NativeVectorT(NativeVectorT&amp;&amp; v) noexcept\n        : m_modulus{std::move(v.m_modulus)}, m_data{std::move(v.m_data)} {}\n\n    /**\n   * Basic constructor for specifying the length of the vector\n   * the modulus and an initializer list.\n   *\n   * @param length is the length of the native vector, in terms of the number of\n   * entries.\n   * @param modulus is the modulus of the ring.\n   * @param rhs is an initializer list of strings\n   */\n\n    NativeVectorT(usint length, const IntegerType&amp; modulus, std::initializer_list&lt;std::string&gt; rhs) noexcept;\n\n    /**\n   * Basic constructor for specifying the length of the vector\n   * the modulus and an initializer list.\n   *\n   * @param length is the length of the native vector, in terms of the number of\n   * entries.\n   * @param modulus is the modulus of the ring.\n   * @param rhs is an initializer list of usint\n   */\n    NativeVectorT(usint length, const IntegerType&amp; modulus, std::initializer_list&lt;uint64_t&gt; rhs) noexcept;\n\n    /**\n   * Assignment operator to assign value from rhs\n   *\n   * @param &amp;rhs is the native vector to be assigned from.\n   * @return Assigned NativeVectorT.\n   */\n    NativeVectorT&amp; operator=(const NativeVectorT&amp; rhs) noexcept {\n        m_modulus = rhs.m_modulus;\n        if (m_data.size() &gt;= rhs.m_data.size()) {\n            std::copy(rhs.m_data.begin(), rhs.m_data.end(), m_data.begin());\n            if (m_data.size() &gt; rhs.m_data.size())\n                m_data.resize(rhs.m_data.size());\n            return *this;\n        }\n        m_data = rhs.m_data;\n        return *this;\n    }\n\n    /**\n   * Move assignment operator\n   *\n   * @param &amp;&amp;rhs is the native vector to be moved.\n   * @return moved NativeVectorT object\n   */\n    NativeVectorT&amp; operator=(NativeVectorT&amp;&amp; rhs) noexcept {\n        m_modulus = std::move(rhs.m_modulus);\n        m_data    = std::move(rhs.m_data);\n        return *this;\n    }\n\n    /**\n   * Initializer list for NativeVectorT.\n   *\n   * @param &amp;&amp;rhs is the list of strings containing integers to be assigned to\n   * the BBV.\n   * @return NativeVectorT object\n   */\n    NativeVectorT&amp; operator=(std::initializer_list&lt;std::string&gt; rhs) noexcept;\n\n    /**\n   * Initializer list for NativeVectorT.\n   *\n   * @param &amp;&amp;rhs is the list of integers to be assigned to the BBV.\n   * @return NativeVectorT object\n   */\n    NativeVectorT&amp; operator=(std::initializer_list&lt;uint64_t&gt; rhs) noexcept;\n\n    /**\n   * Assignment operator to assign value val to first entry, 0 for the rest of\n   * entries.\n   *\n   * @param val is the value to be assigned at the first entry.\n   * @return Assigned NativeVectorT.\n   */\n    constexpr NativeVectorT&amp; operator=(uint64_t val) {\n        std::fill(m_data.begin(), m_data.end(), 0);\n        m_data.at(0) = val;\n        return *this;\n    }\n\n    /**\n   * Sets/gets a value at an index.\n   * This method is slower than operator[] as it checks if index out of range\n   *\n   * @param index is the index to set a value at.\n   */\n    IntegerType&amp; at(size_t i) {\n        if (!NativeVectorT::IndexCheck(i))\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeVectorT index out of range&quot;);\n        return m_data[i];\n    }\n\n    const IntegerType&amp; at(size_t i) const {\n        if (!NativeVectorT::IndexCheck(i))\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeVectorT index out of range&quot;);\n        return m_data[i];\n    }\n\n    /**\n   * operators to get a value at an index.\n   * @param idx is the index to get a value at.\n   * @return is the value at the index. return nullptr if invalid index.\n   */\n    IntegerType&amp; operator[](size_t idx) {\n        return m_data[idx];\n    }\n\n    const IntegerType&amp; operator[](size_t idx) const {\n        return m_data[idx];\n    }\n\n    /**\n   * Sets the vector modulus.\n   *\n   * @param value is the value to set.\n   * @param value is the modulus value to set.\n   */\n    void SetModulus(const IntegerType&amp; value) {\n        if (value.GetMSB() &gt; MAX_MODULUS_SIZE)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::not_available_error,\n                          &quot;NativeVectorT supports only modulus size &lt;=  &quot; + std::to_string(MAX_MODULUS_SIZE) + &quot; bits&quot;);\n        m_modulus.m_value = value.m_value;\n    }\n\n    /**\n   * Sets the vector modulus and changes the values to match the new modulus.\n   *\n   * @param value is the value to set.\n   */\n    void SwitchModulus(const IntegerType&amp; value);\n\n    /**\n   * Gets the vector modulus.\n   *\n   * @return the vector modulus.\n   */\n    const IntegerType&amp; GetModulus() const {\n        return m_modulus;\n    }\n\n    /**\n   * Gets the vector length.\n   *\n   * @return vector length.\n   */\n    size_t GetLength() const {\n        return m_data.size();\n    }\n\n    // MODULAR ARITHMETIC OPERATIONS\n\n    /**\n   * Vector Modulus operator.\n   *\n   * @param modulus is the modulus to perform on the current vector entries.\n   * @return is the result after the modulus operation on current vector.\n   */\n    NativeVectorT Mod(const IntegerType&amp; modulus) const;\n\n    /**\n   * Vector Modulus operator. In-place variant.\n   *\n   * @param modulus is the modulus to perform on the current vector entries.\n   * @return is the result after the modulus operation on current vector.\n   */\n    NativeVectorT&amp; ModEq(const IntegerType&amp; modulus);\n\n    /**\n   * Scalar modulus addition.\n   *\n   * After addition modulus operation is performed with the current vector\n   * modulus.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeVectorT ModAdd(const IntegerType&amp; b) const;\n\n    /**\n   * Scalar modulus addition. In-place variant.\n   *\n   * After addition modulus operation is performed with the current vector\n   * modulus.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeVectorT&amp; ModAddEq(const IntegerType&amp; b);\n\n    /**\n   * Scalar modulus addition at a particular index.\n   *\n   * @param i is the index of the entry to add.\n   * @param &amp;b is the scalar to add.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeVectorT ModAddAtIndex(size_t i, const IntegerType&amp; b) const;\n\n    /**\n   * Scalar modulus addition at a particular index. In-place variant.\n   *\n   * @param i is the index of the entry to add.\n   * @param &amp;b is the scalar to add.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeVectorT&amp; ModAddAtIndexEq(size_t i, const IntegerType&amp; b);\n\n    /**\n   * vector modulus addition.\n   *\n   * @param &amp;b is the vector to add at all locations.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeVectorT ModAdd(const NativeVectorT&amp; b) const;\n\n    /**\n   * vector modulus addition. In-place variant.\n   *\n   * @param &amp;b is the vector to add at all locations.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeVectorT&amp; ModAddEq(const NativeVectorT&amp; b);\n    NativeVectorT&amp; ModAddNoCheckEq(const NativeVectorT&amp; b) {\n        size_t size{m_data.size()};\n        auto mv{m_modulus};\n        for (size_t i = 0; i &lt; size; ++i)\n            m_data[i].ModAddFastEq(b[i], mv);\n        return *this;\n    }\n\n    /**\n   * Scalar modulus subtraction.\n   * After substraction modulus operation is performed with the current vector\n   * modulus.\n   * @param &amp;b is the scalar to subtract from all locations.\n   * @return is the result of the modulus substraction operation.\n   */\n    NativeVectorT ModSub(const IntegerType&amp; b) const;\n\n    /**\n   * Scalar modulus subtraction. In-place variant.\n   * After substraction modulus operation is performed with the current vector\n   * modulus.\n   * @param &amp;b is the scalar to subtract from all locations.\n   * @return is the result of the modulus substraction operation.\n   */\n    NativeVectorT&amp; ModSubEq(const IntegerType&amp; b);\n\n    /**\n   * Vector Modulus subtraction.\n   *\n   * @param &amp;b is the vector to subtract.\n   * @return is the result of the modulus subtraction operation.\n   */\n    NativeVectorT ModSub(const NativeVectorT&amp; b) const;\n\n    /**\n   * Vector Modulus subtraction. In-place variant.\n   *\n   * @param &amp;b is the vector to subtract.\n   * @return is the result of the modulus subtraction operation.\n   */\n    NativeVectorT&amp; ModSubEq(const NativeVectorT&amp; b);\n\n    /**\n   * Scalar modular multiplication.\n   * See the comments in the cpp files for details of the implementation.\n   *\n   * @param &amp;b is the scalar to multiply at all locations.\n   * @return is the result of the modulus multiplication operation.\n   */\n    NativeVectorT ModMul(const IntegerType&amp; b) const;\n\n    /**\n   * Scalar modular multiplication. In-place variant.\n   * See the comments in the cpp files for details of the implementation.\n   *\n   * @param &amp;b is the scalar to multiply at all locations.\n   * @return is the result of the modulus multiplication operation.\n   */\n    NativeVectorT&amp; ModMulEq(const IntegerType&amp; b);\n\n    /**\n   * Vector modulus multiplication.\n   *\n   * @param &amp;b is the vector to multiply.\n   * @return is the result of the modulus multiplication operation.\n   */\n    NativeVectorT ModMul(const NativeVectorT&amp; b) const;\n\n    /**\n   * Vector modulus multiplication. In-place variant.\n   *\n   * @param &amp;b is the vector to multiply.\n   * @return is the result of the modulus multiplication operation.\n   */\n    NativeVectorT&amp; ModMulEq(const NativeVectorT&amp; b);\n    NativeVectorT&amp; ModMulNoCheckEq(const NativeVectorT&amp; b) {\n        size_t size{m_data.size()};\n        auto mv{m_modulus};\n#ifdef NATIVEINT_BARRET_MOD\n        auto mu{m_modulus.ComputeMu()};\n        for (size_t i = 0; i &lt; size; ++i)\n            m_data[i].ModMulFastEq(b[i], mv, mu);\n#else\n        for (size_t i = 0; i &lt; size; ++i)\n            m_data[i].ModMulFastEq(b[i], mv);\n#endif\n        return *this;\n    }\n\n    /**\n   * Vector multiplication without applying the modulus operation.\n   *\n   * @param &amp;b is the vector to multiply.\n   * @return is the result of the multiplication operation.\n   */\n    NativeVectorT MultWithOutMod(const NativeVectorT&amp; b) const;\n\n    /**\n   * Scalar modulus exponentiation.\n   *\n   * @param &amp;b is the scalar to exponentiate at all locations.\n   * @return a new vector which is the result of the modulus exponentiation\n   * operation.\n   */\n    NativeVectorT ModExp(const IntegerType&amp; b) const;\n\n    /**\n   * Scalar modulus exponentiation. In-place variant.\n   *\n   * @param &amp;b is the scalar to exponentiate at all locations.\n   * @return a new vector which is the result of the modulus exponentiation\n   * operation.\n   */\n    NativeVectorT&amp; ModExpEq(const IntegerType&amp; b);\n\n    /**\n   * Modulus inverse.\n   *\n   * @return a new vector which is the result of the modulus inverse operation.\n   */\n    NativeVectorT ModInverse() const {\n        size_t size{m_data.size()};\n        auto mv{m_modulus};\n        NativeVectorT ans(size, mv);\n        for (size_t i{0}; i &lt; size; ++i)\n            ans[i] = m_data[i].ModInverse(mv);\n        return ans;\n    }\n\n    /**\n   * Modulus inverse. In-place variant.\n   *\n   * @return a new vector which is the result of the modulus inverse operation.\n   */\n    NativeVectorT&amp; ModInverseEq() {\n        size_t size{m_data.size()};\n        auto mv{m_modulus};\n        for (size_t i{0}; i &lt; size; ++i)\n            m_data[i] = m_data[i].ModInverse(mv);\n        return *this;\n    }\n\n    /**\n   * Perform a modulus by 2 operation.  Returns the least significant bit.\n   *\n   * @return a new vector which is the return value of the modulus by 2, also\n   * the least significant bit.\n   */\n    NativeVectorT ModByTwo() const;\n\n    /**\n   * Perform a modulus by 2 operation.  Returns the least significant bit.\n   * In-place variant.\n   *\n   * @return a new vector which is the return value of the modulus by 2, also\n   * the least significant bit.\n   */\n    NativeVectorT&amp; ModByTwoEq();\n\n    /**\n   * Multiply and Rounding operation on a BigInteger x. Returns [x*p/q] where []\n   * is the rounding operation.\n   *\n   * @param p is the numerator to be multiplied.\n   * @param q is the denominator to be divided.\n   * @return the result of multiply and round.\n   */\n    NativeVectorT MultiplyAndRound(const IntegerType&amp; p, const IntegerType&amp; q) const;\n\n    /**\n   * Multiply and Rounding operation on a BigInteger x. Returns [x*p/q] where []\n   * is the rounding operation. In-place variant.\n   *\n   * @param p is the numerator to be multiplied.\n   * @param q is the denominator to be divided.\n   * @return the result of multiply and round.\n   */\n    NativeVectorT&amp; MultiplyAndRoundEq(const IntegerType&amp; p, const IntegerType&amp; q);\n\n    /**\n   * Divide and Rounding operation on a BigInteger x. Returns [x/q] where [] is\n   * the rounding operation.\n   *\n   * @param q is the denominator to be divided.\n   * @return the result of divide and round.\n   */\n    NativeVectorT DivideAndRound(const IntegerType&amp; q) const;\n\n    /**\n   * Divide and Rounding operation on a BigInteger x. Returns [x/q] where [] is\n   * the rounding operation. In-place variant.\n   *\n   * @param q is the denominator to be divided.\n   * @return the result of divide and round.\n   */\n    NativeVectorT&amp; DivideAndRoundEq(const IntegerType&amp; q);\n\n    // OTHER FUNCTIONS\n\n    /**\n   * Digit vector at a specific index for all entries for a given number base.\n   * Warning: only power-of-2 bases are currently supported.\n   * Example: for vector (83, 1, 45), index 2 and base 4 we have:\n   *\n   *                           index:0,1,2,3\n   * |83|                           |3,0,1,1|                 |1|\n   * |1 | --base 4 decomposition--&gt; |1,0,0,0| --at index 2--&gt; |0|\n   * |45|                           |1,3,2,0|                 |2|\n   *\n   * The return vector is (1,0,2)\n   *\n   * @param index is the index to return the digit from in all entries.\n   * @param base is the base to use for the operation.\n   * @return is the digit at a specific index for all entries for a given number\n   * base\n   */\n    NativeVectorT GetDigitAtIndexForBase(usint index, usint base) const;\n\n    // STRINGS &amp; STREAMS\n\n    /**\n   * ostream operator to output vector values to console\n   *\n   * @param os is the std ostream object.\n   * @param &amp;ptr_obj is the NativeVectorT object to be printed.\n   * @return std ostream object which captures the vector values.\n   */\n    template &lt;class IntegerType_c&gt;\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const NativeVectorT&lt;IntegerType_c&gt;&amp; ptr_obj) {\n        auto len = ptr_obj.m_data.size();\n        os &lt;&lt; &quot;[&quot;;\n        for (usint i = 0; i &lt; len; i++) {\n            os &lt;&lt; ptr_obj.m_data[i];\n            os &lt;&lt; ((i == (len - 1)) ? &quot;]&quot; : &quot; &quot;);\n        }\n        os &lt;&lt; &quot; modulus: &quot; &lt;&lt; ptr_obj.m_modulus;\n        return os;\n    }\n\n    template &lt;class Archive&gt;\n    typename std::enable_if&lt;!cereal::traits::is_text_archive&lt;Archive&gt;::value, void&gt;::type save(\n        Archive&amp; ar, std::uint32_t const version) const {\n        ::cereal::size_type size = m_data.size();\n        ar(size);\n        if (size &gt; 0) {\n            ar(::cereal::binary_data(m_data.data(), size * sizeof(IntegerType)));\n        }\n        ar(m_modulus);\n    }\n\n    template &lt;class Archive&gt;\n    typename std::enable_if&lt;cereal::traits::is_text_archive&lt;Archive&gt;::value, void&gt;::type save(\n        Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::make_nvp(&quot;v&quot;, m_data));\n        ar(::cereal::make_nvp(&quot;m&quot;, m_modulus));\n    }\n\n    template &lt;class Archive&gt;\n    typename std::enable_if&lt;!cereal::traits::is_text_archive&lt;Archive&gt;::value, void&gt;::type load(\n        Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                           &quot; is from a later version of the library&quot;);\n        }\n        ::cereal::size_type size;\n        ar(size);\n        m_data.resize(size);\n        if (size &gt; 0) {\n            auto* data = reinterpret_cast&lt;IntegerType*&gt;(malloc(size * sizeof(IntegerType)));\n            ar(::cereal::binary_data(data, size * sizeof(IntegerType)));\n            for (::cereal::size_type i = 0; i &lt; size; i++) {\n                m_data[i] = data[i];\n            }\n            free(data);\n        }\n        ar(m_modulus);\n    }\n\n    template &lt;class Archive&gt;\n    typename std::enable_if&lt;cereal::traits::is_text_archive&lt;Archive&gt;::value, void&gt;::type load(\n        Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                           &quot; is from a later version of the library&quot;);\n        }\n        ar(::cereal::make_nvp(&quot;v&quot;, m_data));\n        ar(::cereal::make_nvp(&quot;m&quot;, m_modulus));\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;NativeVectorT&quot;;\n    }\n\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n};\n\n}  // namespace intnat\n\nnamespace cereal {\n\n//! Serialization for vector of NativeInteger\n\ntemplate &lt;class Archive, class A&gt;\ninline void CEREAL_SAVE_FUNCTION_NAME(Archive&amp; ar, std::vector&lt;intnat::NativeIntegerT&lt;uint64_t&gt;, A&gt; const&amp; vec) {\n    ar(make_size_tag(static_cast&lt;cereal::size_type&gt;(vec.size())));  // number of elements\n    for (const auto&amp; v : vec) {\n        ar(v.ConvertToInt());\n    }\n}\n\n#if defined(HAVE_INT128)\ntemplate &lt;class Archive, class A&gt;\ninline void CEREAL_SAVE_FUNCTION_NAME(Archive&amp; ar, std::vector&lt;intnat::NativeIntegerT&lt;uint128_t&gt;, A&gt; const&amp; vec) {\n    ar(make_size_tag(static_cast&lt;cereal::size_type&gt;(vec.size())));  // number of elements\n    constexpr uint128_t mask = (static_cast&lt;uint128_t&gt;(1) &lt;&lt; 64) - 1;\n    for (const auto&amp; v : vec) {\n        uint64_t vec[2];\n        uint128_t v128 = v.ConvertToInt();\n        vec[0]         = v128 &amp; mask;  // least significant word\n        vec[1]         = v128 &gt;&gt; 64;   // most significant word\n        ar(vec);\n    }\n}\n#endif\n\n//! Deserialization for vector of NativeInteger\n\ntemplate &lt;class Archive, class A&gt;\ninline void CEREAL_LOAD_FUNCTION_NAME(Archive&amp; ar, std::vector&lt;intnat::NativeIntegerT&lt;uint64_t&gt;, A&gt;&amp; vec) {\n    cereal::size_type size;\n    ar(make_size_tag(size));\n    vec.resize(static_cast&lt;size_t&gt;(size));\n    for (auto&amp; v : vec) {\n        uint64_t b;\n        ar(b);\n        v = b;\n    }\n}\n\n#if defined(HAVE_INT128)\ntemplate &lt;class Archive, class A&gt;\ninline void CEREAL_LOAD_FUNCTION_NAME(Archive&amp; ar, std::vector&lt;intnat::NativeIntegerT&lt;uint128_t&gt;, A&gt;&amp; vec) {\n    cereal::size_type size;\n    ar(make_size_tag(size));\n    vec.resize(static_cast&lt;size_t&gt;(size));\n    for (auto&amp; v : vec) {\n        uint64_t vec[2];\n        ar(vec);\n        v = vec[1];  // most significant word\n        v &lt;&lt;= 64;\n        v += vec[0];  // least significant word\n    }\n}\n#endif\n}  // namespace cereal\n\n#endif  // LBCRYPTO_MATH_HAL_INTNAT_MUBINTVECNAT_H\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef __TRANSFORMNAT_IMPL_H__\n#define __TRANSFORMNAT_IMPL_H__\n\n// ATTENTION: this file contains implementations of the functions\n//            declared in math/intnat/transformnat.h and\n//            MUST be included in the end of math/intnat/transformnat.h ONLY\n//            and nowhere else\n#include &quot;math/hal/basicint.h&quot;\n#include &quot;math/hal/intnat/ubintnat.h&quot;\n#include &quot;math/hal/intnat/mubintvecnat.h&quot;\n#include &quot;math/hal/intnat/transformnat.h&quot;\n#include &quot;math/nbtheory.h&quot;\n\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/inttypes.h&quot;\n#include &quot;utils/utilities.h&quot;\n\n#include &lt;map&gt;\n#include &lt;vector&gt;\n\nnamespace intnat {\n\ntemplate &lt;typename VecType&gt;\nstd::map&lt;typename VecType::Integer, VecType&gt;\n    ChineseRemainderTransformFTTNat&lt;VecType&gt;::m_cycloOrderInverseTableByModulus;\n\ntemplate &lt;typename VecType&gt;\nstd::map&lt;typename VecType::Integer, VecType&gt;\n    ChineseRemainderTransformFTTNat&lt;VecType&gt;::m_cycloOrderInversePreconTableByModulus;\n\ntemplate &lt;typename VecType&gt;\nstd::map&lt;typename VecType::Integer, VecType&gt;\n    ChineseRemainderTransformFTTNat&lt;VecType&gt;::m_rootOfUnityReverseTableByModulus;\n\ntemplate &lt;typename VecType&gt;\nstd::map&lt;typename VecType::Integer, VecType&gt;\n    ChineseRemainderTransformFTTNat&lt;VecType&gt;::m_rootOfUnityInverseReverseTableByModulus;\n\ntemplate &lt;typename VecType&gt;\nstd::map&lt;typename VecType::Integer, VecType&gt;\n    ChineseRemainderTransformFTTNat&lt;VecType&gt;::m_rootOfUnityPreconReverseTableByModulus;\n\ntemplate &lt;typename VecType&gt;\nstd::map&lt;typename VecType::Integer, VecType&gt;\n    ChineseRemainderTransformFTTNat&lt;VecType&gt;::m_rootOfUnityInversePreconReverseTableByModulus;\n\ntemplate &lt;typename VecType&gt;\nstd::map&lt;typename VecType::Integer, VecType&gt; ChineseRemainderTransformArbNat&lt;VecType&gt;::m_cyclotomicPolyMap;\n\ntemplate &lt;typename VecType&gt;\nstd::map&lt;typename VecType::Integer, VecType&gt; ChineseRemainderTransformArbNat&lt;VecType&gt;::m_cyclotomicPolyReverseNTTMap;\n\ntemplate &lt;typename VecType&gt;\nstd::map&lt;typename VecType::Integer, VecType&gt; ChineseRemainderTransformArbNat&lt;VecType&gt;::m_cyclotomicPolyNTTMap;\n\ntemplate &lt;typename VecType&gt;\nstd::map&lt;ModulusRoot&lt;typename VecType::Integer&gt;, VecType&gt; BluesteinFFTNat&lt;VecType&gt;::m_rootOfUnityTableByModulusRoot;\n\ntemplate &lt;typename VecType&gt;\nstd::map&lt;ModulusRoot&lt;typename VecType::Integer&gt;, VecType&gt;\n    BluesteinFFTNat&lt;VecType&gt;::m_rootOfUnityInverseTableByModulusRoot;\n\ntemplate &lt;typename VecType&gt;\nstd::map&lt;ModulusRoot&lt;typename VecType::Integer&gt;, VecType&gt; BluesteinFFTNat&lt;VecType&gt;::m_powersTableByModulusRoot;\n\ntemplate &lt;typename VecType&gt;\nstd::map&lt;ModulusRootPair&lt;typename VecType::Integer&gt;, VecType&gt; BluesteinFFTNat&lt;VecType&gt;::m_RBTableByModulusRootPair;\n\ntemplate &lt;typename VecType&gt;\nstd::map&lt;typename VecType::Integer, ModulusRoot&lt;typename VecType::Integer&gt;&gt;\n    BluesteinFFTNat&lt;VecType&gt;::m_defaultNTTModulusRoot;\n\ntemplate &lt;typename VecType&gt;\nstd::map&lt;typename VecType::Integer, VecType&gt;\n    ChineseRemainderTransformArbNat&lt;VecType&gt;::m_rootOfUnityDivisionTableByModulus;\n\ntemplate &lt;typename VecType&gt;\nstd::map&lt;typename VecType::Integer, VecType&gt;\n    ChineseRemainderTransformArbNat&lt;VecType&gt;::m_rootOfUnityDivisionInverseTableByModulus;\n\ntemplate &lt;typename VecType&gt;\nstd::map&lt;typename VecType::Integer, typename VecType::Integer&gt;\n    ChineseRemainderTransformArbNat&lt;VecType&gt;::m_DivisionNTTModulus;\n\ntemplate &lt;typename VecType&gt;\nstd::map&lt;typename VecType::Integer, typename VecType::Integer&gt;\n    ChineseRemainderTransformArbNat&lt;VecType&gt;::m_DivisionNTTRootOfUnity;\n\ntemplate &lt;typename VecType&gt;\nstd::map&lt;usint, usint&gt; ChineseRemainderTransformArbNat&lt;VecType&gt;::m_nttDivisionDim;\n\ntemplate &lt;typename VecType&gt;\nvoid NumberTheoreticTransformNat&lt;VecType&gt;::ForwardTransformIterative(const VecType&amp; element,\n                                                                     const VecType&amp; rootOfUnityTable, VecType* result) {\n    usint n = element.GetLength();\n    if (result-&gt;GetLength() != n) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;size of input element and size of output element not of same size&quot;);\n    }\n\n    auto modulus = element.GetModulus();\n    IntType mu   = modulus.ComputeMu();\n    result-&gt;SetModulus(modulus);\n\n    usint msb = lbcrypto::GetMSB(n - 1);\n    for (size_t i = 0; i &lt; n; i++) {\n        (*result)[i] = element[lbcrypto::ReverseBits(i, msb)];\n    }\n\n    IntType omega, omegaFactor, oddVal, evenVal;\n    usint logm, i, j, indexEven, indexOdd;\n\n    usint logn = lbcrypto::GetMSB(n - 1);\n    for (logm = 1; logm &lt;= logn; logm++) {\n        // calculate the i indexes into the root table one time per loop\n        std::vector&lt;usint&gt; indexes(1 &lt;&lt; (logm - 1));\n        for (i = 0; i &lt; (usint)(1 &lt;&lt; (logm - 1)); i++) {\n            indexes[i] = (i &lt;&lt; (logn - logm));\n        }\n\n        for (j = 0; j &lt; n; j = j + (1 &lt;&lt; logm)) {\n            for (i = 0; i &lt; (usint)(1 &lt;&lt; (logm - 1)); i++) {\n                omega     = rootOfUnityTable[indexes[i]];\n                indexEven = j + i;\n                indexOdd  = indexEven + (1 &lt;&lt; (logm - 1));\n                oddVal    = (*result)[indexOdd];\n\n                omegaFactor = omega.ModMul(oddVal, modulus, mu);\n                evenVal     = (*result)[indexEven];\n                oddVal      = evenVal;\n                oddVal += omegaFactor;\n                if (oddVal &gt;= modulus) {\n                    oddVal -= modulus;\n                }\n\n                if (evenVal &lt; omegaFactor) {\n                    evenVal += modulus;\n                }\n                evenVal -= omegaFactor;\n\n                (*result)[indexEven] = oddVal;\n                (*result)[indexOdd]  = evenVal;\n            }\n        }\n    }\n    return;\n}\n\ntemplate &lt;typename VecType&gt;\nvoid NumberTheoreticTransformNat&lt;VecType&gt;::InverseTransformIterative(const VecType&amp; element,\n                                                                     const VecType&amp; rootOfUnityInverseTable,\n                                                                     VecType* result) {\n    usint n = element.GetLength();\n\n    IntType modulus = element.GetModulus();\n    IntType mu      = modulus.ComputeMu();\n\n    NumberTheoreticTransformNat&lt;VecType&gt;().ForwardTransformIterative(element, rootOfUnityInverseTable, result);\n    IntType cycloOrderInv(IntType(n).ModInverse(modulus));\n    for (usint i = 0; i &lt; n; i++) {\n        (*result)[i].ModMulEq(cycloOrderInv, modulus, mu);\n    }\n    return;\n}\n\ntemplate &lt;typename VecType&gt;\nvoid NumberTheoreticTransformNat&lt;VecType&gt;::ForwardTransformToBitReverseInPlace(const VecType&amp; rootOfUnityTable,\n                                                                               VecType* element) {\n    usint n         = element-&gt;GetLength();\n    IntType modulus = element-&gt;GetModulus();\n    IntType mu      = modulus.ComputeMu();\n\n    usint i, m, j1, j2, indexOmega, indexLo, indexHi;\n    IntType omega, omegaFactor, loVal, hiVal;\n\n    usint t     = (n &gt;&gt; 1);\n    usint logt1 = lbcrypto::GetMSB(t);\n    for (m = 1; m &lt; n; m &lt;&lt;= 1) {\n        for (i = 0; i &lt; m; ++i) {\n            j1         = i &lt;&lt; logt1;\n            j2         = j1 + t;\n            indexOmega = m + i;\n            omega      = rootOfUnityTable[indexOmega];\n            for (indexLo = j1; indexLo &lt; j2; ++indexLo) {\n                indexHi     = indexLo + t;\n                loVal       = (*element)[indexLo];\n                omegaFactor = (*element)[indexHi];\n                omegaFactor.ModMulFastEq(omega, modulus, mu);\n\n                hiVal = loVal + omegaFactor;\n                if (hiVal &gt;= modulus) {\n                    hiVal -= modulus;\n                }\n\n                if (loVal &lt; omegaFactor) {\n                    loVal += modulus;\n                }\n                loVal -= omegaFactor;\n\n                (*element)[indexLo] = hiVal;\n                (*element)[indexHi] = loVal;\n            }\n        }\n        t &gt;&gt;= 1;\n        logt1--;\n    }\n    return;\n}\n\ntemplate &lt;typename VecType&gt;\nvoid NumberTheoreticTransformNat&lt;VecType&gt;::ForwardTransformToBitReverse(const VecType&amp; element,\n                                                                        const VecType&amp; rootOfUnityTable,\n                                                                        VecType* result) {\n    usint n = element.GetLength();\n    if (result-&gt;GetLength() != n) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;size of input element and size of output element not of same size&quot;);\n    }\n\n    IntType modulus = element.GetModulus();\n    IntType mu      = modulus.ComputeMu();\n    result-&gt;SetModulus(modulus);\n\n    usint i, m, j1, j2, indexOmega, indexLo, indexHi;\n    IntType omega, omegaFactor, loVal, hiVal, zero(0);\n\n    for (i = 0; i &lt; n; ++i) {\n        (*result)[i] = element[i];\n    }\n\n    usint t     = (n &gt;&gt; 1);\n    usint logt1 = lbcrypto::GetMSB(t);\n    for (m = 1; m &lt; n; m &lt;&lt;= 1) {\n        for (i = 0; i &lt; m; ++i) {\n            j1         = i &lt;&lt; logt1;\n            j2         = j1 + t;\n            indexOmega = m + i;\n            omega      = rootOfUnityTable[indexOmega];\n            for (indexLo = j1; indexLo &lt; j2; ++indexLo) {\n                indexHi     = indexLo + t;\n                loVal       = (*result)[indexLo];\n                omegaFactor = (*result)[indexHi];\n                if (omegaFactor != zero) {\n                    omegaFactor.ModMulFastEq(omega, modulus, mu);\n\n                    hiVal = loVal + omegaFactor;\n                    if (hiVal &gt;= modulus) {\n                        hiVal -= modulus;\n                    }\n\n                    if (loVal &lt; omegaFactor) {\n                        loVal += modulus;\n                    }\n                    loVal -= omegaFactor;\n\n                    (*result)[indexLo] = hiVal;\n                    (*result)[indexHi] = loVal;\n                }\n                else {\n                    (*result)[indexHi] = loVal;\n                }\n            }\n        }\n        t &gt;&gt;= 1;\n        logt1--;\n    }\n    return;\n}\n\ntemplate &lt;typename VecType&gt;\nvoid NumberTheoreticTransformNat&lt;VecType&gt;::ForwardTransformToBitReverseInPlace(const VecType&amp; rootOfUnityTable,\n                                                                               const VecType&amp; preconRootOfUnityTable,\n                                                                               VecType* element) {\n    auto modulus{element-&gt;GetModulus()};\n    uint32_t n(element-&gt;GetLength() &gt;&gt; 1), t{n}, logt{lbcrypto::GetMSB(t)};\n    for (uint32_t m{1}; m &lt; n; m &lt;&lt;= 1, t &gt;&gt;= 1, --logt) {\n        for (uint32_t i{0}; i &lt; m; ++i) {\n            auto omega{rootOfUnityTable[i + m]};\n            auto preconOmega{preconRootOfUnityTable[i + m]};\n            for (uint32_t j1{i &lt;&lt; logt}, j2{j1 + t}; j1 &lt; j2; ++j1) {\n                auto omegaFactor{(*element)[j1 + t]};\n                omegaFactor.ModMulFastConstEq(omega, modulus, preconOmega);\n                auto loVal{(*element)[j1 + 0]};\n#if defined(__GNUC__) &amp;&amp; !defined(__clang__)\n                auto hiVal{loVal + omegaFactor};\n                if (hiVal &gt;= modulus)\n                    hiVal -= modulus;\n                if (loVal &lt; omegaFactor)\n                    loVal += modulus;\n                loVal -= omegaFactor;\n                (*element)[j1 + 0] = hiVal;\n                (*element)[j1 + t] = loVal;\n#else\n                // fixes Clang slowdown issue, but requires lowVal be less than modulus\n                (*element)[j1 + 0] += omegaFactor - (omegaFactor &gt;= (modulus - loVal) ? modulus : 0);\n                if (omegaFactor &gt; loVal)\n                    loVal += modulus;\n                (*element)[j1 + t] = loVal - omegaFactor;\n#endif\n            }\n        }\n    }\n    for (uint32_t i{0}; i &lt; (n &lt;&lt; 1); i += 2) {\n        auto omegaFactor{(*element)[i + 1]};\n        auto omega{rootOfUnityTable[(i &gt;&gt; 1) + n]};\n        auto preconOmega{preconRootOfUnityTable[(i &gt;&gt; 1) + n]};\n        omegaFactor.ModMulFastConstEq(omega, modulus, preconOmega);\n        auto loVal{(*element)[i + 0]};\n#if defined(__GNUC__) &amp;&amp; !defined(__clang__)\n        auto hiVal{loVal + omegaFactor};\n        if (hiVal &gt;= modulus)\n            hiVal -= modulus;\n        if (loVal &lt; omegaFactor)\n            loVal += modulus;\n        loVal -= omegaFactor;\n        (*element)[i + 0] = hiVal;\n        (*element)[i + 1] = loVal;\n#else\n        (*element)[i + 0] += omegaFactor - (omegaFactor &gt;= (modulus - loVal) ? modulus : 0);\n        if (omegaFactor &gt; loVal)\n            loVal += modulus;\n        (*element)[i + t] = loVal - omegaFactor;\n#endif\n    }\n}\n\ntemplate &lt;typename VecType&gt;\nvoid NumberTheoreticTransformNat&lt;VecType&gt;::ForwardTransformToBitReverse(const VecType&amp; element,\n                                                                        const VecType&amp; rootOfUnityTable,\n                                                                        const VecType&amp; preconRootOfUnityTable,\n                                                                        VecType* result) {\n    usint n = element.GetLength();\n\n    if (result-&gt;GetLength() != n) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;size of input element and size of output element not of same size&quot;);\n    }\n\n    IntType modulus = element.GetModulus();\n\n    result-&gt;SetModulus(modulus);\n\n    for (uint32_t i = 0; i &lt; n; ++i) {\n        (*result)[i] = element[i];\n    }\n\n    uint32_t indexOmega, indexHi;\n    NativeInteger preconOmega;\n    IntType omega, omegaFactor, loVal, hiVal, zero(0);\n\n    usint t     = (n &gt;&gt; 1);\n    usint logt1 = lbcrypto::GetMSB(t);\n    for (uint32_t m = 1; m &lt; n; m &lt;&lt;= 1, t &gt;&gt;= 1, --logt1) {\n        uint32_t j1, j2;\n        for (uint32_t i = 0; i &lt; m; ++i) {\n            j1          = i &lt;&lt; logt1;\n            j2          = j1 + t;\n            indexOmega  = m + i;\n            omega       = rootOfUnityTable[indexOmega];\n            preconOmega = preconRootOfUnityTable[indexOmega];\n            for (uint32_t indexLo = j1; indexLo &lt; j2; ++indexLo) {\n                indexHi     = indexLo + t;\n                loVal       = (*result)[indexLo];\n                omegaFactor = (*result)[indexHi];\n                if (omegaFactor != zero) {\n                    omegaFactor.ModMulFastConstEq(omega, modulus, preconOmega);\n\n                    hiVal = loVal + omegaFactor;\n                    if (hiVal &gt;= modulus) {\n                        hiVal -= modulus;\n                    }\n\n                    if (loVal &lt; omegaFactor) {\n                        loVal += modulus;\n                    }\n                    loVal -= omegaFactor;\n\n                    (*result)[indexLo] = hiVal;\n                    (*result)[indexHi] = loVal;\n                }\n                else {\n                    (*result)[indexHi] = loVal;\n                }\n            }\n        }\n    }\n    return;\n}\n\ntemplate &lt;typename VecType&gt;\nvoid NumberTheoreticTransformNat&lt;VecType&gt;::InverseTransformFromBitReverseInPlace(const VecType&amp; rootOfUnityInverseTable,\n                                                                                 const IntType&amp; cycloOrderInv,\n                                                                                 VecType* element) {\n    usint n         = element-&gt;GetLength();\n    IntType modulus = element-&gt;GetModulus();\n    IntType mu      = modulus.ComputeMu();\n\n    IntType loVal, hiVal, omega, omegaFactor;\n    usint i, m, j1, j2, indexOmega, indexLo, indexHi;\n\n    usint t     = 1;\n    usint logt1 = 1;\n    for (m = (n &gt;&gt; 1); m &gt;= 1; m &gt;&gt;= 1) {\n        for (i = 0; i &lt; m; ++i) {\n            j1         = i &lt;&lt; logt1;\n            j2         = j1 + t;\n            indexOmega = m + i;\n            omega      = rootOfUnityInverseTable[indexOmega];\n\n            for (indexLo = j1; indexLo &lt; j2; ++indexLo) {\n                indexHi = indexLo + t;\n\n                hiVal = (*element)[indexHi];\n                loVal = (*element)[indexLo];\n\n                omegaFactor = loVal;\n                if (omegaFactor &lt; hiVal) {\n                    omegaFactor += modulus;\n                }\n\n                omegaFactor -= hiVal;\n\n                loVal += hiVal;\n                if (loVal &gt;= modulus) {\n                    loVal -= modulus;\n                }\n\n                omegaFactor.ModMulFastEq(omega, modulus, mu);\n\n                (*element)[indexLo] = loVal;\n                (*element)[indexHi] = omegaFactor;\n            }\n        }\n        t &lt;&lt;= 1;\n        logt1++;\n    }\n\n    for (i = 0; i &lt; n; i++) {\n        (*element)[i].ModMulFastEq(cycloOrderInv, modulus, mu);\n    }\n    return;\n}\n\ntemplate &lt;typename VecType&gt;\nvoid NumberTheoreticTransformNat&lt;VecType&gt;::InverseTransformFromBitReverse(const VecType&amp; element,\n                                                                          const VecType&amp; rootOfUnityInverseTable,\n                                                                          const IntType&amp; cycloOrderInv,\n                                                                          VecType* result) {\n    usint n = element.GetLength();\n\n    if (result-&gt;GetLength() != n) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;size of input element and size of output element not of same size&quot;);\n    }\n\n    result-&gt;SetModulus(element.GetModulus());\n\n    for (usint i = 0; i &lt; n; i++) {\n        (*result)[i] = element[i];\n    }\n    InverseTransformFromBitReverseInPlace(rootOfUnityInverseTable, cycloOrderInv, result);\n}\n\ntemplate &lt;typename VecType&gt;\nvoid NumberTheoreticTransformNat&lt;VecType&gt;::InverseTransformFromBitReverseInPlace(\n    const VecType&amp; rootOfUnityInverseTable, const VecType&amp; preconRootOfUnityInverseTable, const IntType&amp; cycloOrderInv,\n    const IntType&amp; preconCycloOrderInv, VecType* element) {\n    auto modulus{element-&gt;GetModulus()};\n    uint32_t n(element-&gt;GetLength());\n    for (uint32_t i{0}; i &lt; n; i += 2) {\n        auto omega{rootOfUnityInverseTable[(i + n) &gt;&gt; 1]};\n        auto preconOmega{preconRootOfUnityInverseTable[(i + n) &gt;&gt; 1]};\n        auto hiVal{(*element)[i + 1]};\n        auto loVal{(*element)[i + 0]};\n#if defined(__GNUC__) &amp;&amp; !defined(__clang__)\n        auto omegaFactor{loVal};\n        if (omegaFactor &lt; hiVal)\n            omegaFactor += modulus;\n        omegaFactor -= hiVal;\n        loVal += hiVal;\n        if (loVal &gt;= modulus)\n            loVal -= modulus;\n        loVal.ModMulFastConstEq(cycloOrderInv, modulus, preconCycloOrderInv);\n        omegaFactor.ModMulFastConstEq(omega, modulus, preconOmega);\n        omegaFactor.ModMulFastConstEq(cycloOrderInv, modulus, preconCycloOrderInv);\n        (*element)[i + 0] = loVal;\n        (*element)[i + 1] = omegaFactor;\n#else\n        auto omegaFactor{loVal + (hiVal &gt; loVal ? modulus : 0) - hiVal};\n        loVal += hiVal - (hiVal &gt;= (modulus - loVal) ? modulus : 0);\n        loVal.ModMulFastConstEq(cycloOrderInv, modulus, preconCycloOrderInv);\n        (*element)[i + 0] = loVal;\n        omegaFactor.ModMulFastConstEq(omega, modulus, preconOmega);\n        omegaFactor.ModMulFastConstEq(cycloOrderInv, modulus, preconCycloOrderInv);\n        (*element)[i + 1] = omegaFactor;\n#endif\n    }\n    for (uint32_t m{n &gt;&gt; 2}, t{2}, logt{2}; m &gt;= 1; m &gt;&gt;= 1, t &lt;&lt;= 1, ++logt) {\n        for (uint32_t i{0}; i &lt; m; ++i) {\n            auto omega{rootOfUnityInverseTable[i + m]};\n            auto preconOmega{preconRootOfUnityInverseTable[i + m]};\n            for (uint32_t j1{i &lt;&lt; logt},  j2{j1 + t}; j1 &lt; j2; ++j1) {\n                auto hiVal{(*element)[j1 + t]};\n                auto loVal{(*element)[j1 + 0]};\n#if defined(__GNUC__) &amp;&amp; !defined(__clang__)\n                auto omegaFactor{loVal};\n                if (omegaFactor &lt; hiVal)\n                    omegaFactor += modulus;\n                omegaFactor -= hiVal;\n                loVal += hiVal;\n                if (loVal &gt;= modulus)\n                    loVal -= modulus;\n                omegaFactor.ModMulFastConstEq(omega, modulus, preconOmega);\n                (*element)[j1 + 0] = loVal;\n                (*element)[j1 + t] = omegaFactor;\n#else\n                (*element)[j1 + 0] += hiVal - (hiVal &gt;= (modulus - loVal) ? modulus : 0);\n                auto omegaFactor = loVal + (hiVal &gt; loVal ? modulus : 0) - hiVal;\n                omegaFactor.ModMulFastConstEq(omega, modulus, preconOmega);\n                (*element)[j1 + t] = omegaFactor;\n#endif\n            }\n        }\n    }\n}\n\ntemplate &lt;typename VecType&gt;\nvoid NumberTheoreticTransformNat&lt;VecType&gt;::InverseTransformFromBitReverse(\n    const VecType&amp; element, const VecType&amp; rootOfUnityInverseTable, const VecType&amp; preconRootOfUnityInverseTable,\n    const IntType&amp; cycloOrderInv, const IntType&amp; preconCycloOrderInv, VecType* result) {\n    usint n = element.GetLength();\n    if (result-&gt;GetLength() != n) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;size of input element and size of output element not of same size&quot;);\n    }\n\n    result-&gt;SetModulus(element.GetModulus());\n\n    for (usint i = 0; i &lt; n; i++) {\n        (*result)[i] = element[i];\n    }\n    InverseTransformFromBitReverseInPlace(rootOfUnityInverseTable, preconRootOfUnityInverseTable, cycloOrderInv,\n                                          preconCycloOrderInv, result);\n\n    return;\n}\n\ntemplate &lt;typename VecType&gt;\nvoid ChineseRemainderTransformFTTNat&lt;VecType&gt;::ForwardTransformToBitReverseInPlace(const IntType&amp; rootOfUnity,\n                                                                                   const usint CycloOrder,\n                                                                                   VecType* element) {\n    if (rootOfUnity == IntType(1) || rootOfUnity == IntType(0)) {\n        return;\n    }\n\n    if (!lbcrypto::IsPowerOfTwo(CycloOrder)) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;CyclotomicOrder is not a power of two&quot;);\n    }\n\n    usint CycloOrderHf = (CycloOrder &gt;&gt; 1);\n    if (element-&gt;GetLength() != CycloOrderHf) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;element size must be equal to CyclotomicOrder / 2&quot;);\n    }\n\n    IntType modulus = element-&gt;GetModulus();\n\n    auto mapSearch = m_rootOfUnityReverseTableByModulus.find(modulus);\n    if (mapSearch == m_rootOfUnityReverseTableByModulus.end() || mapSearch-&gt;second.GetLength() != CycloOrderHf) {\n        PreCompute(rootOfUnity, CycloOrder, modulus);\n    }\n\n    NumberTheoreticTransformNat&lt;VecType&gt;().ForwardTransformToBitReverseInPlace(\n        m_rootOfUnityReverseTableByModulus[modulus], m_rootOfUnityPreconReverseTableByModulus[modulus], element);\n}\n\ntemplate &lt;typename VecType&gt;\nvoid ChineseRemainderTransformFTTNat&lt;VecType&gt;::ForwardTransformToBitReverse(const VecType&amp; element,\n                                                                            const IntType&amp; rootOfUnity,\n                                                                            const usint CycloOrder, VecType* result) {\n    if (rootOfUnity == IntType(1) || rootOfUnity == IntType(0)) {\n        *result = element;\n        return;\n    }\n\n    if (!lbcrypto::IsPowerOfTwo(CycloOrder)) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;CyclotomicOrder is not a power of two&quot;);\n    }\n\n    usint CycloOrderHf = (CycloOrder &gt;&gt; 1);\n    if (result-&gt;GetLength() != CycloOrderHf) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;result size must be equal to CyclotomicOrder / 2&quot;);\n    }\n\n    IntType modulus = element.GetModulus();\n\n    auto mapSearch = m_rootOfUnityReverseTableByModulus.find(modulus);\n    if (mapSearch == m_rootOfUnityReverseTableByModulus.end() || mapSearch-&gt;second.GetLength() != CycloOrderHf) {\n        PreCompute(rootOfUnity, CycloOrder, modulus);\n    }\n\n    NumberTheoreticTransformNat&lt;VecType&gt;().ForwardTransformToBitReverse(\n        element, m_rootOfUnityReverseTableByModulus[modulus], m_rootOfUnityPreconReverseTableByModulus[modulus],\n        result);\n\n    return;\n}\n\ntemplate &lt;typename VecType&gt;\nvoid ChineseRemainderTransformFTTNat&lt;VecType&gt;::InverseTransformFromBitReverseInPlace(const IntType&amp; rootOfUnity,\n                                                                                     const usint CycloOrder,\n                                                                                     VecType* element) {\n    if (rootOfUnity == IntType(1) || rootOfUnity == IntType(0)) {\n        return;\n    }\n\n    if (!lbcrypto::IsPowerOfTwo(CycloOrder)) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;CyclotomicOrder is not a power of two&quot;);\n    }\n\n    usint CycloOrderHf = (CycloOrder &gt;&gt; 1);\n    if (element-&gt;GetLength() != CycloOrderHf) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;element size must be equal to CyclotomicOrder / 2&quot;);\n    }\n\n    IntType modulus = element-&gt;GetModulus();\n\n    auto mapSearch = m_rootOfUnityReverseTableByModulus.find(modulus);\n    if (mapSearch == m_rootOfUnityReverseTableByModulus.end() || mapSearch-&gt;second.GetLength() != CycloOrderHf) {\n        PreCompute(rootOfUnity, CycloOrder, modulus);\n    }\n\n    usint msb = lbcrypto::GetMSB(CycloOrderHf - 1);\n    NumberTheoreticTransformNat&lt;VecType&gt;().InverseTransformFromBitReverseInPlace(\n        m_rootOfUnityInverseReverseTableByModulus[modulus], m_rootOfUnityInversePreconReverseTableByModulus[modulus],\n        m_cycloOrderInverseTableByModulus[modulus][msb], m_cycloOrderInversePreconTableByModulus[modulus][msb],\n        element);\n}\n\ntemplate &lt;typename VecType&gt;\nvoid ChineseRemainderTransformFTTNat&lt;VecType&gt;::InverseTransformFromBitReverse(const VecType&amp; element,\n                                                                              const IntType&amp; rootOfUnity,\n                                                                              const usint CycloOrder, VecType* result) {\n    if (rootOfUnity == IntType(1) || rootOfUnity == IntType(0)) {\n        *result = element;\n        return;\n    }\n\n    if (!lbcrypto::IsPowerOfTwo(CycloOrder)) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;CyclotomicOrder is not a power of two&quot;);\n    }\n\n    usint CycloOrderHf = (CycloOrder &gt;&gt; 1);\n    if (result-&gt;GetLength() != CycloOrderHf) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;result size must be equal to CyclotomicOrder / 2&quot;);\n    }\n\n    IntType modulus = element.GetModulus();\n\n    auto mapSearch = m_rootOfUnityReverseTableByModulus.find(modulus);\n    if (mapSearch == m_rootOfUnityReverseTableByModulus.end() || mapSearch-&gt;second.GetLength() != CycloOrderHf) {\n        PreCompute(rootOfUnity, CycloOrder, modulus);\n    }\n\n    usint n = element.GetLength();\n    result-&gt;SetModulus(element.GetModulus());\n    for (usint i = 0; i &lt; n; i++) {\n        (*result)[i] = element[i];\n    }\n\n    usint msb = lbcrypto::GetMSB(CycloOrderHf - 1);\n    NumberTheoreticTransformNat&lt;VecType&gt;().InverseTransformFromBitReverseInPlace(\n        m_rootOfUnityInverseReverseTableByModulus[modulus], m_rootOfUnityInversePreconReverseTableByModulus[modulus],\n        m_cycloOrderInverseTableByModulus[modulus][msb], m_cycloOrderInversePreconTableByModulus[modulus][msb], result);\n\n    return;\n}\n\ntemplate &lt;typename VecType&gt;\nvoid ChineseRemainderTransformFTTNat&lt;VecType&gt;::PreCompute(const IntType&amp; rootOfUnity, const usint CycloOrder,\n                                                          const IntType&amp; modulus) {\n    // Half of cyclo order\n    usint CycloOrderHf = (CycloOrder &gt;&gt; 1);\n\n    auto mapSearch = m_rootOfUnityReverseTableByModulus.find(modulus);\n    if (mapSearch == m_rootOfUnityReverseTableByModulus.end() || mapSearch-&gt;second.GetLength() != CycloOrderHf) {\n#pragma omp critical\n        {\n            IntType x(1), xinv(1);\n            usint msb  = lbcrypto::GetMSB(CycloOrderHf - 1);\n            IntType mu = modulus.ComputeMu();\n            VecType Table(CycloOrderHf, modulus);\n            VecType TableI(CycloOrderHf, modulus);\n            IntType rootOfUnityInverse = rootOfUnity.ModInverse(modulus);\n            usint iinv;\n            for (usint i = 0; i &lt; CycloOrderHf; i++) {\n                iinv         = lbcrypto::ReverseBits(i, msb);\n                Table[iinv]  = x;\n                TableI[iinv] = xinv;\n                x.ModMulEq(rootOfUnity, modulus, mu);\n                xinv.ModMulEq(rootOfUnityInverse, modulus, mu);\n            }\n            m_rootOfUnityReverseTableByModulus[modulus]        = Table;\n            m_rootOfUnityInverseReverseTableByModulus[modulus] = TableI;\n\n            VecType TableCOI(msb + 1, modulus);\n            for (usint i = 0; i &lt; msb + 1; i++) {\n                IntType coInv(IntType(1 &lt;&lt; i).ModInverse(modulus));\n                TableCOI[i] = coInv;\n            }\n            m_cycloOrderInverseTableByModulus[modulus] = TableCOI;\n\n            NativeInteger nativeModulus = modulus.ConvertToInt();\n            VecType preconTable(CycloOrderHf, nativeModulus);\n            VecType preconTableI(CycloOrderHf, nativeModulus);\n\n            for (usint i = 0; i &lt; CycloOrderHf; i++) {\n                preconTable[i] = NativeInteger(m_rootOfUnityReverseTableByModulus[modulus][i].ConvertToInt())\n                                     .PrepModMulConst(nativeModulus);\n                preconTableI[i] = NativeInteger(m_rootOfUnityInverseReverseTableByModulus[modulus][i].ConvertToInt())\n                                      .PrepModMulConst(nativeModulus);\n            }\n\n            VecType preconTableCOI(msb + 1, nativeModulus);\n            for (usint i = 0; i &lt; msb + 1; i++) {\n                preconTableCOI[i] = NativeInteger(m_cycloOrderInverseTableByModulus[modulus][i].ConvertToInt())\n                                        .PrepModMulConst(nativeModulus);\n            }\n\n            m_rootOfUnityPreconReverseTableByModulus[modulus]        = preconTable;\n            m_rootOfUnityInversePreconReverseTableByModulus[modulus] = preconTableI;\n            m_cycloOrderInversePreconTableByModulus[modulus]         = preconTableCOI;\n        }\n    }\n}\n\ntemplate &lt;typename VecType&gt;\nvoid ChineseRemainderTransformFTTNat&lt;VecType&gt;::PreCompute(std::vector&lt;IntType&gt;&amp; rootOfUnity, const usint CycloOrder,\n                                                          std::vector&lt;IntType&gt;&amp; moduliiChain) {\n    usint numOfRootU = rootOfUnity.size();\n    usint numModulii = moduliiChain.size();\n\n    if (numOfRootU != numModulii) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;size of root of unity and size of moduli chain not of same size&quot;);\n    }\n\n    for (usint i = 0; i &lt; numOfRootU; ++i) {\n        IntType currentRoot(rootOfUnity[i]);\n        IntType currentMod(moduliiChain[i]);\n        PreCompute(currentRoot, CycloOrder, currentMod);\n    }\n}\n\ntemplate &lt;typename VecType&gt;\nvoid ChineseRemainderTransformFTTNat&lt;VecType&gt;::Reset() {\n    m_cycloOrderInverseTableByModulus.clear();\n    m_cycloOrderInversePreconTableByModulus.clear();\n    m_rootOfUnityReverseTableByModulus.clear();\n    m_rootOfUnityInverseReverseTableByModulus.clear();\n    m_rootOfUnityPreconReverseTableByModulus.clear();\n    m_rootOfUnityInversePreconReverseTableByModulus.clear();\n}\n\ntemplate &lt;typename VecType&gt;\nvoid BluesteinFFTNat&lt;VecType&gt;::PreComputeDefaultNTTModulusRoot(usint cycloOrder, const IntType&amp; modulus) {\n    usint nttDim          = pow(2, ceil(log2(2 * cycloOrder - 1)));\n    const auto nttModulus = lbcrypto::FirstPrime&lt;IntType&gt;(log2(nttDim) + 2 * modulus.GetMSB(), nttDim);\n    const auto nttRoot    = lbcrypto::RootOfUnity&lt;IntType&gt;(nttDim, nttModulus);\n    const ModulusRoot&lt;IntType&gt; nttModulusRoot = {nttModulus, nttRoot};\n    m_defaultNTTModulusRoot[modulus]          = nttModulusRoot;\n\n    PreComputeRootTableForNTT(cycloOrder, nttModulusRoot);\n}\n\ntemplate &lt;typename VecType&gt;\nvoid BluesteinFFTNat&lt;VecType&gt;::PreComputeRootTableForNTT(usint cyclotoOrder,\n                                                         const ModulusRoot&lt;IntType&gt;&amp; nttModulusRoot) {\n    usint nttDim           = pow(2, ceil(log2(2 * cyclotoOrder - 1)));\n    const auto&amp; nttModulus = nttModulusRoot.first;\n    const auto&amp; nttRoot    = nttModulusRoot.second;\n\n    IntType root(nttRoot);\n\n    auto rootInv = root.ModInverse(nttModulus);\n\n    usint nttDimHf = (nttDim &gt;&gt; 1);\n    VecType rootTable(nttDimHf, nttModulus);\n    VecType rootTableInverse(nttDimHf, nttModulus);\n\n    IntType x(1);\n    for (usint i = 0; i &lt; nttDimHf; i++) {\n        rootTable[i] = x;\n        x            = x.ModMul(root, nttModulus);\n    }\n\n    x = 1;\n    for (usint i = 0; i &lt; nttDimHf; i++) {\n        rootTableInverse[i] = x;\n        x                   = x.ModMul(rootInv, nttModulus);\n    }\n\n    m_rootOfUnityTableByModulusRoot[nttModulusRoot]        = rootTable;\n    m_rootOfUnityInverseTableByModulusRoot[nttModulusRoot] = rootTableInverse;\n}\n\ntemplate &lt;typename VecType&gt;\nvoid BluesteinFFTNat&lt;VecType&gt;::PreComputePowers(usint cycloOrder, const ModulusRoot&lt;IntType&gt;&amp; modulusRoot) {\n    const auto&amp; modulus = modulusRoot.first;\n    const auto&amp; root    = modulusRoot.second;\n\n    VecType powers(cycloOrder, modulus);\n    powers[0] = 1;\n    for (usint i = 1; i &lt; cycloOrder; i++) {\n        auto iSqr = (i * i) % (2 * cycloOrder);\n        auto val  = root.ModExp(IntType(iSqr), modulus);\n        powers[i] = val;\n    }\n    m_powersTableByModulusRoot[modulusRoot] = powers;\n}\n\ntemplate &lt;typename VecType&gt;\nvoid BluesteinFFTNat&lt;VecType&gt;::PreComputeRBTable(usint cycloOrder, const ModulusRootPair&lt;IntType&gt;&amp; modulusRootPair) {\n    const auto&amp; modulusRoot = modulusRootPair.first;\n    const auto&amp; modulus     = modulusRoot.first;\n    const auto&amp; root        = modulusRoot.second;\n    const auto rootInv      = root.ModInverse(modulus);\n\n    const auto&amp; nttModulusRoot = modulusRootPair.second;\n    const auto&amp; nttModulus     = nttModulusRoot.first;\n    // const auto &amp;nttRoot = nttModulusRoot.second;\n    // assumes rootTable is precomputed\n    const auto&amp; rootTable = m_rootOfUnityTableByModulusRoot[nttModulusRoot];\n    usint nttDim          = pow(2, ceil(log2(2 * cycloOrder - 1)));\n\n    VecType b(2 * cycloOrder - 1, modulus);\n    b[cycloOrder - 1] = 1;\n    for (usint i = 1; i &lt; cycloOrder; i++) {\n        auto iSqr             = (i * i) % (2 * cycloOrder);\n        auto val              = rootInv.ModExp(IntType(iSqr), modulus);\n        b[cycloOrder - 1 + i] = val;\n        b[cycloOrder - 1 - i] = val;\n    }\n\n    auto Rb = PadZeros(b, nttDim);\n    Rb.SetModulus(nttModulus);\n\n    VecType RB(nttDim);\n    NumberTheoreticTransformNat&lt;VecType&gt;().ForwardTransformIterative(Rb, rootTable, &amp;RB);\n    m_RBTableByModulusRootPair[modulusRootPair] = RB;\n}\n\ntemplate &lt;typename VecType&gt;\nVecType BluesteinFFTNat&lt;VecType&gt;::ForwardTransform(const VecType&amp; element, const IntType&amp; root,\n                                                   const usint cycloOrder) {\n    const auto&amp; modulus        = element.GetModulus();\n    const auto&amp; nttModulusRoot = m_defaultNTTModulusRoot[modulus];\n\n    return ForwardTransform(element, root, cycloOrder, nttModulusRoot);\n}\n\ntemplate &lt;typename VecType&gt;\nVecType BluesteinFFTNat&lt;VecType&gt;::ForwardTransform(const VecType&amp; element, const IntType&amp; root, const usint cycloOrder,\n                                                   const ModulusRoot&lt;IntType&gt;&amp; nttModulusRoot) {\n    if (element.GetLength() != cycloOrder) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;expected size of element vector should be equal to cyclotomic order&quot;);\n    }\n\n    const auto&amp; modulus                    = element.GetModulus();\n    const ModulusRoot&lt;IntType&gt; modulusRoot = {modulus, root};\n    const VecType&amp; powers                  = m_powersTableByModulusRoot[modulusRoot];\n\n    const auto&amp; nttModulus = nttModulusRoot.first;\n    // assumes rootTable is precomputed\n    const auto&amp; rootTable = m_rootOfUnityTableByModulusRoot[nttModulusRoot];\n    const auto&amp; rootTableInverse =\n        m_rootOfUnityInverseTableByModulusRoot[nttModulusRoot];  // assumes rootTableInverse is precomputed\n    VecType x = element.ModMul(powers);\n\n    usint nttDim = pow(2, ceil(log2(2 * cycloOrder - 1)));\n    auto Ra      = PadZeros(x, nttDim);\n    Ra.SetModulus(nttModulus);\n    VecType RA(nttDim);\n    NumberTheoreticTransformNat&lt;VecType&gt;().ForwardTransformIterative(Ra, rootTable, &amp;RA);\n\n    const ModulusRootPair&lt;IntType&gt; modulusRootPair = {modulusRoot, nttModulusRoot};\n    const auto&amp; RB                                 = m_RBTableByModulusRootPair[modulusRootPair];\n\n    auto RC = RA.ModMul(RB);\n    VecType Rc(nttDim);\n    NumberTheoreticTransformNat&lt;VecType&gt;().InverseTransformIterative(RC, rootTableInverse, &amp;Rc);\n    auto resizeRc = Resize(Rc, cycloOrder - 1, 2 * (cycloOrder - 1));\n    resizeRc.SetModulus(modulus);\n    resizeRc.ModEq(modulus);\n    auto result = resizeRc.ModMul(powers);\n\n    return result;\n}\n\ntemplate &lt;typename VecType&gt;\nVecType BluesteinFFTNat&lt;VecType&gt;::PadZeros(const VecType&amp; a, const usint finalSize) {\n    usint s = a.GetLength();\n    VecType result(finalSize, a.GetModulus());\n\n    for (usint i = 0; i &lt; s; i++) {\n        result[i] = a[i];\n    }\n\n    for (usint i = a.GetLength(); i &lt; finalSize; i++) {\n        result[i] = IntType(0);\n    }\n\n    return result;\n}\n\ntemplate &lt;typename VecType&gt;\nVecType BluesteinFFTNat&lt;VecType&gt;::Resize(const VecType&amp; a, usint lo, usint hi) {\n    VecType result(hi - lo + 1, a.GetModulus());\n\n    for (usint i = lo, j = 0; i &lt;= hi; i++, j++) {\n        result[j] = a[i];\n    }\n\n    return result;\n}\n\ntemplate &lt;typename VecType&gt;\nvoid BluesteinFFTNat&lt;VecType&gt;::Reset() {\n    m_rootOfUnityTableByModulusRoot.clear();\n    m_rootOfUnityInverseTableByModulusRoot.clear();\n    m_powersTableByModulusRoot.clear();\n    m_RBTableByModulusRootPair.clear();\n    m_defaultNTTModulusRoot.clear();\n}\n\ntemplate &lt;typename VecType&gt;\nvoid ChineseRemainderTransformArbNat&lt;VecType&gt;::SetCylotomicPolynomial(const VecType&amp; poly, const IntType&amp; mod) {\n    m_cyclotomicPolyMap[mod] = poly;\n}\n\ntemplate &lt;typename VecType&gt;\nvoid ChineseRemainderTransformArbNat&lt;VecType&gt;::PreCompute(const usint cyclotoOrder, const IntType&amp; modulus) {\n    BluesteinFFTNat&lt;VecType&gt;().PreComputeDefaultNTTModulusRoot(cyclotoOrder, modulus);\n}\n\ntemplate &lt;typename VecType&gt;\nvoid ChineseRemainderTransformArbNat&lt;VecType&gt;::SetPreComputedNTTModulus(usint cyclotoOrder, const IntType&amp; modulus,\n                                                                        const IntType&amp; nttModulus,\n                                                                        const IntType&amp; nttRoot) {\n    const ModulusRoot&lt;IntType&gt; nttModulusRoot = {nttModulus, nttRoot};\n    BluesteinFFTNat&lt;VecType&gt;().PreComputeRootTableForNTT(cyclotoOrder, nttModulusRoot);\n}\n\ntemplate &lt;typename VecType&gt;\nvoid ChineseRemainderTransformArbNat&lt;VecType&gt;::SetPreComputedNTTDivisionModulus(usint cyclotoOrder,\n                                                                                const IntType&amp; modulus,\n                                                                                const IntType&amp; nttMod,\n                                                                                const IntType&amp; nttRootBig) {\n    OPENFHE_DEBUG_FLAG(false);\n\n    usint n = lbcrypto::GetTotient(cyclotoOrder);\n    OPENFHE_DEBUG(&quot;GetTotient(&quot; &lt;&lt; cyclotoOrder &lt;&lt; &quot;)= &quot; &lt;&lt; n);\n\n    usint power                    = cyclotoOrder - n;\n    m_nttDivisionDim[cyclotoOrder] = 2 * std::pow(2, ceil(log2(power)));\n\n    usint nttDimBig = std::pow(2, ceil(log2(2 * cyclotoOrder - 1)));\n\n    // Computes the root of unity for the division NTT based on the root of unity\n    // for regular NTT\n    IntType nttRoot = nttRootBig.ModExp(IntType(nttDimBig / m_nttDivisionDim[cyclotoOrder]), nttMod);\n\n    m_DivisionNTTModulus[modulus]     = nttMod;\n    m_DivisionNTTRootOfUnity[modulus] = nttRoot;\n    // part0 setting of rootTable and inverse rootTable\n    usint nttDim = m_nttDivisionDim[cyclotoOrder];\n    IntType root(nttRoot);\n    auto rootInv = root.ModInverse(nttMod);\n\n    usint nttDimHf = (nttDim &gt;&gt; 1);\n    VecType rootTable(nttDimHf, nttMod);\n    VecType rootTableInverse(nttDimHf, nttMod);\n\n    IntType x(1);\n    for (usint i = 0; i &lt; nttDimHf; i++) {\n        rootTable[i] = x;\n        x            = x.ModMul(root, nttMod);\n    }\n\n    x = 1;\n    for (usint i = 0; i &lt; nttDimHf; i++) {\n        rootTableInverse[i] = x;\n        x                   = x.ModMul(rootInv, nttMod);\n    }\n\n    m_rootOfUnityDivisionTableByModulus[nttMod]        = rootTable;\n    m_rootOfUnityDivisionInverseTableByModulus[nttMod] = rootTableInverse;\n\n    // end of part0\n    // part1\n    const auto&amp; RevCPM = InversePolyMod(m_cyclotomicPolyMap[modulus], modulus, power);\n    auto RevCPMPadded  = BluesteinFFTNat&lt;VecType&gt;().PadZeros(RevCPM, nttDim);\n    RevCPMPadded.SetModulus(nttMod);\n    // end of part1\n\n    VecType RA(nttDim);\n    NumberTheoreticTransformNat&lt;VecType&gt;().ForwardTransformIterative(RevCPMPadded, rootTable, &amp;RA);\n    m_cyclotomicPolyReverseNTTMap[modulus] = RA;\n\n    const auto&amp; cycloPoly = m_cyclotomicPolyMap[modulus];\n\n    VecType QForwardTransform(nttDim, nttMod);\n    for (usint i = 0; i &lt; cycloPoly.GetLength(); i++) {\n        QForwardTransform[i] = cycloPoly[i];\n    }\n\n    VecType QFwdResult(nttDim);\n    NumberTheoreticTransformNat&lt;VecType&gt;().ForwardTransformIterative(QForwardTransform, rootTable, &amp;QFwdResult);\n\n    m_cyclotomicPolyNTTMap[modulus] = QFwdResult;\n}\n\ntemplate &lt;typename VecType&gt;\nVecType ChineseRemainderTransformArbNat&lt;VecType&gt;::InversePolyMod(const VecType&amp; cycloPoly, const IntType&amp; modulus,\n                                                                 usint power) {\n    VecType result(power, modulus);\n    usint r = ceil(log2(power));\n    VecType h(1, modulus);  // h is a unit polynomial\n    h[0] = 1;\n\n    // Precompute the Barrett mu parameter\n    IntType mu = modulus.ComputeMu();\n\n    for (usint i = 0; i &lt; r; i++) {\n        usint qDegree = std::pow(2, i + 1);\n        VecType q(qDegree + 1, modulus);  // q = x^(2^i+1)\n        q[qDegree]   = 1;\n        auto hSquare = PolynomialMultiplication(h, h);\n\n        auto a = h * IntType(2);\n        auto b = PolynomialMultiplication(hSquare, cycloPoly);\n        // b = 2h - gh^2\n        for (usint j = 0; j &lt; b.GetLength(); j++) {\n            if (j &lt; a.GetLength()) {\n                b[j] = a[j].ModSub(b[j], modulus, mu);\n            }\n            else {\n                b[j] = modulus.ModSub(b[j], modulus, mu);\n            }\n        }\n        h = PolyMod(b, q, modulus);\n    }\n    // take modulo x^power\n    for (usint i = 0; i &lt; power; i++) {\n        result[i] = h[i];\n    }\n\n    return result;\n}\n\ntemplate &lt;typename VecType&gt;\nVecType ChineseRemainderTransformArbNat&lt;VecType&gt;::ForwardTransform(const VecType&amp; element, const IntType&amp; root,\n                                                                   const IntType&amp; nttModulus, const IntType&amp; nttRoot,\n                                                                   const usint cycloOrder) {\n    usint phim = lbcrypto::GetTotient(cycloOrder);\n    if (element.GetLength() != phim) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;element size should be equal to phim&quot;);\n    }\n\n    const auto&amp; modulus                    = element.GetModulus();\n    const ModulusRoot&lt;IntType&gt; modulusRoot = {modulus, root};\n\n    const ModulusRoot&lt;IntType&gt; nttModulusRoot      = {nttModulus, nttRoot};\n    const ModulusRootPair&lt;IntType&gt; modulusRootPair = {modulusRoot, nttModulusRoot};\n\n#pragma omp critical\n    {\n        if (BluesteinFFTNat&lt;VecType&gt;::m_rootOfUnityTableByModulusRoot[nttModulusRoot].GetLength() == 0) {\n            BluesteinFFTNat&lt;VecType&gt;().PreComputeRootTableForNTT(cycloOrder, nttModulusRoot);\n        }\n\n        if (BluesteinFFTNat&lt;VecType&gt;::m_powersTableByModulusRoot[modulusRoot].GetLength() == 0) {\n            BluesteinFFTNat&lt;VecType&gt;().PreComputePowers(cycloOrder, modulusRoot);\n        }\n\n        if (BluesteinFFTNat&lt;VecType&gt;::m_RBTableByModulusRootPair[modulusRootPair].GetLength() == 0) {\n            BluesteinFFTNat&lt;VecType&gt;().PreComputeRBTable(cycloOrder, modulusRootPair);\n        }\n    }\n\n    VecType inputToBluestein = Pad(element, cycloOrder, true);\n    auto outputBluestein =\n        BluesteinFFTNat&lt;VecType&gt;().ForwardTransform(inputToBluestein, root, cycloOrder, nttModulusRoot);\n    VecType output = Drop(outputBluestein, cycloOrder, true, nttModulus, nttRoot);\n\n    return output;\n}\n\ntemplate &lt;typename VecType&gt;\nVecType ChineseRemainderTransformArbNat&lt;VecType&gt;::InverseTransform(const VecType&amp; element, const IntType&amp; root,\n                                                                   const IntType&amp; nttModulus, const IntType&amp; nttRoot,\n                                                                   const usint cycloOrder) {\n    usint phim = lbcrypto::GetTotient(cycloOrder);\n    if (element.GetLength() != phim) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;element size should be equal to phim&quot;);\n    }\n\n    const auto&amp; modulus = element.GetModulus();\n    auto rootInverse(root.ModInverse(modulus));\n    const ModulusRoot&lt;IntType&gt; modulusRootInverse = {modulus, rootInverse};\n\n    const ModulusRoot&lt;IntType&gt; nttModulusRoot      = {nttModulus, nttRoot};\n    const ModulusRootPair&lt;IntType&gt; modulusRootPair = {modulusRootInverse, nttModulusRoot};\n\n#pragma omp critical\n    {\n        if (BluesteinFFTNat&lt;VecType&gt;::m_rootOfUnityTableByModulusRoot[nttModulusRoot].GetLength() == 0) {\n            BluesteinFFTNat&lt;VecType&gt;().PreComputeRootTableForNTT(cycloOrder, nttModulusRoot);\n        }\n\n        if (BluesteinFFTNat&lt;VecType&gt;::m_powersTableByModulusRoot[modulusRootInverse].GetLength() == 0) {\n            BluesteinFFTNat&lt;VecType&gt;().PreComputePowers(cycloOrder, modulusRootInverse);\n        }\n\n        if (BluesteinFFTNat&lt;VecType&gt;::m_RBTableByModulusRootPair[modulusRootPair].GetLength() == 0) {\n            BluesteinFFTNat&lt;VecType&gt;().PreComputeRBTable(cycloOrder, modulusRootPair);\n        }\n    }\n    VecType inputToBluestein = Pad(element, cycloOrder, false);\n    auto outputBluestein =\n        BluesteinFFTNat&lt;VecType&gt;().ForwardTransform(inputToBluestein, rootInverse, cycloOrder, nttModulusRoot);\n    auto cyclotomicInverse((IntType(cycloOrder)).ModInverse(modulus));\n    outputBluestein = outputBluestein * cyclotomicInverse;\n    VecType output  = Drop(outputBluestein, cycloOrder, false, nttModulus, nttRoot);\n    return output;\n}\n\ntemplate &lt;typename VecType&gt;\nVecType ChineseRemainderTransformArbNat&lt;VecType&gt;::Pad(const VecType&amp; element, const usint cycloOrder, bool forward) {\n    usint n = lbcrypto::GetTotient(cycloOrder);\n\n    const auto&amp; modulus = element.GetModulus();\n    VecType inputToBluestein(cycloOrder, modulus);\n\n    if (forward) {  // Forward transform padding\n        for (usint i = 0; i &lt; n; i++) {\n            inputToBluestein[i] = element[i];\n        }\n    }\n    else {  // Inverse transform padding\n        auto tList = lbcrypto::GetTotientList(cycloOrder);\n        usint i    = 0;\n        for (auto&amp; coprime : tList) {\n            inputToBluestein[coprime] = element[i++];\n        }\n    }\n\n    return inputToBluestein;\n}\n\ntemplate &lt;typename VecType&gt;\nVecType ChineseRemainderTransformArbNat&lt;VecType&gt;::Drop(const VecType&amp; element, const usint cycloOrder, bool forward,\n                                                       const IntType&amp; bigMod, const IntType&amp; bigRoot) {\n    usint n = lbcrypto::GetTotient(cycloOrder);\n\n    const auto&amp; modulus = element.GetModulus();\n    VecType output(n, modulus);\n\n    if (forward) {  // Forward transform drop\n        auto tList = lbcrypto::GetTotientList(cycloOrder);\n        for (usint i = 0; i &lt; n; i++) {\n            output[i] = element[tList[i]];\n        }\n    }\n    else {  // Inverse transform drop\n        if ((n + 1) == cycloOrder) {\n            IntType mu = modulus.ComputeMu();  // Precompute the Barrett mu parameter\n            // cycloOrder is prime: Reduce mod Phi_{n+1}(x)\n            // Reduction involves subtracting the coeff of x^n from all terms\n            auto coeff_n = element[n];\n            for (usint i = 0; i &lt; n; i++) {\n                output[i] = element[i].ModSub(coeff_n, modulus, mu);\n            }\n        }\n        else if ((n + 1) * 2 == cycloOrder) {\n            IntType mu = modulus.ComputeMu();  // Precompute the Barrett mu parameter\n            // cycloOrder is 2*prime: 2 Step reduction\n            // First reduce mod x^(n+1)+1 (=(x+1)*Phi_{2*(n+1)}(x))\n            // Subtract co-efficient of x^(i+n+1) from x^(i)\n            for (usint i = 0; i &lt; n; i++) {\n                auto coeff_i  = element[i];\n                auto coeff_ip = element[i + n + 1];\n                output[i]     = coeff_i.ModSub(coeff_ip, modulus, mu);\n            }\n            auto coeff_n = element[n].ModSub(element[2 * n + 1], modulus, mu);\n            // Now reduce mod Phi_{2*(n+1)}(x)\n            // Similar to the prime case but with alternating signs\n            for (usint i = 0; i &lt; n; i++) {\n                if (i % 2 == 0) {\n                    output[i].ModSubEq(coeff_n, modulus, mu);\n                }\n                else {\n                    output[i].ModAddEq(coeff_n, modulus, mu);\n                }\n            }\n        }\n        else {\n            // precompute root of unity tables for division NTT\n            if ((m_rootOfUnityDivisionTableByModulus[bigMod].GetLength() == 0) ||\n                (m_DivisionNTTModulus[modulus] != bigMod)) {\n                SetPreComputedNTTDivisionModulus(cycloOrder, modulus, bigMod, bigRoot);\n            }\n\n            // cycloOrder is arbitrary\n            // auto output = PolyMod(element, this-&gt;m_cyclotomicPolyMap[modulus],\n            // modulus);\n\n            const auto&amp; nttMod    = m_DivisionNTTModulus[modulus];\n            const auto&amp; rootTable = m_rootOfUnityDivisionTableByModulus[nttMod];\n            VecType aPadded2(m_nttDivisionDim[cycloOrder], nttMod);\n            // perform mod operation\n            usint power = cycloOrder - n;\n            for (usint i = n; i &lt; element.GetLength(); i++) {\n                aPadded2[power - (i - n) - 1] = element[i];\n            }\n            VecType A(m_nttDivisionDim[cycloOrder]);\n            NumberTheoreticTransformNat&lt;VecType&gt;().ForwardTransformIterative(aPadded2, rootTable, &amp;A);\n            auto AB                      = A * m_cyclotomicPolyReverseNTTMap[modulus];\n            const auto&amp; rootTableInverse = m_rootOfUnityDivisionInverseTableByModulus[nttMod];\n            VecType a(m_nttDivisionDim[cycloOrder]);\n            NumberTheoreticTransformNat&lt;VecType&gt;().InverseTransformIterative(AB, rootTableInverse, &amp;a);\n\n            VecType quotient(m_nttDivisionDim[cycloOrder], modulus);\n            for (usint i = 0; i &lt; power; i++) {\n                quotient[i] = a[i];\n            }\n            quotient.ModEq(modulus);\n            quotient.SetModulus(nttMod);\n\n            VecType newQuotient(m_nttDivisionDim[cycloOrder]);\n            NumberTheoreticTransformNat&lt;VecType&gt;().ForwardTransformIterative(quotient, rootTable, &amp;newQuotient);\n            newQuotient *= m_cyclotomicPolyNTTMap[modulus];\n\n            VecType newQuotient2(m_nttDivisionDim[cycloOrder]);\n            NumberTheoreticTransformNat&lt;VecType&gt;().InverseTransformIterative(newQuotient, rootTableInverse,\n                                                                             &amp;newQuotient2);\n            newQuotient2.SetModulus(modulus);\n            newQuotient2.ModEq(modulus);\n\n            IntType mu = modulus.ComputeMu();  // Precompute the Barrett mu parameter\n\n            for (usint i = 0; i &lt; n; i++) {\n                output[i] = element[i].ModSub(newQuotient2[cycloOrder - 1 - i], modulus, mu);\n            }\n        }\n    }\n    return output;\n}\n\ntemplate &lt;typename VecType&gt;\nvoid ChineseRemainderTransformArbNat&lt;VecType&gt;::Reset() {\n    m_cyclotomicPolyMap.clear();\n    m_cyclotomicPolyReverseNTTMap.clear();\n    m_cyclotomicPolyNTTMap.clear();\n    m_rootOfUnityDivisionTableByModulus.clear();\n    m_rootOfUnityDivisionInverseTableByModulus.clear();\n    m_DivisionNTTModulus.clear();\n    m_DivisionNTTRootOfUnity.clear();\n    m_nttDivisionDim.clear();\n    BluesteinFFTNat&lt;VecType&gt;().Reset();\n}\n\n// forced template instantiation\n// template class ChineseRemainderTransformFTTNat&lt;NativeVector&gt;;\n// template class ChineseRemainderTransformArbNat&lt;NativeVector&gt;;\n\n}  // namespace intnat\n\n#endif  // __TRANSFORMNAT_IMPL_H__\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "content": "// clang-format off\n//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  PRNG engine based on BLAKE2b\n */\n\n#ifndef _SRC_LIB_UTILS_BLAKE2ENGINE_H\n#define _SRC_LIB_UTILS_BLAKE2ENGINE_H\n\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;array&gt;\n#include &lt;limits&gt;\n\n#include &quot;blake2.h&quot;\n\n#include &quot;utils/exception.h&quot;\n\nnamespace lbcrypto {\n\n// the buffer stores 1024 samples of 32-bit integers\nconst uint32_t PRNG_BUFFER_SIZE = 1024;\n\n/**\n * @brief Defines the PRNG engine used by OpenFHE. It is based on BLAKE2. Use\n * this as a template for adding other PRNG engines to OpenFHE.\n */\nclass Blake2Engine {\n public:\n  // all C++11 distributions used in OpenFHE work by default with uint32_t\n  // a different data type can be specified if needed for a particular\n  // architecture\n  using result_type = uint32_t;\n\n  /**\n   * @brief Constructor using a small seed - used for generating a large seed\n   */\n  explicit Blake2Engine(result_type seed)\n      : m_counter(0), m_buffer({}), m_bufferIndex(0) {\n    m_seed[0] = seed;\n  }\n\n  /**\n   * @brief Main constructor taking a vector of 16 integers as a seed\n   */\n  explicit Blake2Engine(const std::array&lt;result_type, 16&gt;&amp; seed)\n      : m_counter(0), m_seed(seed), m_buffer({}), m_bufferIndex(0) {}\n\n  /**\n   * @brief Main constructor taking a vector of 16 integers as a seed and a\n   * counter\n   */\n  explicit Blake2Engine(const std::array&lt;result_type, 16&gt;&amp; seed,\n                        result_type counter)\n      : m_counter(counter), m_seed(seed), m_buffer({}), m_bufferIndex(0) {}\n\n  /**\n   * @brief minimum value used by C+11 distribution generators when no lower\n   * bound is explicitly specified by the user\n   */\n  static constexpr result_type min() {\n    return std::numeric_limits&lt;result_type&gt;::min();\n  }\n\n  /**\n   * @brief maximum value used by C+11 distribution generators when no upper\n   * bound is explicitly specified by the user\n   */\n  static constexpr result_type max() {\n    return std::numeric_limits&lt;result_type&gt;::max();\n  }\n\n  /**\n   * @brief main call to the PRNG\n   */\n  result_type operator()() {\n    result_type result;\n\n    if (m_bufferIndex == PRNG_BUFFER_SIZE) m_bufferIndex = 0;\n\n    // makes a call to the BLAKE2 generator only when the currently buffered\n    // values are all consumed precomputations are done only once for the\n    // current buffer\n    if (m_bufferIndex == 0) Generate();\n\n    result = m_buffer[m_bufferIndex];\n\n    m_bufferIndex++;\n\n    return result;\n  }\n\n  Blake2Engine(const Blake2Engine&amp; other) {\n    m_counter = other.m_counter;\n    m_seed = other.m_seed;\n    m_buffer = other.m_buffer;\n    m_bufferIndex = other.m_bufferIndex;\n  }\n\n  void operator=(const Blake2Engine&amp; other) {\n    m_counter = other.m_counter;\n    m_seed = other.m_seed;\n    m_buffer = other.m_buffer;\n    m_bufferIndex = other.m_bufferIndex;\n  }\n\n private:\n  /**\n   * @brief The main call to blake2xb function\n   */\n  void Generate() {\n    // m_counter is the input to the hash function\n    // m_buffer is the output\n    if (blake2xb(m_buffer.begin(), m_buffer.size() * sizeof(result_type),\n                 &amp;m_counter, sizeof(m_counter), m_seed.cbegin(),\n                 m_seed.size() * sizeof(result_type)) != 0) {\n      &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;PRNG: blake2xb failed&quot;);\n    }\n    m_counter++;\n    return;\n  }\n\n  // counter used as input to the BLAKE2 hash function\n  // gets incremented after each call\n  uint64_t m_counter = 0;\n\n  // the seed for the BLAKE2 hash function\n  std::array&lt;result_type, 16&gt; m_seed{};\n\n  // The vector that stores random samples generated using the hash function\n  std::array&lt;result_type, PRNG_BUFFER_SIZE&gt; m_buffer{};\n\n  // Index in m_buffer corresponding to the current PRNG sample\n  uint16_t m_bufferIndex = 0;\n};\n\n}  // namespace lbcrypto\n\n#endif\n// clang-format on\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/math/discretegaussiangeneratorgeneric.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/math/discretegaussiangeneratorgeneric.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/math/discretegaussiangeneratorgeneric.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  This code provides generation of gaussian distributions of discrete values. Discrete uniform generator\n  relies on the built-in C++ generator for 32-bit unsigned integers defined in &lt;random&gt;\n */\n\n/*This is the header file for the Generic Sampler used for various Discrete\n * Gaussian Sampling applications. This class implements the generic sampler by\n * UCSD discussed in the https://eprint.iacr.org/2017/259.pdf and it is heavily\n * based on Michael Walter&#x27;s original code. Along the sides of the\n * implementation there are also two different &quot;base samplers&quot;, which are used\n * for the generic sampler or can be used on their own depending on the\n * requirements of needed application.\n *\n * The first base sampler uses Peikert&#x27;s inversion method, discussed in\n * section 4.1 of https://eprint.iacr.org/2010/088.pdf and summarized in\n * section 3.2.2 of\n * https://link.springer.com/content/pdf/10.1007%2Fs00200-014-0218-3.pdf.\n * Peikert&#x27;s method requires precomputation of CDF tables around a specific\n * center and the table must be kept during the sampling process. Hence,\n * Peikert&#x27;s method works best if the DESIRED STANDARD DEVIATION IS SMALL and\n * THE MEAN OF THE DISTRIBUTION IS FIXED, as each new center will require a new\n * set of precomputations.\n *\n * Second base sampler is  the Knuth-Yao Sampler discussed in section 5 of\n * https://link.springer.com/content/pdf/10.1007%2Fs00200-014-0218-3.pdf .\n * Similar to Peikert&#x27;s, Knuth-Yao precomputes the PDF&#x27;s of the numbers based on\n * standard deviation and the center, which is used during the sampling process.\n * Therefore like Peikert&#x27;s method,  Knuth-Yao works best method works best if\n * the DESIRED STANDARD DEVIATION IS SMALL and THE MEAN OF THE DISTRIBUTION IS\n * FIXED, as each new center will require a new set of precomputations, just\n * like Peikert&#x27;s inversion method.\n *\n * The &quot;generic sampler&quot; on the other hand, works independent from standard\n * deviation of the distribution. It combines an array of previously discussed\n * base samplers centered around 0 to (2^b-1) / 2^b through convolution. The\n * tables of base samplers however, must be precomputed beforehand; but they do\n * not need to be recalculated at any time of the sampling process. It is USABLE\n * FOR ANY STANDARD DEVIATION AND MEAN, just like Karney&#x27;s method defined in\n * discretegaussiangenerator.h, needs only one single precomputation and is not\n * prone to timing attacks unlike Karney. Karney&#x27;s method, however, is faster\n * than the generic sampler.\n *\n * PARAMETER SELECTION FOR GENERIC SAMPLER\n *\n * The selection of parameters change the run time/memory usage/precision of the\n * generic sampler. The triple trade off between these parameters are defined in\n * the equation k = (PRECISION - FLIPS) / LOG_BASE. k denotes the level of\n * precision of the generic sampler. Higher the k is, higher the precision of\n * the generic sampler but higher the run time. PRECISION denotes the number of\n * decimal bits in the center of the distribution. Since we are using &#x27;double&#x27;\n * for mean, it is fixed to 53 by definition. FLIPS denote the number of\n * Bernoulli flips used to approximate the bits used in combination of base\n * sampler. Higher the number of flips, larger the number of bits approximated\n * rather than calculated which means smaller run times. Generic sampler\n * requires a set of base samplers centered around 0/2^b to (2^b-1)/2^b;\n * LOG_BASE denotes b in this equation. Higher the LOG_BASE is, more base\n * samplers required which requires additional memory; but at the same time\n * smaller run times.\n *\n * The base samplers used in generic sampler requires varying centers between\n * 0/2^b and (2^b-1)/(2^b) with the same standard deviation. The standard\n * deviation required for base samplers must satisfy SIGMA&gt;=4*SQRT(2)*N, where\n * sigma is the standard deviation of the base sampler and N is the smoothing\n * parameter\n *\n * */\n\n#ifndef LBCRYPTO_INC_MATH_DISCRETEGAUSSIANGENERATORGENERIC_H_\n#define LBCRYPTO_INC_MATH_DISCRETEGAUSSIANGENERATORGENERIC_H_\n\n#define MAX_LEVELS 4\n\n// #include &quot;math/math-hal.h&quot;\n#include &quot;math/distributiongenerator.h&quot;\n// #include &quot;math/nbtheory.h&quot;\n\n#include &quot;utils/inttypes.h&quot;\n\n#include &lt;cmath&gt;\n#include &lt;memory&gt;\n#include &lt;random&gt;\n#include &lt;vector&gt;\n\nnamespace lbcrypto {\n\nenum BaseSamplerType { KNUTH_YAO = 0, PEIKERT = 1 };\n\nclass DiscreteGaussianGeneratorGeneric;\nclass BaseSampler;\nclass SamplerCombiner;\nclass BitGenerator;\n\n/*\n * @brief Class implementation to generate random bit. This is created for\n * centralizing the random bit pools by the samplers.\n */\nclass BitGenerator {\npublic:\n    BitGenerator()  = default;\n    ~BitGenerator() = default;\n    /*\n   * @brief Method for generating a random bit\n   * @return A random bit\n   */\n    short Generate() {  // NOLINT\n        if (counter % 31 == 0) {\n            sequence = (PseudoRandomNumberGenerator::GetPRNG())();\n            sequence = sequence &lt;&lt; 1;\n            counter  = 0;\n        }\n        short bit = (sequence &gt;&gt; (31 - counter)) &amp; 1;  // NOLINT\n        counter++;\n        return bit;\n    }\n\nprivate:\n    uint32_t sequence = 0;\n    char counter      = 0;\n};\n/*\n * @brief Class definiton for base samplers with precomputation that is used for\n * UCSD generic sampler\n */\nclass BaseSampler {\npublic:\n    /*\n   * @brief Constructor\n   * @param mean Mean of the distribution\n   * @param std Standard deviation of the distribution\n   * @param generator Pointer to the bit generator that the sampler will use the\n   * random bits from\n   * @param bType Type of the base sampler\n   */\n    BaseSampler(double mean, double std, BitGenerator* generator, BaseSamplerType bType);\n    BaseSampler() = default;\n    /*\n   * @brief Method for generating integer from the base sampler\n   * @return A random integer from the distribution\n   */\n    virtual int64_t GenerateInteger();\n    /*\n   * @brief Destroyer for the base sampler\n   */\n    virtual ~BaseSampler() = default;\n    /*\n   * @brief Method for generating a random bit from the bit generator within\n   * @return A random bit\n   */\n    short RandomBit() {  // NOLINT\n        return bg-&gt;Generate();\n    }\n\nprivate:\n    // all parameters are set as int because it is assumed that they are used for\n    // generating &quot;small&quot; polynomials only\n    double b_a;\n\n    /**\n   *Mean of the distribution used\n   */\n    int64_t b_mean;\n\n    /**\n   * The standard deviation of the distribution.\n   */\n    float b_std;\n\n    /**\n   * Generator used for creating random bits through sampling\n   */\n    BitGenerator* bg;\n    /**\n   * Type of the base sampler (Knuth Yao or Peikert&#x27;s Inversion)\n   */\n    BaseSamplerType b_type;\n\n    int fin;\n\n    std::vector&lt;std::vector&lt;short&gt;&gt; DDGTree;  // NOLINT\n\n    // short *DDGColumn = nullptr;\n\n    /**\n   *Array that stores the Hamming Weights of the probability matrix used in\n   *Knuth-Yao sampling\n   */\n    std::vector&lt;uint32_t&gt; hammingWeights;\n    /**\n   *Size of probability matrix used in Knuth-Yao\n   */\n    int32_t b_matrixSize;\n\n    /**\n   *Index of first bit with non zero Hamming weight in the probability table\n   */\n    int32_t firstNonZero;\n\n    int32_t endIndex;\n\n    std::vector&lt;double&gt; m_vals;\n    /**\n   * @brief Sub-procedure called by Peikert&#x27;s inversion sampling\n   * @param S Vector containing the CDF values\n   * @param search Searched probability value\n   * @return Index that is the smallest bigger value than search\n   */\n    usint FindInVector(const std::vector&lt;double&gt;&amp; S, double search) const;\n    /**\n   * @brief Generates DDG tree used through the sampling in Knuth-Yao\n   * @param probMatrix The probability matrix used for filling the DDG tree\n   */\n    void GenerateDDGTree(const std::vector&lt;uint64_t&gt;&amp; probMatrix);\n    /**\n   * @brief Initializes the generator used for Peikert&#x27;s Inversion method.\n   * @param mean Mean of the distribution that the sampler will be using\n   *\n   */\n    void Initialize(double mean);\n\n    /**\n   * @brief Generates the probability matrix of given distribution, which is\n   * used in Knuth-Yao method\n   * @param sttdev standard deviation of Discrete Gaussian Distribution\n   * @param mean Center of the distribution\n   * @param tableCount Number of probability tables to be generated\n   */\n    void GenerateProbMatrix(double stddev, double mean);\n    /**\n   * @ brief Returns a generated integer. Uses Naive Knuth-Yao method\n   * @ return A random value within the Discrete Gaussian Distribution\n   */\n    int64_t GenerateIntegerKnuthYao();\n    /**\n   * @brief Returns a generated integer. Uses Peikert&#x27;s inversion method.\n   */\n    int64_t GenerateIntegerPeikert() const;\n};\n/*\n * @brief Class for combining samples from two base samplers, which is used for\n * UCSD generic sampling\n */\nclass SamplerCombiner final : public BaseSampler {\npublic:\n    /**\n   * @brief Constructor\n   * @param s1 Pointer to the first sampler to be combined\n   * @param s2 Pointer to the second sampler to be combined\n   * @param z1 Coefficient for the first sampler\n   * @param z2 Coefficient for the second sampler\n   */\n    SamplerCombiner(BaseSampler* s1, BaseSampler* s2, int64_t z1, int64_t z2)\n        : sampler1(s1), sampler2(s1), x1(z1), x2(z2) {}\n    /**\n   * @brief Return the combined value for two samplers with given coefficients\n   * @return Combined value of the samplers with given coefficents\n   */\n    int64_t GenerateInteger() override {\n        return x1 * sampler1-&gt;GenerateInteger() + x2 * sampler2-&gt;GenerateInteger();\n    }\n    /**\n   * @brief Destructor\n   */\n    ~SamplerCombiner() = default;\n\nprivate:\n    // Samplers to be combined\n    BaseSampler *sampler1, *sampler2;\n    // Coefficients that are used for combining\n    int64_t x1, x2;\n};\n\n/**\n * @brief The class for Generic Discrete Gaussion Distribution generator.\n */\nclass DiscreteGaussianGeneratorGeneric {\npublic:\n    /**\n   * @brief Basic constructor which does the precomputations.\n   * @param samplers Array containing the base samplers\n   * @param std Standard deviation of the base samplers\n   * @param base Log of number of centers that are used for calculating base\n   * samplers (Recall that base samplers are centered from 0 to (2^b-1)/2^b)\n   * @param N smoothing parameter\n   */\n    DiscreteGaussianGeneratorGeneric(BaseSampler** samplers, const double std, const int b, double N);\n\n    /**\n   * @ brief Returns a generated integer. Uses generic algorithm in UCSD paper,\n   * based on Sample Z\n   * @ param mean Mean of the distribution\n   * @ param variance Variance of the desired distribution\n   * @ return A random value within the Discrete Gaussian Distribution\n   */\n    int64_t GenerateInteger(double mean, double std);\n    int64_t GenerateInteger() {\n        return base_samplers[0]-&gt;GenerateInteger();\n    }\n    /**\n   * @brief Destructor\n   */\n    ~DiscreteGaussianGeneratorGeneric();\n\nprivate:\n    /**\n   * @brief Subroutine used by Sample C\n   * @param center Center of the distribution\n   */\n    int64_t flipAndRound(double center);\n    /**\n   * @brief Sample C defined in the paper\n   * @param center Center of the distribution\n   */\n    int64_t SampleC(int64_t center);\n\n    BaseSampler* wide_sampler;\n    BaseSampler** base_samplers;\n    BaseSampler* combiners[MAX_LEVELS];\n    long double wide_variance, sampler_variance;\n    double x, c, ci;\n    int k, log_base;\n    uint64_t mask;\n    /**\n   * @ brief Method to return the nth bit of a number\n   * @ param number The number that the bit of desired\n   * @ param n Desired bit number\n   * @ return The nth bit of the number starting from 0 being the LSB\n   */\n    short extractBit(int64_t number, int n) {  // NOLINT\n        return (number &gt;&gt; n) &amp; 1;\n    }\n};\n\n}  // namespace lbcrypto\n\n#endif  // LBCRYPTO_INC_MATH_DISCRETEGAUSSIANGENERATORGENERIC_H_\n"}}, "reports": [{"fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/intnat/mubintvecnat.cpp", "reportHash": "1fabb63174ea0878b49982549484405a", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 323, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'NativeVectorT::ModMul'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/vector.h", "line": 362, "column": 16}, {"message": "Entered call from 'operator*'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/intnat/mubintvecnat.cpp", "line": 321, "column": 1}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/intnat/mubintvecnat.cpp", "line": 322, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/intnat/mubintvecnat.cpp", "line": 323, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/intnat/mubintvecnat.cpp", "reportHash": "47d0aad4217ddee9dc68e783840d6226", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 341, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'NativeVectorT::ModMulEq'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/vector.h", "line": 365, "column": 16}, {"message": "Entered call from 'operator*='", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/intnat/mubintvecnat.cpp", "line": 339, "column": 1}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/intnat/mubintvecnat.cpp", "line": 340, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/intnat/mubintvecnat.cpp", "line": 341, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "reportHash": "4fe49240553edfa6f5d54f695abc41ca", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 273, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'mubintvec::ModMulEq'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "line": 282, "column": 9}, {"message": "Entered call from 'PolyImpl::operator*='", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "line": 348, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "line": 350, "column": 9}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "line": 353, "column": 24}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "line": 353, "column": 24}, {"message": "Looping back to the head of the loop", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "line": 353, "column": 5}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "line": 353, "column": 24}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "line": 353, "column": 24}, {"message": "Calling 'ubint::ModMulFastEq'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "line": 354, "column": 9}, {"message": "Entered call from 'mubintvec::ModMulEq'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/bigintdyn/ubintdyn.h", "line": 628, "column": 5}, {"message": "Calling 'ubint::ModMulFast'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/bigintdyn/ubintdyn.h", "line": 629, "column": 24}, {"message": "Entered call from 'ubint::ModMulFastEq'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 383, "column": 1}, {"message": "Assuming field 'm_MSB' is not equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 384, "column": 9}, {"message": "Assuming field 'm_MSB' is not equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 384, "column": 23}, {"message": "Assuming field 'm_MSB' is not equal to 1", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 386, "column": 9}, {"message": "Assuming field 'm_MSB' is not equal to 1", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 388, "column": 9}, {"message": "Assuming 'aSize' is >= 'bSize'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 395, "column": 9}, {"message": "Assuming 'i' is >= 'bSize'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 401, "column": 24}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 401, "column": 24}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 411, "column": 9}, {"message": "Calling 'ubint::Mod'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 412, "column": 16}, {"message": "Entered call from 'ubint::ModMulFast'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 271, "column": 1}, {"message": "Assuming field 'm_MSB' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 272, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 273, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "reportHash": "0254da645f8ab75ff420c13f869f288c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 387, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'm_value' is < 'b.m_value'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 386, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 387, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "reportHash": "5380f2b58c8cc0b03ddfddbb8a178d3d", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 427, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'p' is < field 'm_value'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 426, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 427, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "reportHash": "723efb9c1b673ca487b1266eb104bc69", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 484, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'RootOfUnity<intnat::NativeIntegerT<unsigned long>>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 456, "column": 28}, {"message": "Entered call from 'PackedEncoding::SetParams_2n'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "line": 183, "column": 1}, {"message": "Calling 'NativeIntegerT::DividedBy'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "line": 195, "column": 33}, {"message": "Entered call from 'RootOfUnity<intnat::NativeIntegerT<unsigned long>>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 482, "column": 5}, {"message": "Assuming field 'm_value' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 483, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 484, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "reportHash": "5d72e61bb6fbee802b7fdb2565d5d085", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 652, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'NativeIntegerT::ComputeMu'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "line": 402, "column": 13}, {"message": "Entered call from 'PolyMod<intnat::NativeVectorT<intnat::NativeIntegerT<unsigned long>>>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 650, "column": 5}, {"message": "Assuming field 'm_value' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 651, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 652, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "reportHash": "322097b496e5932b0647b1766da2a723", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1449, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming field 'm_value' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 1448, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 1449, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "reportHash": "215d3532ee5df6fdf0f987c842c6d871", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1568, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming field 'typeFlag' is equal to IsNativePoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 198, "column": 10}, {"message": "Calling 'NativeIntegerT::ModInverse'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 199, "column": 32}, {"message": "Entered call from 'PackedEncoding::Decode'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 1562, "column": 5}, {"message": "Assuming 'a' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 1565, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 1568, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/mubintvecnat.h", "reportHash": "75192edf6b10dd1ab55adde589125e0f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 312, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'forward' is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1193, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1200, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1209, "column": 18}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1233, "column": 18}, {"message": "Calling 'ChineseRemainderTransformArbNat::SetPreComputedNTTDivisionModulus'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1235, "column": 17}, {"message": "Entered call from 'ChineseRemainderTransformArbNat::Drop'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 979, "column": 1}, {"message": "Assuming 'i' is >= 'nttDimHf'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1009, "column": 23}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1009, "column": 23}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1015, "column": 23}, {"message": "Calling 'NativeVectorT::SetModulus'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1027, "column": 5}, {"message": "Entered call from 'ChineseRemainderTransformArbNat::SetPreComputedNTTDivisionModulus'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/mubintvecnat.h", "line": 310, "column": 5}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/mubintvecnat.h", "line": 311, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/mubintvecnat.h", "line": 312, "column": 13}], "macros": [{"message": "bool dbg_flag =false ;", "name": "OPENFHE_DEBUG_FLAG(false)", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 983, "column": 5}, {"message": "do {if (dbg_flag ){std ::cerr <<\"GetTotient(\"<<cyclotoOrder <<\")= \"<<n <<std ::endl ;}}while (0)", "name": "OPENFHE_DEBUG(\"GetTotient(\" << cyclotoOrder << \")= \" << n)", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 986, "column": 5}], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "reportHash": "4d9d69aa1b1440545ac3d8f74e113bd4", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 128, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'forward' is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1193, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1200, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1209, "column": 18}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1233, "column": 18}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1247, "column": 31}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1247, "column": 31}, {"message": "Calling 'NumberTheoreticTransformNat::ForwardTransformIterative'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1251, "column": 13}, {"message": "Entered call from 'ChineseRemainderTransformArbNat::Drop'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 124, "column": 1}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 127, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 128, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "reportHash": "0f0ceb1d66fc84ebeb4a66e878fda263", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 364, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming field 'typeFlag' is not equal to IsNativePoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 198, "column": 10}, {"message": "Assuming field 'typeFlag' is not equal to IsDCRTPoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 198, "column": 46}, {"message": "Calling 'PackedEncoding::Unpack'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 216, "column": 9}, {"message": "Entered call from 'PackedEncoding::Decode'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 391, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 400, "column": 9}, {"message": "Assuming 'i' is >= 'phim'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 410, "column": 23}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 410, "column": 23}, {"message": "Calling 'ChineseRemainderTransformFTTNat::ForwardTransformToBitReverse'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 419, "column": 9}, {"message": "Entered call from 'PackedEncoding::Unpack'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 603, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 616, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 623, "column": 66}, {"message": "Calling 'NumberTheoreticTransformNat::ForwardTransformToBitReverse'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 627, "column": 5}, {"message": "Entered call from 'ChineseRemainderTransformFTTNat::ForwardTransformToBitReverse'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 357, "column": 1}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 363, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 364, "column": 9}], "macros": [{"message": "bool dbg_flag =false ;", "name": "OPENFHE_DEBUG_FLAG(false)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 392, "column": 5}, {"message": "do {if (dbg_flag ){std ::cerr <<\"Unpack for order \"<<m <<\" phim \"<<phim <<\" modulus \"<<modulusNI <<std ::endl ;}}while (0)", "name": "OPENFHE_DEBUG(\"Unpack for order \" << m << \" phim \" << phim << \" modulus \" << modulusNI)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 406, "column": 5}, {"message": "do {if (dbg_flag ){std ::cerr <<packedVector <<std ::endl ;}}while (0)", "name": "OPENFHE_DEBUG(packedVector)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 414, "column": 5}], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "reportHash": "188a4fa6392932debe90f523ed308ee2", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 583, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 583, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "reportHash": "14f3ed3e6c9cff1d6c0dfd2d2a722d0f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 588, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 587, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 588, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "reportHash": "2077ea4662733879e80c8384bed1a0e2", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 617, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming field 'typeFlag' is not equal to IsNativePoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 198, "column": 10}, {"message": "Assuming field 'typeFlag' is not equal to IsDCRTPoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 198, "column": 46}, {"message": "Calling 'PackedEncoding::Unpack'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 216, "column": 9}, {"message": "Entered call from 'PackedEncoding::Decode'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 391, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 400, "column": 9}, {"message": "Assuming 'i' is >= 'phim'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 410, "column": 23}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 410, "column": 23}, {"message": "Calling 'ChineseRemainderTransformFTTNat::ForwardTransformToBitReverse'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 419, "column": 9}, {"message": "Entered call from 'PackedEncoding::Unpack'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 603, "column": 1}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 616, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 617, "column": 9}], "macros": [{"message": "bool dbg_flag =false ;", "name": "OPENFHE_DEBUG_FLAG(false)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 392, "column": 5}, {"message": "do {if (dbg_flag ){std ::cerr <<\"Unpack for order \"<<m <<\" phim \"<<phim <<\" modulus \"<<modulusNI <<std ::endl ;}}while (0)", "name": "OPENFHE_DEBUG(\"Unpack for order \" << m << \" phim \" << phim << \" modulus \" << modulusNI)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 406, "column": 5}, {"message": "do {if (dbg_flag ){std ::cerr <<packedVector <<std ::endl ;}}while (0)", "name": "OPENFHE_DEBUG(packedVector)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 414, "column": 5}], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "reportHash": "4b066c10e49e5b8a6a1075f3596ed46e", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 643, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 643, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "reportHash": "abd610504e0c3305f5277937617ede7c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 648, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 647, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 648, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "reportHash": "ffaa3a1818e41337e58d8da92e237d5c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 680, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming field 'isEncoded' is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 52, "column": 9}, {"message": "Assuming field 'typeFlag' is not equal to IsNativePoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 56, "column": 10}, {"message": "Assuming field 'typeFlag' is not equal to IsDCRTPoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 56, "column": 46}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 140, "column": 21}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 140, "column": 21}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 160, "column": 16}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 160, "column": 16}, {"message": "Calling 'PackedEncoding::Pack'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 169, "column": 9}, {"message": "Entered call from 'PackedEncoding::Encode'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 320, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 329, "column": 9}, {"message": "Assuming 'i' is >= 'phim'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 339, "column": 23}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 339, "column": 23}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 348, "column": 13}, {"message": "Calling 'ChineseRemainderTransformFTTNat::InverseTransformFromBitReverse'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 359, "column": 13}, {"message": "Entered call from 'PackedEncoding::Pack'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 666, "column": 1}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 679, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 680, "column": 9}], "macros": [{"message": "bool dbg_flag =false ;", "name": "OPENFHE_DEBUG_FLAG(false)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 321, "column": 5}, {"message": "do {if (dbg_flag ){std ::cerr <<\"Pack for order \"<<m <<\" phim \"<<phim <<\" modulus \"<<modulusNI <<std ::endl ;}}while (0)", "name": "OPENFHE_DEBUG(\"Pack for order \" << m << \" phim \" << phim << \" modulus \" << modulusNI)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 335, "column": 5}, {"message": "do {if (dbg_flag ){std ::cerr <<*ring <<std ::endl ;}}while (0)", "name": "OPENFHE_DEBUG(*ring)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 343, "column": 5}, {"message": "do {if (dbg_flag ){std ::cerr <<slotValues <<std ::endl ;}}while (0)", "name": "OPENFHE_DEBUG(slotValues)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 344, "column": 5}], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "reportHash": "28430fc6b07fb4b3d1781b1e10ae6773", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 769, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'numOfRootU' is not equal to 'numModulii'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 768, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 769, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "reportHash": "2148cd48835043559869db8a7cee7489", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 890, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming field 'typeFlag' is not equal to IsNativePoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 198, "column": 10}, {"message": "Assuming field 'typeFlag' is not equal to IsDCRTPoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 198, "column": 46}, {"message": "Calling 'PackedEncoding::Unpack'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 216, "column": 9}, {"message": "Entered call from 'PackedEncoding::Decode'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 391, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 400, "column": 9}, {"message": "Assuming 'i' is >= 'phim'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 410, "column": 23}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 410, "column": 23}, {"message": "Calling 'ChineseRemainderTransformArbNat::ForwardTransform'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 423, "column": 25}, {"message": "Entered call from 'PackedEncoding::Unpack'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1086, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1090, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1102, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1106, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1110, "column": 13}, {"message": "Calling 'BluesteinFFTNat::ForwardTransform'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1117, "column": 9}, {"message": "Entered call from 'ChineseRemainderTransformArbNat::ForwardTransform'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 887, "column": 1}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 889, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 890, "column": 9}], "macros": [{"message": "bool dbg_flag =false ;", "name": "OPENFHE_DEBUG_FLAG(false)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 392, "column": 5}, {"message": "do {if (dbg_flag ){std ::cerr <<\"Unpack for order \"<<m <<\" phim \"<<phim <<\" modulus \"<<modulusNI <<std ::endl ;}}while (0)", "name": "OPENFHE_DEBUG(\"Unpack for order \" << m << \" phim \" << phim << \" modulus \" << modulusNI)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 406, "column": 5}, {"message": "do {if (dbg_flag ){std ::cerr <<packedVector <<std ::endl ;}}while (0)", "name": "OPENFHE_DEBUG(packedVector)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 414, "column": 5}], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "reportHash": "e9799760091a1475904363da0dcdc25f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1091, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming field 'typeFlag' is not equal to IsNativePoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 198, "column": 10}, {"message": "Assuming field 'typeFlag' is not equal to IsDCRTPoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 198, "column": 46}, {"message": "Calling 'PackedEncoding::Unpack'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 216, "column": 9}, {"message": "Entered call from 'PackedEncoding::Decode'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 391, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 400, "column": 9}, {"message": "Assuming 'i' is >= 'phim'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 410, "column": 23}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 410, "column": 23}, {"message": "Calling 'ChineseRemainderTransformArbNat::ForwardTransform'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 423, "column": 25}, {"message": "Entered call from 'PackedEncoding::Unpack'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1086, "column": 1}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1090, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1091, "column": 9}], "macros": [{"message": "bool dbg_flag =false ;", "name": "OPENFHE_DEBUG_FLAG(false)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 392, "column": 5}, {"message": "do {if (dbg_flag ){std ::cerr <<\"Unpack for order \"<<m <<\" phim \"<<phim <<\" modulus \"<<modulusNI <<std ::endl ;}}while (0)", "name": "OPENFHE_DEBUG(\"Unpack for order \" << m << \" phim \" << phim << \" modulus \" << modulusNI)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 406, "column": 5}, {"message": "do {if (dbg_flag ){std ::cerr <<packedVector <<std ::endl ;}}while (0)", "name": "OPENFHE_DEBUG(packedVector)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 414, "column": 5}], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "reportHash": "8882e9a09a6cf7faa01ac54c71c677a4", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1129, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming field 'isEncoded' is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 52, "column": 9}, {"message": "Assuming field 'typeFlag' is not equal to IsNativePoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 56, "column": 10}, {"message": "Assuming field 'typeFlag' is not equal to IsDCRTPoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 56, "column": 46}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 140, "column": 21}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 140, "column": 21}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 160, "column": 16}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 160, "column": 16}, {"message": "Calling 'PackedEncoding::Pack'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 169, "column": 9}, {"message": "Entered call from 'PackedEncoding::Encode'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 320, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 329, "column": 9}, {"message": "Assuming 'i' is >= 'phim'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 339, "column": 23}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 339, "column": 23}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 366, "column": 27}, {"message": "Calling 'ChineseRemainderTransformArbNat::InverseTransform'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 375, "column": 22}, {"message": "Entered call from 'PackedEncoding::Pack'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1124, "column": 1}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1128, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 1129, "column": 9}], "macros": [{"message": "bool dbg_flag =false ;", "name": "OPENFHE_DEBUG_FLAG(false)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 321, "column": 5}, {"message": "do {if (dbg_flag ){std ::cerr <<\"Pack for order \"<<m <<\" phim \"<<phim <<\" modulus \"<<modulusNI <<std ::endl ;}}while (0)", "name": "OPENFHE_DEBUG(\"Pack for order \" << m << \" phim \" << phim << \" modulus \" << modulusNI)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 335, "column": 5}, {"message": "do {if (dbg_flag ){std ::cerr <<*ring <<std ::endl ;}}while (0)", "name": "OPENFHE_DEBUG(*ring)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 343, "column": 5}, {"message": "do {if (dbg_flag ){std ::cerr <<slotValues <<std ::endl ;}}while (0)", "name": "OPENFHE_DEBUG(slotValues)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 344, "column": 5}, {"message": "do {if (dbg_flag ){std ::cerr <<\"permutedSlots \"<<permutedSlots <<std ::endl ;}}while (0)", "name": "OPENFHE_DEBUG(\"permutedSlots \" << permutedSlots)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 370, "column": 9}, {"message": "do {if (dbg_flag ){std ::cerr <<\"m_initRoot[modulusM] \"<<m_initRoot [modulusM ]<<std ::endl ;}}while (0)", "name": "OPENFHE_DEBUG(\"m_initRoot[modulusM] \" << m_initRoot[modulusM])", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 371, "column": 9}, {"message": "do {if (dbg_flag ){std ::cerr <<\"m_bigModulus[modulusM] \"<<m_bigModulus [modulusM ]<<std ::endl ;}}while (0)", "name": "OPENFHE_DEBUG(\"m_bigModulus[modulusM] \" << m_bigModulus[modulusM])", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 372, "column": 9}, {"message": "do {if (dbg_flag ){std ::cerr <<\"m_bigRoot[modulusM] \"<<m_bigRoot [modulusM ]<<std ::endl ;}}while (0)", "name": "OPENFHE_DEBUG(\"m_bigRoot[modulusM] \" << m_bigRoot[modulusM])", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 373, "column": 9}], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "reportHash": "eb17d1cd839bbaf2a30f5c40524269dc", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 148, "column": 7, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'BitGenerator::Generate'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/discretegaussiangeneratorgeneric.h", "line": 181, "column": 16}, {"message": "Entered call from 'BaseSampler::RandomBit'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/discretegaussiangeneratorgeneric.h", "line": 136, "column": 5}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/discretegaussiangeneratorgeneric.h", "line": 137, "column": 13}, {"message": "Calling 'Blake2Engine::operator()'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/discretegaussiangeneratorgeneric.h", "line": 138, "column": 24}, {"message": "Entered call from 'BitGenerator::Generate'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "line": 107, "column": 3}, {"message": "Assuming 'PRNG_BUFFER_SIZE' is not equal to field 'm_bufferIndex'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "line": 110, "column": 9}, {"message": "Assuming field 'm_bufferIndex' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "line": 115, "column": 9}, {"message": "Calling 'Blake2Engine::Generate'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "line": 115, "column": 29}, {"message": "Entered call from 'Blake2Engine::operator()'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "line": 142, "column": 3}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "line": 145, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "line": 148, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "reportHash": "efda2b59acbf740358d06a3f87856d78", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 191, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 449, "column": 9}, {"message": "Calling 'RootOfUnity<intnat::NativeIntegerT<unsigned long>>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 456, "column": 28}, {"message": "Entered call from 'PackedEncoding::SetParams_2n'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "line": 183, "column": 1}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "line": 191, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "reportHash": "3991ac136730caf05321ac85dab543b9", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 337, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'BluesteinFFTNat::PreComputeDefaultNTTModulusRoot'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 967, "column": 5}, {"message": "Entered call from 'ChineseRemainderTransformArbNat::PreCompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 790, "column": 1}, {"message": "Calling 'FirstPrime<intnat::NativeIntegerT<unsigned long>>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/transformnat-impl.h", "line": 792, "column": 29}, {"message": "Entered call from 'BluesteinFFTNat::PreComputeDefaultNTTModulusRoot'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "line": 334, "column": 1}, {"message": "Assuming 'nBits' is > MAX_MODULUS_SIZE", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "line": 336, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "line": 337, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "reportHash": "9eff09e030fef55167fac33481dd49c6", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 68, "column": 17, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming field 'isEncoded' is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 52, "column": 9}, {"message": "Assuming field 'typeFlag' is not equal to IsNativePoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 56, "column": 10}, {"message": "Assuming field 'typeFlag' is equal to IsDCRTPoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 56, "column": 46}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 68, "column": 17}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "reportHash": "20a2c877113a0c3f93cf4f56fa847742", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 85, "column": 17, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming field 'isEncoded' is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 52, "column": 9}, {"message": "Assuming field 'typeFlag' is equal to IsNativePoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 56, "column": 10}, {"message": "Assuming 'j' is >= field 'noiseScaleDeg'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 77, "column": 28}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 77, "column": 28}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 81, "column": 21}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 81, "column": 21}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 84, "column": 17}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 85, "column": 17}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "reportHash": "20a2c877113a0c3f93cf4f56fa847742", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 144, "column": 17, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming field 'isEncoded' is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 52, "column": 9}, {"message": "Assuming field 'typeFlag' is not equal to IsNativePoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 56, "column": 10}, {"message": "Assuming field 'typeFlag' is not equal to IsDCRTPoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 56, "column": 46}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 140, "column": 21}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 140, "column": 21}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 143, "column": 17}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 144, "column": 17}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "reportHash": "ec458caa76f1573dfbbfb6f0b0099c25", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 450, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 449, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 450, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "reportHash": "0d3efdeff9e7e1daed573ebe450c29ce", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 487, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming field 'typeFlag' is not equal to IsNativePoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 198, "column": 10}, {"message": "Assuming field 'typeFlag' is not equal to IsDCRTPoly", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 198, "column": 46}, {"message": "Calling 'PackedEncoding::Unpack'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 216, "column": 9}, {"message": "Entered call from 'PackedEncoding::Decode'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 391, "column": 1}, {"message": "Calling 'PackedEncoding::SetParams'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 401, "column": 9}, {"message": "Entered call from 'PackedEncoding::Unpack'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 233, "column": 1}, {"message": "Calling 'PackedEncoding::SetParams_2n'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 242, "column": 15}, {"message": "Entered call from 'PackedEncoding::SetParams'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 483, "column": 1}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 486, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 487, "column": 9}], "macros": [{"message": "bool dbg_flag =false ;", "name": "OPENFHE_DEBUG_FLAG(false)", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/encoding/packedencoding.cpp", "line": 392, "column": 5}], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>

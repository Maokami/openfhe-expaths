<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijn@haverbeke.berlin> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report.events;
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report.events;
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setChecker(report.checker);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.fileId]);
    this.drawBugPath();

    this.jumpTo(event.line, 0);
    this.highlightBugEvent(idx);
  },

  highlightBugEvent : function (idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setChecker : function (checker) {
    var content = checker.name;
    if (checker.url) {
      content = '<a href="' + checker.url + '" target="_blank">' +
        checker.name + '</a>';
    }

    this._checkerName.innerHTML = content;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.filePath;
    let e = document.createElement('div');
    e.innerHTML = file.content;
    this._codeMirror.doc.setValue(e.innerText);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.fileId !== that._currentBugEvent.fileId) {
        return;
      }

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.fileId !== that._currentBugEvent.fileId)
        return;

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp": {"id": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  This file contains the main class for unsigned big integers: ubint. Big integers are represented as arrays of\n  machine native unsigned integers. The native integer type is supplied as a template parameter.\n  Currently implementation based on uint32_t and uint64_t is supported. a native double the base integer size is also needed.\n */\n\n#include &quot;config_core.h&quot;\n#ifdef WITH_BE4\n\n    #include &quot;math/math-hal.h&quot;\n\n    #include &quot;utils/exception.h&quot;\n    #include &quot;utils/inttypes.h&quot;\n    #include &quot;utils/serializable.h&quot;\n\n    #include &lt;iostream&gt;\n    #include &lt;string&gt;\n    #include &lt;vector&gt;\n\nnamespace bigintdyn {\n\n// Sum and Carry algorithm with radix 2^m_bitLength.\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::Add(const ubint&amp; b) const {\n    const ubint* A = this;\n    auto sizeA     = m_value.size();\n    const ubint* B = &amp;b;\n    auto sizeB     = b.m_value.size();\n    if (sizeA &lt; sizeB) {\n        std::swap(A, B);\n        std::swap(sizeA, sizeB);\n    }\n\n    if (B-&gt;m_MSB == 0)\n        return *A;\n\n    std::vector&lt;limb_t&gt; r(sizeA + 1);\n    Dlimb_t c{0};\n    for (size_t i = 0; i &lt; sizeA; ++i, c &gt;&gt;= m_limbBitLength) {\n        auto av = static_cast&lt;Dlimb_t&gt;(A-&gt;m_value[i]);\n        auto bv = static_cast&lt;Dlimb_t&gt;(i &lt; sizeB ? B-&gt;m_value[i] : 0);\n        r[i]    = static_cast&lt;limb_t&gt;(c += av + bv);\n    }\n    r[sizeA] = static_cast&lt;limb_t&gt;(c);\n    return ubint(std::move(r));\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::AddEq(const ubint&amp; b) {\n    const ubint* A = this;\n    auto sizeA     = m_value.size();\n    const ubint* B = &amp;b;\n    auto sizeB     = B-&gt;m_value.size();\n    if (sizeA &lt; sizeB) {\n        std::swap(A, B);\n        std::swap(sizeA, sizeB);\n    }\n\n    if (B-&gt;m_MSB == 0)\n        return *this = *A;\n\n    std::vector&lt;limb_t&gt; r(sizeA + 1);\n    Dlimb_t c{0};\n    for (size_t i = 0; i &lt; sizeA; ++i, c &gt;&gt;= m_limbBitLength) {\n        auto av = static_cast&lt;Dlimb_t&gt;(A-&gt;m_value[i]);\n        auto bv = static_cast&lt;Dlimb_t&gt;(i &lt; sizeB ? B-&gt;m_value[i] : 0);\n        r[i]    = static_cast&lt;limb_t&gt;(c += av + bv);\n    }\n    r[sizeA] = static_cast&lt;limb_t&gt;(c);\n    m_value  = std::move(r);\n    ubint&lt;limb_t&gt;::NormalizeLimbs();\n    return *this;\n}\n\n// TODO: convert to vector constructor method\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::Sub(const ubint&amp; b) const {\n    // return 0 if b is higher than *this as there is no support for negative numbers\n    if (*this &lt;= b)\n        return ubint();\n    ubint result(*this);\n    for (size_t i = 0; i &lt; b.m_value.size(); ++i) {\n        if (result.m_value[i] &lt; b.m_value[i]) {  // carryover condition need to\n                                                 // borrow from higher limbs.\n            size_t cntr{i};\n            result.m_value[cntr] += (m_MaxLimb - b.m_value[cntr]) + 1;\n            // set all the zero limbs to all FFs (propagate the 1)\n            while (0 == result.m_value[++cntr])\n                result.m_value[cntr] = m_MaxLimb;\n            // and eventually borrow 1 from the first nonzero limb we find\n            result.m_value[cntr]--;\n        }\n        else {  // usual subtraction condition\n            result.m_value[i] -= b.m_value[i];\n        }\n    }\n    result.NormalizeLimbs();\n    return result;\n}\n\n// TODO: convert to vector constructor method\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::SubEq(const ubint&amp; b) {\n    if (*this &lt;= b) {\n        m_MSB      = 0;\n        m_value[0] = 0;\n        m_value.resize(1);\n        return *this;\n    }\n    for (size_t i = 0; i &lt; b.m_value.size(); ++i) {\n        if (m_value[i] &lt; b.m_value[i]) {\n            size_t cntr{i};\n            m_value[cntr] += (m_MaxLimb - b.m_value[cntr]) + 1;\n            while (0 == m_value[++cntr])\n                m_value[cntr] = m_MaxLimb;\n            m_value[cntr]--;\n        }\n        else {\n            m_value[i] -= b.m_value[i];\n        }\n    }\n    ubint&lt;limb_t&gt;::NormalizeLimbs();\n    return *this;\n}\n\n// Multiply operation: usual school book shift and add after multiplication\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::Mul(const ubint&amp; b) const {\n    if (m_MSB == 0 || b.m_MSB == 0)\n        return ubint();\n    if (b.m_MSB == 1)\n        return *this;\n    if (m_MSB == 1)\n        return b;\n\n    const ubint* A = this;\n    auto aSize     = m_value.size();\n    const ubint* B = &amp;b;\n    auto bSize     = b.m_value.size();\n    if (aSize &lt; bSize) {\n        std::swap(A, B);\n        std::swap(aSize, bSize);\n    }\n\n    ubint ans;\n    for (size_t i = 0; i &lt; bSize; ++i) {\n        std::vector&lt;limb_t&gt; c(i + aSize + 1);\n        Dlimb_t limbb = static_cast&lt;Dlimb_t&gt;(B-&gt;m_value[i]);\n        Dlimb_t ofl{0};\n        for (size_t j = 0; j &lt; aSize; ++j, ofl &gt;&gt;= m_limbBitLength)\n            c[i + j] = static_cast&lt;limb_t&gt;(ofl += limbb * A-&gt;m_value[j]);\n        c[i + aSize] = static_cast&lt;limb_t&gt;(ofl);\n\n        ans = std::move(ans.Add(ubint(std::move(c))));\n    }\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::DividedBy(const ubint&amp; b) const {\n    if (b.m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Divisor is zero&quot;);\n    if (b.m_MSB &gt; m_MSB)\n        return ubint();\n    if ((b.m_MSB == m_MSB) &amp;&amp; (b.m_value.back() == m_value.back()))\n        return ubint(1);\n    ubint ans;\n    divq_vect(ans, *this, b);\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::DividedByEq(const ubint&amp; b) {\n    if (b.m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Divisor is zero&quot;);\n    if (b.m_MSB &gt; m_MSB) {\n        m_MSB = 0;\n        m_value.resize(1);\n        m_value[0] = 0;\n        return *this;\n    }\n    if ((b.m_MSB == m_MSB) &amp;&amp; (b.m_value.back() == m_value.back())) {\n        m_MSB = 1;\n        m_value.resize(1);\n        m_value[0] = 1;\n        return *this;\n    }\n    ubint ans;\n    divq_vect(ans, *this, b);\n    return *this = std::move(ans);\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::Exp(usint p) const {\n    if (p == 0)\n        return ubint(1);\n    if (p == 1)\n        return *this;\n    ubint tmp{ubint&lt;limb_t&gt;::Exp(p &gt;&gt; 1)};\n    tmp = tmp.Mul(tmp);\n    if (p &amp; 0x1)\n        return tmp.Mul(*this);\n    return tmp;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::MultiplyAndRound(const ubint&amp; p, const ubint&amp; q) const {\n    if (q.m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;MultiplyAndRound() Divisor is zero&quot;);\n    auto t{ubint&lt;limb_t&gt;::Mul(p)};\n    ubint halfQ(q &gt;&gt; 1);\n    if (t &lt;= halfQ)\n        return ubint();\n    if ((t.m_MSB == halfQ.m_MSB) || ((t.m_MSB == q.m_MSB) &amp;&amp; (t.m_value.back() &lt; q.m_value.back())))\n        return ubint(1);\n    ubint ans, rv;\n    divqr_vect(ans, rv, t, q);\n    if (rv &gt; halfQ)\n        return ans.Add(ubint(1));\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::DivideAndRound(const ubint&amp; q) const {\n    if (q.m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;DivideAndRound() Divisor is zero&quot;);\n    ubint halfQ(q &gt;&gt; 1);\n    if (*this &lt;= halfQ)\n        return ubint();\n    if ((m_MSB == halfQ.m_MSB) || ((m_MSB == q.m_MSB) &amp;&amp; (m_value.back() &lt; q.m_value.back())))\n        return ubint(1);\n    ubint ans, rv;\n    divqr_vect(ans, rv, *this, q);\n    if (rv &gt; halfQ)\n        return ans.Add(ubint(1));\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::Mod(const ubint&amp; modulus) const {\n    if (modulus.m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Mod() using zero modulus&quot;);\n    if (*this &lt; modulus)\n        return *this;\n    if (modulus.m_MSB == 2 &amp;&amp; modulus.m_value[0] == 2)\n        return ubint(m_value[0] &amp; 0x1);\n    ubint ans;\n    divr_vect(ans, *this, modulus);\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::ModEq(const ubint&amp; modulus) {\n    if (modulus.m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Mod() using zero modulus&quot;);\n    if (*this &lt; modulus)\n        return *this;\n    if (modulus.m_MSB == 2 &amp;&amp; modulus.m_value[0] == 2) {\n        m_value.resize(1);\n        m_value[0] &amp;= 0x1;\n        m_MSB = m_value[0];\n        return *this;\n    }\n    ubint ans;\n    divr_vect(ans, *this, modulus);\n    return *this = std::move(ans);\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModAdd(const ubint&amp; b, const ubint&amp; modulus) const {\n    ubint bv(b);\n    if (bv &gt;= modulus)\n        bv.ModEq(modulus);\n    ubint av(*this);\n    if (av &gt;= modulus)\n        av.ModEq(modulus);\n    av = av.Add(bv);\n    if (av &gt;= modulus)\n        return av.Sub(modulus);\n    return av;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::ModAddEq(const ubint&amp; b, const ubint&amp; modulus) {\n    ubint bv(b);\n    if (bv &gt;= modulus)\n        bv.ModEq(modulus);\n    if (*this &gt;= modulus)\n        ubint&lt;limb_t&gt;::ModEq(modulus);\n    *this = bv.Add(*this);\n    if (*this &gt;= modulus)\n        return ubint&lt;limb_t&gt;::SubEq(modulus);\n    return *this;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModAddFast(const ubint&amp; b, const ubint&amp; modulus) const {\n    ubint ans(b.Add(*this));\n    if (ans &gt;= modulus)\n        return ans.Sub(modulus);\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::ModAddFastEq(const ubint&amp; b, const ubint&amp; modulus) {\n    *this = b.Add(*this);\n    if (*this &gt;= modulus)\n        return ubint&lt;limb_t&gt;::SubEq(modulus);\n    return *this;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModSub(const ubint&amp; b, const ubint&amp; modulus) const {\n    auto av(*this);\n    auto bv(b);\n    if (bv &gt;= modulus)\n        bv.ModEq(modulus);\n    if (av &gt;= modulus)\n        av.ModEq(modulus);\n    if (av &lt; bv)\n        av = modulus.Add(av);\n    return av.Sub(bv);\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::ModSubEq(const ubint&amp; b, const ubint&amp; modulus) {\n    auto bv(b);\n    if (bv &gt;= modulus)\n        bv.ModEq(modulus);\n    if (*this &gt;= modulus)\n        ubint&lt;limb_t&gt;::ModEq(modulus);\n    if (*this &lt; bv)\n        *this = modulus.Add(*this);\n    return ubint&lt;limb_t&gt;::SubEq(bv);\n}\n\ntemplate &lt;typename limb_t&gt;\ninline ubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModSubFast(const ubint&amp; b, const ubint&amp; modulus) const {\n    if (*this &lt; b)\n        return modulus.Add(*this).Sub(b);\n    return ubint&lt;limb_t&gt;::Sub(b);\n}\n\ntemplate &lt;typename limb_t&gt;\ninline ubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::ModSubFastEq(const ubint&amp; b, const ubint&amp; modulus) {\n    if (*this &lt; b)\n        return *this = std::move(modulus.Add(*this).Sub(b));\n    return ubint&lt;limb_t&gt;::SubEq(b);\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModMulFast(const ubint&amp; b, const ubint&amp; modulus) const {\n    if (m_MSB == 0 || b.m_MSB == 0)\n        return ubint();\n    if (b.m_MSB == 1)\n        return *this;\n    if (m_MSB == 1)\n        return b;\n\n    const ubint* A = this;\n    auto aSize     = m_value.size();\n    const ubint* B = &amp;b;\n    auto bSize     = b.m_value.size();\n    if (aSize &lt; bSize) {\n        std::swap(A, B);\n        std::swap(aSize, bSize);\n    }\n\n    ubint ans;\n    for (size_t i = 0; i &lt; bSize; ++i) {\n        std::vector&lt;limb_t&gt; c(i + aSize + 1);\n        Dlimb_t limbb = static_cast&lt;Dlimb_t&gt;(B-&gt;m_value[i]);\n        Dlimb_t ofl{0};\n        for (size_t j = 0; j &lt; aSize; ++j, ofl &gt;&gt;= m_limbBitLength)\n            c[i + j] = static_cast&lt;limb_t&gt;(ofl += limbb * A-&gt;m_value[j]);\n        c[i + aSize] = static_cast&lt;limb_t&gt;(ofl);\n\n        ans = std::move(ans.Add(ubint(std::move(c))));\n    }\n    if (ans &gt;= modulus)\n        return ans.Mod(modulus);\n    return ans;\n}\n\n// Extended Euclid algorithm used to find the multiplicative inverse\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModInverse(const ubint&amp; modulus) const {\n    if (m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Zero has no inverse&quot;);\n\n    ubint second(*this);\n    if (second &gt;= modulus)\n        second = second.Mod(modulus);\n    if (second.m_MSB == 1)\n        return second;\n\n    // NORTH ALGORITHM\n    ubint first(modulus);\n    std::vector&lt;ubint&gt; quotient;\n    quotient.reserve(8);  // TODO\n\n    ubint q, mod_back;\n    divqr_vect(q, mod_back, first, second);\n    quotient.emplace_back(std::move(q));\n\n    if (mod_back.m_MSB == 0) {\n        std::string msg = ubint&lt;limb_t&gt;::ToString() + &quot; does not have a ModInverse using &quot; + modulus.ToString();\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, msg);\n    }\n\n    // max number of iterations should be &lt; 2^k where k == min(bitsize(inputs))\n    // TODO: consider breaking out of the loop if this limit exceeded.\n    //       loop counter would need to be a ubint.\n    while (mod_back.m_MSB != 1) {\n        first  = second;\n        second = mod_back;\n\n        ubint q;\n        divqr_vect(q, mod_back, first, second);\n        quotient.emplace_back(std::move(q));\n    }\n\n    // SOUTH ALGORITHM\n    first  = ubint();\n    second = ubint(1);\n    for (auto it = quotient.rbegin(); it != quotient.rend(); ++it) {\n        mod_back = *it * second + first;\n        first    = second;\n        second   = mod_back;\n    }\n    if (quotient.size() &amp; 0x1)\n        return modulus - mod_back;\n    return mod_back;\n}\n\n// Modular Exponentiation using Square and Multiply Algorithm\n// reference:http://guan.cse.nsysu.edu.tw/note/expn.pdf\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModExp(const ubint&amp; b, const ubint&amp; modulus) const {\n    ubint t(this-&gt;Mod(modulus));\n    ubint p(b);\n    ubint r(1);\n    if (p.m_value[0] &amp; 0x1)\n        r = r.ModMulFast(t, modulus);\n    while ((p &gt;&gt;= 1).m_MSB) {\n        t = t.ModMulFast(t, modulus);\n        if (p.m_value[0] &amp; 0x1)\n            r = r.ModMulFast(t, modulus);\n    }\n    return r;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::LShift(usshort shift) const {\n    static constexpr usshort mask{m_limbBitLength - 1};\n    if (m_MSB == 0)\n        return ubint();\n    auto ans(*this);\n    ans.m_MSB += shift;\n    size_t shiftByLimb{static_cast&lt;size_t&gt;(shift) &gt;&gt; m_log2LimbBitLength};\n    shift &amp;= mask;\n    if (shift) {\n        Dlimb_t ofl{0};\n        for (auto&amp; v : ans.m_value) {\n            ofl |= static_cast&lt;Dlimb_t&gt;(v) &lt;&lt; shift;\n            v = static_cast&lt;limb_t&gt;(ofl);\n            ofl &gt;&gt;= m_limbBitLength;\n        }\n        if (ofl)\n            ans.m_value.push_back(static_cast&lt;limb_t&gt;(ofl));\n    }\n    if (shiftByLimb) {\n        size_t j = ans.m_value.size();\n        size_t i = j + shiftByLimb;\n        ans.m_value.resize(i);\n        while (i &gt; 0)\n            ans.m_value[--i] = (j &gt; 0) ? ans.m_value[--j] : 0;\n    }\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::LShiftEq(usshort shift) {\n    static constexpr usshort mask{m_limbBitLength - 1};\n    if (m_MSB == 0)\n        return *this;\n    m_MSB += shift;\n    size_t shiftByLimb{static_cast&lt;size_t&gt;(shift) &gt;&gt; m_log2LimbBitLength};\n    shift &amp;= mask;\n    if (shift) {\n        Dlimb_t ofl{0};\n        for (auto&amp; v : m_value) {\n            ofl |= static_cast&lt;Dlimb_t&gt;(v) &lt;&lt; shift;\n            v = static_cast&lt;limb_t&gt;(ofl);\n            ofl &gt;&gt;= m_limbBitLength;\n        }\n        if (ofl)\n            m_value.push_back(static_cast&lt;limb_t&gt;(ofl));\n    }\n    if (shiftByLimb) {\n        size_t j = m_value.size();\n        size_t i = j + shiftByLimb;\n        m_value.resize(i);\n        while (i &gt; 0)\n            m_value[--i] = (j &gt; 0) ? m_value[--j] : 0;\n    }\n    return *this;\n}\n\n/**Right Shift is done by splitting the number of shifts into\n *1. Multiple of the bit length of limb data type.\n *  Shifting is done by the shifting the limb type numbers in the array to\n *the right.\n *2. Shifts between 1 to bit length of limb data type.\n *   Shifting is done by using bit shift operations and carry over propagation.\n */\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::RShift(usshort shift) const {\n    static constexpr usshort mask{m_limbBitLength - 1};\n    if (m_MSB &lt;= shift)\n        return ubint(0);\n    ubint ans(*this);\n    ans.m_MSB -= shift;\n    size_t shiftByLimb{static_cast&lt;size_t&gt;(shift) &gt;&gt; m_log2LimbBitLength};\n    shift &amp;= mask;\n    Dlimb_t tmp{ans.m_value[shiftByLimb++] &gt;&gt; shift};\n    usint lshift{m_limbBitLength - shift};\n    size_t size{ans.m_value.size() - shiftByLimb};\n    for (size_t i = 0; i &lt; size; ++i, tmp &gt;&gt;= m_limbBitLength) {\n        tmp |= static_cast&lt;Dlimb_t&gt;(ans.m_value[i + shiftByLimb]) &lt;&lt; lshift;\n        ans.m_value[i] = static_cast&lt;limb_t&gt;(tmp);\n    }\n    ans.m_value.resize(size);\n    if (tmp)\n        ans.m_value.push_back(static_cast&lt;limb_t&gt;(tmp));\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::RShiftEq(usshort shift) {\n    static constexpr usshort mask{m_limbBitLength - 1};\n    if (m_MSB &lt;= shift) {\n        m_MSB = 0;\n        m_value.resize(1);\n        m_value[0] = 0;\n        return *this;\n    }\n    m_MSB -= shift;\n    size_t shiftByLimb{static_cast&lt;size_t&gt;(shift) &gt;&gt; m_log2LimbBitLength};\n    shift &amp;= mask;\n    Dlimb_t tmp{m_value[shiftByLimb++] &gt;&gt; shift};\n    usint lshift{m_limbBitLength - shift};\n    size_t size{m_value.size() - shiftByLimb};\n    for (size_t i = 0; i &lt; size; ++i, tmp &gt;&gt;= m_limbBitLength) {\n        tmp |= static_cast&lt;Dlimb_t&gt;(m_value[i + shiftByLimb]) &lt;&lt; lshift;\n        m_value[i] = static_cast&lt;limb_t&gt;(tmp);\n    }\n    m_value.resize(size);\n    if (tmp)\n        m_value.push_back(static_cast&lt;limb_t&gt;(tmp));\n    return *this;\n}\n\n// Converts the ubint to float using the std library functions.\ntemplate &lt;typename limb_t&gt;\nfloat ubint&lt;limb_t&gt;::ConvertToFloat() const {\n    float ans{-1.0f};\n    try {\n        ans = std::stof(ubint&lt;limb_t&gt;::ToString());\n    }\n    catch (const std::exception&amp; e) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::type_error, &quot;ConvertToFloat() parse error converting to float&quot;);\n    }\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\ndouble ubint&lt;limb_t&gt;::ConvertToDouble() const {\n    double ans{-1.0};\n    try {\n        // ans = std::stod(this-&gt;ToString());\n        usint ceilInt = MSBToLimbs(m_MSB);\n        double factor = pow(2, m_limbBitLength);\n        double power  = 1.0;\n\n        ans = 0.0;\n        for (usint i = 0; i &lt; ceilInt; ++i, power *= factor)\n            ans += power * m_value[i];\n    }\n    catch (const std::exception&amp; e) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::type_error, &quot;ConvertToDouble() parse error converting to double&quot;);\n    }\n    return ans;\n}\n\n// Converts the ubint to long double using the std library functions.\ntemplate &lt;typename limb_t&gt;\nlong double ubint&lt;limb_t&gt;::ConvertToLongDouble() const {\n    long double ans{-1.0};\n    try {\n        ans = std::stold(ubint&lt;limb_t&gt;::ToString());\n    }\n    catch (const std::exception&amp; e) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::type_error, &quot;ConvertToLongDouble() parse error converting to long double&quot;);\n    }\n    return ans;\n}\n\n// TODO\n// Splits binary string to equi sized chunks then populates internal array values\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::FromBinaryString(const std::string&amp; vin) {\n    std::string v = vin;\n    // v.erase(0, v.find_first_not_of(&#x27; &#x27;));\n    v.erase(0, v.find_first_not_of(&#x27;0&#x27;));\n    if (v.size() == 0)\n        return ubint();\n    ubint value;\n    value.m_value.clear();\n    usint len  = v.length();\n    usint cntr = MSBToLimbs(len);\n    std::string val;\n    Dlimb_t partial_value = 0;\n    for (usint i = 0; i &lt; cntr; i++) {\n        if (len &gt; ((i + 1) * m_limbBitLength)) {\n            val = v.substr((len - (i + 1) * m_limbBitLength), m_limbBitLength);\n        }\n        else {\n            val = v.substr(0, len % m_limbBitLength);\n        }\n        for (usint j = 0; j &lt; val.length(); j++) {\n            partial_value += std::stoi(val.substr(j, 1));\n            partial_value &lt;&lt;= 1;\n        }\n        partial_value &gt;&gt;= 1;\n        value.m_value.push_back((limb_t)partial_value);\n        partial_value = 0;\n    }\n    value.SetMSB();\n    return value;\n}\n\n// TODO: * i to &lt;&lt; i\ntemplate &lt;typename limb_t&gt;\nusint ubint&lt;limb_t&gt;::GetDigitAtIndexForBase(usint index, usint base) const {\n    usint DigitLen = ceil(log2(base));\n    usint digit    = 0;\n    usint newIndex = 1 + (index - 1) * DigitLen;\n    for (usint i = 1; i &lt; base; i &lt;&lt;= 1) {\n        digit += GetBitAtIndex(newIndex++) * i;\n    }\n    return digit;\n}\n\ntemplate &lt;typename limb_t&gt;\nconst std::string ubint&lt;limb_t&gt;::ToString() const {\n    std::vector&lt;uschar&gt; val{0};\n    val.reserve(m_MSB &gt;&gt; 1);\n    for (usint i = m_MSB; i &gt; 0; --i) {\n        auto ofl = GetBitAtIndex(i);  // TODO: needlessly expensive here\n        for (auto&amp; a : val) {\n            a = (a &lt;&lt; 1) + ofl;\n            if ((ofl = (a &gt; 9)))\n                a -= 10;\n        }\n        if (ofl)\n            val.push_back(1);\n    }\n    for (auto&amp; a : val)\n        a += &#x27;0&#x27;;\n    return std::string(val.rbegin(), val.rend());\n}\n\n/* q[0], r[0], u[0], and v[0] contain the LEAST significant words.\n (The sequence is in little-endian order).\n\n This is a fairly precise implementation of Knuth&#x27;s Algorithm D, for a\n binary computer with base b = 2**(32|64). The caller supplies:\n 1. Space q for the quotient, m - n + 1 words (at least one).\n 2. Space r for the remainder (optional), n words.\n 3. The dividend u, m words, m &gt;= 1.\n 4. The divisor v, n words, n &gt;= 2.\n The most significant digit of the divisor, v[n-1], must be nonzero.  The\n dividend u may have leading zeros; this just makes the algorithm take\n longer and makes the quotient contain more leading zeros.  A value of\n nullptr may be given for the address of the remainder to signify that the\n caller does not want the remainder.\n The program does not alter the input parameters u and v.\n The quotient and remainder returned may have leading zeros.  The\n function itself returns a value of 0 for success and 1 for invalid\n parameters (e.g., division by 0).\n For now, we must have m &gt;= n.  Knuth&#x27;s Algorithm D also requires\n that the dividend be at least as long as the divisor.  (In his terms,\n m &gt;= 0 (unstated).  Therefore m+n &gt;= n.) */\n\ntemplate &lt;typename limb_t&gt;\nvoid ubint&lt;limb_t&gt;::divqr_vect(ubint&amp; qin, ubint&amp; rin, const ubint&amp; uin, const ubint&amp; vin) const noexcept {\n    auto&amp; u = uin.m_value;\n    int m   = u.size();\n    auto&amp; v = vin.m_value;\n    int n   = v.size();\n    auto&amp; q = qin.m_value;\n    q.resize(m - n + 1);\n    auto&amp; r = rin.m_value;\n    Dlimb_t ofl{0};\n\n    if (n == 1) {\n        for (int i = m - 1; i &gt;= 0; --i) {\n            ofl  = (ofl &lt;&lt; m_limbBitLength) | u[i];\n            q[i] = static_cast&lt;limb_t&gt;(ofl / v[0]);\n            ofl %= v[0];\n        }\n        qin.NormalizeLimbs();\n\n        r.resize(1);\n        r[0]      = static_cast&lt;limb_t&gt;(ofl);\n        rin.m_MSB = lbcrypto::GetMSB(r[0]);\n        return;\n    }\n\n    // Normalize by shifting v left just enough so that its high-order\n    // bit is set, and shift u left the same amount. We may have to append a\n    // high-order digit on the dividend; we do that unconditionally.\n\n    auto sl{m_limbBitLength - lbcrypto::GetMSB(v.back())};\n    std::vector&lt;limb_t&gt; vn(n);\n    ofl = 0;\n    for (int i = 0; i &lt; n; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(v[i]) &lt;&lt; sl;\n        vn[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    std::vector&lt;limb_t&gt; un(m + 1);\n    ofl = 0;\n    for (int i = 0; i &lt; m; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(u[i]) &lt;&lt; sl;\n        un[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    un[m] = static_cast&lt;limb_t&gt;(ofl);\n    Dlimb_t qhat, rhat, p;\n    for (int j = m - n; j &gt;= 0; --j) {\n        ofl  = (static_cast&lt;Dlimb_t&gt;(un[j + n]) &lt;&lt; m_limbBitLength) | un[j + n - 1];\n        qhat = ofl / vn[n - 1];\n        rhat = ofl % vn[n - 1];\n        while ((qhat &gt;&gt; m_limbBitLength) || ((qhat * vn[n - 2]) &gt; ((rhat &lt;&lt; m_limbBitLength) | un[j + n - 2]))) {\n            qhat -= 1;\n            rhat += vn[n - 1];\n            if (rhat &gt;&gt; m_limbBitLength)\n                break;\n        }\n        SDlimb_t k{0}, t;\n        for (int i = 0; i &lt; n; ++i) {\n            p         = qhat * vn[i];\n            t         = un[i + j] - k - (p &amp; m_MaxLimb);\n            un[i + j] = static_cast&lt;limb_t&gt;(t);\n            k         = (p &gt;&gt; m_limbBitLength) - (t &gt;&gt; m_limbBitLength);\n        }\n        t         = un[j + n] - k;\n        un[j + n] = static_cast&lt;limb_t&gt;(t);\n        q[j]      = qhat;\n        if (t &lt; 0) {\n            q[j] -= 1;\n            k = 0;\n            for (int i = 0; i &lt; n; ++i) {\n                t         = static_cast&lt;Dlimb_t&gt;(un[i + j]) + vn[i] + k;\n                un[i + j] = static_cast&lt;limb_t&gt;(t);\n                k         = t &gt;&gt; m_limbBitLength;\n            }\n            un[j + n] += k;\n        }\n    }\n    qin.NormalizeLimbs();\n\n    ofl = un[0] &gt;&gt; sl;\n    auto sr{m_limbBitLength - sl};\n    r.resize(n--);\n    for (int i = 0; i &lt; n; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(un[i + 1]) &lt;&lt; sr;\n        r[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    r[n] = un[n] &gt;&gt; sl;\n    rin.NormalizeLimbs();\n}\n\ntemplate &lt;typename limb_t&gt;\nvoid ubint&lt;limb_t&gt;::divq_vect(ubint&amp; qin, const ubint&amp; uin, const ubint&amp; vin) const noexcept {\n    auto&amp; u = uin.m_value;\n    int m   = u.size();\n    auto&amp; v = vin.m_value;\n    int n   = v.size();\n    auto&amp; q = qin.m_value;\n    q.resize(m - n + 1);\n    Dlimb_t ofl{0};\n\n    if (n == 1) {\n        for (int i = m - 1; i &gt;= 0; --i) {\n            ofl  = (ofl &lt;&lt; m_limbBitLength) | u[i];\n            q[i] = static_cast&lt;limb_t&gt;(ofl / v[0]);\n            ofl %= v[0];\n        }\n        qin.NormalizeLimbs();\n        return;\n    }\n\n    auto sl{m_limbBitLength - lbcrypto::GetMSB(v.back())};\n    std::vector&lt;limb_t&gt; vn(n);\n    ofl = 0;\n    for (int i = 0; i &lt; n; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(v[i]) &lt;&lt; sl;\n        vn[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    std::vector&lt;limb_t&gt; un(m + 1);\n    ofl = 0;\n    for (int i = 0; i &lt; m; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(u[i]) &lt;&lt; sl;\n        un[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    un[m] = static_cast&lt;limb_t&gt;(ofl);\n    Dlimb_t qhat, rhat, p;\n    for (int j = m - n; j &gt;= 0; --j) {\n        ofl  = (static_cast&lt;Dlimb_t&gt;(un[j + n]) &lt;&lt; m_limbBitLength) | un[j + n - 1];\n        qhat = ofl / vn[n - 1];\n        rhat = ofl % vn[n - 1];\n        while ((qhat &gt;&gt; m_limbBitLength) || ((qhat * vn[n - 2]) &gt; ((rhat &lt;&lt; m_limbBitLength) | un[j + n - 2]))) {\n            qhat -= 1;\n            rhat += vn[n - 1];\n            if (rhat &gt;&gt; m_limbBitLength)\n                break;\n        }\n        SDlimb_t k{0}, t;\n        for (int i = 0; i &lt; n; ++i) {\n            p         = qhat * vn[i];\n            t         = un[i + j] - k - (p &amp; m_MaxLimb);\n            un[i + j] = static_cast&lt;limb_t&gt;(t);\n            k         = (p &gt;&gt; m_limbBitLength) - (t &gt;&gt; m_limbBitLength);\n        }\n        t         = un[j + n] - k;\n        un[j + n] = static_cast&lt;limb_t&gt;(t);\n        q[j]      = qhat;\n        if (t &lt; 0) {\n            q[j] -= 1;\n            k = 0;\n            for (int i = 0; i &lt; n; ++i) {\n                t         = static_cast&lt;Dlimb_t&gt;(un[i + j]) + vn[i] + k;\n                un[i + j] = static_cast&lt;limb_t&gt;(t);\n                k         = t &gt;&gt; m_limbBitLength;\n            }\n            un[j + n] += k;\n        }\n    }\n    qin.NormalizeLimbs();\n}\n\ntemplate &lt;typename limb_t&gt;\nvoid ubint&lt;limb_t&gt;::divr_vect(ubint&amp; rin, const ubint&amp; uin, const ubint&amp; vin) const noexcept {\n    auto&amp; u = uin.m_value;\n    int m   = u.size();\n    auto&amp; v = vin.m_value;\n    int n   = v.size();\n    auto&amp; r = rin.m_value;\n    Dlimb_t ofl{0};\n\n    if (n == 1) {\n        std::vector&lt;limb_t&gt; q(m - n + 1);\n        for (int i = m - 1; i &gt;= 0; --i) {\n            ofl  = (ofl &lt;&lt; m_limbBitLength) | u[i];\n            q[i] = static_cast&lt;limb_t&gt;(ofl / v[0]);\n            ofl %= v[0];\n        }\n        r[0]      = static_cast&lt;limb_t&gt;(ofl);\n        rin.m_MSB = lbcrypto::GetMSB(r[0]);\n        return;\n    }\n\n    auto sl{m_limbBitLength - lbcrypto::GetMSB(v.back())};\n    std::vector&lt;limb_t&gt; vn(n);\n    ofl = 0;\n    for (int i = 0; i &lt; n; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(v[i]) &lt;&lt; sl;\n        vn[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    std::vector&lt;limb_t&gt; un(m + 1);\n    ofl = 0;\n    for (int i = 0; i &lt; m; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(u[i]) &lt;&lt; sl;\n        un[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    un[m] = static_cast&lt;limb_t&gt;(ofl);\n    Dlimb_t qhat, rhat, p;\n    for (int j = m - n; j &gt;= 0; --j) {\n        ofl  = (static_cast&lt;Dlimb_t&gt;(un[j + n]) &lt;&lt; m_limbBitLength) | un[j + n - 1];\n        qhat = ofl / vn[n - 1];\n        rhat = ofl % vn[n - 1];\n        while ((qhat &gt;&gt; m_limbBitLength) || ((qhat * vn[n - 2]) &gt; ((rhat &lt;&lt; m_limbBitLength) | un[j + n - 2]))) {\n            qhat -= 1;\n            rhat += vn[n - 1];\n            if (rhat &gt;&gt; m_limbBitLength)\n                break;\n        }\n        SDlimb_t k{0}, t;\n        for (int i = 0; i &lt; n; ++i) {\n            p         = qhat * vn[i];\n            t         = un[i + j] - k - (p &amp; m_MaxLimb);\n            un[i + j] = static_cast&lt;limb_t&gt;(t);\n            k         = (p &gt;&gt; m_limbBitLength) - (t &gt;&gt; m_limbBitLength);\n        }\n        t         = un[j + n] - k;\n        un[j + n] = static_cast&lt;limb_t&gt;(t);\n        if (t &lt; 0) {\n            k = 0;\n            for (int i = 0; i &lt; n; ++i) {\n                t         = static_cast&lt;Dlimb_t&gt;(un[i + j]) + vn[i] + k;\n                un[i + j] = static_cast&lt;limb_t&gt;(t);\n                k         = t &gt;&gt; m_limbBitLength;\n            }\n            un[j + n] += k;\n        }\n    }\n\n    r.resize(n--);\n    ofl = un[0] &gt;&gt; sl;\n    auto sr{m_limbBitLength - sl};\n    for (int i = 0; i &lt; n; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(un[i + 1]) &lt;&lt; sr;\n        r[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    r[n] = un[n] &gt;&gt; sl;\n    rin.NormalizeLimbs();\n}\n\n// Initializes the vector of limbs from the string equivalent of ubint\n// Algorithm used is repeated division by 2\n// Reference:http://pctechtips.org/convert-from-decimal-to-binary-with-recursion-in-java/\ntemplate &lt;typename limb_t&gt;\nvoid ubint&lt;limb_t&gt;::SetValue(const std::string&amp; vin) {\n    std::string v{vin};\n    // v.erase(0, v.find_first_not_of(&#x27; &#x27;));\n    v.erase(0, v.find_first_not_of(&#x27;0&#x27;));\n    if (v.size() == 0)\n        v = &quot;0&quot;;\n\n    size_t arrSize = v.length() - 1;\n    for (size_t i = 0; i &lt;= arrSize; ++i)\n        v[i] -= &#x27;0&#x27;;\n\n    m_value.clear();\n    //    m_value.reserve(MSBToLimbs(arrSize &lt;&lt; 2));\n    usint cnt{0};\n    limb_t val{0};\n    size_t zptr{0};\n    while (zptr &lt;= arrSize) {\n        val |= static_cast&lt;limb_t&gt;(v[arrSize] &amp; 0x1) &lt;&lt; cnt++;\n        for (size_t i = zptr; i &lt; arrSize; ++i) {\n            v[i + 1] += (v[i] &amp; 0x1) * 10;\n            v[i] &gt;&gt;= 1;\n        }\n        v[arrSize] &gt;&gt;= 1;\n        if (v[zptr] == 0)\n            zptr++;\n\n        if ((cnt == m_limbBitLength) || (zptr &gt; arrSize)) {\n            m_value.push_back(val);\n            cnt = val = 0;\n        }\n    }\n    ubint&lt;limb_t&gt;::NormalizeLimbs();\n}\n\ntemplate &lt;typename limb_t&gt;\nuschar ubint&lt;limb_t&gt;::GetBitAtIndex(usint index) const {\n    constexpr usint mask{m_limbBitLength - 1};\n    if (index &gt; m_MSB)\n        return 0;\n    size_t idx{MSBToLimbs(index) - 1};\n    index &amp;= mask;\n    return static_cast&lt;uschar&gt;((m_value[idx] &gt;&gt; (index ? index - 1 : mask)) &amp; 0x1);\n}\n\ntemplate class bigintdyn::ubint&lt;expdtype&gt;;\n\n    #if 0\n// to stream internal representation\ntemplate std::ostream&amp; operator&lt;&lt;&lt;expdtype&gt;(std::ostream&amp; os, const std::vector&lt;expdtype&gt;&amp; v);\n    #endif\n\n}  // namespace bigintdyn\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Control for encryption operations\n */\n\n#ifndef SRC_PKE_CRYPTOCONTEXT_H_\n#define SRC_PKE_CRYPTOCONTEXT_H_\n\n#include &quot;cryptocontextfactory.h&quot;\n#include &quot;cryptocontext-fwd.h&quot;\n#include &quot;ciphertext.h&quot;\n\n#include &quot;encoding/plaintextfactory.h&quot;\n\n#include &quot;key/evalkey.h&quot;\n#include &quot;key/keypair.h&quot;\n\n#include &quot;schemebase/base-pke.h&quot;\n#include &quot;schemebase/base-scheme.h&quot;\n#include &quot;schemerns/rns-cryptoparameters.h&quot;\n\n#include &quot;utils/caller_info.h&quot;\n#include &quot;utils/serial.h&quot;\n#include &quot;utils/type_name.h&quot;\n\n#include &quot;binfhecontext.h&quot;\n\n#include &lt;functional&gt;\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;unordered_map&gt;\n\nnamespace lbcrypto {\n\n/**\n * @brief CryptoContextImpl\n *\n * A CryptoContextImpl is the object used to access the OpenFHE library\n *\n * All OpenFHE functionality is accessed by way of an instance of a\n * CryptoContextImpl; we say that various objects are &quot;created in&quot; a context,\n * and can only be used in the context in which they were created\n *\n * All OpenFHE methods are accessed through CryptoContextImpl methods. Guards\n * are implemented to make certain that only valid objects that have been\n * created in the context are used\n *\n * Contexts are created using GenCryptoContext(), and can be serialized\n * and recovered from a serialization\n */\ntemplate &lt;typename Element&gt;\nclass CryptoContextImpl : public Serializable {\n    using IntType  = typename Element::Integer;\n    using ParmType = typename Element::Params;\n\n    void SetKSTechniqueInScheme();\n\n    const CryptoContext&lt;Element&gt; GetContextForPointer(const CryptoContextImpl&lt;Element&gt;* cc) const {\n        const auto&amp; contexts = CryptoContextFactory&lt;Element&gt;::GetAllContexts();\n        for (const auto&amp; ctx : contexts) {\n            if (cc == ctx.get())\n                return ctx;\n        }\n        &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Cannot find context for the given pointer to CryptoContextImpl&quot;);\n    }\n\n    virtual Plaintext MakeCKKSPackedPlaintextInternal(const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; value,\n                                                      size_t noiseScaleDeg, uint32_t level,\n                                                      const std::shared_ptr&lt;ParmType&gt; params, usint slots) const {\n        const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersRNS&gt;(GetCryptoParameters());\n        if (level &gt; 0) {\n            // validation of level: We need to compare it to multiplicativeDepth, but multiplicativeDepth is not\n            // readily available. so, what we get is numModuli and use it for calculations\n            size_t numModuli = cryptoParams-&gt;GetElementParams()-&gt;GetParams().size();\n            uint32_t multiplicativeDepth =\n                (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT) ? (numModuli - 2) : (numModuli - 1);\n            // we throw an exception if level &gt;= numModuli. however, we use multiplicativeDepth in the error message,\n            // so the user can understand the error more easily.\n            if (level &gt;= numModuli) {\n                std::string errorMsg;\n                if (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT)\n                    errorMsg = &quot;The level value should be less than or equal to (multiplicativeDepth + 1).&quot;;\n                else\n                    errorMsg = &quot;The level value should be less than or equal to multiplicativeDepth.&quot;;\n\n                errorMsg += &quot; Currently: level is [&quot; + std::to_string(level) + &quot;] and multiplicativeDepth is [&quot; +\n                            std::to_string(multiplicativeDepth) + &quot;]&quot;;\n                &quot;hey&quot;; OPENFHE_THROW(config_error, errorMsg);\n            }\n        }\n\n        double scFact = 0;\n        if (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT &amp;&amp; level == 0) {\n            scFact = cryptoParams-&gt;GetScalingFactorRealBig(level);\n            // In FLEXIBLEAUTOEXT mode at level 0, we don&#x27;t use the noiseScaleDeg\n            // in our encoding function, so we set it to 1 to make sure it\n            // has no effect on the encoding.\n            noiseScaleDeg = 1;\n        }\n        else {\n            scFact = cryptoParams-&gt;GetScalingFactorReal(level);\n        }\n\n        Plaintext p;\n        if (params == nullptr) {\n            std::shared_ptr&lt;ILDCRTParams&lt;DCRTPoly::Integer&gt;&gt; elemParamsPtr;\n            if (level != 0) {\n                ILDCRTParams&lt;DCRTPoly::Integer&gt; elemParams = *(cryptoParams-&gt;GetElementParams());\n                for (uint32_t i = 0; i &lt; level; i++) {\n                    elemParams.PopLastParam();\n                }\n                elemParamsPtr = std::make_shared&lt;ILDCRTParams&lt;DCRTPoly::Integer&gt;&gt;(elemParams);\n            }\n            else {\n                elemParamsPtr = cryptoParams-&gt;GetElementParams();\n            }\n            // Check if plaintext has got enough slots for data (value)\n            usint ringDim    = elemParamsPtr-&gt;GetRingDimension();\n            size_t valueSize = value.size();\n            if (valueSize &gt; ringDim / 2) {\n                &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The size [&quot; + std::to_string(valueSize) +\n                                                &quot;] of the vector with values should not be greater than ringDim/2 [&quot; +\n                                                std::to_string(ringDim / 2) + &quot;] if the scheme is CKKS&quot;);\n            }\n            // TODO (dsuponit): we should call a version of MakePlaintext instead of calling Plaintext() directly here\n            p = Plaintext(std::make_shared&lt;CKKSPackedEncoding&gt;(elemParamsPtr, this-&gt;GetEncodingParams(), value,\n                                                               noiseScaleDeg, level, scFact, slots));\n        }\n        else {\n            // Check if plaintext has got enough slots for data (value)\n            usint ringDim    = params-&gt;GetRingDimension();\n            size_t valueSize = value.size();\n            if (valueSize &gt; ringDim / 2) {\n                &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The size [&quot; + std::to_string(valueSize) +\n                                                &quot;] of the vector with values should not be greater than ringDim/2 [&quot; +\n                                                std::to_string(ringDim / 2) + &quot;] if the scheme is CKKS&quot;);\n            }\n            // TODO (dsuponit): we should call a version of MakePlaintext instead of calling Plaintext() directly here\n            p = Plaintext(std::make_shared&lt;CKKSPackedEncoding&gt;(params, this-&gt;GetEncodingParams(), value, noiseScaleDeg,\n                                                               level, scFact, slots));\n        }\n        p-&gt;Encode();\n\n        // In FLEXIBLEAUTOEXT mode, a fresh plaintext at level 0 always has noiseScaleDeg 2.\n        if (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT &amp;&amp; level == 0) {\n            p-&gt;SetNoiseScaleDeg(2);\n        }\n        return p;\n    }\n\n    /**\n    * MakePlaintext constructs a CoefPackedEncoding or PackedEncoding in this context\n    * @param encoding is PACKED_ENCODING or COEF_PACKED_ENCODING\n    * @param value is the value to encode\n    * @param depth is the multiplicative depth to encode the plaintext at\n    * @param level is the level to encode the plaintext at\n    * @return plaintext\n    */\n    Plaintext MakePlaintext(const PlaintextEncodings encoding, const std::vector&lt;int64_t&gt;&amp; value, size_t depth,\n                            uint32_t level) const {\n        const auto cryptoParams = std::dynamic_pointer_cast&lt;CryptoParametersRNS&gt;(GetCryptoParameters());\n        if (level &gt; 0) {\n            if (getSchemeId() == SCHEME::BFVRNS_SCHEME) {\n                std::string errorMsg(&quot;The level value should be zero for BFVRNS_SCHEME. Currently: level is [&quot; +\n                                     std::to_string(level) + &quot;]&quot;);\n                &quot;hey&quot;; OPENFHE_THROW(config_error, errorMsg);\n            }\n            // validation of level: We need to compare it to multiplicativeDepth, but multiplicativeDepth is not\n            // readily available. so, what we get is numModuli and use it for calculations\n            size_t numModuli = cryptoParams-&gt;GetElementParams()-&gt;GetParams().size();\n            uint32_t multiplicativeDepth =\n                (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT) ? (numModuli - 2) : (numModuli - 1);\n            // we throw an exception if level &gt;= numModuli. however, we use multiplicativeDepth in the error message,\n            // so the user can understand the error more easily.\n            if (level &gt;= numModuli) {\n                std::string errorMsg;\n                if (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT)\n                    errorMsg = &quot;The level value should be less than or equal to (multiplicativeDepth + 1).&quot;;\n                else\n                    errorMsg = &quot;The level value should be less than or equal to multiplicativeDepth.&quot;;\n\n                errorMsg += &quot; Currently: level is [&quot; + std::to_string(level) + &quot;] and multiplicativeDepth is [&quot; +\n                            std::to_string(multiplicativeDepth) + &quot;]&quot;;\n                &quot;hey&quot;; OPENFHE_THROW(config_error, errorMsg);\n            }\n        }\n\n        Plaintext p;\n        if (getSchemeId() == SCHEME::BGVRNS_SCHEME &amp;&amp; (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTO ||\n                                                       cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT)) {\n            NativeInteger scf;\n            if (cryptoParams-&gt;GetScalingTechnique() == FLEXIBLEAUTOEXT &amp;&amp; level == 0) {\n                scf = cryptoParams-&gt;GetScalingFactorIntBig(level);\n                p   = PlaintextFactory::MakePlaintext(value, encoding, this-&gt;GetElementParams(),\n                                                      this-&gt;GetEncodingParams(), getSchemeId(), 1, level, scf);\n                p-&gt;SetNoiseScaleDeg(2);\n            }\n            else {\n                scf = cryptoParams-&gt;GetScalingFactorInt(level);\n                p   = PlaintextFactory::MakePlaintext(value, encoding, this-&gt;GetElementParams(),\n                                                      this-&gt;GetEncodingParams(), getSchemeId(), depth, level, scf);\n            }\n        }\n        else {\n            auto elementParams = this-&gt;GetElementParams();\n            p = PlaintextFactory::MakePlaintext(value, encoding, elementParams, this-&gt;GetEncodingParams(),\n                                                getSchemeId());\n        }\n\n        return p;\n    }\n\n    /**\n    * MakePlaintext static that takes a cc and calls the Plaintext Factory\n    * @param encoding\n    * @param cc\n    * @param value\n    * @return\n    */\n    template &lt;typename Value1&gt;\n    static Plaintext MakePlaintext(PlaintextEncodings encoding, CryptoContext&lt;Element&gt; cc, const Value1&amp; value) {\n        return PlaintextFactory::MakePlaintext(value, encoding, cc-&gt;GetElementParams(), cc-&gt;GetEncodingParams());\n    }\n\n    template &lt;typename Value1, typename Value2&gt;\n    static Plaintext MakePlaintext(PlaintextEncodings encoding, CryptoContext&lt;Element&gt; cc, const Value1&amp; value,\n                                   const Value2&amp; value2) {\n        return PlaintextFactory::MakePlaintext(encoding, cc-&gt;GetElementParams(), cc-&gt;GetEncodingParams(), value,\n                                               value2);\n    }\n\nprivate:\n    // cached evalmult keys, by secret key UID\n    static inline std::map&lt;std::string, std::vector&lt;EvalKey&lt;Element&gt;&gt;&gt; s_evalMultKeyMap{};\n    // cached evalsum keys, by secret key UID\n    static inline std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt; s_evalSumKeyMap{};\n    // cached evalautomorphism keys, by secret key UID\n    static inline std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt; s_evalAutomorphismKeyMap{};\n\nprotected:\n    // crypto parameters used for this context\n    std::shared_ptr&lt;CryptoParametersBase&lt;Element&gt;&gt; params;\n    // algorithm used; accesses all crypto methods\n    std::shared_ptr&lt;SchemeBase&lt;Element&gt;&gt; scheme;\n\n    static std::map&lt;std::string, std::vector&lt;EvalKey&lt;Element&gt;&gt;&gt;&amp; evalMultKeyMap();\n    static std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt;&amp; evalSumKeyMap();\n    static std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt;&amp; evalAutomorphismKeyMap();\n\n    SCHEME m_schemeId = SCHEME::INVALID_SCHEME;\n\n    uint32_t m_keyGenLevel;\n\n    /**\n   * TypeCheck makes sure that an operation between two ciphertexts is permitted\n   * @param a\n   * @param b\n   */\n    void TypeCheck(const ConstCiphertext&lt;Element&gt; a, const ConstCiphertext&lt;Element&gt; b, CALLER_INFO_ARGS_HDR) const {\n        if (a == nullptr || b == nullptr) {\n            std::string errorMsg(std::string(&quot;Null Ciphertext&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(type_error, errorMsg);\n        }\n        if (a-&gt;GetCryptoContext().get() != this) {\n            std::string errorMsg(std::string(&quot;Ciphertext was not created in this CryptoContext&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(type_error, errorMsg);\n        }\n        if (a-&gt;GetCryptoContext() != b-&gt;GetCryptoContext()) {\n            std::string errorMsg(std::string(&quot;Ciphertexts were not created in the same CryptoContext&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(type_error, errorMsg);\n        }\n        if (a-&gt;GetKeyTag() != b-&gt;GetKeyTag()) {\n            std::string errorMsg(std::string(&quot;Ciphertexts were not encrypted with same keys&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(type_error, errorMsg);\n        }\n        if (a-&gt;GetEncodingType() != b-&gt;GetEncodingType()) {\n            std::stringstream ss;\n            ss &lt;&lt; &quot;Ciphertext encoding types &quot; &lt;&lt; a-&gt;GetEncodingType();\n            ss &lt;&lt; &quot; and &quot; &lt;&lt; b-&gt;GetEncodingType();\n            ss &lt;&lt; &quot; do not match&quot;;\n            ss &lt;&lt; CALLER_INFO;\n            &quot;hey&quot;; OPENFHE_THROW(type_error, ss.str());\n        }\n    }\n\n    /**\n   * TypeCheck makes sure that an operation between a ciphertext and a plaintext\n   * is permitted\n   * @param a\n   * @param b\n   */\n    void TypeCheck(const ConstCiphertext&lt;Element&gt; a, const ConstPlaintext&amp; b, CALLER_INFO_ARGS_HDR) const {\n        if (a == nullptr) {\n            std::string errorMsg(std::string(&quot;Null Ciphertext&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(type_error, errorMsg);\n        }\n        if (b == nullptr) {\n            std::string errorMsg(std::string(&quot;Null Plaintext&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(type_error, errorMsg);\n        }\n        if (a-&gt;GetCryptoContext().get() != this) {\n            std::string errorMsg(std::string(&quot;Ciphertext was not created in this CryptoContext&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(type_error, errorMsg);\n        }\n        if (a-&gt;GetEncodingType() != b-&gt;GetEncodingType()) {\n            std::stringstream ss;\n            ss &lt;&lt; &quot;Ciphertext encoding type &quot; &lt;&lt; a-&gt;GetEncodingType();\n            ss &lt;&lt; &quot; and Plaintext encoding type &quot; &lt;&lt; b-&gt;GetEncodingType();\n            ss &lt;&lt; &quot; do not match&quot;;\n            ss &lt;&lt; CALLER_INFO;\n            &quot;hey&quot;; OPENFHE_THROW(type_error, ss.str());\n        }\n    }\n\n    bool Mismatched(const CryptoContext&lt;Element&gt; a) const {\n        if (a.get() != this) {\n            return true;\n        }\n        return false;\n    }\n\n    template &lt;typename T&gt;\n    void CheckKey(const T&amp; key, CALLER_INFO_ARGS_HDR) const {\n        if (key == nullptr) {\n            std::string errorMsg(std::string(&quot;Key is nullptr&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errorMsg);\n        }\n        if (Mismatched(key-&gt;GetCryptoContext())) {\n            std::string errorMsg(std::string(&quot;Key was not generated with the same crypto context&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errorMsg);\n        }\n    }\n\n    void CheckCiphertext(const ConstCiphertext&lt;Element&gt;&amp; ciphertext, CALLER_INFO_ARGS_HDR) const {\n        if (ciphertext == nullptr) {\n            std::string errorMsg(std::string(&quot;Ciphertext is nullptr&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errorMsg);\n        }\n        if (Mismatched(ciphertext-&gt;GetCryptoContext())) {\n            std::string errorMsg(std::string(&quot;Ciphertext was not generated with the same crypto context&quot;) +\n                                 CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errorMsg);\n        }\n    }\n\n    PrivateKey&lt;Element&gt; privateKey;\n\npublic:\n    /**\n   * This stores the private key in the crypto context.\n   * This is only intended for debugging and should not be\n   * used in production systems. Please define DEBUG_KEY in\n   * openfhe.h to enable this.\n   *\n   * If used, one can create a key pair and store the secret\n   * key in th crypto context like this:\n   *\n   * auto keys = cc-&gt;KeyGen();\n   * cc-&gt;SetPrivateKey(keys.secretKey);\n   *\n   * After that, anyone in the code, one can access the\n   * secret key by getting the crypto context and doing the\n   * following:\n   *\n   * auto sk = cc-&gt;GetPrivateKey();\n   *\n   * This key can be used for decrypting any intermediate\n   * ciphertexts for debugging purposes.\n   *\n   * @param sk the secret key\n   *\n   */\n    void SetPrivateKey(const PrivateKey&lt;Element&gt; privateKey) {\n#ifdef DEBUG_KEY\n        std::cerr &lt;&lt; &quot;Warning - SetPrivateKey is only intended to be used for debugging &quot;\n                     &quot;purposes - not for production systems.&quot;\n                  &lt;&lt; std::endl;\n        this-&gt;privateKey = privateKey;\n#else\n        &quot;hey&quot;; OPENFHE_THROW(not_available_error, &quot;SetPrivateKey is only allowed if DEBUG_KEY is set in openfhe.h&quot;);\n#endif\n    }\n\n    /**\n   * This gets the private key from the crypto context.\n   * This is only intended for debugging and should not be\n   * used in production systems. Please define DEBUG_KEY in\n   * openfhe.h to enable this.\n   *\n   * If used, one can create a key pair and store the secret\n   * key in th crypto context like this:\n   *\n   * auto keys = cc-&gt;KeyGen();\n   * cc-&gt;SetPrivateKey(keys.secretKey);\n   *\n   * After that, anyone in the code, one can access the\n   * secret key by getting the crypto context and doing the\n   * following:\n   *\n   * auto sk = cc-&gt;GetPrivateKey();\n   *\n   * This key can be used for decrypting any intermediate\n   * ciphertexts for debugging purposes.\n   *\n   * @return the secret key\n   *\n   */\n    const PrivateKey&lt;Element&gt; GetPrivateKey() {\n#ifdef DEBUG_KEY\n        return this-&gt;privateKey;\n#else\n        &quot;hey&quot;; OPENFHE_THROW(not_available_error, &quot;GetPrivateKey is only allowed if DEBUG_KEY is set in openfhe.h&quot;);\n#endif\n    }\n\n    void setSchemeId(SCHEME schemeTag) {\n        this-&gt;m_schemeId = schemeTag;\n    }\n\n    SCHEME getSchemeId() const {\n        return this-&gt;m_schemeId;\n    }\n\n    /**\n   * CryptoContextImpl constructor from pointers to parameters and scheme\n   * @param params pointer to CryptoParameters\n   * @param scheme pointer to Crypto Scheme object\n   * @param schemeId scheme identifier\n   */\n    // TODO (dsuponit): investigate if we really need 2 constructors for CryptoContextImpl as one of them take regular pointer\n    // and the other one takes shared_ptr\n    CryptoContextImpl(CryptoParametersBase&lt;Element&gt;* params = nullptr, SchemeBase&lt;Element&gt;* scheme = nullptr,\n                      SCHEME schemeId = SCHEME::INVALID_SCHEME) {\n        this-&gt;params.reset(params);\n        this-&gt;scheme.reset(scheme);\n        this-&gt;m_keyGenLevel = 0;\n        this-&gt;m_schemeId    = schemeId;\n    }\n\n    /**\n   * CryptoContextImpl constructor from shared pointers to parameters and scheme\n   * @param params shared pointer to CryptoParameters\n   * @param scheme sharedpointer to Crypto Scheme object\n   * @param schemeId scheme identifier\n   */\n    CryptoContextImpl(std::shared_ptr&lt;CryptoParametersBase&lt;Element&gt;&gt; params,\n                      std::shared_ptr&lt;SchemeBase&lt;Element&gt;&gt; scheme, SCHEME schemeId = SCHEME::INVALID_SCHEME) {\n        this-&gt;params        = params;\n        this-&gt;scheme        = scheme;\n        this-&gt;m_keyGenLevel = 0;\n        this-&gt;m_schemeId    = schemeId;\n    }\n\n    /**\n   * Copy constructor\n   * @param c - source\n   */\n    CryptoContextImpl(const CryptoContextImpl&lt;Element&gt;&amp; c) {\n        params              = c.params;\n        scheme              = c.scheme;\n        this-&gt;m_keyGenLevel = 0;\n        this-&gt;m_schemeId    = c.m_schemeId;\n    }\n\n    /**\n   * Assignment\n   * @param rhs - assigning from\n   * @return this\n   */\n    CryptoContextImpl&lt;Element&gt;&amp; operator=(const CryptoContextImpl&lt;Element&gt;&amp; rhs) {\n        params        = rhs.params;\n        scheme        = rhs.scheme;\n        m_keyGenLevel = rhs.m_keyGenLevel;\n        m_schemeId    = rhs.m_schemeId;\n        return *this;\n    }\n\n    /**\n   * A CryptoContextImpl is only valid if the shared pointers are both valid\n   */\n    operator bool() const {\n        return params &amp;&amp; scheme;\n    }\n\n    /**\n   * Private method to compare two contexts; this is only used internally and\n   * is not generally available\n   * @param a - operand 1\n   * @param b - operand 2\n   * @return true if the implementations have identical parms and scheme\n   */\n    friend bool operator==(const CryptoContextImpl&lt;Element&gt;&amp; a, const CryptoContextImpl&lt;Element&gt;&amp; b) {\n        // Identical if the parameters and the schemes are identical... the exact\n        // same object, OR the same type and the same values\n        if (a.params.get() == b.params.get()) {\n            return true;\n        }\n        else {\n            if (typeid(*a.params.get()) != typeid(*b.params.get())) {\n                return false;\n            }\n            if (*a.params.get() != *b.params.get())\n                return false;\n        }\n\n        if (a.scheme.get() == b.scheme.get()) {\n            return true;\n        }\n        else {\n            if (typeid(*a.scheme.get()) != typeid(*b.scheme.get())) {\n                return false;\n            }\n            if (*a.scheme.get() != *b.scheme.get())\n                return false;\n        }\n\n        return true;\n    }\n\n    /**\n   * Private method to compare two contexts; this is only used internally and\n   * is not generally available\n   * */\n    friend bool operator!=(const CryptoContextImpl&lt;Element&gt;&amp; a, const CryptoContextImpl&lt;Element&gt;&amp; b) {\n        return !(a == b);\n    }\n\n    /**\n   * SerializeEvalMultKey for a single EvalMult key or all EvalMult keys\n   *\n   * @param ser - stream to serialize to\n   * @param sertype - type of serialization\n   * @param id for key to serialize - if empty std::string, serialize them all\n   * @return true on success\n   */\n    template &lt;typename ST&gt;\n    static bool SerializeEvalMultKey(std::ostream&amp; ser, const ST&amp; sertype, std::string id = &quot;&quot;) {\n        std::map&lt;std::string, std::vector&lt;EvalKey&lt;Element&gt;&gt;&gt;* smap;\n        std::map&lt;std::string, std::vector&lt;EvalKey&lt;Element&gt;&gt;&gt; omap;\n\n        if (id.length() == 0) {\n            smap = &amp;GetAllEvalMultKeys();\n        }\n        else {\n            const auto k = GetAllEvalMultKeys().find(id);\n\n            if (k == GetAllEvalMultKeys().end())\n                return false;  // no such id\n\n            smap           = &amp;omap;\n            omap[k-&gt;first] = k-&gt;second;\n        }\n\n        Serial::Serialize(*smap, ser, sertype);\n        return true;\n    }\n\n    /**\n   * SerializeEvalMultKey for all EvalMultKeys made in a given context\n   *\n   * @param ser stream to serialize to\n   * @param sertype type of serialization\n   * @param cc whose keys should be serialized\n   * @return true on success (false on failure or no keys found)\n   */\n    template &lt;typename ST&gt;\n    static bool SerializeEvalMultKey(std::ostream&amp; ser, const ST&amp; sertype, const CryptoContext&lt;Element&gt; cc) {\n        std::map&lt;std::string, std::vector&lt;EvalKey&lt;Element&gt;&gt;&gt; omap;\n        for (const auto&amp; k : GetAllEvalMultKeys()) {\n            if (k.second[0]-&gt;GetCryptoContext() == cc) {\n                omap[k.first] = k.second;\n            }\n        }\n\n        if (omap.size() == 0)\n            return false;\n\n        Serial::Serialize(omap, ser, sertype);\n        return true;\n    }\n\n    /**\n   * DeserializeEvalMultKey deserialize all keys in the serialization\n   * deserialized keys silently replace any existing matching keys\n   * deserialization will create CryptoContextImpl if necessary\n   *\n   * @param serObj - stream with a serialization\n   * @param sertype type of serialization\n   * @return true on success\n   */\n    template &lt;typename ST&gt;\n    static bool DeserializeEvalMultKey(std::istream&amp; ser, const ST&amp; sertype) {\n        std::map&lt;std::string, std::vector&lt;EvalKey&lt;Element&gt;&gt;&gt; evalMultKeyMap;\n\n        Serial::Deserialize(GetAllEvalMultKeys(), ser, sertype);\n\n        // The deserialize call created any contexts that needed to be created....\n        // so all we need to do is put the keys into the maps for their context\n\n        for (auto k : GetAllEvalMultKeys()) {\n            GetAllEvalMultKeys()[k.first] = k.second;\n        }\n\n        return true;\n    }\n\n    /**\n   * ClearEvalMultKeys - flush EvalMultKey cache\n   */\n    static void ClearEvalMultKeys() {\n        GetAllEvalMultKeys().clear();\n    }\n\n    /**\n   * ClearEvalMultKeys - flush EvalMultKey cache for a given id\n   * @param id the correponding key id\n   */\n    static void ClearEvalMultKeys(const std::string&amp; id) {\n        auto kd = GetAllEvalMultKeys().find(id);\n        if (kd != GetAllEvalMultKeys().end())\n            GetAllEvalMultKeys().erase(kd);\n    }\n\n    /**\n   * ClearEvalMultKeys - flush EvalMultKey cache for a given context\n   * @param cc crypto context\n   */\n    static void ClearEvalMultKeys(const CryptoContext&lt;Element&gt; cc) {\n        for (auto it = GetAllEvalMultKeys().begin(); it != GetAllEvalMultKeys().end();) {\n            if (it-&gt;second[0]-&gt;GetCryptoContext() == cc) {\n                it = GetAllEvalMultKeys().erase(it);\n            }\n            else {\n                ++it;\n            }\n        }\n    }\n\n    /**\n   * InsertEvalMultKey - add the given vector of keys to the map, replacing the\n   * existing vector if there\n   * @param evalKeyVec vector of keys\n   */\n    static void InsertEvalMultKey(const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec);\n\n    /**\n   * SerializeEvalSumKey for a single EvalSum key or all of the EvalSum keys\n   *\n   * @param ser - stream to serialize to\n   * @param sertype - type of serialization\n   * @param id - key to serialize; empty std::string means all keys\n   * @return true on success\n   */\n    template &lt;typename ST&gt;\n    static bool SerializeEvalSumKey(std::ostream&amp; ser, const ST&amp; sertype, std::string id = &quot;&quot;) {\n        std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt;* smap;\n        std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt; omap;\n\n        if (id.length() == 0) {\n            smap = &amp;GetAllEvalSumKeys();\n        }\n        else {\n            auto k = GetAllEvalSumKeys().find(id);\n\n            if (k == GetAllEvalSumKeys().end())\n                return false;  // no such id\n\n            smap           = &amp;omap;\n            omap[k-&gt;first] = k-&gt;second;\n        }\n        Serial::Serialize(*smap, ser, sertype);\n        return true;\n    }\n\n    /**\n   * SerializeEvalSumKey for all of the EvalSum keys for a context\n   *\n   * @param ser - stream to serialize to\n   * @param sertype - type of serialization\n   * @param cc - context\n   * @return true on success\n   */\n    template &lt;typename ST&gt;\n    static bool SerializeEvalSumKey(std::ostream&amp; ser, const ST&amp; sertype, const CryptoContext&lt;Element&gt; cc) {\n        std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt; omap;\n        for (const auto&amp; k : GetAllEvalSumKeys()) {\n            if (k.second-&gt;begin()-&gt;second-&gt;GetCryptoContext() == cc) {\n                omap[k.first] = k.second;\n            }\n        }\n\n        if (omap.size() == 0)\n            return false;\n\n        Serial::Serialize(omap, ser, sertype);\n\n        return true;\n    }\n\n    /**\n   * DeserializeEvalSumKey deserialize all keys in the serialization\n   * deserialized keys silently replace any existing matching keys\n   * deserialization will create CryptoContextImpl if necessary\n   *\n   * @param ser - stream to serialize from\n   * @param sertype - type of serialization\n   * @return true on success\n   */\n    template &lt;typename ST&gt;\n    static bool DeserializeEvalSumKey(std::istream&amp; ser, const ST&amp; sertype) {\n        std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt; evalSumKeyMap;\n\n        Serial::Deserialize(evalSumKeyMap, ser, sertype);\n\n        // The deserialize call created any contexts that needed to be created....\n        // so all we need to do is put the keys into the maps for their context\n\n        for (auto k : evalSumKeyMap) {\n            GetAllEvalSumKeys()[k.first] = k.second;\n        }\n\n        return true;\n    }\n\n    /**\n   * ClearEvalSumKeys - flush EvalSumKey cache\n   */\n    static void ClearEvalSumKeys();\n\n    /**\n   * ClearEvalSumKeys - flush EvalSumKey cache for a given id\n   * @param id key id\n   */\n    static void ClearEvalSumKeys(const std::string&amp; id);\n\n    /**\n   * ClearEvalSumKeys - flush EvalSumKey cache for a given context\n   * @param cc crypto context\n   */\n    static void ClearEvalSumKeys(const CryptoContext&lt;Element&gt; cc);\n\n    /**\n   * InsertEvalSumKey - add the given map of keys to the map, replacing the\n   * existing map if there\n   * @param evalKeyMap key map\n   */\n    static void InsertEvalSumKey(const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap);\n\n    /**\n   * SerializeEvalAutomorphismKey for a single EvalAuto key or all of the\n   * EvalAuto keys\n   *\n   * @param ser - stream to serialize to\n   * @param sertype - type of serialization\n   * @param id - key to serialize; empty std::string means all keys\n   * @return true on success\n   */\n    template &lt;typename ST&gt;\n    static bool SerializeEvalAutomorphismKey(std::ostream&amp; ser, const ST&amp; sertype, std::string id = &quot;&quot;) {\n        std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt;* smap;\n        std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt; omap;\n        if (id.length() == 0) {\n            smap = &amp;GetAllEvalAutomorphismKeys();\n        }\n        else {\n            auto k = GetAllEvalAutomorphismKeys().find(id);\n\n            if (k == GetAllEvalAutomorphismKeys().end())\n                return false;  // no such id\n\n            smap           = &amp;omap;\n            omap[k-&gt;first] = k-&gt;second;\n        }\n        Serial::Serialize(*smap, ser, sertype);\n        return true;\n    }\n\n    /**\n   * SerializeEvalAutomorphismKey for all of the EvalAuto keys for a context\n   *\n   * @param ser - stream to serialize to\n   * @param sertype - type of serialization\n   * @param cc - context\n   * @return true on success\n   */\n    template &lt;typename ST&gt;\n    static bool SerializeEvalAutomorphismKey(std::ostream&amp; ser, const ST&amp; sertype, const CryptoContext&lt;Element&gt; cc) {\n        std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt; omap;\n        for (const auto&amp; k : GetAllEvalAutomorphismKeys()) {\n            if (k.second-&gt;begin()-&gt;second-&gt;GetCryptoContext() == cc) {\n                omap[k.first] = k.second;\n            }\n        }\n\n        if (omap.size() == 0)\n            return false;\n\n        Serial::Serialize(omap, ser, sertype);\n        return true;\n    }\n\n    /**\n   * DeserializeEvalAutomorphismKey deserialize all keys in the serialization\n   * deserialized keys silently replace any existing matching keys\n   * deserialization will create CryptoContextImpl if necessary\n   *\n   * @param ser - stream to serialize from\n   * @param sertype - type of serialization\n   * @return true on success\n   */\n    template &lt;typename ST&gt;\n    static bool DeserializeEvalAutomorphismKey(std::istream&amp; ser, const ST&amp; sertype) {\n        std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt; evalSumKeyMap;\n\n        Serial::Deserialize(evalSumKeyMap, ser, sertype);\n\n        // The deserialize call created any contexts that needed to be created....\n        // so all we need to do is put the keys into the maps for their context\n\n        for (auto k : evalSumKeyMap) {\n            GetAllEvalAutomorphismKeys()[k.first] = k.second;\n        }\n\n        return true;\n    }\n\n    /**\n   * ClearEvalAutomorphismKeys - flush EvalAutomorphismKey cache\n   */\n    static void ClearEvalAutomorphismKeys();\n\n    /**\n   * ClearEvalAutomorphismKeys - flush EvalAutomorphismKey cache for a given id\n   * @param id\n   */\n    static void ClearEvalAutomorphismKeys(const std::string&amp; id);\n\n    /**\n   * ClearEvalAutomorphismKeys - flush EvalAutomorphismKey cache for a given\n   * context\n   * @param cc\n   */\n    static void ClearEvalAutomorphismKeys(const CryptoContext&lt;Element&gt; cc);\n\n    /**\n   * InsertEvalAutomorphismKey - add the given map of keys to the map, replacing\n   * the existing map if there\n   * @param mapToInsert\n   */\n    static void InsertEvalAutomorphismKey(const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap);\n\n    //------------------------------------------------------------------------------\n    // TURN FEATURES ON\n    //------------------------------------------------------------------------------\n\n    /**\n   * Enable a particular feature for use with this CryptoContextImpl\n   * @param feature - the feature that should be enabled\n   */\n    void Enable(PKESchemeFeature feature) {\n        scheme-&gt;Enable(feature);\n    }\n\n    /**\n   * Enable several features at once\n   * @param featureMask - bitwise or of several PKESchemeFeatures\n   */\n    void Enable(usint featureMask) {\n        scheme-&gt;Enable(featureMask);\n    }\n\n    // GETTERS\n    /**\n   * Getter for Scheme\n   * @return scheme\n   */\n    const std::shared_ptr&lt;SchemeBase&lt;Element&gt;&gt; GetScheme() const {\n        return scheme;\n    }\n\n    /**\n   * Getter for CryptoParams\n   * @return params\n   */\n    const std::shared_ptr&lt;CryptoParametersBase&lt;Element&gt;&gt; GetCryptoParameters() const {\n        return params;\n    }\n\n    /**\n   * For future use: getter for the level at which evaluation keys should be generated\n   */\n    size_t GetKeyGenLevel() const {\n        return m_keyGenLevel;\n    }\n\n    /**\n   * For future use: setter for the level at which evaluation keys should be generated\n   */\n    void SetKeyGenLevel(size_t level) {\n        m_keyGenLevel = level;\n    }\n\n    /**\n   * Getter for element params\n   * @return\n   */\n    const std::shared_ptr&lt;ParmType&gt; GetElementParams() const {\n        return params-&gt;GetElementParams();\n    }\n\n    /**\n   * Getter for encoding params\n   * @return\n   */\n    const EncodingParams GetEncodingParams() const {\n        return params-&gt;GetEncodingParams();\n    }\n\n    /**\n   * Get the cyclotomic order used for this context\n   *\n   * @return\n   */\n    usint GetCyclotomicOrder() const {\n        return params-&gt;GetElementParams()-&gt;GetCyclotomicOrder();\n    }\n\n    /**\n   * Get the ring dimension used for this context\n   *\n   * @return\n   */\n    usint GetRingDimension() const {\n        return params-&gt;GetElementParams()-&gt;GetRingDimension();\n    }\n\n    /**\n   * Get the ciphertext modulus used for this context\n   *\n   * @return\n   */\n    const IntType&amp; GetModulus() const {\n        return params-&gt;GetElementParams()-&gt;GetModulus();\n    }\n\n    /**\n   * Get the ciphertext modulus used for this context\n   *\n   * @return\n   */\n    const IntType&amp; GetRootOfUnity() const {\n        return params-&gt;GetElementParams()-&gt;GetRootOfUnity();\n    }\n\n    //------------------------------------------------------------------------------\n    // KEYS GETTERS\n    //------------------------------------------------------------------------------\n\n    /**\n   * Get a map of relinearization keys for all secret keys\n   */\n    static std::map&lt;std::string, std::vector&lt;EvalKey&lt;Element&gt;&gt;&gt;&amp; GetAllEvalMultKeys() {\n        return evalMultKeyMap();\n    }\n\n    /**\n   * Get relinearization keys for a specific secret key tag\n   */\n    static const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; GetEvalMultKeyVector(const std::string&amp; keyID) {\n        auto ekv = GetAllEvalMultKeys().find(keyID);\n        if (ekv == GetAllEvalMultKeys().end()) {\n            &quot;hey&quot;; OPENFHE_THROW(not_available_error,\n                          &quot;You need to use EvalMultKeyGen so that you have an &quot;\n                          &quot;EvalMultKey available for this ID&quot;);\n        }\n        return ekv-&gt;second;\n    }\n\n    /**\n   * Get a map of automorphism keys for all secret keys\n   */\n    static std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt;&amp; GetAllEvalAutomorphismKeys() {\n        return evalAutomorphismKeyMap();\n    }\n\n    /**\n   * Get automorphism keys for a specific secret key tag\n   */\n    static std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; GetEvalAutomorphismKeyMap(const std::string&amp; id);\n\n    /**\n   * Get a map of summation keys (each is composed of several automorphism keys) for all secret keys\n   */\n    static std::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt;&amp; GetAllEvalSumKeys();\n\n    /**\n   * Get a map of summation keys (each is composed of several automorphism keys) for a specific secret key tag\n   */\n    static const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; GetEvalSumKeyMap(const std::string&amp; id);\n\n    //------------------------------------------------------------------------------\n    // PLAINTEXT FACTORY METHODS\n    //------------------------------------------------------------------------------\n\n    // TODO to be deprecated in 2.0\n    /**\n   * MakeStringPlaintext constructs a StringEncoding in this context\n   * @param str string to be encoded\n   * @return plaintext\n   */\n    Plaintext MakeStringPlaintext(const std::string&amp; str) const {\n        return PlaintextFactory::MakePlaintext(str, STRING_ENCODING, this-&gt;GetElementParams(),\n                                               this-&gt;GetEncodingParams());\n    }\n\n    /**\n   * MakeCoefPackedPlaintext constructs a CoefPackedEncoding in this context\n   * @param value vector of signed integers mod t\n   * @param noiseScaleDeg is degree of the scaling factor to encode the plaintext at\n   * @param level is the level to encode the plaintext at\n   * @return plaintext\n   */\n    Plaintext MakeCoefPackedPlaintext(const std::vector&lt;int64_t&gt;&amp; value, size_t noiseScaleDeg = 1,\n                                      uint32_t level = 0) const {\n        if (!value.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Cannot encode an empty value vector&quot;);\n\n        return MakePlaintext(COEF_PACKED_ENCODING, value, noiseScaleDeg, level);\n    }\n\n    /**\n   * MakePackedPlaintext constructs a PackedEncoding in this context\n   * @param value vector of signed integers mod t\n   * @param noiseScaleDeg is degree of the scaling factor to encode the plaintext at\n   * @param level is the level to encode the plaintext at\n   * @return plaintext\n   */\n    Plaintext MakePackedPlaintext(const std::vector&lt;int64_t&gt;&amp; value, size_t noiseScaleDeg = 1,\n                                  uint32_t level = 0) const {\n        if (!value.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Cannot encode an empty value vector&quot;);\n\n        return MakePlaintext(PACKED_ENCODING, value, noiseScaleDeg, level);\n    }\n\n    /**\n   * COMPLEX ARITHMETIC IS NOT AVAILABLE,\n   * AND THIS METHOD BE DEPRECATED. USE THE REAL-NUMBER METHOD INSTEAD.\n   * MakeCKKSPackedPlaintext constructs a CKKSPackedEncoding in this context\n   * from a vector of complex numbers\n   * @param value - input vector of complex number\n   * @param scaleDeg - degree of scaling factor used to encode the vector\n   * @param level - level at each the vector will get encrypted\n   * @param params - parameters to be usef for the ciphertext\n   * @return plaintext\n   */\n    Plaintext MakeCKKSPackedPlaintext(const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; value, size_t scaleDeg = 1,\n                                      uint32_t level = 0, const std::shared_ptr&lt;ParmType&gt; params = nullptr,\n                                      usint slots = 0) const {\n        if (!value.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Cannot encode an empty value vector&quot;);\n\n        return MakeCKKSPackedPlaintextInternal(value, scaleDeg, level, params, slots);\n    }\n\n    /**\n   * MakeCKKSPackedPlaintext constructs a CKKSPackedEncoding in this context\n   * from a vector of real numbers\n   * @param value - input vector of real numbers\n   * @param scaleDeg - degree of scaling factor used to encode the vector\n   * @param level - level at each the vector will get encrypted\n   * @param params - parameters to be usef for the ciphertext\n   * @return plaintext\n   */\n    Plaintext MakeCKKSPackedPlaintext(const std::vector&lt;double&gt;&amp; value, size_t scaleDeg = 1, uint32_t level = 0,\n                                      const std::shared_ptr&lt;ParmType&gt; params = nullptr, usint slots = 0) const {\n        if (!value.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Cannot encode an empty value vector&quot;);\n\n        std::vector&lt;std::complex&lt;double&gt;&gt; complexValue(value.size());\n        std::transform(value.begin(), value.end(), complexValue.begin(),\n                       [](double da) { return std::complex&lt;double&gt;(da); });\n\n        return MakeCKKSPackedPlaintextInternal(complexValue, scaleDeg, level, params, slots);\n    }\n\n    /**\n   * GetPlaintextForDecrypt returns a new Plaintext to be used in decryption.\n   *\n   * @param pte Type of plaintext we want to return\n   * @param evp Element parameters\n   * @param ep Encoding parameters\n   * @return plaintext\n   */\n    static Plaintext GetPlaintextForDecrypt(PlaintextEncodings pte, std::shared_ptr&lt;ParmType&gt; evp, EncodingParams ep);\n\n    //------------------------------------------------------------------------------\n    // PKE Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * KeyGen generates a key pair using this algorithm&#x27;s KeyGen method\n   * @return a public/secret key pair\n   */\n    KeyPair&lt;Element&gt; KeyGen() {\n        return GetScheme()-&gt;KeyGen(GetContextForPointer(this), false);\n    }\n\n    /**\n   * NOT SUPPORTED BY ANY CRYPTO SCHEME NOW\n   * SparseKeyGen generates a key pair with special structure, and without full\n   * entropy, for use in special cases like Ring Reduction\n   * @return a public/secret key pair\n   */\n    KeyPair&lt;Element&gt; SparseKeyGen() {\n        return GetScheme()-&gt;KeyGen(GetContextForPointer(this), true);\n    }\n\n    /**\n   * Encrypt a plaintext using a given public key\n   * @param plaintext plaintext\n   * @param publicKey public key\n   * @return ciphertext (or null on failure)\n   */\n    Ciphertext&lt;Element&gt; Encrypt(const Plaintext&amp; plaintext, const PublicKey&lt;Element&gt; publicKey) const {\n        if (plaintext == nullptr)\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Input plaintext is nullptr&quot;);\n        CheckKey(publicKey);\n\n        Ciphertext&lt;Element&gt; ciphertext = GetScheme()-&gt;Encrypt(plaintext-&gt;GetElement&lt;Element&gt;(), publicKey);\n\n        if (ciphertext) {\n            ciphertext-&gt;SetEncodingType(plaintext-&gt;GetEncodingType());\n            ciphertext-&gt;SetScalingFactor(plaintext-&gt;GetScalingFactor());\n            ciphertext-&gt;SetScalingFactorInt(plaintext-&gt;GetScalingFactorInt());\n            ciphertext-&gt;SetNoiseScaleDeg(plaintext-&gt;GetNoiseScaleDeg());\n            ciphertext-&gt;SetLevel(plaintext-&gt;GetLevel());\n            ciphertext-&gt;SetSlots(plaintext-&gt;GetSlots());\n        }\n\n        return ciphertext;\n    }\n\n    /**\n   * Encrypt a plaintext using a given public key\n   * @param publicKey public key\n   * @param plaintext plaintext\n   * @return ciphertext (or null on failure)\n   */\n    Ciphertext&lt;Element&gt; Encrypt(const PublicKey&lt;Element&gt; publicKey, Plaintext plaintext) const {\n        return Encrypt(plaintext, publicKey);\n    }\n\n    /**\n   * Encrypt a plaintext using a given private key\n   * @param plaintext input plaintext\n   * @param privateKey private key\n   * @return ciphertext (or null on failure)\n   */\n    Ciphertext&lt;Element&gt; Encrypt(const Plaintext&amp; plaintext, const PrivateKey&lt;Element&gt; privateKey) const {\n        //    if (plaintext == nullptr)\n        //      &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Input plaintext is nullptr&quot;);\n        CheckKey(privateKey);\n\n        Ciphertext&lt;Element&gt; ciphertext = GetScheme()-&gt;Encrypt(plaintext-&gt;GetElement&lt;Element&gt;(), privateKey);\n\n        if (ciphertext) {\n            ciphertext-&gt;SetEncodingType(plaintext-&gt;GetEncodingType());\n            ciphertext-&gt;SetScalingFactor(plaintext-&gt;GetScalingFactor());\n            ciphertext-&gt;SetScalingFactorInt(plaintext-&gt;GetScalingFactorInt());\n            ciphertext-&gt;SetNoiseScaleDeg(plaintext-&gt;GetNoiseScaleDeg());\n            ciphertext-&gt;SetLevel(plaintext-&gt;GetLevel());\n            ciphertext-&gt;SetSlots(plaintext-&gt;GetSlots());\n        }\n\n        return ciphertext;\n    }\n\n    /**\n   * Encrypt a plaintext using a given private key\n   * @param privateKey private key\n   * @param plaintext input plaintext\n   * @return ciphertext (or null on failure)\n   */\n    Ciphertext&lt;Element&gt; Encrypt(const PrivateKey&lt;Element&gt; privateKey, Plaintext plaintext) const {\n        return Encrypt(plaintext, privateKey);\n    }\n\n    /**\n   * Decrypt a single ciphertext into the appropriate plaintext\n   *\n   * @param ciphertext - ciphertext to decrypt\n   * @param privateKey - decryption key\n   * @param plaintext - resulting plaintext object pointer is here\n   * @return\n   */\n    DecryptResult Decrypt(ConstCiphertext&lt;Element&gt; ciphertext, const PrivateKey&lt;Element&gt; privateKey,\n                          Plaintext* plaintext);\n\n    /**\n   * Decrypt a single ciphertext into the appropriate plaintext\n   *\n   * @param privateKey - decryption key\n   * @param ciphertext - ciphertext to decrypt\n   * @param plaintext - resulting plaintext object pointer is here\n   * @return\n   */\n    inline DecryptResult Decrypt(const PrivateKey&lt;Element&gt; privateKey, ConstCiphertext&lt;Element&gt; ciphertext,\n                                 Plaintext* plaintext) {\n        return Decrypt(ciphertext, privateKey, plaintext);\n    }\n\n    //------------------------------------------------------------------------------\n    // KeySwitch Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * KeySwitchGen creates a key that can be used with the OpenFHE KeySwitch\n   * operation\n   * @param oldPrivateKey input secrey key\n   * @param newPrivateKey output secret key\n   * @return new evaluation key\n   */\n    EvalKey&lt;Element&gt; KeySwitchGen(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                  const PrivateKey&lt;Element&gt; newPrivateKey) const {\n        CheckKey(oldPrivateKey);\n        CheckKey(newPrivateKey);\n\n        return GetScheme()-&gt;KeySwitchGen(oldPrivateKey, newPrivateKey);\n    }\n\n    /**\n   * KeySwitch - OpenFHE KeySwitch method\n   * @param ciphertext - ciphertext\n   * @param evalKey - evaluation key used for key switching\n   * @return new CiphertextImpl after applying key switch\n   */\n    Ciphertext&lt;Element&gt; KeySwitch(ConstCiphertext&lt;Element&gt; ciphertext, const EvalKey&lt;Element&gt; evalKey) const {\n        CheckCiphertext(ciphertext);\n        CheckKey(evalKey);\n\n        return GetScheme()-&gt;KeySwitch(ciphertext, evalKey);\n    }\n\n    /**\n   * KeySwitchInPlace - OpenFHE KeySwitchInPlace method\n   * @param ciphertext - ciphertext\n   * @param evalKey - evaluation key used for key switching\n   */\n    void KeySwitchInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const EvalKey&lt;Element&gt; evalKey) const {\n        CheckCiphertext(ciphertext);\n        CheckKey(evalKey);\n\n        GetScheme()-&gt;KeySwitchInPlace(ciphertext, evalKey);\n    }\n\n    //------------------------------------------------------------------------------\n    // SHE NEGATION Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * Negates a ciphertext\n   * @param ciphertext input ciphertext\n   * @return new ciphertext -ct\n   */\n    Ciphertext&lt;Element&gt; EvalNegate(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;EvalNegate(ciphertext);\n    }\n\n    /**\n   * In-place negation of a ciphertext\n   * @param ciphertext input ciphertext\n   */\n    void EvalNegateInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        CheckCiphertext(ciphertext);\n\n        GetScheme()-&gt;EvalNegateInPlace(ciphertext);\n    }\n\n    //------------------------------------------------------------------------------\n    // SHE ADDITION Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * Homomorphic addition of two ciphertexts\n   * @param ciphertext1 first addend\n   * @param ciphertext2 second addend\n   * @return the result as a new ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n        return GetScheme()-&gt;EvalAdd(ciphertext1, ciphertext2);\n    }\n\n    /**\n   * In-place homomorphic addition of two ciphertexts\n   * @param ciphertext1 first addend\n   * @param ciphertext2 second addend\n   * @return \\p ciphertext1 contains \\p ciphertext1 + \\p ciphertext2\n   */\n    void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n        GetScheme()-&gt;EvalAddInPlace(ciphertext1, ciphertext2);\n    }\n\n    /**\n   * Homomorphic addition of two mutable ciphertexts (they can be changed during the operation)\n   * @param ciphertext1 first addend\n   * @param ciphertext2 second addend\n   * @return the result as a new ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalAddMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n        return GetScheme()-&gt;EvalAddMutable(ciphertext1, ciphertext2);\n    }\n\n    /**\n   * In-place homomorphic addition of two mutable ciphertexts (they can be changed during the operation)\n   * @param ciphertext1 first addend\n   * @param ciphertext2 second addend\n   * @return \\p ciphertext1 contains \\p ciphertext1 + \\p ciphertext2\n   */\n    void EvalAddMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n        GetScheme()-&gt;EvalAddMutableInPlace(ciphertext1, ciphertext2);\n    }\n\n    /**\n   * EvalAdd - OpenFHE EvalAdd method for a ciphertext and plaintext\n   * @param ciphertext input ciphertext\n   * @param plaintext input plaintext\n   * @return new ciphertext for ciphertext + plaintext\n   */\n    Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const {\n        TypeCheck(ciphertext, plaintext);\n        plaintext-&gt;SetFormat(EVALUATION);\n        return GetScheme()-&gt;EvalAdd(ciphertext, plaintext);\n    }\n\n    /**\n   * EvalAdd - OpenFHE EvalAdd method for a ciphertext and plaintext\n   * @param plaintext input plaintext\n   * @param ciphertext input ciphertext\n   * @return new ciphertext for ciphertext + plaintext\n   */\n    Ciphertext&lt;Element&gt; EvalAdd(ConstPlaintext plaintext, ConstCiphertext&lt;Element&gt; ciphertext) const {\n        return EvalAdd(ciphertext, plaintext);\n    }\n\n    /**\n   * In-place addition for a ciphertext and plaintext\n   * @param ciphertext input ciphertext\n   * @param plaintext input plaintext\n   */\n    void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, ConstPlaintext plaintext) const {\n        TypeCheck(ciphertext, plaintext);\n        plaintext-&gt;SetFormat(EVALUATION);\n        GetScheme()-&gt;EvalAddInPlace(ciphertext, plaintext);\n    }\n\n    /**\n   * In-place addition for a ciphertext and plaintext\n   * @param plaintext input plaintext\n   * @param ciphertext input ciphertext\n   */\n    void EvalAddInPlace(ConstPlaintext plaintext, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        EvalAddInPlace(ciphertext, plaintext);\n    }\n\n    /**\n   * Homomorphic addition a mutable ciphertext and plaintext\n   * @param ciphertext input ciphertext\n   * @param plaintext input plaintext\n   * @return new ciphertext for ciphertext + plaintext\n   */\n    Ciphertext&lt;Element&gt; EvalAddMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        TypeCheck((ConstCiphertext&lt;Element&gt;)ciphertext, (ConstPlaintext)plaintext);\n        plaintext-&gt;SetFormat(EVALUATION);\n        return GetScheme()-&gt;EvalAddMutable(ciphertext, plaintext);\n    }\n\n    /**\n   * Homomorphic addition a mutable ciphertext and plaintext\n   * @param plaintext input plaintext\n   * @param ciphertext input ciphertext\n   * @return new ciphertext for ciphertext + plaintext\n   */\n    Ciphertext&lt;Element&gt; EvalAddMutable(Plaintext plaintext, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        return EvalAddMutable(ciphertext, plaintext);\n    }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, const NativeInteger&amp; constant) const {\n    //  return GetScheme()-&gt;EvalAdd(ciphertext, constant);\n    // }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // Ciphertext&lt;Element&gt; EvalAdd(const NativeInteger&amp; constant, ConstCiphertext&lt;Element&gt; ciphertext) const {\n    //  return EvalAdd(ciphertext, constant);\n    // }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const NativeInteger&amp; constant) const {\n    //  GetScheme()-&gt;EvalAddInPlace(ciphertext, constant);\n    // }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // void EvalAddInPlace(const NativeInteger&amp; constant, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n    //  EvalAddInPlace(ciphertext, constant);\n    // }\n\n    /**\n   * EvalAdd - OpenFHE EvalAdd method for a ciphertext and a real number.  Supported only in CKKS.\n   * @param ciphertext input ciphertext\n   * @param constant a real number\n   * @return new ciphertext for ciphertext + constant\n   */\n    Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        Ciphertext&lt;Element&gt; result =\n            constant &gt;= 0 ? GetScheme()-&gt;EvalAdd(ciphertext, constant) : GetScheme()-&gt;EvalSub(ciphertext, -constant);\n        return result;\n    }\n\n    /**\n   * EvalAdd - OpenFHE EvalAdd method for a ciphertext and a real number.  Supported only in CKKS.\n   * @param constant a real number\n   * @param ciphertext input ciphertext\n   * @return new ciphertext for ciphertext + constant\n   */\n    Ciphertext&lt;Element&gt; EvalAdd(double constant, ConstCiphertext&lt;Element&gt; ciphertext) const {\n        return EvalAdd(ciphertext, constant);\n    }\n\n    /**\n   * In-place addition of a ciphertext and a real number. Supported only in CKKS.\n   * @param ciphertext input ciphertext\n   * @param constant a real number\n   */\n    void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        if (constant == 0)\n            return;\n        if (constant &gt; 0) {\n            GetScheme()-&gt;EvalAddInPlace(ciphertext, constant);\n        }\n        else {\n            GetScheme()-&gt;EvalSubInPlace(ciphertext, std::fabs(constant));\n        }\n    }\n\n    /**\n   * In-place addition of a ciphertext and a real number.  Supported only in CKKS.\n   * @param constant a real number\n   * @param ciphertext input ciphertext\n   */\n    void EvalAddInPlace(double constant, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        EvalAddInPlace(ciphertext, constant);\n    }\n\n    //------------------------------------------------------------------------------\n    // SHE SUBTRACTION Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * Homomorphic subtraction of two ciphertexts\n   * @param ciphertext1 minuend\n   * @param ciphertext2 subtrahend\n   * @return the result as a new ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n        return GetScheme()-&gt;EvalSub(ciphertext1, ciphertext2);\n    }\n\n    /**\n   * In-place homomorphic subtraction of two ciphertexts\n   * @param ciphertext1 minuend\n   * @param ciphertext2 subtrahend\n   * @return the result as a new ciphertext\n   */\n    void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n        GetScheme()-&gt;EvalSubInPlace(ciphertext1, ciphertext2);\n    }\n\n    /**\n   * Homomorphic subtraction of two mutable ciphertexts\n   * @param ciphertext1 minuend\n   * @param ciphertext2 subtrahend\n   * @return the result as a new ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSubMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n        return GetScheme()-&gt;EvalSubMutable(ciphertext1, ciphertext2);\n    }\n\n    /**\n   * In-place homomorphic subtraction of two mutable ciphertexts\n   * @param ciphertext1 minuend\n   * @param ciphertext2 subtrahend\n   * @return the updated minuend\n   */\n    void EvalSubMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n        GetScheme()-&gt;EvalSubMutableInPlace(ciphertext1, ciphertext2);\n    }\n\n    /**\n   * Homomorphic subtraction of a ciphertext and plaintext\n   * @param ciphertext minuend\n   * @param plaintext subtrahend\n   * @return new ciphertext for ciphertext - plaintext\n   */\n    Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const {\n        TypeCheck(ciphertext, plaintext);\n        return GetScheme()-&gt;EvalSub(ciphertext, plaintext);\n    }\n\n    /**\n   * Homomorphic subtraction of a ciphertext and plaintext\n   * @param plaintext minuend\n   * @param ciphertext subtrahend\n   * @return new ciphertext for plaintext - ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSub(ConstPlaintext plaintext, ConstCiphertext&lt;Element&gt; ciphertext) const {\n        return EvalAdd(EvalNegate(ciphertext), plaintext);\n    }\n\n    /**\n   * Homomorphic subtraction of mutable ciphertext and plaintext\n   * @param ciphertext minuend\n   * @param plaintext subtrahend\n   * @return new ciphertext for ciphertext - plaintext\n   */\n    Ciphertext&lt;Element&gt; EvalSubMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        TypeCheck((ConstCiphertext&lt;Element&gt;)ciphertext, (ConstPlaintext)plaintext);\n        return GetScheme()-&gt;EvalSubMutable(ciphertext, plaintext);\n    }\n\n    /**\n   * Homomorphic subtraction of mutable ciphertext and plaintext\n   * @param plaintext minuend\n   * @param ciphertext subtrahend\n   * @return new ciphertext for plaintext - ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSubMutable(Plaintext plaintext, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        Ciphertext&lt;Element&gt; negated = EvalNegate(ciphertext);\n        Ciphertext&lt;Element&gt; result  = EvalAddMutable(negated, plaintext);\n        ciphertext                  = EvalNegate(negated);\n        return result;\n    }\n\n    /**\n   * Subtraction of a ciphertext and a real number. Supported only in CKKS.\n   * @param ciphertext input ciphertext\n   * @param constant a real number\n   * @return new ciphertext for ciphertext - constant\n   */\n    Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        Ciphertext&lt;Element&gt; result =\n            constant &gt;= 0 ? GetScheme()-&gt;EvalSub(ciphertext, constant) : GetScheme()-&gt;EvalAdd(ciphertext, -constant);\n        return result;\n    }\n\n    /**\n   * Subtraction of a ciphertext and a real number.  Supported only in CKKS.\n   * @param constant a real number\n   * @param ciphertext input ciphertext\n   * @return new ciphertext for constant - ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSub(double constant, ConstCiphertext&lt;Element&gt; ciphertext) const {\n        return EvalAdd(EvalNegate(ciphertext), constant);\n    }\n\n    /**\n   * In-place subtraction of a ciphertext and a real number.  Supported only in CKKS.\n   * @param ciphertext input ciphertext\n   * @param constant a real number\n   */\n    void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        if (constant &gt;= 0) {\n            GetScheme()-&gt;EvalSubInPlace(ciphertext, constant);\n        }\n        else {\n            GetScheme()-&gt;EvalAddInPlace(ciphertext, -constant);\n        }\n    }\n\n    /**\n   * In-placve subtraction of ciphertext from a real number.  Supported only in CKKS.\n   * @param constant a real number\n   * @param ciphertext input ciphertext\n   */\n    void EvalSubInPlace(double constant, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        EvalNegateInPlace(ciphertext);\n        EvalAddInPlace(ciphertext, constant);\n    }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, const NativeInteger&amp; constant) const {\n    //  return GetScheme()-&gt;EvalSub(ciphertext, constant);\n    // }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // Ciphertext&lt;Element&gt; EvalSub(const NativeInteger&amp; constant, ConstCiphertext&lt;Element&gt; ciphertext) const {\n    //  return EvalAdd(EvalNegate(ciphertext), constant);\n    // }\n\n    //  void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const NativeInteger&amp; constant) const {\n    //    GetScheme()-&gt;EvalSubInPlace(ciphertext, constant);\n    //  }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // void EvalSubInPlace(const NativeInteger&amp; constant, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n    //  EvalNegateInPlace(ciphertext);\n    //  EvalAddInPlace(ciphertext, constant);\n    // }\n\n    //------------------------------------------------------------------------------\n    // SHE MULTIPLICATION Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * EvalMultKeyGen creates a relinearization key (for s^2) that can be used with the OpenFHE EvalMult\n   * operator\n   * the new evaluation key is stored in cryptocontext\n   * @param key secret key\n   */\n    void EvalMultKeyGen(const PrivateKey&lt;Element&gt; key) {\n        if (key == nullptr || Mismatched(key-&gt;GetCryptoContext()))\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Key passed to EvalMultKeyGen were not generated with this crypto context&quot;);\n\n        EvalKey&lt;Element&gt; k = GetScheme()-&gt;EvalMultKeyGen(key);\n\n        GetAllEvalMultKeys()[k-&gt;GetKeyTag()] = {k};\n    }\n\n    /**\n   * EvalMultsKeyGen creates a vector evalmult keys that can be used with the\n   * OpenFHE EvalMult operator 1st key (for s^2) is used for multiplication of\n   * ciphertexts of depth 1 2nd key (for s^3) is used for multiplication of\n   * ciphertexts of depth 2, etc.\n   * a vector of new evaluation keys is stored in crytpocontext\n   *\n   * @param key secret key\n   */\n    void EvalMultKeysGen(const PrivateKey&lt;Element&gt; key) {\n        if (key == nullptr || Mismatched(key-&gt;GetCryptoContext()))\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Key passed to EvalMultsKeyGen were not generated with this crypto context&quot;);\n\n        const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeys = GetScheme()-&gt;EvalMultKeysGen(key);\n\n        GetAllEvalMultKeys()[evalKeys[0]-&gt;GetKeyTag()] = evalKeys;\n    }\n\n    /**\n   * EvalMult - OpenFHE EvalMult method for a pair of ciphertexts (uses a relinearization key from the crypto context)\n   * @param ciphertext1 multiplier\n   * @param ciphertext2 multiplicand\n   * @return new ciphertext for ciphertext1 * ciphertext2\n   */\n    Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertext1-&gt;GetKeyTag());\n        if (!evalKeyVec.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Evaluation key has not been generated for EvalMult&quot;);\n        }\n\n        return GetScheme()-&gt;EvalMult(ciphertext1, ciphertext2, evalKeyVec[0]);\n    }\n\n    /**\n   * EvalMult - OpenFHE EvalMult method for a pair of mutable ciphertexts (uses a relinearization key from the crypto context)\n   * @param ciphertext1 multiplier\n   * @param ciphertext2 multiplicand\n   * @return new ciphertext for ciphertext1 * ciphertext2\n   */\n    Ciphertext&lt;Element&gt; EvalMultMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertext1-&gt;GetKeyTag());\n        if (!evalKeyVec.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Evaluation key has not been generated for EvalMultMutable&quot;);\n        }\n\n        return GetScheme()-&gt;EvalMultMutable(ciphertext1, ciphertext2, evalKeyVec[0]);\n    }\n\n    /**\n   * In-place EvalMult method for a pair of mutable ciphertexts (uses a relinearization key from the crypto context)\n   * @param ciphertext1 multiplier\n   * @param ciphertext2 multiplicand\n   */\n    void EvalMultMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertext1-&gt;GetKeyTag());\n        if (!evalKeyVec.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Evaluation key has not been generated for EvalMultMutable&quot;);\n        }\n\n        GetScheme()-&gt;EvalMultMutableInPlace(ciphertext1, ciphertext2, evalKeyVec[0]);\n    }\n\n    /**\n   * Efficient homomorphic squaring of a ciphertext - uses a relinearization key stored in the crypto context\n   * @param ciphertext input ciphertext\n   * @return squared ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSquare(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        CheckCiphertext(ciphertext);\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertext-&gt;GetKeyTag());\n        if (!evalKeyVec.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Evaluation key has not been generated for EvalMult&quot;);\n        }\n\n        return GetScheme()-&gt;EvalSquare(ciphertext, evalKeyVec[0]);\n    }\n\n    /**\n   * Efficient homomorphic squaring of a mutable ciphertext - uses a relinearization key stored in the crypto context\n   * @param ciphertext input ciphertext\n   * @return squared ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSquareMutable(Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        CheckCiphertext(ciphertext);\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertext-&gt;GetKeyTag());\n        if (!evalKeyVec.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Evaluation key has not been generated for EvalMultMutable&quot;);\n        }\n\n        return GetScheme()-&gt;EvalSquareMutable(ciphertext, evalKeyVec[0]);\n    }\n\n    /**\n   * In-place homomorphic squaring of a mutable ciphertext - uses a relinearization key stored in the crypto context\n   * @param ciphertext input ciphertext\n   * @return squared ciphertext\n   */\n    void EvalSquareInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        CheckCiphertext(ciphertext);\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertext-&gt;GetKeyTag());\n        if (!evalKeyVec.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Evaluation key has not been generated for EvalMultMutable&quot;);\n        }\n\n        GetScheme()-&gt;EvalSquareInPlace(ciphertext, evalKeyVec[0]);\n    }\n\n    /**\n   * Homomorphic multiplication of two ciphertexts withour relinearization\n   * @param ciphertext1 multiplier\n   * @param ciphertext2 multiplicand\n   * @return new ciphertext for ciphertext1 * ciphertext2\n   */\n    Ciphertext&lt;Element&gt; EvalMultNoRelin(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                        ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        TypeCheck(ciphertext1, ciphertext2);\n        return GetScheme()-&gt;EvalMult(ciphertext1, ciphertext2);\n    }\n\n    /**\n   * Function for relinearization of a ciphertext to the lowest level (with 2 polynomials per ciphertext).\n   * @param ciphertext input ciphertext.\n   * @return relinearized ciphertext\n   */\n    Ciphertext&lt;Element&gt; Relinearize(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        // input parameter check\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Input ciphertext is nullptr&quot;);\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertext-&gt;GetKeyTag());\n\n        if (evalKeyVec.size() &lt; (ciphertext-&gt;GetElements().size() - 2)) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error,\n                          &quot;Insufficient value was used for maxRelinSkDeg to generate &quot;\n                          &quot;keys for EvalMult&quot;);\n        }\n\n        return GetScheme()-&gt;Relinearize(ciphertext, evalKeyVec);\n    }\n\n    /**\n   * In-place relinearization of a ciphertext to the lowest level (with 2 polynomials per ciphertext).\n   * @param ciphertext input ciphertext.\n   */\n    void RelinearizeInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        // input parameter check\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Input ciphertext is nullptr&quot;);\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertext-&gt;GetKeyTag());\n        if (evalKeyVec.size() &lt; (ciphertext-&gt;GetElements().size() - 2)) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error,\n                          &quot;Insufficient value was used for maxRelinSkDeg to generate &quot;\n                          &quot;keys for EvalMult&quot;);\n        }\n\n        GetScheme()-&gt;RelinearizeInPlace(ciphertext, evalKeyVec);\n    }\n\n    /**\n   * Homomorphic multiplication of two ciphertexts followed by relinearization to the lowest level\n   * @param ciphertext1 first input ciphertext.\n   * @param ciphertext2 second input ciphertext.\n   * @return new ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalMultAndRelinearize(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                               ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        // input parameter check\n        if (!ciphertext1 || !ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Input ciphertext is nullptr&quot;);\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertext1-&gt;GetKeyTag());\n\n        if (evalKeyVec.size() &lt; (ciphertext1-&gt;GetElements().size() + ciphertext2-&gt;GetElements().size() - 3)) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error,\n                          &quot;Insufficient value was used for maxRelinSkDeg to generate &quot;\n                          &quot;keys for EvalMult&quot;);\n        }\n\n        return GetScheme()-&gt;EvalMultAndRelinearize(ciphertext1, ciphertext2, evalKeyVec);\n    }\n\n    /**\n   * Multiplication of a ciphertext by a plaintext\n   * @param ciphertext multiplier\n   * @param plaintext multiplicand\n   * @return the result of multiplication\n   */\n    Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const {\n        TypeCheck(ciphertext, plaintext);\n        return GetScheme()-&gt;EvalMult(ciphertext, plaintext);\n    }\n\n    /**\n   * Multiplication of a plaintext by a ciphertext\n   * @param plaintext multiplier\n   * @param ciphertext multiplicand\n   * @return the result of multiplication\n   */\n    Ciphertext&lt;Element&gt; EvalMult(ConstPlaintext plaintext, ConstCiphertext&lt;Element&gt; ciphertext) const {\n        return EvalMult(ciphertext, plaintext);\n    }\n\n    /**\n   * Multiplication of mutable ciphertext and plaintext\n   * @param ciphertext multiplier\n   * @param plaintext multiplicand\n   * @return the result of multiplication\n   */\n    Ciphertext&lt;Element&gt; EvalMultMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        TypeCheck(ciphertext, plaintext);\n        return GetScheme()-&gt;EvalMultMutable(ciphertext, plaintext);\n    }\n\n    /**\n   * Multiplication of mutable plaintext and ciphertext\n   * @param plaintext multiplier\n   * @param ciphertext multiplicand\n   * @return the result of multiplication\n   */\n    Ciphertext&lt;Element&gt; EvalMultMutable(Plaintext plaintext, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        return EvalMultMutable(ciphertext, plaintext);\n    }\n\n    // template &lt;typename T = const NativeInteger,\n    //    typename std::enable_if &lt;!std::is_same&lt;ConstCiphertext&lt;Element&gt;, T&gt;::value, bool&gt;::type = true&gt;\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext, const NativeInteger&amp; constant) const {\n    //  if (!ciphertext) {\n    //    &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Input ciphertext is nullptr&quot;);\n    //  }\n    //  return GetScheme()-&gt;EvalMult(ciphertext, constant);\n    // }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // Ciphertext&lt;Element&gt; EvalMult(const NativeInteger&amp; constant, ConstCiphertext&lt;Element&gt; ciphertext) const {\n    //  return EvalMult(ciphertext, constant);\n    // }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const NativeInteger&amp; constant) const {\n    //  if (!ciphertext) {\n    //    &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Input ciphertext is nullptr&quot;);\n    //  }\n\n    //  GetScheme()-&gt;EvalMultInPlace(ciphertext, constant);\n    // }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // void EvalMultInPlace(const NativeInteger&amp; constant, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n    //  EvalMultInPlace(ciphertext, constant);\n    // }\n\n    /**\n   * Multiplication of a ciphertext by a real number.  Supported only in CKKS.\n   * @param ciphertext multiplier\n   * @param constant multiplicand\n   * @return the result of multiplication\n   */\n    Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        if (!ciphertext) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Input ciphertext is nullptr&quot;);\n        }\n        return GetScheme()-&gt;EvalMult(ciphertext, constant);\n    }\n\n    /**\n   * Multiplication of a ciphertext by a real number.  Supported only in CKKS.\n   * @param constant multiplier\n   * @param ciphertext multiplicand\n   * @return the result of multiplication\n   */\n    inline Ciphertext&lt;Element&gt; EvalMult(double constant, ConstCiphertext&lt;Element&gt; ciphertext) const {\n        return EvalMult(ciphertext, constant);\n    }\n\n    /**\n   * In-place multiplication of a ciphertext by a real number. Supported only in CKKS.\n   * @param ciphertext multiplier\n   * @param constant multiplicand\n   */\n    void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        if (!ciphertext) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Input ciphertext is nullptr&quot;);\n        }\n\n        GetScheme()-&gt;EvalMultInPlace(ciphertext, constant);\n    }\n\n    /**\n   * In-place multiplication of a ciphertext by a real number. Supported only in CKKS.\n   * @param constant multiplier (real number)\n   * @param ciphertext multiplicand\n   */\n    inline void EvalMultInPlace(double constant, Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        EvalMultInPlace(ciphertext, constant);\n    }\n\n    //------------------------------------------------------------------------------\n    // SHE AUTOMORPHISM Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * Generate automophism keys for a given private key; Uses the private key for\n   * encryption\n   *\n   * @param privateKey private key.\n   * @param indexList list of automorphism indices to be computed\n   * @return returns the evaluation keys\n   */\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalAutomorphismKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::vector&lt;usint&gt;&amp; indexList) const {\n        CheckKey(privateKey);\n        if (!indexList.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input index vector is empty&quot;);\n\n        return GetScheme()-&gt;EvalAutomorphismKeyGen(privateKey, indexList);\n    }\n\n    /**\n   * NOT USED BY ANY CRYPTO SCHEME: Generate automophism keys for a public and private key\n   */\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalAutomorphismKeyGen(\n        const PublicKey&lt;Element&gt; publicKey, const PrivateKey&lt;Element&gt; privateKey,\n        const std::vector&lt;usint&gt;&amp; indexList) const {\n        CheckKey(publicKey);\n        CheckKey(privateKey);\n        if (!indexList.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input index vector is empty&quot;);\n\n        return GetScheme()-&gt;EvalAutomorphismKeyGen(publicKey, privateKey, indexList);\n    }\n\n    /**\n   * Function for evaluating automorphism of ciphertext at index i\n   *\n   * @param ciphertext the input ciphertext.\n   * @param i automorphism index\n   * @param &amp;evalKeys - reference to the vector of evaluation keys generated by\n   * EvalAutomorphismKeyGen.\n   * @return resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalAutomorphism(ConstCiphertext&lt;Element&gt; ciphertext, usint i,\n                                         const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap,\n                                         CALLER_INFO_ARGS_HDR) const {\n        CheckCiphertext(ciphertext);\n\n        if (evalKeyMap.empty()) {\n            std::string errorMsg(std::string(&quot;Empty input key map&quot;) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(type_error, errorMsg);\n        }\n\n        auto key = evalKeyMap.find(i);\n\n        if (key == evalKeyMap.end()) {\n            std::string errorMsg(std::string(&quot;Could not find an EvalKey for index &quot;) + std::to_string(i) + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(type_error, errorMsg);\n        }\n\n        auto evalKey = key-&gt;second;\n\n        CheckKey(evalKey);\n\n        return GetScheme()-&gt;EvalAutomorphism(ciphertext, i, evalKeyMap);\n    }\n\n    /**\n   * Finds an automorphism index for a given vector index using a scheme-specific algorithm\n   * @param idx regular vector index\n   * @return the automorphism index\n   */\n    usint FindAutomorphismIndex(const usint idx) const {\n        const auto cryptoParams  = GetCryptoParameters();\n        const auto elementParams = cryptoParams-&gt;GetElementParams();\n        uint32_t m               = elementParams-&gt;GetCyclotomicOrder();\n        return GetScheme()-&gt;FindAutomorphismIndex(idx, m);\n    }\n\n    /**\n   * Finds automorphism indices for a given list of vector indices using a scheme-specific algorithm\n   * @param idxList vector of indices\n   * @return a vector of automorphism indices\n   */\n    std::vector&lt;usint&gt; FindAutomorphismIndices(const std::vector&lt;usint&gt;&amp; idxList) const {\n        std::vector&lt;usint&gt; newIndices;\n        newIndices.reserve(idxList.size());\n        for (const auto idx : idxList) {\n            newIndices.emplace_back(FindAutomorphismIndex(idx));\n        }\n        return newIndices;\n    }\n\n    /**\n   * Rotates a ciphertext by an index (positive index is a left shift, negative index is a right shift).\n   * Uses a rotation key stored in a crypto context.\n   * Calls EvalAtIndex under the hood.\n   * @param ciphertext input ciphertext\n   * @param index rotation index\n   * @return a rotated ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalRotate(ConstCiphertext&lt;Element&gt; ciphertext, int32_t index) const {\n        CheckCiphertext(ciphertext);\n\n        auto evalKeyMap = GetEvalAutomorphismKeyMap(ciphertext-&gt;GetKeyTag());\n        return GetScheme()-&gt;EvalAtIndex(ciphertext, index, evalKeyMap);\n    }\n\n    /**\n   * EvalFastRotationPrecompute implements the precomputation step of\n   * hoisted automorphisms.\n   *\n   * Please refer to Section 5 of Halevi and Shoup, &quot;Faster Homomorphic\n   * linear transformations in HELib.&quot; for more details, link:\n   * https://eprint.iacr.org/2018/244.\n   *\n   * Generally, automorphisms are performed with three steps: (1) the\n   * automorphism is applied on the ciphertext, (2) the automorphed values are\n   * decomposed into digits, and (3) key switching is applied to make it\n   * possible to further compute on the ciphertext.\n   *\n   * Hoisted automorphisms is a technique that performs the digit decomposition\n   * for the original ciphertext first, and then performs the automorphism and\n   * the key switching on the decomposed digits. The benefit of this is that the\n   * digit decomposition is independent of the automorphism rotation index, so\n   * it can be reused for multiple different indices. This can greatly improve\n   * performance when we have to compute many automorphisms on the same\n   * ciphertext. This routinely happens when we do permutations (EvalPermute).\n   *\n   * EvalFastRotationPrecompute implements the digit decomposition step of\n   * hoisted automorphisms.\n   *\n   * @param ciphertext the input ciphertext on which to do the precomputation (digit\n   * decomposition)\n   */\n    std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EvalFastRotationPrecompute(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        return GetScheme()-&gt;EvalFastRotationPrecompute(ciphertext);\n    }\n\n    /**\n   * EvalFastRotation implements the automorphism and key switching step of\n   * hoisted automorphisms.\n   *\n   * Please refer to Section 5 of Halevi and Shoup, &quot;Faster Homomorphic\n   * linear transformations in HELib.&quot; for more details, link:\n   * https://eprint.iacr.org/2018/244.\n   *\n   * Generally, automorphisms are performed with three steps: (1) the\n   * automorphism is applied on the ciphertext, (2) the automorphed values are\n   * decomposed into digits, and (3) key switching is applied to make it\n   * possible to further compute on the ciphertext.\n   *\n   * Hoisted automorphisms is a technique that performs the digit decomposition\n   * for the original ciphertext first, and then performs the automorphism and\n   * the key switching on the decomposed digits. The benefit of this is that the\n   * digit decomposition is independent of the automorphism rotation index, so\n   * it can be reused for multiple different indices. This can greatly improve\n   * performance when we have to compute many automorphisms on the same\n   * ciphertext. This routinely happens when we do permutations (EvalPermute).\n   *\n   * EvalFastRotation implements the automorphism and key swithcing step of\n   * hoisted automorphisms.\n   *\n   * This method assumes that all required rotation keys exist. This may not be\n   * true if we are using baby-step/giant-step key switching. Please refer to\n   * Section 5.1 of the above reference and EvalPermuteBGStepHoisted to see how\n   * to deal with this issue.\n   *\n   * @param ciphertext the input ciphertext to perform the automorphism on\n   * @param index the index of the rotation. Positive indices correspond to left\n   * rotations and negative indices correspond to right rotations.\n   * @param m is the cyclotomic order\n   * @param digits the digit decomposition created by EvalFastRotationPrecompute\n   * at the precomputation step.\n   */\n    Ciphertext&lt;Element&gt; EvalFastRotation(ConstCiphertext&lt;Element&gt; ciphertext, const usint index, const usint m,\n                                         const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits) const {\n        return GetScheme()-&gt;EvalFastRotation(ciphertext, index, m, digits);\n    }\n\n    /**\n   * Only supported for hybrid key switching.\n   * Performs fast (hoisted) rotation and returns the results\n   * in the extended CRT basis P*Q\n   *\n   * @param ciphertext input ciphertext\n   * @param index the rotation index.\n   * @param digits the precomputed digits for the ciphertext\n   * @param addFirst if true, the the first element c0 is also computed (otherwise ignored)\n   * @return resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalFastRotationExt(ConstCiphertext&lt;Element&gt; ciphertext, usint index,\n                                            const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits, bool addFirst) const {\n        auto evalKeyMap = GetEvalAutomorphismKeyMap(ciphertext-&gt;GetKeyTag());\n\n        return GetScheme()-&gt;EvalFastRotationExt(ciphertext, index, digits, addFirst, evalKeyMap);\n    }\n\n    /**\n   * Only supported for hybrid key switching.\n   * Takes a ciphertext in the extended basis P*Q\n   * and scales down to Q.\n   *\n   * @param ciphertext input ciphertext in the extended basis\n   * @return resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; KeySwitchDown(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        return GetScheme()-&gt;KeySwitchDown(ciphertext);\n    }\n\n    /**\n   * Only supported for hybrid key switching.\n   * Scales down the polynomial c0 from extended basis P*Q to Q.\n   *\n   * @param ciphertext input ciphertext in the extended basis\n   * @return resulting polynomial\n   */\n    Element KeySwitchDownFirstElement(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        return GetScheme()-&gt;KeySwitchDownFirstElement(ciphertext);\n    }\n\n    /**\n   * Only supported for hybrid key switching.\n   * Takes a ciphertext in the normal basis Q\n   * and extends it to extended basis P*Q.\n   *\n   * @param ciphertext input ciphertext in basis Q\n   * @return resulting ciphertext in basis P*Q\n   */\n    Ciphertext&lt;Element&gt; KeySwitchExt(ConstCiphertext&lt;Element&gt; ciphertext, bool addFirst) const {\n        return GetScheme()-&gt;KeySwitchExt(ciphertext, addFirst);\n    }\n\n    /**\n   * EvalAtIndexKeyGen generates evaluation keys for a list of rotation indices\n   *\n   * @param privateKey private key.\n   * @param indexList list of indices.\n   * @param publicKey public key (used in NTRU schemes). Not used anymore.\n   */\n    void EvalAtIndexKeyGen(const PrivateKey&lt;Element&gt; privateKey, const std::vector&lt;int32_t&gt;&amp; indexList,\n                           const PublicKey&lt;Element&gt; publicKey = nullptr);\n\n    /**\n   * EvalRotateKeyGen generates evaluation keys for a list of rotation indices.\n   * Calls EvalAtIndexKeyGen under the hood.\n   *\n   * @param privateKey private key.\n   * @param indexList list of indices.\n   * @param publicKey public key (used in NTRU schemes).\n   */\n    void EvalRotateKeyGen(const PrivateKey&lt;Element&gt; privateKey, const std::vector&lt;int32_t&gt;&amp; indexList,\n                          const PublicKey&lt;Element&gt; publicKey = nullptr) {\n        EvalAtIndexKeyGen(privateKey, indexList, publicKey);\n    };\n\n    /**\n   * Rotates a ciphertext by an index (positive index is a left shift, negative index is a right shift).\n   * Uses a rotation key stored in a crypto context.\n   * @param ciphertext input ciphertext\n   * @param index rotation index\n   * @return a rotated ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalAtIndex(ConstCiphertext&lt;Element&gt; ciphertext, int32_t index) const;\n\n    //------------------------------------------------------------------------------\n    // SHE Leveled Methods Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * ComposedEvalMult - calls multiplication, relinearization, and then modulus switching/rescaling.\n   * Uses a relinearization key stored in the crypto context.\n   * @param ciphertext1 - first ciphertext\n   * @param ciphertext2 - second ciphertext\n   */\n    Ciphertext&lt;Element&gt; ComposedEvalMult(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                         ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        CheckCiphertext(ciphertext1);\n        CheckCiphertext(ciphertext2);\n\n        auto evalKeyVec = GetEvalMultKeyVector(ciphertext1-&gt;GetKeyTag());\n        if (!evalKeyVec.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Evaluation key has not been generated for EvalMult&quot;);\n        }\n\n        return GetScheme()-&gt;ComposedEvalMult(ciphertext1, ciphertext2, evalKeyVec[0]);\n    }\n\n    /**\n   * Rescale - An alias for OpenFHE ModReduce method.\n   * This is because ModReduce is called Rescale in CKKS.\n   *\n   * @param ciphertext - ciphertext\n   * @return rescaled ciphertext\n   */\n    Ciphertext&lt;Element&gt; Rescale(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;ModReduce(ciphertext, BASE_NUM_LEVELS_TO_DROP);\n    }\n\n    /**\n   * Rescale - An alias for OpenFHE ModReduceInPlace method.\n   * This is because ModReduceInPlace is called RescaleInPlace in CKKS.\n   *\n   * @param ciphertext - ciphertext to be rescaled in-place\n   */\n    void RescaleInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        CheckCiphertext(ciphertext);\n\n        GetScheme()-&gt;ModReduceInPlace(ciphertext, BASE_NUM_LEVELS_TO_DROP);\n    }\n\n    /**\n   * ModReduce - OpenFHE ModReduce method used only for BGV/CKKS.\n   * @param ciphertext - ciphertext\n   * @return mod reduced ciphertext\n   */\n    Ciphertext&lt;Element&gt; ModReduce(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;ModReduce(ciphertext, BASE_NUM_LEVELS_TO_DROP);\n    }\n\n    /**\n   * ModReduce - OpenFHE ModReduceInPlace method used only for BGV/CKKS.\n   * @param ciphertext - ciphertext to be mod-reduced in-place\n   */\n    void ModReduceInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        CheckCiphertext(ciphertext);\n\n        GetScheme()-&gt;ModReduceInPlace(ciphertext, BASE_NUM_LEVELS_TO_DROP);\n    }\n\n    /**\n   * LevelReduce - drops unnecessary RNS limbs (levels) from the ciphertext and evaluation key\n   * @param ciphertext input ciphertext. Supported only in BGV/CKKS.\n   * @param evalKey input evaluation key (modified in place)\n   * @returns the ciphertext with reduced number opf RNS limbs\n   */\n    Ciphertext&lt;Element&gt; LevelReduce(ConstCiphertext&lt;Element&gt; ciphertext, const EvalKey&lt;Element&gt; evalKey,\n                                    size_t levels = 1) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;LevelReduce(ciphertext, evalKey, levels);\n    }\n\n    /**\n   * LevelReduceInPlace - drops unnecessary RNS limbs (levels) from the ciphertext and evaluation key. Supported only in BGV/CKKS.\n   * @param ciphertext input ciphertext (modified in place)\n   * @param evalKey input evaluation key (modified in place)\n   */\n    void LevelReduceInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const EvalKey&lt;Element&gt; evalKey, size_t levels = 1) const {\n        CheckCiphertext(ciphertext);\n        if (levels &lt;= 0) {\n            return;\n        }\n        GetScheme()-&gt;LevelReduceInPlace(ciphertext, evalKey, levels);\n    }\n    /**\n   * Compress - Reduces the size of ciphertext modulus to minimize the\n   * communication cost before sending the encrypted result for decryption.\n   * Similar to ModReduce but for BFV where ModReduce is not exposed directly.\n   * @param ciphertext - input ciphertext\n   * @param numTowers - number of RNS limbs after compressing (default is 1)\n   * @return compressed ciphertext\n   */\n    Ciphertext&lt;Element&gt; Compress(ConstCiphertext&lt;Element&gt; ciphertext, uint32_t towersLeft = 1) const {\n        if (ciphertext == nullptr)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;input ciphertext is invalid (has no data)&quot;);\n\n        return GetScheme()-&gt;Compress(ciphertext, towersLeft);\n    }\n\n    //------------------------------------------------------------------------------\n    // Advanced SHE Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * EvalAddMany - Evaluate addition on a vector of ciphertexts.\n   * It computes the addition in a binary tree manner.\n   *\n   * @param ctList is the list of ciphertexts.\n   * @return new ciphertext.\n   */\n    Ciphertext&lt;Element&gt; EvalAddMany(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const {\n        // input parameter check\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Empty input ciphertext vector&quot;);\n\n        if (ciphertextVec.size() == 1) {\n            return ciphertextVec[0];\n        }\n\n        return GetScheme()-&gt;EvalAddMany(ciphertextVec);\n    }\n\n    /**\n   * EvalAddManyInPlace - Evaluate addition on a vector of ciphertexts.\n   * Addition is computed in a binary tree manner. Difference with EvalAddMany\n   * is that EvalAddManyInPlace uses the input ciphertext vector to store\n   * intermediate results, to avoid the overhead of using extra tepmorary\n   * space.\n   *\n   * @param ctList is the list of ciphertexts.\n   * @return new ciphertext.\n   */\n    Ciphertext&lt;Element&gt; EvalAddManyInPlace(std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const {\n        // input parameter check\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Empty input ciphertext vector&quot;);\n\n        return GetScheme()-&gt;EvalAddManyInPlace(ciphertextVec);\n    }\n\n    /**\n   * EvalMultMany - OpenFHE function for evaluating multiplication on\n   * ciphertext followed by relinearization operation (at the end). It computes\n   * the multiplication in a binary tree manner. Also, it reduces the number of\n   * elements in the ciphertext to two after each multiplication.\n   * Currently it assumes that the consecutive two input arguments have\n   * total number of ring elements smaller than the supported one (for the secret key degree used by EvalMultsKeyGen). Otherwise, it throws an\n   * error.\n   *\n   * @param ciphertextVec  is the ciphertext list.\n   * @return new ciphertext.\n   */\n    Ciphertext&lt;Element&gt; EvalMultMany(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const {\n        // input parameter check\n        if (!ciphertextVec.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Empty input ciphertext vector&quot;);\n        }\n\n        if (ciphertextVec.size() == 1) {\n            return ciphertextVec[0];\n        }\n\n        const auto evalKeyVec = GetEvalMultKeyVector(ciphertextVec[0]-&gt;GetKeyTag());\n        if (evalKeyVec.size() &lt; (ciphertextVec[0]-&gt;GetElements().size() - 2)) {\n            &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Insufficient value was used for maxRelinSkDeg to generate keys&quot;);\n        }\n\n        return GetScheme()-&gt;EvalMultMany(ciphertextVec, evalKeyVec);\n    }\n\n    //------------------------------------------------------------------------------\n    // Advanced SHE LINEAR WEIGHTED SUM\n    //------------------------------------------------------------------------------\n\n    /**\n   * EvalLinearWSum - OpenFHE EvalLinearWSum method to compute a linear\n   * weighted sum. Supported only in CKKS.\n   *\n   * @param ciphertextVec&amp; a list of ciphertexts\n   * @param constantVec&amp; a list of weights\n   * @return new ciphertext containing the weighted sum\n   */\n    Ciphertext&lt;Element&gt; EvalLinearWSum(std::vector&lt;ConstCiphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                       const std::vector&lt;double&gt;&amp; constantVec) const {\n        return GetScheme()-&gt;EvalLinearWSum(ciphertextVec, constantVec);\n    }\n\n    /**\n   * EvalLinearWSum - OpenFHE EvalLinearWSum method to compute a linear\n   * weighted sum. Supported only in CKKS.\n   *\n   * @param constantVec&amp; a list of weights\n   * @param ciphertextVec&amp; a list of ciphertexts\n   * @return new ciphertext containing the weighted sum\n   */\n    Ciphertext&lt;Element&gt; EvalLinearWSum(const std::vector&lt;double&gt;&amp; constantsVec,\n                                       std::vector&lt;ConstCiphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const {\n        return EvalLinearWSum(ciphertextVec, constantsVec);\n    }\n\n    /**\n   * EvalLinearWSum - OpenFHE EvalLinearWSum method to compute a linear\n   * weighted sum (mutable version). Supported only in CKKS.\n   *\n   * @param ciphertextVec&amp; ciphertexts a list of mutable ciphertexts\n   * @param constantVec&amp; constants a list of weights\n   * @return new ciphertext containing the weighted sum\n   */\n    Ciphertext&lt;Element&gt; EvalLinearWSumMutable(std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                              const std::vector&lt;double&gt;&amp; constantsVec) const {\n        return GetScheme()-&gt;EvalLinearWSumMutable(ciphertextVec, constantsVec);\n    }\n\n    /**\n   * EvalLinearWSum - OpenFHE EvalLinearWSum method to compute a linear\n   * weighted sum (mutable version). Supported only in CKKS.\n   *\n   * @param constantVec&amp; constants a list of weights\n   * @param ciphertextVec&amp; ciphertexts a list of mutable ciphertexts\n   * @return new ciphertext containing the weighted sum\n   */\n    Ciphertext&lt;Element&gt; EvalLinearWSumMutable(const std::vector&lt;double&gt;&amp; constantsVec,\n                                              std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const {\n        return EvalLinearWSumMutable(ciphertextVec, constantsVec);\n    }\n\n    //------------------------------------------------------------------------------\n    // Advanced SHE EVAL POLYNOMIAL\n    //------------------------------------------------------------------------------\n\n    /**\n   * Method for evaluation for polynomials represented as power series. Supported only in CKKS.\n   * If the degree of the polynomial is less than 5, use\n   * EvalPolyLinear (naive linear method), otherwise, use EvalPolyPS (Paterson-Stockmeyer method).\n   *\n   * @param ciphertext input ciphertext\n   * @param &amp;coefficients is the vector of coefficients in the polynomial; the\n   * size of the vector is the degree of the polynomial + 1\n   * @return the result of polynomial evaluation.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalPoly(ConstCiphertext&lt;Element&gt; ciphertext,\n                                         const std::vector&lt;double&gt;&amp; coefficients) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;EvalPoly(ciphertext, coefficients);\n    }\n\n    /**\n   * Naive method for polynomial evaluation for polynomials represented in the power\n   * series (fast only for small-degree polynomials; less than 10). Uses a binary tree computation of\n   * the polynomial powers. Supported only in CKKS.\n   *\n   * @param cipherText input ciphertext\n   * @param &amp;coefficients is the vector of coefficients in the polynomial; the\n   * size of the vector is the degree of the polynomial\n   * @return the result of polynomial evaluation.\n   */\n    Ciphertext&lt;Element&gt; EvalPolyLinear(ConstCiphertext&lt;Element&gt; ciphertext,\n                                       const std::vector&lt;double&gt;&amp; coefficients) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;EvalPolyLinear(ciphertext, coefficients);\n    }\n\n    /**\n   * Paterson-Stockmeyer method for evaluation for polynomials represented in the power\n   * series. Supported only in CKKS.\n   *\n   * @param cipherText input ciphertext\n   * @param &amp;coefficients is the vector of coefficients in the polynomial; the\n   * size of the vector is the degree of the polynomial\n   * @return the result of polynomial evaluation.\n   */\n    Ciphertext&lt;Element&gt; EvalPolyPS(ConstCiphertext&lt;Element&gt; ciphertext, const std::vector&lt;double&gt;&amp; coefficients) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;EvalPolyPS(ciphertext, coefficients);\n    }\n\n    //------------------------------------------------------------------------------\n    // Advanced SHE EVAL CHEBYSHEV SERIES\n    //------------------------------------------------------------------------------\n\n    /**\n   * Method for evaluating Chebyshev polynomial interpolation;\n   * first the range [a,b] is mapped to [-1,1] using linear transformation 1 + 2\n   * (x-a)/(b-a) If the degree of the polynomial is less than 5, use\n   * EvalChebyshevSeriesLinear (naive linear method), otherwise, use EvalChebyshevSeriesPS (Paterson-Stockmeyer method).\n   * Supported only in CKKS.\n   *\n   * @param cipherText input ciphertext\n   * @param &amp;coefficients is the vector of coefficients in Chebyshev expansion\n   * @param a - lower bound of argument for which the coefficients were found\n   * @param b - upper bound of argument for which the coefficients were found\n   * @return the result of polynomial evaluation.\n   */\n    Ciphertext&lt;Element&gt; EvalChebyshevSeries(ConstCiphertext&lt;Element&gt; ciphertext,\n                                            const std::vector&lt;double&gt;&amp; coefficients, double a, double b) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;EvalChebyshevSeries(ciphertext, coefficients, a, b);\n    }\n\n    /**\n   * Naive linear method for evaluating Chebyshev polynomial interpolation;\n   * first the range [a,b] is mapped to [-1,1] using linear transformation 1 + 2\n   * (x-a)/(b-a). Supported only in CKKS.\n   *\n   * @param cipherText input ciphertext\n   * @param &amp;coefficients is the vector of coefficients in Chebyshev expansion\n   * @param a - lower bound of argument for which the coefficients were found\n   * @param b - upper bound of argument for which the coefficients were found\n   * @return the result of polynomial evaluation.\n   */\n    Ciphertext&lt;Element&gt; EvalChebyshevSeriesLinear(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                  const std::vector&lt;double&gt;&amp; coefficients, double a, double b) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;EvalChebyshevSeriesLinear(ciphertext, coefficients, a, b);\n    }\n\n    /**\n   * Paterson-Stockmeyer method for evaluating Chebyshev polynomial interpolation;\n   * first the range [a,b] is mapped to [-1,1] using linear transformation 1 + 2\n   * (x-a)/(b-a). Supported only in CKKS.\n   *\n   * @param cipherText input ciphertext\n   * @param &amp;coefficients is the vector of coefficients in Chebyshev expansion\n   * @param a - lower bound of argument for which the coefficients were found\n   * @param b - upper bound of argument for which the coefficients were found\n   * @return the result of polynomial evaluation.\n   */\n    Ciphertext&lt;Element&gt; EvalChebyshevSeriesPS(ConstCiphertext&lt;Element&gt; ciphertext,\n                                              const std::vector&lt;double&gt;&amp; coefficients, double a, double b) const {\n        CheckCiphertext(ciphertext);\n\n        return GetScheme()-&gt;EvalChebyshevSeriesPS(ciphertext, coefficients, a, b);\n    }\n\n    /**\n   * Method for calculating Chebyshev evaluation on a ciphertext for a smooth input\n   * function over the range [a,b]. Supported only in CKKS.\n   *\n   * @param func is the function to be approximated\n   * @param ciphertext input ciphertext\n   * @param a - lower bound of argument for which the coefficients were found\n   * @param b - upper bound of argument for which the coefficients were found\n   * @param degree Desired degree of approximation\n   * @return the coefficients of the Chebyshev approximation.\n   */\n    Ciphertext&lt;Element&gt; EvalChebyshevFunction(std::function&lt;double(double)&gt; func, ConstCiphertext&lt;Element&gt; ciphertext,\n                                              double a, double b, uint32_t degree) const;\n\n    /**\n   * Evaluate approximate sine function on a ciphertext using the Chebyshev approximation.\n   * Supported only in CKKS.\n   *\n   * @param ciphertext input ciphertext\n   * @param a - lower bound of argument for which the coefficients were found\n   * @param b - upper bound of argument for which the coefficients were found\n   * @param degree Desired degree of approximation\n   * @return the result of polynomial evaluation.\n   */\n    Ciphertext&lt;Element&gt; EvalSin(ConstCiphertext&lt;Element&gt; ciphertext, double a, double b, uint32_t degree) const;\n\n    /**\n   * Evaluate approximate cosine function on a ciphertext using the Chebyshev approximation.\n   * Supported only in CKKS.\n   *\n   * @param ciphertext input ciphertext\n   * @param a - lower bound of argument for which the coefficients were found\n   * @param b - upper bound of argument for which the coefficients were found\n   * @param degree Desired degree of approximation\n   * @return the result of polynomial evaluation.\n   */\n    Ciphertext&lt;Element&gt; EvalCos(ConstCiphertext&lt;Element&gt; ciphertext, double a, double b, uint32_t degree) const;\n\n    /**\n   * Evaluate approximate logistic function 1/(1 + exp(-x)) on a ciphertext using the Chebyshev approximation.\n   * Supported only in CKKS.\n   *\n   * @param ciphertext input ciphertext\n   * @param a - lower bound of argument for which the coefficients were found\n   * @param b - upper bound of argument for which the coefficients were found\n   * @param degree Desired degree of approximation\n   * @return the result of polynomial evaluation.\n   */\n    Ciphertext&lt;Element&gt; EvalLogistic(ConstCiphertext&lt;Element&gt; ciphertext, double a, double b, uint32_t degree) const;\n\n    /**\n   * Evaluate approximate division function 1/x where x &gt;= 1 on a ciphertext using the Chebyshev approximation.\n   * Supported only in CKKS.\n   *\n   * @param ciphertext input ciphertext\n   * @param a - lower bound of argument for which the coefficients were found\n   * @param b - upper bound of argument for which the coefficients were found\n   * @param degree Desired degree of approximation\n   * @return the result of polynomial evaluation.\n   */\n    Ciphertext&lt;Element&gt; EvalDivide(ConstCiphertext&lt;Element&gt; ciphertext, double a, double b, uint32_t degree) const;\n\n    //------------------------------------------------------------------------------\n    // Advanced SHE EVAL SUM\n    //------------------------------------------------------------------------------\n\n    /**\n   * EvalSumKeyGen Generates the key map to be used by EvalSum\n   *\n   * @param privateKey private key.\n   * @param publicKey public key (used in NTRU schemes).\n   */\n    void EvalSumKeyGen(const PrivateKey&lt;Element&gt; privateKey, const PublicKey&lt;Element&gt; publicKey = nullptr);\n\n    /**\n   * Generate the automorphism keys for EvalSumRows; works\n   * only for packed encoding\n   *\n   * @param privateKey private key.\n   * @param publicKey public key.\n   * @param rowSize size of rows in the matrix\n   * @param subringDim subring dimension (set to cyclotomic order if set to 0)\n   * @return returns the evaluation keys\n   */\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSumRowsKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                                                         const PublicKey&lt;Element&gt; publicKey = nullptr,\n                                                                         usint rowSize = 0, usint subringDim = 0);\n    /**\n   * Generates the automorphism keys for EvalSumCols; works\n   * only for packed encoding\n   *\n   * @param privateKey private key.\n   * @param publicKey public key.\n   * @return returns the evaluation keys\n   */\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSumColsKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                                                         const PublicKey&lt;Element&gt; publicKey = nullptr);\n\n    /**\n   * Function for evaluating a sum of all components in a vector.\n   *\n   * @param ciphertext the input ciphertext.\n   * @param batchSize size of the batch\n   * @return resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSum(ConstCiphertext&lt;Element&gt; ciphertext, usint batchSize) const;\n\n    /**\n   * Sums all elements over row-vectors in a matrix - works only with packed\n   * encoding\n   *\n   * @param ciphertext the input ciphertext.\n   * @param rowSize size of rows in the matrix\n   * @param &amp;evalSumKeyMap - reference to the map of evaluation keys generated by\n   * @param subringDim the current cyclotomic order/subring dimension. If set to\n   * 0, we use the full cyclotomic order.\n   * @return resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSumRows(ConstCiphertext&lt;Element&gt; ciphertext, usint rowSize,\n                                    const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalSumKeyMap, usint subringDim = 0) const;\n\n    /**\n   * Sums all elements over column-vectors in a matrix - works only with packed\n   * encoding\n   *\n   * @param ciphertext the input ciphertext.\n   * @param rowSize size of rows in the matrix\n   * @param &amp;evalSumKeyMap - reference to the map of evaluation keys generated by\n   * @return resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalSumCols(ConstCiphertext&lt;Element&gt; ciphertext, usint rowSize,\n                                    const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalSumKeyMap) const;\n\n    //------------------------------------------------------------------------------\n    // Advanced SHE EVAL INNER PRODUCT\n    //------------------------------------------------------------------------------\n\n    /**\n   * Evaluates inner product in packed encoding (uses EvalSum)\n   *\n   * @param ciphertext1 first vector.\n   * @param ciphertext2 second vector.\n   * @param batchSize size of the batch to be summed up\n   * @return resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalInnerProduct(ConstCiphertext&lt;Element&gt; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2,\n                                         usint batchSize) const;\n\n    /**\n   * Evaluates inner product in packed encoding (uses EvalSum)\n   *\n   * @param ciphertext1 first vector - ciphertext.\n   * @param plaintext second vector - plaintext.\n   * @param batchSize size of the batch to be summed up\n   * @return resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalInnerProduct(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext,\n                                         usint batchSize) const;\n\n    /**\n   * Merges multiple ciphertexts with encrypted results in slot 0 into a single\n   * ciphertext. The slot assignment is done based on the order of ciphertexts in\n   * the vector. Requires the generation of rotation keys for the indices that are needed.\n   *\n   * @param ciphertextVector vector of ciphertexts to be merged.\n   * @return resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; EvalMerge(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const;\n\n    //------------------------------------------------------------------------------\n    // PRE Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * ReKeyGen produces an Eval Key that OpenFHE can use for Proxy Re-Encryption\n   * @param oldPrivateKey original secret key\n   * @param newPublicKey public key for the new secret key\n   * @return new evaluation key\n   */\n    EvalKey&lt;Element&gt; ReKeyGen(const PrivateKey&lt;Element&gt; oldPrivateKey, const PublicKey&lt;Element&gt; newPublicKey) const {\n        CheckKey(oldPrivateKey);\n        CheckKey(newPublicKey);\n\n        return GetScheme()-&gt;ReKeyGen(oldPrivateKey, newPublicKey);\n    }\n\n    /**\n   * ReKeyGen produces an Eval Key that OpenFHE can use for Proxy Re-Encryption\n   * NOTE this functionality has been completely removed from OpenFHE\n   * @param oldPrivateKey original secret key\n   * @param newPrivateKey new secret key\n   * @return new evaluation key\n   */\n    EvalKey&lt;Element&gt; ReKeyGen(const PrivateKey&lt;Element&gt; originalPrivateKey,\n                              const PrivateKey&lt;Element&gt; newPrivateKey) const\n        __attribute__((deprecated(&quot;functionality removed from OpenFHE&quot;)));\n\n    /**\n   * ReEncrypt - Proxy Re-Encryption mechanism for OpenFHE\n   * @param ciphertext - input ciphertext\n   * @param evalKey - evaluation key from the PRE keygen method\n   * @param publicKey the public key of the recipient of the re-encrypted\n   * ciphertext.\n   * @return the resulting ciphertext\n   */\n    Ciphertext&lt;Element&gt; ReEncrypt(ConstCiphertext&lt;Element&gt; ciphertext, EvalKey&lt;Element&gt; evalKey,\n                                  const PublicKey&lt;Element&gt; publicKey = nullptr) const {\n        CheckCiphertext(ciphertext);\n        CheckKey(evalKey);\n\n        return GetScheme()-&gt;ReEncrypt(ciphertext, evalKey, publicKey);\n    }\n\n    //------------------------------------------------------------------------------\n    // Multiparty Wrapper\n    //------------------------------------------------------------------------------\n\n    /**\n   * Threshold FHE: Generates a public key from a vector of secret shares.\n   * ONLY FOR DEBUGGIN PURPOSES. SHOULD NOT BE USED IN PRODUCTION.\n   *\n   * @param &amp;privateKeyVec secrete key shares.\n   * @return key pair including the private for the current party and joined\n   * public key\n   */\n    KeyPair&lt;Element&gt; MultipartyKeyGen(const std::vector&lt;PrivateKey&lt;Element&gt;&gt;&amp; privateKeyVec) {\n        if (!privateKeyVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key vector is empty&quot;);\n        return GetScheme()-&gt;MultipartyKeyGen(GetContextForPointer(this), privateKeyVec, false);\n    }\n\n    /**\n   * Threshold FHE: Generation of a public key derived\n   * from a previous joined public key (for prior secret shares) and the secret\n   * key share of the current party.\n   *\n   * @param publicKey joined public key from prior parties.\n   * @param makeSparse set to true if ring reduce by a factor of 2 is to be\n   * used. NOT SUPPORTED BY ANY SCHEME ANYMORE.\n   * @param fresh set to true if proxy re-encryption is used in the multi-party\n   * protocol or star topology is used\n   * @return key pair including the secret share for the current party and\n   * joined public key\n   */\n    KeyPair&lt;Element&gt; MultipartyKeyGen(const PublicKey&lt;Element&gt; publicKey, bool makeSparse = false, bool fresh = false) {\n        if (!publicKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input public key is empty&quot;);\n        return GetScheme()-&gt;MultipartyKeyGen(GetContextForPointer(this), publicKey, makeSparse, fresh);\n    }\n\n    /**\n   * Threshold FHE: Method for decryption operation run by the lead decryption\n   * client\n   *\n   * @param &amp;ciphertextVec a vector of ciphertexts\n   * @param privateKey secret key share used for decryption.\n   * @returm vector of partially decrypted ciphertexts.\n   */\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; MultipartyDecryptLead(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                                           const PrivateKey&lt;Element&gt; privateKey) const {\n        CheckKey(privateKey);\n\n        std::vector&lt;Ciphertext&lt;Element&gt;&gt; newCiphertextVec;\n\n        for (size_t i = 0; i &lt; ciphertextVec.size(); i++) {\n            CheckCiphertext(ciphertextVec[i]);\n            newCiphertextVec.push_back(GetScheme()-&gt;MultipartyDecryptLead(ciphertextVec[i], privateKey));\n        }\n\n        return newCiphertextVec;\n    }\n\n    /**\n   * Threshold FHE: &quot;Partial&quot; decryption computed by all parties except for the\n   * lead one\n   *\n   * @param &amp;ciphertextVec a vector of ciphertexts\n   * @param privateKey secret key share used for decryption.\n   * @returm vector of partially decrypted ciphertexts.\n   */\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; MultipartyDecryptMain(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                                           const PrivateKey&lt;Element&gt; privateKey) const {\n        CheckKey(privateKey);\n\n        std::vector&lt;Ciphertext&lt;Element&gt;&gt; newCiphertextVec;\n        for (size_t i = 0; i &lt; ciphertextVec.size(); i++) {\n            CheckCiphertext(ciphertextVec[i]);\n            newCiphertextVec.push_back(GetScheme()-&gt;MultipartyDecryptMain(ciphertextVec[i], privateKey));\n        }\n\n        return newCiphertextVec;\n    }\n\n    /**\n   * Threshold FHE: Method for combining the partially decrypted ciphertexts\n   * and getting the final decryption in the clear.\n   *\n   * @param &amp;partialCiphertextVec vector of &quot;partial&quot; decryptions.\n   * @param *plaintext the plaintext output.\n   * @return the decoding result.\n   */\n    DecryptResult MultipartyDecryptFusion(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; partialCiphertextVec,\n                                          Plaintext* plaintext) const {\n        std::string datatype = demangle(typeid(Element).name());\n        &quot;hey&quot;; OPENFHE_THROW(config_error, std::string(__func__) + &quot; is not implemented for &quot; + datatype);\n    }\n\n    /**\n   * Threshold FHE: Generates a joined evaluation key\n   * from the current secret share and a prior joined\n   * evaluation key\n   *\n   * @param originalPrivateKey secret key transformed from.\n   * @param newPrivateKey secret key transformed to.\n   * @param ek the prior joined evaluation key.\n   * @return the new joined evaluation key.\n   */\n    EvalKey&lt;Element&gt; MultiKeySwitchGen(const PrivateKey&lt;Element&gt; originalPrivateKey,\n                                       const PrivateKey&lt;Element&gt; newPrivateKey, const EvalKey&lt;Element&gt; evalKey) const {\n        if (!originalPrivateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first private key is nullptr&quot;);\n        if (!newPrivateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second private key is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n\n        return GetScheme()-&gt;MultiKeySwitchGen(originalPrivateKey, newPrivateKey, evalKey);\n    }\n\n    /**\n   * Threshold FHE: Generates joined automorphism keys\n   * from the current secret share and prior joined\n   * automorphism keys\n   *\n   * @param privateKey secret key share.\n   * @param evalKeyMap a dictionary with prior joined automorphism keys.\n   * @param &amp;indexList a vector of automorphism indices.\n   * @param keyId - new key identifier used for the resulting evaluation key\n   * @return a dictionary with new joined automorphism keys.\n   */\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiEvalAutomorphismKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap,\n        const std::vector&lt;usint&gt;&amp; indexList, const std::string&amp; keyId = &quot;&quot;) {\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        if (!evalKeyMap)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is nullptr&quot;);\n        if (!indexList.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input index vector is empty&quot;);\n\n        return GetScheme()-&gt;MultiEvalAutomorphismKeyGen(privateKey, evalKeyMap, indexList, keyId);\n    }\n\n    /**\n   * Threshold FHE: Generates joined rotation keys\n   * from the current secret share and prior joined\n   * rotation keys\n   *\n   * @param privateKey secret key share.\n   * @param evalKeyMap a dictionary with prior joined rotation keys.\n   * @param &amp;indexList a vector of rotation indices.\n   * @param keyId - new key identifier used for the resulting evaluation key\n   * @return a dictionary with new joined rotation keys.\n   */\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiEvalAtIndexKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap,\n        const std::vector&lt;int32_t&gt;&amp; indexList, const std::string&amp; keyId = &quot;&quot;) {\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        if (!evalKeyMap)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is nullptr&quot;);\n        if (!indexList.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input index vector is empty&quot;);\n\n        return GetScheme()-&gt;MultiEvalAtIndexKeyGen(privateKey, evalKeyMap, indexList, keyId);\n    }\n\n    /**\n   * Threshold FHE: Generates joined summation evaluation keys\n   * from the current secret share and prior joined\n   * summation keys\n   *\n   * @param privateKey secret key share.\n   * @param evalKeyMap a dictionary with prior joined summation keys.\n   * @param keyId - new key identifier used for the resulting evaluation key\n   * @return new joined summation keys.\n   */\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiEvalSumKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap,\n        const std::string&amp; keyId = &quot;&quot;) {\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        if (!evalKeyMap)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is nullptr&quot;);\n        return GetScheme()-&gt;MultiEvalSumKeyGen(privateKey, evalKeyMap, keyId);\n    }\n\n    /**\n   * Threshold FHE: Adds two prior evaluation keys\n   *\n   * @param evalKey1 first evaluation key.\n   * @param evalKey2 second evaluation key.\n   * @param keyId - new key identifier used for the resulting evaluation key\n   * @return the new joined key.\n   */\n    EvalKey&lt;Element&gt; MultiAddEvalKeys(EvalKey&lt;Element&gt; evalKey1, EvalKey&lt;Element&gt; evalKey2,\n                                      const std::string&amp; keyId = &quot;&quot;) {\n        if (!evalKey1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first evaluation key is nullptr&quot;);\n        if (!evalKey2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second evaluation key is nullptr&quot;);\n\n        return GetScheme()-&gt;MultiAddEvalKeys(evalKey1, evalKey2, keyId);\n    }\n\n    /**\n   * Threshold FHE: Generates a partial evaluation key for homomorphic\n   * multiplication based on the current secret share and an existing partial\n   * evaluation key\n   *\n   * @param privateKey current secret share.\n   * @param evalKey prior evaluation key.\n   * @param keyId - new key identifier used for the resulting evaluation key\n   * @return the new joined key.\n   */\n    EvalKey&lt;Element&gt; MultiMultEvalKey(PrivateKey&lt;Element&gt; privateKey, EvalKey&lt;Element&gt; evalKey,\n                                      const std::string&amp; keyId = &quot;&quot;) {\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n\n        return GetScheme()-&gt;MultiMultEvalKey(privateKey, evalKey, keyId);\n    }\n\n    /**\n   * Threshold FHE: Adds two prior evaluation key sets for summation\n   *\n   * @param evalKeyMap1 first summation key set.\n   * @param evalKeyMap2 second summation key set.\n   * @param keyId - new key identifier used for the resulting evaluation key\n   * @return the new joined key set for summation.\n   */\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiAddEvalSumKeys(\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap1,\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap2, const std::string&amp; keyId = &quot;&quot;) {\n        if (!evalKeyMap1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first evaluation key map is nullptr&quot;);\n        if (!evalKeyMap2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second evaluation key map is nullptr&quot;);\n\n        return GetScheme()-&gt;MultiAddEvalSumKeys(evalKeyMap1, evalKeyMap2, keyId);\n    }\n\n    /**\n   * Threshold FHE: Adds two prior evaluation key sets for automorphisms\n   *\n   * @param evalKeyMap1 first automorphism key set.\n   * @param evalKeyMap2 second automorphism key set.\n   * @param keyId - new key identifier used for the resulting evaluation key.\n   * @return the new joined key set for summation.\n   */\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiAddEvalAutomorphismKeys(\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap1,\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap2, const std::string&amp; keyId = &quot;&quot;) {\n        if (!evalKeyMap1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first evaluation key map is nullptr&quot;);\n        if (!evalKeyMap2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second evaluation key map is nullptr&quot;);\n\n        return GetScheme()-&gt;MultiAddEvalAutomorphismKeys(evalKeyMap1, evalKeyMap2, keyId);\n    }\n\n    /**\n   * Threshold FHE: Adds two  partial public keys\n   *\n   * @param publicKey1 first public key.\n   * @param publicKey2 second public key.\n   * @param keyId - new key identifier used for the resulting evaluation key.\n   * @return the new joined key.\n   */\n    PublicKey&lt;Element&gt; MultiAddPubKeys(PublicKey&lt;Element&gt; publicKey1, PublicKey&lt;Element&gt; publicKey2,\n                                       const std::string&amp; keyId = &quot;&quot;) {\n        if (!publicKey1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first public key is nullptr&quot;);\n        if (!publicKey2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second public key is nullptr&quot;);\n\n        return GetScheme()-&gt;MultiAddPubKeys(publicKey1, publicKey2, keyId);\n    }\n\n    /**\n    * Threshold FHE: Adds two  partial evaluation keys for multiplication\n    *\n    * @param evalKey1 first evaluation key.\n    * @param evalKey2 second evaluation key.\n    * @param keyId - new key identifier used for the resulting evaluation key.\n    * @return the new joined key.\n    */\n    EvalKey&lt;Element&gt; MultiAddEvalMultKeys(EvalKey&lt;Element&gt; evalKey1, EvalKey&lt;Element&gt; evalKey2,\n                                          const std::string&amp; keyId = &quot;&quot;) {\n        if (!evalKey1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first evaluation key is nullptr&quot;);\n        if (!evalKey2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second evaluation key is nullptr&quot;);\n\n        return GetScheme()-&gt;MultiAddEvalMultKeys(evalKey1, evalKey2, keyId);\n    }\n\n    /**\n    * Threshold FHE: Prepare a ciphertext for Multi-Party Interactive Bootstrapping.\n    *\n    * @param ciphertext: Input Ciphertext\n    * @return: Resulting Ciphertext\n    */\n    Ciphertext&lt;Element&gt; IntMPBootAdjustScale(ConstCiphertext&lt;Element&gt; ciphertext) const;\n\n    /**\n    * Threshold FHE: Generate a common random polynomial for Multi-Party Interactive Bootstrapping\n    *\n    * @param publicKey: the scheme public key (you can also provide the lead party&#x27;s public-key)\n    * @return: Resulting ring element\n    */\n    Ciphertext&lt;Element&gt; IntMPBootRandomElementGen(const PublicKey&lt;Element&gt; publicKey) const;\n\n    /**\n    * Threshold FHE: Does masked decryption as part of Multi-Party Interactive Bootstrapping.\n    * Each party calls this function as part of the protocol\n    *\n    * @param privateKey: secret key share for party i\n    * @param ciphertext: input ciphertext\n    * @param a: input common random polynomial\n    * @return: Resulting masked decryption\n    */\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; IntMPBootDecrypt(const PrivateKey&lt;Element&gt; privateKey,\n                                                      ConstCiphertext&lt;Element&gt; ciphertext,\n                                                      ConstCiphertext&lt;Element&gt; a) const;\n\n    /**\n    * Threshold FHE: Aggregates a vector of masked decryptions and re-encryotion shares,\n    * which is the second step of the interactive multiparty bootstrapping procedure.\n    *\n    * @param sharesPairVec: vector of pair of ciphertexts, each element of this vector contains\n    * (h_0i, h_1i) - the masked-decryption and encryption shares ofparty i\n    * @return: aggregated pair of shares ((h_0, h_1)\n    */\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; IntMPBootAdd(std::vector&lt;std::vector&lt;Ciphertext&lt;Element&gt;&gt;&gt;&amp; sharesPairVec) const;\n\n    /**\n    *  Threshold FHE: Does public key encryption of lead party&#x27;s masked decryption\n    * as part of interactive multi-party bootstrapping, which increases\n    * the ciphertext modulus and enables future computations.\n    * This operation is done by the lead party as the final step\n    * of interactive multi-party bootstrapping.\n    *\n    * @param publicKey: the lead party&#x27;s public key\n    * @param sharesPair: aggregated decryption and re-encryption shares\n    * @param a: common random ring element\n    * @param ciphertext: input ciphertext\n    * @return: Resulting encryption\n    */\n    Ciphertext&lt;Element&gt; IntMPBootEncrypt(const PublicKey&lt;Element&gt; publicKey,\n                                         const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; sharesPair, ConstCiphertext&lt;Element&gt; a,\n                                         ConstCiphertext&lt;Element&gt; ciphertext) const;\n\n    /**\n   * Threshold FHE with aborts: secret sharing of secret key for aborts\n   *\n   * @param &amp;sk secret key to be shared.\n   * @param N total number of parties.\n   * @param threshold - threshold number of parties.\n   * @param index - index of the party invoking the function.\n   * @param shareType - Type of secret sharing to be used - additive or shamir sharing.\n   * @return the secret shares of the secret key sk.\n   */\n    std::unordered_map&lt;uint32_t, Element&gt; ShareKeys(const PrivateKey&lt;Element&gt;&amp; sk, usint N, usint threshold,\n                                                    usint index, const std::string&amp; shareType) const {\n        std::string datatype = demangle(typeid(Element).name());\n        &quot;hey&quot;; OPENFHE_THROW(config_error, std::string(__func__) + &quot; is not implemented for &quot; + datatype);\n    }\n\n    /**\n   * Threshold FHE with aborts: Recovers a secret key share from other existing secret shares.\n   *\n   * @param &amp;sk secret recovered from the secret shares.\n   * @param &amp;sk_shares secret shares.\n   * @param N total number of parties.\n   * @param threshold - threshold number of parties.\n   * @param shareType - Type of secret sharing to be used - additive or shamir sharing\n   * @return the recovered key from the secret shares assigned to sk.\n   */\n    void RecoverSharedKey(PrivateKey&lt;Element&gt;&amp; sk, std::unordered_map&lt;uint32_t, Element&gt;&amp; sk_shares, usint N,\n                          usint threshold, const std::string&amp; shareType) const;\n\n    //------------------------------------------------------------------------------\n    // FHE Bootstrap Methods\n    //------------------------------------------------------------------------------\n\n    /**\n   * Bootstrap functionality:\n   * There are three methods that have to be called in this specific order:\n   * 1. EvalBootstrapSetup: computes and encodes the coefficients for encoding and\n   * decoding and stores the necessary parameters\n   * 2. EvalBootstrapKeyGen: computes and stores the keys for rotations and conjugation\n   * 3. EvalBootstrap: refreshes the given ciphertext\n   */\n\n    /**\n   * Sets all parameters for both linear  and FFT-like methods. Supported in CKKS only.\n   *\n   * @param levelBudget - vector of budgets for the amount of levels in encoding\n   * and decoding\n   * @param dim1 - vector of inner dimension in the baby-step giant-step routine\n   * for encoding and decoding\n   * @param slots - number of slots to be bootstrapped\n   * @param correctionFactor - value to internally rescale message by to improve precision of bootstrapping. If set to 0, we use the default logic. This value is only used when NATIVE_SIZE=64.\n   */\n    void EvalBootstrapSetup(std::vector&lt;uint32_t&gt; levelBudget = {5, 4}, std::vector&lt;uint32_t&gt; dim1 = {0, 0},\n                            uint32_t slots = 0, uint32_t correctionFactor = 0) {\n        GetScheme()-&gt;EvalBootstrapSetup(*this, levelBudget, dim1, slots, correctionFactor);\n    }\n    /**\n   * Generates all automorphism keys for EvalBootstrap. Supported in CKKS only.\n   * EvalBootstrapKeyGen uses the baby-step/giant-step strategy.\n   *\n   * @param privateKey private key.\n   * @param slots number of slots to support permutations on\n   */\n    void EvalBootstrapKeyGen(const PrivateKey&lt;Element&gt; privateKey, uint32_t slots) {\n        if (privateKey == NULL || this-&gt;Mismatched(privateKey-&gt;GetCryptoContext())) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Private key passed to &quot; + std::string(__func__) +\n                                            &quot; was not generated with this cryptocontext&quot;);\n        }\n\n        auto evalKeys = GetScheme()-&gt;EvalBootstrapKeyGen(privateKey, slots);\n\n        auto ekv = GetAllEvalAutomorphismKeys().find(privateKey-&gt;GetKeyTag());\n        if (ekv == GetAllEvalAutomorphismKeys().end()) {\n            GetAllEvalAutomorphismKeys()[privateKey-&gt;GetKeyTag()] = evalKeys;\n        }\n        else {\n            auto&amp; currRotMap = GetEvalAutomorphismKeyMap(privateKey-&gt;GetKeyTag());\n            auto iterRowKeys = evalKeys-&gt;begin();\n            while (iterRowKeys != evalKeys-&gt;end()) {\n                auto idx = iterRowKeys-&gt;first;\n                // Search current rotation key map and add key\n                // only if it doesn&#x27;t exist\n                if (currRotMap.find(idx) == currRotMap.end()) {\n                    currRotMap.insert(*iterRowKeys);\n                }\n                iterRowKeys++;\n            }\n        }\n    }\n    /**\n   * Defines the bootstrapping evaluation of ciphertext using either the\n   * FFT-like method or the linear method\n   *\n   * @param ciphertext the input ciphertext.\n   * @param numIterations number of iterations to run iterative bootstrapping (Meta-BTS). Increasing the iterations increases the precision of bootstrapping.\n   * @param precision precision of initial bootstrapping algorithm. This value is\n   * determined by the user experimentally by first running EvalBootstrap with numIterations = 1 and precision = 0 (unused).\n   * @return the refreshed ciphertext.\n   */\n    Ciphertext&lt;Element&gt; EvalBootstrap(ConstCiphertext&lt;Element&gt; ciphertext, uint32_t numIterations = 1,\n                                      uint32_t precision = 0) const {\n        return GetScheme()-&gt;EvalBootstrap(ciphertext, numIterations, precision);\n    }\n\n    //------------------------------------------------------------------------------\n    // Scheme switching Methods\n    //------------------------------------------------------------------------------\n\n    /**\n   * Scheme switching between CKKS and FHEW functionality\n   * There are three methods that have to be called in this specific order:\n   * 1. EvalCKKStoFHEWSetup: generates a FHEW cryptocontext and returns the key, computes and encodes\n   * the coefficients for encoding and decoding and stores the necessary parameters\n   * 2. EvalCKKStoFHEWKeyGen: computes and stores the keys for rotations and conjugation\n   * 3. EvalCKKStoFHEW: returns the FHEW/CGGI ciphertext\n   * 1&#x27;. EvalFHEWtoCKKSwitchetup: takes in the CKKS cryptocontext and sets the parameters\n   * 2&#x27;. EvalFHEWtoCKKSKeyGen: computes and stores the switching key and the keys for rotations and conjugation\n   * 3&#x27;. EvalFHEWtoCKKS: returns the CKKS ciphertext\n   * 1&#x27;&#x27;. EvalSchemeSwitchingSetup: generates a FHEW cryptocontext and returns the key, computes and encodes\n   * the coefficients for encoding and decoding and stores the necessary parameters\n   * 2&#x27;&#x27;. EvalSchemeSwitchingKeyGen: computes and stores the switching key and the keys for rotations and conjugation\n   * 3&#x27;&#x27;. EvalCompareSchemeSwitching/EvalFuncSchemeSwitching: returns the CKKS ciphertext of the function specified\n   */\n\n    /**\n   * Sets all parameters for switching from CKKS to FHEW\n   *\n   * @param sl security level for CKKS cryptocontext\n   * @param slBin security level for FHEW cryptocontext (only STD128 and TOY are currently supported)\n   * @param arbFunc whether the binfhecontext should be created for arbitrary function evaluation or not\n   * @param logQ size of ciphertext modulus in FHEW for large-precision evaluation\n   * @param dynamic whether to use dynamic mode for FHEW\n   * @param numSlotsCKKS number of slots in CKKS encryption\n   * @param logQswitch size of ciphertext modulus in intermediate switch for security with the FHEW ring dimension\n   * @return the FHEW cryptocontext and its secret key (if a method from extracting the binfhecontext\n   * from the secret key is created, then we can only return the secret key)\n   * TODO: add an overload for when BinFHEContext is already generated and fed as a parameter\n   */\n    std::pair&lt;BinFHEContext, LWEPrivateKey&gt; EvalCKKStoFHEWSetup(SecurityLevel sl      = HEStd_128_classic,\n                                                                BINFHE_PARAMSET slBin = STD128, bool arbFunc = false,\n                                                                uint32_t logQ = 25, bool dynamic = false,\n                                                                uint32_t numSlotsCKKS = 0, uint32_t logQswitch = 27);\n\n    /**\n   * Generates all keys for scheme switching: the rotation keys for the baby-step/giant-step strategy\n   * for the linear transform in the homomorphic decoding, conjugation keys, switching key from CKKS to FHEW\n   *\n   * @param keypair CKKS key pair\n   * @param lwesk FHEW secret key\n   * @param dim1 baby-step for the linear transform\n   * @param L level on which the hom. decoding matrix should be. We want the hom. decoded ciphertext to be on the last level\n   */\n    void EvalCKKStoFHEWKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk, uint32_t dim1 = 0,\n                              uint32_t L = 1);\n\n    /**\n   * Performs precomputations for the homomorphic decoding in CKKS. Given as a separate method than EvalCKKStoFHEWSetup\n   * to allow the user to specify a scale that depends on the CKKS and FHEW cryptocontexts\n   *\n   * @param scale factor with which to scale the matrix in the linear transform\n   */\n    void EvalCKKStoFHEWPrecompute(double scale = 1.0);\n\n    /**\n   * Performs the scheme switching on a CKKS ciphertext\n   *\n   * @param ciphertext CKKS ciphertext to switch\n   * @param numCtxts number of coefficients to extract from the CKKS ciphertext. If it is zero, it defaults to number of slots\n   * @return a vector of LWE ciphertexts of length the numCtxts\n   */\n    std::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt; EvalCKKStoFHEW(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                   uint32_t numCtxts = 0);\n\n    /**\n   * Sets all parameters for switching from FHEW to CKKS. The CKKS cryptocontext to switch to is\n   * already generated.\n   *\n   * @param ccLWE the FHEW cryptocontext from which to switch\n   * @param numSlotsCKKS number of FHEW ciphertexts that becomes the number of slots in CKKS encryption\n   * @param logQ size of ciphertext modulus in FHEW for large-precision evaluation\n   */\n    void EvalFHEWtoCKKSSetup(const BinFHEContext&amp; ccLWE, uint32_t numSlotsCKKS = 0, uint32_t logQ = 25);\n\n    /**\n   * Generates all keys for scheme switching: the rotation keys for the baby-step/giant-step strategy\n   * in the linear transform for the partial decryption, the switching key from FHEW to CKKS\n   *\n   * @param keypair CKKS key pair\n   * @param lwesk FHEW secret key\n   * @param numSlots number of slots for the CKKS encryption of the FHEW secret key\n   * @param dim1 baby-step for the linear transform\n   * @param L level on which the hom. decoding matrix should be. We want the hom. decoded ciphertext to be on the last level\n   */\n    void EvalFHEWtoCKKSKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk, uint32_t numSlots = 0,\n                              uint32_t dim1 = 0, uint32_t L = 0);\n\n    /**\n   * Performs the scheme switching on a vector of FHEW ciphertexts\n   *\n   * @param LWECiphertexts FHEW/LWE ciphertexts to switch\n   * @param numCtxts number of values to encrypt from the LWE ciphertexts in the new CKKS ciphertext\n   * @param numSlots number of slots to use in the encoding in the new CKKS/RLWE ciphertext\n   * @param p plaintext modulus to use to decide postscaling, by default p = 4\n   * @param pmin, pmax plaintext space of the resulting messages (by default [0,2] assuming\n   * the LWE ciphertext had plaintext modulus p = 4 and only bits were encrypted)\n   * @return a CKKS ciphertext encrypting in its slots the messages in the LWE ciphertexts\n   */\n    Ciphertext&lt;Element&gt; EvalFHEWtoCKKS(std::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt;&amp; LWECiphertexts,\n                                       uint32_t numCtxts = 0, uint32_t numSlots = 0, uint32_t p = 4, double pmin = 0.0,\n                                       double pmax = 2.0) const;\n\n    /**\n   * Sets all parameters for switching from CKKS to FHEW and back\n   *\n   * @param sl security level for CKKS cryptocontext\n   * @param slBin security level for FHEW cryptocontext\n   * @param arbFunc whether the binfhecontext should be created for arbitrary function evaluation or not\n   * @param logQ size of ciphertext modulus in FHEW for large-precision evaluation\n   * @param dynamic whether to use dynamic mode for FHEW\n   * @param numSlotsCKKS number of slots in CKKS encryption\n   * @param logQswitch size of ciphertext modulus in intermediate switch for security with the FHEW ring dimension\n   * @return the FHEW cryptocontext and its secret key (if a method from extracting the binfhecontext\n   * from the secret key is created, then we can only return the secret key)\n   * TODO: add an overload for when BinFHEContext is already generated and fed as a parameter\n   */\n    std::pair&lt;BinFHEContext, LWEPrivateKey&gt; EvalSchemeSwitchingSetup(SecurityLevel sl      = HEStd_128_classic,\n                                                                     BINFHE_PARAMSET slBin = STD128,\n                                                                     bool arbFunc = false, uint32_t logQ = 25,\n                                                                     bool dynamic = false, uint32_t numSlotsCKKS = 0,\n                                                                     uint32_t logQswitch = 27);\n\n    /**\n   * Generates all keys for scheme switching: the rotation keys for the baby-step/giant-step strategy\n   * in the linear transform for the homomorphic encoding and partial decryption, the switching key from\n   * FHEW to CKKS\n   *\n   * @param keypair CKKS key pair\n   * @param lwesk FHEW secret key\n   * @param numValues parameter of argmin computation, set to zero if not needed\n   * @param oneHot flag that indicates whether the argmin result should have one hot encoding or not\n   * @param alt flag that indicates whether to use the alternative version of argmin which requires fewer automorphism keys\n   * @param dim1CF baby-step for the linear transform in CKKS to FHEW\n   * @param dim1FC baby-step for the linear transform in FHEW to CKKS\n   * @param LCF level on which to do the linear transform in CKKS to FHEW\n   * @param LFC level on which to do the linear transform in FHEW to CKKS\n   */\n    void EvalSchemeSwitchingKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk, uint32_t numValues = 0,\n                                   bool oneHot = true, bool alt = false, uint32_t dim1CF = 0, uint32_t dim1FC = 0,\n                                   uint32_t LCF = 1, uint32_t LFC = 0);\n\n    /**\n   * Performs precomputations for the homomorphic decoding in CKKS. Given as a separate method than EvalSchemeSwitchingSetup\n   * to allow the user to specify a scale that depends on the CKKS and FHEW cryptocontexts\n   *\n   * @param pLWE the desired plaintext modulus for the new FHEW ciphertexts\n   * @param initLevel the level of the ciphertext that will be switched\n   * @param scaleSign factor to multiply the CKKS ciphertext when switching to FHEW in case the messages are too small;\n   * the resulting FHEW ciphertexts will encrypt values modulo pLWE, so scaleSign should account for this\n   * @param unit whether the input messages are normalized to the unit circle\n   */\n    void EvalCompareSwitchPrecompute(uint32_t pLWE = 0, uint32_t initLevel = 0, double scaleSign = 1.0,\n                                     bool unit = false);\n\n    /**\n   * Performs the scheme switching on the difference of two CKKS ciphertexts to compare, evaluates the sign function\n   * over the resulting FHEW ciphertexts, then performs the scheme switching back to a CKKS ciphertext\n   *\n   * @param ciphertext1, ciphertext2 CKKS ciphertexts of messages that need to be compared\n   * @param numCtxts number of coefficients to extract from the CKKS ciphertext\n   * @param numSlots number of slots to encode the new CKKS ciphertext with\n   * @param pLWE the desired plaintext modulus for the new FHEW ciphertexts\n   * @param scaleSign factor to multiply the CKKS ciphertext when switching to FHEW in case the messages are too small;\n   * the resulting FHEW ciphertexts will encrypt values modulo pLWE, so scaleSign should account for this\n   * pLWE and scaleSign are given here only if the homomorphic decoding matrix is not scaled with the desired values\n   * @param unit whether the input messages are normalized to the unit circle\n   * @return a CKKS ciphertext encrypting in its slots the sign of  messages in the LWE ciphertexts\n   */\n    Ciphertext&lt;Element&gt; EvalCompareSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                   ConstCiphertext&lt;Element&gt; ciphertext2, uint32_t numCtxts = 0,\n                                                   uint32_t numSlots = 0, uint32_t pLWE = 0, double scaleSign = 1.0,\n                                                   bool unit = false);\n\n    /**\n   * Computes the minimum and argument of the first numValues packed in a CKKS ciphertext via repeated\n   * scheme switchings to FHEW and back.\n   *\n   * @param ciphertext CKKS ciphertexts of values that need to be compared\n   * @param publicKey public key of the CKKS cryptocontext\n   * @param numValues number of values to extract from the CKKS ciphertext. We always assume for the moment numValues is a power of two\n   * @param numSlots number of slots to encode the new CKKS ciphertext with\n   * @param oneHot whether the argmin result is given as a one hot/elementary vector or as the index\n   * @param pLWE the desired plaintext modulus for the new FHEW ciphertexts\n   * @param scaleSign factor to multiply the CKKS ciphertext when switching to FHEW in case the messages are too small;\n   * the resulting FHEW ciphertexts will encrypt values modulo pLWE, so scaleSign should account for this\n   * pLWE and scaleSign are given here only if the homomorphic decoding matrix is not scaled with the desired values\n   * @return a vector of two CKKS ciphertexts where the first encrypts the minimum value and the second encrypts the\n   * index (in the representation specified by oneHot). The ciphertexts have junk after the first slot in the first ciphertext\n   * and after numValues in the second ciphertext if oneHot=true and after the first slot if oneHot=false.\n   */\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMinSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                            PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                            uint32_t numSlots = 0, bool oneHot = true,\n                                                            uint32_t pLWE = 0, double scaleSign = 1.0);\n\n    /**\n     * Same as EvalMinSchemeSwitching but performs more operations in FHEW than in CKKS. Slightly better precision but slower.\n    */\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMinSchemeSwitchingAlt(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                               PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                               uint32_t numSlots = 0, bool oneHot = true,\n                                                               uint32_t pLWE = 0, double scaleSign = 1.0);\n\n    /**\n   * Computes the maximum and argument of the first numValues packed in a CKKS ciphertext via repeated\n   * scheme switchings to FHEW and back.\n   *\n   * @param ciphertext CKKS ciphertexts of values that need to be compared\n   * @param publicKey public key of the CKKS cryptocontext\n   * @param numValues number of values to extract from the CKKS ciphertext. We always assume for the moment numValues is a power of two\n   * @param numSlots number of slots to encode the new CKKS ciphertext with\n   * @param oneHot whether the argmax result is given as a one hot/elementary vector or as the index\n   * @param pLWE the desired plaintext modulus for the new FHEW ciphertexts\n   * @param scaleSign factor to multiply the CKKS ciphertext when switching to FHEW in case the messages are too small;\n   * the resulting FHEW ciphertexts will encrypt values modulo pLWE, so scaleSign should account for this\n   * pLWE and scaleSign are given here only if the homomorphic decoding matrix is not scaled with the desired values\n   * @return a vector of two CKKS ciphertexts where the first encrypts the maximum value and the second encrypts the\n   * index (in the representation specified by oneHot). The ciphertexts have junk after the first slot in the first ciphertext\n   * and after numValues in the second ciphertext if oneHot=true and after the first slot if oneHot=false.\n   */\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMaxSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                            PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                            uint32_t numSlots = 0, bool oneHot = true,\n                                                            uint32_t pLWE = 0, double scaleSign = 1.0);\n\n    /**\n     * Same as EvalMaxSchemeSwitching but performs more operations in FHEW than in CKKS. Slightly better precision but slower.\n    */\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMaxSchemeSwitchingAlt(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                               PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                               uint32_t numSlots = 0, bool oneHot = true,\n                                                               uint32_t pLWE = 0, double scaleSign = 1.0);\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(cereal::make_nvp(&quot;cc&quot;, params));\n        ar(cereal::make_nvp(&quot;kt&quot;, scheme));\n        ar(cereal::make_nvp(&quot;si&quot;, m_schemeId));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                 &quot; is from a later version of the library&quot;);\n        }\n        ar(cereal::make_nvp(&quot;cc&quot;, params));\n        ar(cereal::make_nvp(&quot;kt&quot;, scheme));\n        ar(cereal::make_nvp(&quot;si&quot;, m_schemeId));\n        SetKSTechniqueInScheme();\n\n        // NOTE: a pointer to this object will be wrapped in a shared_ptr, and is a\n        // &quot;CryptoContext&quot;. OpenFHE relies on the notion that identical\n        // CryptoContextImpls are not duplicated in memory Once we deserialize this\n        // object, we must check to see if there is a matching object for this\n        // object that&#x27;s already existing in memory if it DOES exist, use it. If it\n        // does NOT exist, add this to the cache of all contexts\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;CryptoContext&quot;;\n    }\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n};\n\n// Member function specializations. Their implementations are in cryptocontext.cpp\ntemplate &lt;&gt;\nDecryptResult CryptoContextImpl&lt;DCRTPoly&gt;::MultipartyDecryptFusion(\n    const std::vector&lt;Ciphertext&lt;DCRTPoly&gt;&gt;&amp; partialCiphertextVec, Plaintext* plaintext) const;\ntemplate &lt;&gt;\nstd::unordered_map&lt;uint32_t, DCRTPoly&gt; CryptoContextImpl&lt;DCRTPoly&gt;::ShareKeys(const PrivateKey&lt;DCRTPoly&gt;&amp; sk, usint N,\n                                                                              usint threshold, usint index,\n                                                                              const std::string&amp; shareType) const;\n}  // namespace lbcrypto\n\n#endif /* SRC_PKE_CRYPTOCONTEXT_H_ */\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Wraps parameters for integer lattice operations using double-CRT representation. Inherits from ElemParams\n */\n\n#ifndef LBCRYPTO_INC_LATTICE_ILDCRTPARAMS_H\n#define LBCRYPTO_INC_LATTICE_ILDCRTPARAMS_H\n\n#include &quot;lattice/elemparams.h&quot;\n#include &quot;lattice/ilparams.h&quot;\n\n#include &quot;math/math-hal.h&quot;\n#include &quot;math/nbtheory-impl.h&quot;\n\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/inttypes.h&quot;\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\nnamespace lbcrypto {\n\n/**\n * @brief Parameters for array of ideal lattices (used for Double-CRT).\n *\n * The double-CRT representation of polynomials is a common optimization for\n * lattice encryption operations. Basically, it allows large-modulus polynamials\n * to be represented as multiple smaller-modulus polynomials. The double-CRT\n * representations are discussed theoretically here:\n *   - Gentry C., Halevi S., Smart N.P. (2012) Homomorphic Evaluation of the AES\n * Circuit. In: Safavi-Naini R., Canetti R. (eds) Advances in Cryptology \u2013\n * CRYPTO 2012. Lecture Notes in Computer Science, vol 7417. Springer, Berlin,\n * Heidelberg\n */\ntemplate &lt;typename IntType&gt;\nclass ILDCRTParams final : public ElemParams&lt;IntType&gt; {\npublic:\n    static constexpr usint DEFAULT_NBITS = 20;\n\n    using Integer        = IntType;\n    using ILNativeParams = ILParamsImpl&lt;NativeInteger&gt;;\n\n    /**\n   * @brief Constructor with basic parameter set.\n   * q is selected as FirstPrime(bits, order)\n   * @param order the order of the ciphertext.\n   * @param depth is the size of the tower.\n   * @param bits is the number of bits of each tower&#x27;s moduli.\n   */\n    explicit ILDCRTParams(usint order = 0, usint depth = 1, usint bits = DEFAULT_NBITS)\n        : ElemParams&lt;IntType&gt;(order, 0), m_params(depth) {\n        if (order == 0)\n            return;\n        if (depth == 0)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Invalid depth for ILDCRTParams&quot;);\n        if (bits == 0 || bits &gt; 64)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Invalid bits for ILDCRTParams&quot;);\n        auto q{FirstPrime&lt;NativeInteger&gt;(bits, order)};\n        for (usint j = 0; j &lt; depth; ++j, q = NextPrime&lt;NativeInteger&gt;(q, order))\n            m_params[j] = std::make_shared&lt;ILNativeParams&gt;(order, q, RootOfUnity&lt;NativeInteger&gt;(order, q));\n        RecalculateModulus();\n    }\n\n    /**\n   * @brief Constructor with basic parameters\n   *\n   * @param cyclotomic_order the order of the ciphertext\n   * @param &amp;modulus is the modulus for the primary ciphertext.\n   * @param rootsOfUnity is unused\n   */\n\n    // root of unity unused?\n    ILDCRTParams(usint cyclotomic_order, const IntType&amp; modulus, const IntType&amp; rootOfUnity)\n        : ElemParams&lt;IntType&gt;(cyclotomic_order, modulus, 0, 0, 0), m_originalModulus(modulus) {\n        // NOTE params generation uses this constructor to make an empty params that\n        // it will later populate during the gen process. For that special case...\n        // we don&#x27;t populate, and we just return\n        if (cyclotomic_order == 0)\n            return;\n        std::vector&lt;NativeInteger&gt; moduli;\n        std::vector&lt;NativeInteger&gt; rootsOfUnity;\n        auto q{FirstPrime&lt;NativeInteger&gt;(DEFAULT_NBITS, cyclotomic_order)};\n        IntType compositeModulus(1);\n        while (true) {\n            moduli.push_back(q);\n            rootsOfUnity.push_back(RootOfUnity(cyclotomic_order, q));\n            m_params.push_back(std::make_shared&lt;ILNativeParams&gt;(cyclotomic_order, q, rootsOfUnity.back()));\n            compositeModulus = compositeModulus * IntType(q.ConvertToInt());\n            if (compositeModulus &gt;= modulus)\n                break;\n            q = NextPrime(q, cyclotomic_order);\n        }\n        RecalculateModulus();\n    }\n\n    /**\n   * @brief Constructor with some pre-computed parameters provided as input.\n   * @param cyclotomic_order the order of the ciphertext\n   * @param moduli the list of the smaller moduli of the component polynomials.\n   * @param rootsOfUnity the list of the smaller roots of unity of the component\n   * polynomials.\n   * @param moduliBig the list of the big moduli of the component polynomials\n   * (arbitrary cyclotomics).\n   * @param rootsOfUnityBig the list of the roots of unity of the component\n   * polynomials for big moduli (arbitrary cyclotomics).\n   * @return\n   */\n    ILDCRTParams(usint cyclotomic_order, const std::vector&lt;NativeInteger&gt;&amp; moduli,\n                 const std::vector&lt;NativeInteger&gt;&amp; rootsOfUnity, const std::vector&lt;NativeInteger&gt;&amp; moduliBig = {},\n                 const std::vector&lt;NativeInteger&gt;&amp; rootsOfUnityBig = {},\n                 const IntType&amp; inputOriginalModulus               = IntType(0))\n        : ElemParams&lt;IntType&gt;(cyclotomic_order, 0, 0, 0, 0),\n          m_originalModulus(inputOriginalModulus),\n          m_params(moduli.size()) {\n        if (moduli.size() != rootsOfUnity.size())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;sizes of moduli and roots of unity do not match&quot;);\n        size_t size{moduli.size()};\n        if (moduliBig.size() == size) {\n            for (size_t i = 0; i &lt; size; ++i)\n                m_params[i] = std::make_shared&lt;ILNativeParams&gt;(cyclotomic_order, moduli[i], rootsOfUnity[i],\n                                                               moduliBig[i], rootsOfUnityBig[i]);\n        }\n        else {\n            for (size_t i = 0; i &lt; size; ++i)\n                m_params[i] = std::make_shared&lt;ILNativeParams&gt;(cyclotomic_order, moduli[i], rootsOfUnity[i]);\n        }\n        RecalculateModulus();\n    }\n\n    /**\n   * @brief Constructor with only cylotomic order and chain of moduli.\n   * Multiplied values of the chain of moduli is automatically calculated. Root\n   * of unity of the modulus is also calculated.\n   *\n   * @param cyclotomic_order the order of the ciphertext\n   * @param &amp;moduli is the tower of moduli\n   */\n    ILDCRTParams(usint cyclotomic_order, const std::vector&lt;NativeInteger&gt;&amp; moduli,\n                 const IntType&amp; inputOriginalModulus = IntType(0))\n        : ElemParams&lt;IntType&gt;(cyclotomic_order, 0, 0, 0, 0),\n          m_originalModulus(inputOriginalModulus),\n          m_params(moduli.size()) {\n        for (size_t i = 0; i &lt; moduli.size(); i++)\n            m_params[i] = std::make_shared&lt;ILNativeParams&gt;(cyclotomic_order, moduli[i], 0, 0, 0);\n        RecalculateModulus();\n    }\n\n    /**\n   * @brief Constructor that takes in the cyclotomic order and the component\n   * parameters of the component moduli.\n   * @param cyclotomic_order the primary cyclotomic order.  This is not checked\n   * against the component moduli.\n   * @param params the componet parameters.\n   * @return\n   */\n    ILDCRTParams(usint cyclotomic_order, std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt;&amp; params,\n                 const IntType&amp; inputOriginalModulus = IntType(0))\n        : ElemParams&lt;IntType&gt;(cyclotomic_order, 0, 0, 0, 0), m_originalModulus(inputOriginalModulus), m_params(params) {\n        RecalculateModulus();\n    }\n\n    ILDCRTParams(const ILDCRTParams&amp; rhs)\n        : ElemParams&lt;IntType&gt;(rhs), m_originalModulus(rhs.m_originalModulus), m_params(rhs.m_params) {}\n\n    ILDCRTParams(ILDCRTParams&amp;&amp; rhs) noexcept\n        : ElemParams&lt;IntType&gt;(rhs),\n          m_originalModulus(std::move(rhs.m_originalModulus)),\n          m_params(std::move(rhs.m_params)) {}\n\n    /**\n   * Assignment Operator.\n   *\n   * @param &amp;rhs the copied ILDCRTParams.\n   * @return the resulting ILDCRTParams.\n   */\n    ILDCRTParams&amp; operator=(const ILDCRTParams&amp; rhs) {\n        ElemParams&lt;IntType&gt;::operator=(rhs);\n        m_originalModulus = rhs.m_originalModulus;\n        m_params          = rhs.m_params;\n        return *this;\n    }\n\n    ILDCRTParams&amp; operator=(ILDCRTParams&amp;&amp; rhs) noexcept {\n        ElemParams&lt;IntType&gt;::operator=(rhs);\n        m_originalModulus = std::move(rhs.m_originalModulus);\n        m_params          = std::move(rhs.m_params);\n        return *this;\n    }\n\n    // ACCESSORS\n    /**\n   * @brief Getter method for the component parameters.\n   * @return A vector of the component polynomial parameters.\n   */\n    const std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt;&amp; GetParams() const {\n        return m_params;\n    }\n\n    /**\n   * @brief Getter method that returns a subset of the component parameters.\n   *\n   * @param start The index of the first tower to include in the result.\n   * @param end The index of the last tower to include.\n   * @return A vector of the component polynomial parameters.\n   */\n    std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt; GetParamPartition(uint32_t start, uint32_t end) const {\n        if (end &lt; start || end &gt;= m_params.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Incorrect parameters for GetParamPartition - (start: &quot; + std::to_string(start) +\n                                          &quot;, end:&quot; + std::to_string(end) + &quot;)&quot;);\n        }\n\n        std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt; resParams;\n        for (uint32_t i = start; i &lt;= end; ++i)\n            resParams.push_back(m_params[i]);\n        return resParams;\n    }\n\n    /**\n   * @brief Simple getter method for the original modulus, not the ciphertex\n   * modulus.\n   * @return The original  modulus, not the big ciphertext modulus.\n   */\n    const IntType&amp; GetOriginalModulus() const {\n        return m_originalModulus;\n    }\n    /**\n   * @brief Simple setter method for the original modulus, not the ciphertex\n   * modulus.\n   * @return void\n   */\n    void SetOriginalModulus(const IntType&amp; inputOriginalModulus) {\n        m_originalModulus = inputOriginalModulus;\n    }\n    /**\n   * @brief Getter method for the component parameters of a specific index.\n   * @param i the index of the parameters to return.  Note this this call is\n   * unguarded if the index is out of bounds.\n   * @return the parameters at index i.\n   */\n    std::shared_ptr&lt;ILNativeParams&gt;&amp; operator[](usint i) {\n        return m_params[i];\n    }\n\n    /**\n   * @brief Removes the last parameter set and adjust the multiplied moduli.\n   *\n   */\n    void PopLastParam() {\n        ElemParams&lt;IntType&gt;::m_ciphertextModulus /= IntType(m_params.back()-&gt;GetModulus().ConvertToInt());\n        m_params.pop_back();\n    }\n\n    /**\n   * @brief Removes the first parameter set and adjust the multiplied moduli.\n   *\n   */\n    void PopFirstParam() {\n        ElemParams&lt;IntType&gt;::m_ciphertextModulus /= IntType(m_params[0]-&gt;GetModulus().ConvertToInt());\n        m_params.erase(m_params.begin());\n    }\n\n    /**\n   * Destructor.\n   */\n    ~ILDCRTParams() override = default;\n\n    /**\n   * @brief Equality operator checks if the ElemParams are the same.\n   *\n   * @param &amp;other ElemParams to compare against.\n   * @return the equality check results.\n   */\n    bool operator==(const ElemParams&lt;IntType&gt;&amp; other) const override {\n        const auto* dcrtParams = dynamic_cast&lt;const ILDCRTParams*&gt;(&amp;other);\n\n        if (dcrtParams == nullptr)\n            return false;\n\n        if (ElemParams&lt;IntType&gt;::operator==(other) == false)\n            return false;\n\n        if (m_params.size() != dcrtParams-&gt;m_params.size())\n            return false;\n\n        for (size_t i = 0; i &lt; m_params.size(); i++) {\n            if (*m_params[i] != *dcrtParams-&gt;m_params[i])\n                return false;\n        }\n\n        //    if (originalModulus != dcrtParams-&gt;originalModulus)\n        //      return false;\n\n        return true;\n    }\n\n    /**\n   * @brief Method to recalculate the composite modulus from the component\n   * moduli.\n   */\n    void RecalculateModulus() {\n        ElemParams&lt;IntType&gt;::m_ciphertextModulus = 1;\n        for (size_t i = 0; i &lt; m_params.size(); i++)\n            ElemParams&lt;IntType&gt;::m_ciphertextModulus =\n                ElemParams&lt;IntType&gt;::m_ciphertextModulus * IntType(m_params[i]-&gt;GetModulus().ConvertToInt());\n    }\n\n    /**\n   * @brief Method to recalculate the big composite modulus from the component\n   * moduli.\n   */\n    void RecalculateBigModulus() {\n        ElemParams&lt;IntType&gt;::m_bigCiphertextModulus = 1;\n        for (size_t i = 0; i &lt; m_params.size(); i++)\n            ElemParams&lt;IntType&gt;::m_bigCiphertextModulus =\n                ElemParams&lt;IntType&gt;::m_bigCiphertextModulus * IntType(m_params[i]-&gt;GetBigModulus().ConvertToInt());\n    }\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::base_class&lt;ElemParams&lt;IntType&gt;&gt;(this));\n        ar(::cereal::make_nvp(&quot;p&quot;, m_params));\n        ar(::cereal::make_nvp(&quot;m&quot;, m_originalModulus));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                 &quot; is from a later version of the library&quot;);\n        }\n        ar(::cereal::base_class&lt;ElemParams&lt;IntType&gt;&gt;(this));\n        ar(::cereal::make_nvp(&quot;p&quot;, m_params));\n        ar(::cereal::make_nvp(&quot;m&quot;, m_originalModulus));\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;DCRTParams&quot;;\n    }\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\nprivate:\n    std::ostream&amp; doprint(std::ostream&amp; out) const override {\n        out &lt;&lt; &quot;ILDCRTParams &quot;;\n        ElemParams&lt;IntType&gt;::doprint(out);\n        out &lt;&lt; std::endl &lt;&lt; &quot; Params:&quot; &lt;&lt; std::endl;\n        for (size_t i = 0; i &lt; m_params.size(); i++) {\n            out &lt;&lt; &quot;   &quot; &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; *m_params[i] &lt;&lt; std::endl;\n        }\n        out &lt;&lt; &quot;OriginalModulus &quot; &lt;&lt; m_originalModulus &lt;&lt; std::endl;\n        return out;\n    }\n\n    // original modulus when being constructed from a Poly or when\n    // ctor is passed that parameter\n    // note orignalModulus will be &lt;= composite modules\n    //   i.e. \\Prod_i=0^k-1 m_params[i]-&gt;GetModulus()\n    // note not using ElemParams::ciphertextModulus due to object stripping\n    IntType m_originalModulus{};\n\n    // array of smaller ILParams\n    std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt; m_params;\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/integer.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/integer.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/integer.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  This file contains the interfaces for the math integer data types\n */\n\n#ifndef LBCRYPTO_MATH_INTEGER_INTERFACE_H\n#define LBCRYPTO_MATH_INTEGER_INTERFACE_H\n\n#include &quot;utils/inttypes.h&quot;\n\n#include &lt;string&gt;\n\nnamespace lbcrypto {\n\ntemplate &lt;typename T&gt;\nclass BigIntegerInterface {\npublic:\n    // CONSTRUCTORS\n\n    // Constructors must be implemented in the derived classes\n    // There are no base class constructors that need to be called\n\n    // The derived classes should implement constructors from uint64_t,\n    // NativeInteger, and strings There should be copy and move constructors, as\n    // well as copy and move assignment\n\n    /**\n   * Set from a string\n   *\n   * @param str is the string representation of the value\n   */\n    void SetValue(const std::string&amp; str);\n\n    // ARITHMETIC OPERATIONS\n\n    /**\n   * Addition operation.\n   *\n   * @param &amp;b is the value to add.\n   * @return result of the addition operation.\n   */\n    T Add(const T&amp; b) const;\n    T&amp; AddEq(const T&amp; b);\n\n    /// inline operators for the addition operation.\n    friend T operator+(const T&amp; a, const T&amp; b) {\n        return a.Add(b);\n    }\n    friend T&amp; operator+=(T&amp; a, const T&amp; b) {\n        return a.AddEq(b);\n    }\n\n    /**\n   * Subtraction operation.\n   *\n   * @param &amp;b is the value to subtract.\n   * @return is the result of the subtraction operation.\n   */\n    T Sub(const T&amp; b) const;\n    T&amp; SubEq(const T&amp; b);\n\n    /// inline operators for the subtraction operation.\n    friend T operator-(const T&amp; a, const T&amp; b) {\n        return a.Sub(b);\n    }\n    friend T&amp; operator-=(T&amp; a, const T&amp; b) {\n        return a.SubEq(b);\n    }\n\n    /**\n   * Multiplication operation.\n   *\n   * @param &amp;b is the value to multiply with.\n   * @return is the result of the multiplication operation.\n   */\n    T Mul(const T&amp; b) const;\n\n    /**\n   * Multiplication operation. In-place variant.\n   *\n   * @param &amp;b is the value to multiply with.\n   * @return is the result of the multiplication operation.\n   */\n    T&amp; MulEq(const T&amp; b);\n\n    /// inline operators for the multiplication operation.\n    friend T operator*(const T&amp; a, const T&amp; b) {\n        return a.Mul(b);\n    }\n    friend T&amp; operator*=(T&amp; a, const T&amp; b) {\n        return a.MulEq(b);\n    }\n\n    /**\n   * Division operation.\n   *\n   * @param &amp;b is the value to divide by.\n   * @return is the result of the division operation.\n   */\n    T DividedBy(const T&amp; b) const;\n\n    /**\n   * Division operation. In-place variant.\n   *\n   * @param &amp;b is the value to divide by.\n   * @return is the result of the division operation.\n   */\n    T&amp; DividedByEq(const T&amp; b);\n\n    /// inline operators for the division operation.\n    friend T operator/(const T&amp; a, const T&amp; b) {\n        return a.DividedBy(b);\n    }\n    friend T&amp; operator/=(T&amp; a, const T&amp; b) {\n        return a.DividedByEq(b);\n    }\n\n    /**\n   * Multiply and Rounding operation. Returns [x*p/q] where [] is the rounding\n   * operation.\n   *\n   * @param &amp;p is the numerator to be multiplied.\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of multiply and round operation.\n   */\n    T MultiplyAndRound(const T&amp; p, const T&amp; q) const;\n    T&amp; MultiplyAndRoundEq(const T&amp; p, const T&amp; q);\n\n    /**\n   * Divide and Rounding operation. Returns [x/q] where [] is the rounding\n   * operation.\n   *\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of divide and round operation.\n   */\n    T DivideAndRound(const T&amp; q) const;\n    T&amp; DivideAndRoundEq(const T&amp; q);\n\n    // MODULAR ARITHMETIC OPERATIONS\n\n    /**\n   * Naive modulus operation.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @return is the result of the modulus operation.\n   */\n    T Mod(const T&amp; modulus) const;\n    T&amp; ModEq(const T&amp; modulus);\n\n    // inline operators for the modulus operation.\n    friend T operator%(const T&amp; a, const T&amp; b) {\n        return a.Mod(b);\n    }\n    friend T&amp; operator%=(T&amp; a, const T&amp; b) {\n        return a.ModEq(b);\n    }\n\n    /**\n   * Precomputes a parameter mu for Barrett modular reduction.\n   *\n   * @return the precomputed parameter mu.\n   */\n    T ComputeMu() const;\n\n    /**\n   * Barrett modulus operation.\n   * Implements generalized Barrett modular reduction algorithm. Uses one\n   * precomputed value of mu.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus operation.\n   */\n    T Mod(const T&amp; modulus, const T&amp; mu) const;\n    T&amp; ModEq(const T&amp; modulus, const T&amp; mu);\n\n    /**\n   * Modulus addition operation.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus addition operation.\n   */\n    T ModAdd(const T&amp; b, const T&amp; modulus) const;\n    T&amp; ModAddEq(const T&amp; b, const T&amp; modulus);\n\n    /**\n   * Modulus addition where operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus addition operation.\n   */\n    T ModAddFast(const T&amp; b, const T&amp; modulus) const;\n    T&amp; ModAddFastEq(const T&amp; b, const T&amp; modulus);\n\n    /**\n   * Barrett modulus addition operation.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus addition operation.\n   */\n    T ModAdd(const T&amp; b, const T&amp; modulus, const T&amp; mu) const;\n    T&amp; ModAddEq(const T&amp; b, const T&amp; modulus, const T&amp; mu);\n\n    /**\n   * Modulus subtraction operation.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    T ModSub(const T&amp; b, const T&amp; modulus) const;\n    T&amp; ModSubEq(const T&amp; b, const T&amp; modulus);\n\n    /**\n   * Modulus subtraction where operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    T ModSubFast(const T&amp; b, const T&amp; modulus) const;\n    T&amp; ModSubFastEq(const T&amp; b, const T&amp; modulus);\n\n    /**\n   * Barrett modulus subtraction operation.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus subtraction operation.\n   */\n    T ModSub(const T&amp; b, const T&amp; modulus, const T&amp; mu) const;\n    T&amp; ModSubEq(const T&amp; b, const T&amp; modulus, const T&amp; mu);\n\n    /**\n   * Modulus multiplication operation.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    T ModMul(const T&amp; b, const T&amp; modulus) const;\n    T&amp; ModMulEq(const T&amp; b, const T&amp; modulus);\n\n    /**\n   * Barrett modulus multiplication.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus multiplication operation.\n   */\n    T ModMul(const T&amp; b, const T&amp; modulus, const T&amp; mu) const;\n    T&amp; ModMulEq(const T&amp; b, const T&amp; modulus, const T&amp; mu);\n\n    /**\n   * Modulus multiplication that assumes the operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    T ModMulFast(const T&amp; b, const T&amp; modulus) const;\n    T&amp; ModMulFastEq(const T&amp; b, const T&amp; modulus);\n\n    /**\n   * Barrett modulus multiplication that assumes the operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus multiplication operation.\n   */\n    T ModMulFast(const T&amp; b, const T&amp; modulus, const T&amp; mu) const;\n    T&amp; ModMulFastEq(const T&amp; b, const T&amp; modulus, const T&amp; mu);\n\n    /**\n   * NTL-optimized modular multiplication using a precomputation for the\n   * multiplicand. Assumes operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;bInv NTL precomputation for b.\n   * @return is the result of the modulus multiplication operation.\n   */\n    T ModMulFastConst(const T&amp; b, const T&amp; modulus, const T&amp; bInv) const;\n    T&amp; ModMulFastConstEq(const T&amp; b, const T&amp; modulus, const T&amp; bInv);\n\n    /**\n   * Modulus exponentiation operation.\n   *\n   * @param &amp;b is the scalar to exponentiate at all locations.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus exponentiation operation.\n   */\n    T ModExp(const T&amp; b, const T&amp; modulus) const;\n    T&amp; ModExpEq(const T&amp; b, const T&amp; modulus);\n\n    /**\n   * Modulus inverse operation.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @return is the result of the modulus inverse operation.\n   */\n    T ModInverse(const T&amp; modulus) const;\n    T&amp; ModInverseEq(const T&amp; modulus);\n\n    // SHIFT OPERATIONS\n\n    /**\n   * Left shift operation.\n   *\n   * @param shift # of bits.\n   * @return result of the shift operation.\n   */\n    T LShift(usshort shift) const;\n    T&amp; LShiftEq(usshort shift);\n\n    /// inline operators for the left shift operations.\n    friend T operator&lt;&lt;(const T&amp; a, usshort shift) {\n        return a.LShift(shift);\n    }\n    friend T&amp; operator&lt;&lt;=(T&amp; a, usshort shift) {\n        return a.LShiftEq(shift);\n    }\n\n    /**\n   * Right shift operation.\n   *\n   * @param shift # of bits.\n   * @return result of the shift operation.\n   */\n    T RShift(usshort shift) const;\n    T&amp; RShiftEq(usshort shift);\n\n    /// inline operators for the right shift operations.\n    friend T operator&gt;&gt;(const T&amp; a, usshort shift) {\n        return a.RShift(shift);\n    }\n    friend T&amp; operator&gt;&gt;=(T&amp; a, usshort shift) {\n        return a.RShiftEq(shift);\n    }\n\n    /**\n   * Compares the current BigInteger to BigInteger a.\n   *\n   * @param a is the BigInteger to be compared with.\n   * @return  -1 for strictly less than, 0 for equal to and 1 for strictly\n   * greater than conditons.\n   */\n    int Compare(const T&amp; a) const;\n\n    //// relational operators, using Compare\n    friend bool operator==(const T&amp; a, const T&amp; b) {\n        return a.Compare(b) == 0;\n    }\n    friend bool operator!=(const T&amp; a, const T&amp; b) {\n        return a.Compare(b) != 0;\n    }\n    friend bool operator&gt;(const T&amp; a, const T&amp; b) {\n        return a.Compare(b) &gt; 0;\n    }\n    friend bool operator&gt;=(const T&amp; a, const T&amp; b) {\n        return a.Compare(b) &gt;= 0;\n    }\n    friend bool operator&lt;(const T&amp; a, const T&amp; b) {\n        return a.Compare(b) &lt; 0;\n    }\n    friend bool operator&lt;=(const T&amp; a, const T&amp; b) {\n        return a.Compare(b) &lt;= 0;\n    }\n\n    /**\n   * Convert the value to an int.\n   *\n   * @return the int representation of the value.\n   */\n    uint64_t ConvertToInt() const;\n\n    // OTHER FUNCTIONS\n\n    /**\n   * Returns the MSB location of the value.\n   *\n   * @return the index of the most significant bit.\n   */\n    usint GetMSB() const;\n\n    /**\n   * Get the number of digits using a specific base - support for arbitrary base\n   * may be needed.\n   *\n   * @param base is the base with which to determine length in.\n   * @return the length of the representation in a specific base.\n   */\n    usint GetLengthForBase(usint base) const;\n\n    /**\n   * Get the number of digits using a specific base - support for arbitrary base\n   * may be needed. Example: for number 83, index 2 and base 4 we have:\n   *\n   *                         index:0,1,2,3\n   * 83 --base 4 decomposition--&gt; (3,0,1,1) --at index 2--&gt; 1\n   *\n   * The return number is 1.\n   *\n   * @param index is the location to return value from in the specific base.\n   * @param base is the base with which to determine length in.\n   * @return the length of the representation in a specific base.\n   */\n    usint GetDigitAtIndexForBase(usint index, usint base) const;\n\n    // STRINGS\n\n    // The derived classes MAY implement std::ostream&amp; operator&lt;&lt; but are not\n    // required to\n\n    /**\n   * Convert this integer into a std::string, for serialization\n   *\n   * @return the value of this T as a string.\n   */\n    const std::string ToString() const;\n\nprotected:\n    ~BigIntegerInterface() = default;\n\n    // SERIALIZATION\n};\n\n// TODO\nclass BigMatrixInterface {};\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n This file contains the main class for native integers. It implements the same methods as other mathematical backends.\n*/\n\n#ifndef LBCRYPTO_MATH_HAL_INTNAT_UBINTNAT_H\n#define LBCRYPTO_MATH_HAL_INTNAT_UBINTNAT_H\n\n#include &quot;math/hal/basicint.h&quot;\n#include &quot;math/hal/bigintbackend.h&quot;\n#include &quot;math/hal/integer.h&quot;\n#include &quot;math/nbtheory.h&quot;\n\n#include &quot;utils/debug.h&quot;\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/inttypes.h&quot;\n#include &quot;utils/openfhebase64.h&quot;\n#include &quot;utils/serializable.h&quot;\n\n#include &lt;cstdint&gt;\n// #include &lt;cstdlib&gt;\n// #include &lt;fstream&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n// #include &lt;memory&gt;\n// #include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n// #include &lt;typeinfo&gt;\n#include &lt;vector&gt;\n#include &lt;utility&gt;\n\n// the default behavior of the native integer layer is\n// to assume that the user does not need bounds/range checks\n// in the native integer code\n// if you want them, change this #define to true\n// we use a #define to resolve which to use at compile time\n// sadly, making the choice according to some setting that\n// is checked at runtime has awful performance; using this\n// #define in a simple expression causes the compiler to\n// optimize away the test\n#define NATIVEINT_DO_CHECKS false\n#define NATIVEINT_BARRET_MOD\n\n// TODO: remove these?\nusing U32BITS = uint32_t;\nusing U64BITS = uint64_t;\n#if defined(HAVE_INT128)\nusing U128BITS = uint128_t;\n#endif\n\nnamespace intnat {\n\n// Forward declare class and give it an alias for the expected type\ntemplate &lt;typename IntType&gt;\nclass NativeIntegerT;\nusing NativeInteger = NativeIntegerT&lt;BasicInteger&gt;;\n\ntemplate &lt;typename IntType&gt;\nclass NativeVectorT;\n\n// constexpr double LOG2_10 = 3.32192809;  //!&lt; @brief A pre-computed  constant of Log base 2 of 10.\n// constexpr usint BARRETT_LEVELS = 8;  //!&lt; @brief The number of levels (precomputed\n//!&lt; values) used in the Barrett reductions.\n\n/**\n * @brief Struct to determine other datatyps based on utype.\n * @tparam utype primitive integer data type.\n */\ntemplate &lt;typename utype&gt;\nstruct DataTypes {\n    using SignedType       = void;\n    using DoubleType       = void;\n    using SignedDoubleType = void;\n};\ntemplate &lt;&gt;\nstruct DataTypes&lt;uint32_t&gt; {\n    using SignedType       = int32_t;\n    using DoubleType       = uint64_t;\n    using SignedDoubleType = int64_t;\n};\ntemplate &lt;&gt;\nstruct DataTypes&lt;uint64_t&gt; {\n    using SignedType = int64_t;\n#if defined(HAVE_INT128)\n    using DoubleType       = uint128_t;\n    using SignedDoubleType = int128_t;\n#else\n    using DoubleType       = uint64_t;\n    using SignedDoubleType = int64_t;\n#endif\n};\n#if defined(HAVE_INT128)\ntemplate &lt;&gt;\nstruct DataTypes&lt;uint128_t&gt; {\n    using SignedType       = int128_t;\n    using DoubleType       = uint128_t;\n    using SignedDoubleType = int128_t;\n};\n#endif\n\n/**\n * @brief Main class for big integers represented as an array of native\n * (primitive) unsigned integers\n * @tparam NativeInt native unsigned integer type\n */\ntemplate &lt;typename NativeInt&gt;\nclass NativeIntegerT final : public lbcrypto::BigIntegerInterface&lt;NativeIntegerT&lt;NativeInt&gt;&gt; {\nprivate:\n    NativeInt m_value{0};\n\n    // variable to store the maximum value of the integral data type.\n    static constexpr NativeInt m_uintMax{std::numeric_limits&lt;NativeInt&gt;::max()};\n    // variable to store the bit width of the integral data type.\n    //    static constexpr usint m_uintBitLength{sizeof(NativeInt) * 8};\n    static constexpr usint m_uintBitLength{std::numeric_limits&lt;NativeInt&gt;::digits};\n\n    friend class NativeVectorT&lt;NativeIntegerT&lt;NativeInt&gt;&gt;;\n\npublic:\n    using Integer         = NativeInt;\n    using SignedNativeInt = typename DataTypes&lt;NativeInt&gt;::SignedType;\n    using DNativeInt      = typename DataTypes&lt;NativeInt&gt;::DoubleType;\n    using SDNativeInt     = typename DataTypes&lt;NativeInt&gt;::SignedDoubleType;\n\n    // data structure to represent a double-word integer as two single-word integers\n    struct typeD {\n        NativeInt hi{0};\n        NativeInt lo{0};\n        inline std::string ConvertToString() const {\n            return std::string(&quot;hi [&quot; + toString(hi) + &quot;], lo [&quot; + toString(lo) + &quot;]&quot;);\n        }\n    };\n\n    explicit operator NativeInt() const {\n        return m_value;\n    }\n    explicit operator bool() const {\n        return m_value != 0;\n    }\n\n    constexpr NativeIntegerT() = default;\n    constexpr NativeIntegerT(const NativeIntegerT&amp; val) noexcept : m_value{val.m_value} {}\n    constexpr NativeIntegerT(NativeIntegerT&amp;&amp; val) noexcept : m_value{std::move(val.m_value)} {}\n\n    NativeIntegerT(const std::string&amp; val) {\n        this-&gt;NativeIntegerT::SetValue(val);\n    }\n\n    explicit NativeIntegerT(const char* strval) {\n        this-&gt;NativeIntegerT::SetValue(std::string(strval));\n    }\n    // explicit NativeIntegerT(const char strval) : m_value{NativeInt(strval - &#x27;0&#x27;)} {}\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, bool&gt; = true&gt;\n    constexpr NativeIntegerT(T val) noexcept : m_value(val) {}\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_same_v&lt;T, M2Integer&gt; || std::is_same_v&lt;T, M4Integer&gt; ||\n                                               std::is_same_v&lt;T, M6Integer&gt;,\n                                           bool&gt; = true&gt;\n    constexpr NativeIntegerT(T val) noexcept : m_value{val.template ConvertToInt&lt;NativeInt&gt;()} {}\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;, bool&gt; = true&gt;\n    NativeIntegerT(T val) = delete;\n\n    constexpr NativeIntegerT&amp; operator=(const NativeIntegerT&amp; val) noexcept {\n        m_value = val.m_value;\n        return *this;\n    }\n\n    constexpr NativeIntegerT&amp; operator=(NativeIntegerT&amp;&amp; val) noexcept {\n        m_value = std::move(val.m_value);\n        return *this;\n    }\n\n    NativeIntegerT&amp; operator=(const std::string&amp; val) {\n        this-&gt;NativeIntegerT::SetValue(val);\n        return *this;\n    }\n\n    NativeIntegerT&amp; operator=(const char* strval) {\n        this-&gt;NativeIntegerT::SetValue(std::string(strval));\n        return *this;\n    }\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, bool&gt; = true&gt;\n    constexpr NativeIntegerT&amp; operator=(T val) noexcept {\n        m_value = val;\n        return *this;\n    }\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_same_v&lt;T, M2Integer&gt; || std::is_same_v&lt;T, M4Integer&gt; ||\n                                               std::is_same_v&lt;T, M6Integer&gt;,\n                                           bool&gt; = true&gt;\n    constexpr NativeIntegerT&amp; operator=(T val) noexcept {\n        m_value = val.template ConvertToInt&lt;NativeInt&gt;();\n        return *this;\n    }\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;, bool&gt; = true&gt;\n    NativeIntegerT&amp; operator=(T val) = delete;\n\n    /**\n   * Basic set method for setting the value of a native integer\n   *\n   * @param &amp;strval is the string representation of the native integer to be\n   * copied.\n   */\n    void SetValue(const std::string&amp; str) {\n        NativeInt acc{0}, tst{0};\n        for (auto c : str) {\n            if ((c - &#x27;0&#x27;) &gt; 9)\n                &quot;hey&quot;; OPENFHE_THROW(lbcrypto::type_error, &quot;String contains a non-digit&quot;);\n            if ((acc = (10 * acc) + static_cast&lt;NativeInt&gt;(c - &#x27;0&#x27;)) &lt; tst)\n                &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, str + &quot; is too large to fit in this native integer object&quot;);\n            tst = acc;\n        }\n        m_value = acc;\n    }\n\n    /**\n   * Basic set method for setting the value of a native integer\n   *\n   * @param &amp;val is the big binary integer representation of the native\n   * integer to be assigned.\n   */\n    void SetValue(const NativeIntegerT&amp; val) {\n        m_value = val.m_value;\n    }\n\n    /**\n   *  Set this int to 1.\n   */\n    void SetIdentity() {\n        m_value = static_cast&lt;NativeInt&gt;(1);\n    }\n\n    /**\n   * Addition operation.\n   *\n   * @param &amp;b is the value to add.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT Add(const NativeIntegerT&amp; b) const {\n        return NATIVEINT_DO_CHECKS ? AddCheck(b) : AddFast(b);\n    }\n\n    /**\n   * AddCheck is the addition operation with bounds checking.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT AddCheck(const NativeIntegerT&amp; b) const {\n        auto r{m_value + b.m_value};\n        if (r &lt; m_value || r &lt; b.m_value)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT AddCheck: Overflow&quot;);\n        return {r};\n    }\n\n    /**\n   * AddFast is the addition operation without bounds checking.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT AddFast(const NativeIntegerT&amp; b) const {\n        return {b.m_value + m_value};\n    }\n\n    /**\n   * Addition operation. In-place variant.\n   *\n   * @param &amp;b is the value to add.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT&amp; AddEq(const NativeIntegerT&amp; b) {\n        return NATIVEINT_DO_CHECKS ? AddEqCheck(b) : AddEqFast(b);\n    }\n\n    /**\n   * AddEqCheck is the addition in place operation with bounds checking.\n   * In-place variant.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT&amp; AddEqCheck(const NativeIntegerT&amp; b) {\n        auto oldv{m_value};\n        if ((m_value += b.m_value) &lt; oldv)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT AddEqCheck: Overflow&quot;);\n        return *this;\n    }\n\n    /**\n   * AddEqFast is the addition in place operation without bounds checking.\n   * In-place variant.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT&amp; AddEqFast(const NativeIntegerT&amp; b) {\n        return *this = b.m_value + m_value;\n    }\n\n    /**\n   * Subtraction operation.\n   *\n   * @param &amp;b is the value to subtract.\n   * @return is the result of the subtraction operation.\n   */\n    NativeIntegerT Sub(const NativeIntegerT&amp; b) const {\n        return NATIVEINT_DO_CHECKS ? SubCheck(b) : SubFast(b);\n    }\n\n    /**\n   * SubCheck is the subtraction operation with bounds checking.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT SubCheck(const NativeIntegerT&amp; b) const {\n        return {m_value &lt;= b.m_value ? 0 : m_value - b.m_value};\n    }\n\n    /**\n   * SubFast is the subtraction operation without bounds checking.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    // no saturated subtraction? functionality differs from BigInteger Backends\n    NativeIntegerT SubFast(const NativeIntegerT&amp; b) const {\n        return {m_value - b.m_value};\n    }\n\n    /**\n   * Subtraction operation. In-place variant.\n   *\n   * @param &amp;b is the value to subtract.\n   * @return is the result of the subtraction operation.\n   */\n    NativeIntegerT&amp; SubEq(const NativeIntegerT&amp; b) {\n        return NATIVEINT_DO_CHECKS ? SubEqCheck(b) : SubEqFast(b);\n    }\n\n    /**\n   * SubEqCheck is the subtraction in place operation with bounds checking.\n   * In-place variant.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT&amp; SubEqCheck(const NativeIntegerT&amp; b) {\n        if (m_value &lt; b.m_value)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT SubEqCheck: neg value&quot;);\n        return *this = m_value - b.m_value;\n    }\n\n    /**\n   * SubEqFast is the subtraction in place operation without bounds checking.\n   * In-place variant.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT&amp; SubEqFast(const NativeIntegerT&amp; b) {\n        return *this = m_value - b.m_value;\n    }\n\n    // overloaded binary operators based on integer arithmetic and comparison\n    // functions.\n    NativeIntegerT operator-() const {\n        return NativeIntegerT().Sub(*this);\n    }\n\n    /**\n   * Multiplication operation.\n   *\n   * @param &amp;b is the value to multiply with.\n   * @return is the result of the multiplication operation.\n   */\n    NativeIntegerT Mul(const NativeIntegerT&amp; b) const {\n        return NATIVEINT_DO_CHECKS ? MulCheck(b) : MulFast(b);\n    }\n\n    /**\n   * MulCheck is the multiplication operation with bounds checking.\n   *\n   * @param b is the value to multiply with\n   * @return result of the multiplication operation\n   */\n    NativeIntegerT MulCheck(const NativeIntegerT&amp; b) const {\n        auto p{b.m_value * m_value};\n        if (p &lt; m_value || p &lt; b.m_value)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT MulCheck: Overflow&quot;);\n        return {p};\n    }\n\n    /**\n   * MulFast is the multiplication operation without bounds checking.\n   *\n   * @param b is the value to multiply with.\n   * @return result of the multiplication operation.\n   */\n    NativeIntegerT MulFast(const NativeIntegerT&amp; b) const {\n        return {b.m_value * m_value};\n    }\n\n    /**\n   * Multiplication operation. In-place variant.\n   *\n   * @param &amp;b is the value to multiply with.\n   * @return is the result of the multiplication operation.\n   */\n    NativeIntegerT&amp; MulEq(const NativeIntegerT&amp; b) {\n        return NATIVEINT_DO_CHECKS ? MulEqCheck(b) : MulEqFast(b);\n    }\n\n    /**\n   * MulEqCheck is the multiplication in place operation with bounds checking.\n   * In-place variant.\n   *\n   * @param b is the value to multiply with\n   * @return result of the multiplication operation\n   */\n    NativeIntegerT&amp; MulEqCheck(const NativeIntegerT&amp; b) {\n        auto oldv{m_value};\n        if ((m_value *= b.m_value) &lt; oldv)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT MulEqCheck: Overflow&quot;);\n        return *this;\n    }\n\n    /**\n   * MulEqFast is the multiplication in place operation without bounds\n   * checking. In-place variant.\n   *\n   * @param b is the value to multiply with\n   * @return result of the multiplication operation\n   */\n    NativeIntegerT&amp; MulEqFast(const NativeIntegerT&amp; b) {\n        return *this = b.m_value * m_value;\n    }\n\n    /**\n   * Division operation.\n   *\n   * @param &amp;b is the value to divide by.\n   * @return is the result of the division operation.\n   */\n    NativeIntegerT DividedBy(const NativeIntegerT&amp; b) const {\n        if (b.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT DividedBy: zero&quot;);\n        return {m_value / b.m_value};\n    }\n\n    /**\n   * Division operation. In-place variant.\n   *\n   * @param &amp;b is the value to divide by.\n   * @return is the result of the division operation.\n   */\n    NativeIntegerT&amp; DividedByEq(const NativeIntegerT&amp; b) {\n        if (b.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT DividedByEq: zero&quot;);\n        return *this = m_value / b.m_value;\n    }\n\n    /**\n   * Exponentiation operation. Returns x^p.\n   *\n   * @param p the exponent.\n   * @return is the result of the exponentiation operation.\n   */\n    NativeIntegerT Exp(usint p) const {\n        NativeInt r{1};\n        for (auto x = m_value; p &gt; 0; p &gt;&gt;= 1, x *= x)\n            r *= (p &amp; 0x1) ? x : 1;\n        return {r};\n    }\n\n    /**\n   * Exponentiation operation. Returns x^p. In-place variant.\n   *\n   * @param p the exponent.\n   * @return is the result of the exponentiation operation.\n   */\n    NativeIntegerT&amp; ExpEq(usint p) {\n        auto x{m_value};\n        m_value = 1;\n        for (; p &gt; 0; p &gt;&gt;= 1, x *= x)\n            m_value *= (p &amp; 0x1) ? x : 1;\n        return *this;\n    }\n\n    /**\n   * Multiply and Rounding operation. Returns [x*p/q] where [] is the rounding\n   * operation.\n   *\n   * @param &amp;p is the numerator to be multiplied.\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of multiply and round operation.\n   */\n    NativeIntegerT MultiplyAndRound(const NativeIntegerT&amp; p, const NativeIntegerT&amp; q) const {\n        if (q.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT MultiplyAndRound: Divide by zero&quot;);\n        return static_cast&lt;NativeInt&gt;(p.ConvertToDouble() * (this-&gt;ConvertToDouble() / q.ConvertToDouble()) + 0.5);\n    }\n\n    /**\n   * Multiply and Rounding operation. Returns [x*p/q] where [] is the rounding\n   * operation. In-place variant.\n   *\n   * @param &amp;p is the numerator to be multiplied.\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of multiply and round operation.\n   */\n    NativeIntegerT&amp; MultiplyAndRoundEq(const NativeIntegerT&amp; p, const NativeIntegerT&amp; q) {\n        if (q.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT MultiplyAndRoundEq: Divide by zero&quot;);\n        return *this =\n                   static_cast&lt;NativeInt&gt;(p.ConvertToDouble() * (this-&gt;ConvertToDouble() / q.ConvertToDouble()) + 0.5);\n    }\n\n    /**\n   * Computes the quotient of x*p/q, where x,p,q are all NativeInt numbers, x\n   * is the current value; uses DNativeInt arithmetic\n   *\n   * @param p is the multiplicand\n   * @param q is the divisor\n   * @return the quotient\n   */\n    //    template &lt;typename T = NativeInt&gt;\n    //    NativeIntegerT MultiplyAndDivideQuotient(const NativeIntegerT&amp; p, const NativeIntegerT&amp; q) const {\n    //        DNativeInt xD{m_value};\n    //        DNativeInt pD{p.m_value};\n    //        DNativeInt qD{q.m_value};\n    //        return static_cast&lt;NativeIntegerT&gt;(xD * pD / qD);\n    //    }\n\n    /**\n   * Computes the remainder of x*p/q, where x,p,q are all NativeInt numbers, x\n   * is the current value; uses DNativeInt arithmetic. In-place variant.\n   *\n   * @param p is the multiplicand\n   * @param q is the divisor\n   * @return the remainder\n   */\n    //    template &lt;typename T = NativeInt&gt;\n    //    NativeIntegerT MultiplyAndDivideRemainder(const NativeIntegerT&amp; p, const NativeIntegerT&amp; q) const {\n    //        DNativeInt xD{m_value};\n    //        DNativeInt pD{p.m_value};\n    //        DNativeInt qD{q.m_value};\n    //        return static_cast&lt;NativeIntegerT&gt;(xD * pD % qD);\n    //    }\n\n    /**\n   * Divide and Rounding operation. Returns [x/q] where [] is the rounding\n   * operation.\n   *\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of divide and round operation.\n   */\n    NativeIntegerT DivideAndRound(const NativeIntegerT&amp; q) const {\n        if (q.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT DivideAndRound: zero&quot;);\n        auto ans{m_value / q.m_value};\n        auto rem{m_value % q.m_value};\n        auto halfQ{q.m_value &gt;&gt; 1};\n        if (rem &gt; halfQ)\n            return {ans + 1};\n        return {ans};\n    }\n\n    /**\n   * Divide and Rounding operation. Returns [x/q] where [] is the rounding\n   * operation. In-place variant.\n   *\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of divide and round operation.\n   */\n    NativeIntegerT&amp; DivideAndRoundEq(const NativeIntegerT&amp; q) {\n        if (q.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT DivideAndRoundEq: zero&quot;);\n        auto ans{m_value / q.m_value};\n        auto rem{m_value % q.m_value};\n        auto halfQ{q.m_value &gt;&gt; 1};\n        if (rem &gt; halfQ)\n            return *this = ans + 1;\n        return *this = ans;\n    }\n\n    /**\n   * Naive modulus operation.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @return is the result of the modulus operation.\n   */\n    NativeIntegerT Mod(const NativeIntegerT&amp; modulus) const {\n        return {m_value % modulus.m_value};\n    }\n\n    /**\n   * Naive modulus operation. In-place variant.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @return is the result of the modulus operation.\n   */\n    NativeIntegerT&amp; ModEq(const NativeIntegerT&amp; modulus) {\n        return *this = m_value % modulus.m_value;\n    }\n\n    /**\n   * Precomputes a parameter mu for Barrett modular reduction.\n   *\n   * @return the precomputed parameter mu.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ComputeMu(typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        if (m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT ComputeMu: Divide by zero&quot;);\n        auto&amp;&amp; tmp{DNativeInt{1} &lt;&lt; (2 * lbcrypto::GetMSB(m_value) + 3)};\n        return {tmp / DNativeInt(m_value)};\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ComputeMu(typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        if (m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT ComputeMu: Divide by zero&quot;);\n        auto&amp;&amp; tmp{bigintbackend::BigInteger{1} &lt;&lt; (2 * lbcrypto::GetMSB(m_value) + 3)};\n        return {(tmp / bigintbackend::BigInteger(m_value)).template ConvertToInt&lt;NativeInt&gt;()};\n    }\n\n    /**\n   * Barrett modulus operation.\n   * Implements generalized Barrett modular reduction algorithm. Uses one\n   * precomputed value of mu.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus operation.\n   */\n    // TODO: pass modulus.GetMSB() with mu for faster vector ops?\n    NativeIntegerT Mod(const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu) const {\n        typeD tmp;\n        NativeIntegerT ans{*this};\n        ModMu(tmp, ans, modulus.m_value, mu.m_value, modulus.GetMSB() - 2);\n        return ans;\n    }\n\n    /**\n   * Barrett modulus operation. In-place variant.\n   * Implements generalized Barrett modular reduction algorithm. Uses one\n   * precomputed value of mu.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus operation.\n   */\n    NativeIntegerT&amp; ModEq(const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu) {\n        typeD tmp;\n        ModMu(tmp, *this, modulus.m_value, mu.m_value, modulus.GetMSB() - 2);\n        return *this;\n    }\n\n    /**\n   * Modulus addition operation.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeIntegerT ModAdd(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) const {\n        auto av{m_value};\n        auto bv{b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (av &gt;= mv)\n            av %= mv;\n        if (bv &gt;= mv)\n            bv %= mv;\n        av += bv;\n        if (av &gt;= mv)\n            av -= mv;\n        return {av};\n    }\n\n    /**\n   * Modulus addition operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeIntegerT&amp; ModAddEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) {\n        auto bv{b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (m_value &gt;= mv)\n            m_value = m_value % mv;\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        m_value += bv;\n        if (m_value &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /**\n   * Modulus addition where operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeIntegerT ModAddFast(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) const {\n        auto r{m_value + b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (r &gt;= mv)\n            r -= mv;\n        return {r};\n    }\n    /**\n   * Modulus addition where operands are &lt; modulus. In-place variant.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeIntegerT&amp; ModAddFastEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) {\n        auto&amp; mv{modulus.m_value};\n        m_value += b.m_value;\n        if (m_value &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /**\n   * Barrett modulus addition operation.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus addition operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModAdd(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                          typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        auto&amp; mv{modulus.m_value};\n#ifdef NATIVEINT_BARRET_MOD\n        auto av{*this};\n        auto bv{b};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        av.m_value += bv.m_value;\n        if (av.m_value &gt;= mv)\n            av.m_value -= mv;\n        return av;\n#else\n        auto bv{b.m_value};\n        auto av{m_value};\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &gt;= mv)\n            av = av % mv;\n        av = av + bv;\n        if (av &gt;= mv)\n            return {av - mv};\n        return {av};\n#endif\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModAdd(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                          typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        auto av{*this};\n        auto bv{b};\n        auto&amp; mv{modulus.m_value};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        av.m_value += bv.m_value;\n        if (av.m_value &gt;= mv)\n            av.m_value -= mv;\n        return av;\n    }\n\n    /**\n   * Barrett modulus addition operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus addition operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModAddEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                             typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        auto&amp; mv{modulus.m_value};\n#ifdef NATIVEINT_BARRET_MOD\n        auto av{*this};\n        auto bv{b};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        m_value = av.m_value + bv.m_value;\n        if (m_value &gt;= mv)\n            m_value -= mv;\n        return *this;\n#else\n        auto bv{b.m_value};\n        auto av{m_value};\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &gt;= mv)\n            av = av % mv;\n        av = av + bv;\n        if (av &gt;= mv)\n            return *this = av - mv;\n        return *this = av;\n#endif\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModAddEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                             typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        auto av{*this};\n        auto bv{b};\n        auto&amp; mv{modulus.m_value};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        m_value = av.m_value + bv.m_value;\n        if (m_value &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /**\n   * Modulus subtraction operation.\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    NativeIntegerT ModSub(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) const {\n        auto av{m_value};\n        auto bv{b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (av &gt;= mv)\n            av %= mv;\n        if (bv &gt;= mv)\n            bv %= mv;\n        if (av &lt; bv)\n            return {av + mv - bv};\n        return {av - bv};\n    }\n\n    /**\n   * Modulus subtraction operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    NativeIntegerT&amp; ModSubEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) {\n        auto av{m_value};\n        auto bv{b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (av &gt;= mv)\n            av = av % mv;\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &lt; bv)\n            return *this = av + mv - bv;\n        return *this = av - bv;\n    }\n\n    /**\n   * Modulus subtraction where operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    NativeIntegerT ModSubFast(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) const {\n        if (m_value &lt; b.m_value)\n            return {m_value + modulus.m_value - b.m_value};\n        return {m_value - b.m_value};\n    }\n\n    /**\n   * Modulus subtraction where operands are &lt; modulus. In-place variant.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    NativeIntegerT&amp; ModSubFastEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) {\n        if (m_value &lt; b.m_value)\n            return *this = m_value + modulus.m_value - b.m_value;\n        return *this = m_value - b.m_value;\n    }\n\n    /**\n   * Barrett modulus subtraction operation.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus subtraction operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModSub(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                          typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        auto&amp; mv{modulus.m_value};\n#ifdef NATIVEINT_BARRET_MOD\n        auto av{*this};\n        auto bv{b};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        if (av.m_value &lt; bv.m_value)\n            return {av.m_value + mv - bv.m_value};\n        return {av.m_value - bv.m_value};\n#else\n        auto av{m_value};\n        auto bv{b.m_value};\n        if (av &gt;= mv)\n            av = av % mv;\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &lt; bv)\n            return {av + mv - bv};\n        return {av - bv};\n#endif\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModSub(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                          typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        auto av{*this};\n        auto bv{b};\n        auto&amp; mv{modulus.m_value};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        if (av.m_value &lt; bv.m_value)\n            return {av.m_value + mv - bv.m_value};\n        return {av.m_value - bv.m_value};\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModSubEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                             typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        auto&amp; mv{modulus.m_value};\n#ifdef NATIVEINT_BARRET_MOD\n        auto av{*this};\n        auto bv{b};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        if (av.m_value &lt; bv.m_value)\n            return *this = av.m_value + mv - bv.m_value;\n        return *this = av.m_value - bv.m_value;\n#else\n        auto bv{b.m_value};\n        auto av{m_value};\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &gt;= mv)\n            av = av % mv;\n        if (av &lt; bv)\n            return *this = av + mv - bv;\n        return *this = av - bv;\n#endif\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModSubEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                             typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        auto av{*this};\n        auto bv{b};\n        auto&amp; mv{modulus.m_value};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        if (av.m_value &lt; bv.m_value)\n            return *this = av.m_value + mv - bv.m_value;\n        return *this = av.m_value - bv.m_value;\n    }\n\n    /**\n   * Modulus multiplication operation.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMul(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                          typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        auto av{m_value};\n        auto bv{b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (av &gt;= mv)\n            av = av % mv;\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        DNativeInt rv{static_cast&lt;DNativeInt&gt;(av) * bv};\n        DNativeInt dmv{mv};\n        if (rv &gt;= dmv)\n            rv %= dmv;\n        return {rv};\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMul(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                          typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        typeD tmp;\n        auto av{*this};\n        auto&amp; mv{modulus.m_value};\n        auto mu{modulus.ComputeMu().m_value};\n        int64_t n{modulus.GetMSB() - 2};\n        if (av.m_value &gt;= mv)\n            ModMu(tmp, av, mv, mu, n);\n        auto bv{b};\n        if (bv.m_value &gt;= mv)\n            ModMu(tmp, bv, mv, mu, n);\n        MultD(av.m_value, bv.m_value, tmp);\n        typeD r{tmp};\n        MultD(RShiftD(tmp, n), mu, tmp);\n        MultD(RShiftD(tmp, n + 7), mv, tmp);\n        SubtractD(r, tmp);\n        if (r.lo &gt;= mv)\n            r.lo -= mv;\n        return {r.lo};\n    }\n\n    /**\n   * Modulus multiplication operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModMulEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                             typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        auto av{m_value};\n        auto bv{b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (av &gt;= mv)\n            av = av % mv;\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        DNativeInt rv{static_cast&lt;DNativeInt&gt;(av) * bv};\n        DNativeInt dmv{mv};\n        if (rv &gt;= dmv)\n            rv %= dmv;\n        return *this = static_cast&lt;NativeInt&gt;(rv);\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModMulEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                             typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        auto av{*this};\n        auto&amp; mv{modulus.m_value};\n        typeD tmp;\n        auto mu{modulus.ComputeMu().m_value};\n        int64_t n{modulus.GetMSB() - 2};\n        if (av.m_value &gt;= mv)\n            ModMu(tmp, av, mv, mu, n);\n        auto bv{b};\n        if (bv.m_value &gt;= mv)\n            ModMu(tmp, bv, mv, mu, n);\n        MultD(av.m_value, bv.m_value, tmp);\n        typeD r = tmp;\n        MultD(RShiftD(tmp, n), mu, tmp);\n        MultD(RShiftD(tmp, n + 7), mv, tmp);\n        SubtractD(r, tmp);\n        m_value = r.lo;\n        if (r.lo &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /**\n   * Barrett modulus multiplication.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMul(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                          typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n#ifdef NATIVEINT_BARRET_MOD\n        auto av{*this};\n        auto&amp; mv{modulus.m_value};\n        typeD tmp;\n        int64_t n{modulus.GetMSB() - 2};\n        if (av.m_value &gt;= mv)\n            ModMu(tmp, av, mv, mu.m_value, n);\n        auto bv{b};\n        if (bv.m_value &gt;= mv)\n            ModMu(tmp, bv, mv, mu.m_value, n);\n        MultD(av.m_value, bv.m_value, tmp);\n        auto rv = GetD(tmp);\n        MultD(RShiftD(tmp, n), mu.m_value, tmp);\n        rv -= DNativeInt(mv) * (GetD(tmp) &gt;&gt; n + 7);\n        NativeIntegerT r(rv);\n        if (r.m_value &gt;= mv)\n            r.m_value -= mv;\n        return r;\n#else\n        auto&amp; mv{modulus.m_value};\n        auto bv{b.m_value};\n        auto av{m_value};\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &gt;= mv)\n            av = av % mv;\n        DNativeInt rv{static_cast&lt;DNativeInt&gt;(av) * bv};\n        DNativeInt dmv{mv};\n        if (rv &gt;= dmv)\n            return {rv % dmv};\n        return {rv};\n#endif\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMul(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                          typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        auto av{*this};\n        auto&amp; mv{modulus.m_value};\n        typeD tmp;\n        int64_t n{modulus.GetMSB() - 2};\n        if (av.m_value &gt;= mv)\n            ModMu(tmp, av, mv, mu.m_value, n);\n        auto bv{b};\n        if (bv.m_value &gt;= mv)\n            ModMu(tmp, bv, mv, mu.m_value, n);\n        MultD(av.m_value, bv.m_value, tmp);\n        typeD r = tmp;\n        MultD(RShiftD(tmp, n), mu.m_value, tmp);\n        MultD(RShiftD(tmp, n + 7), mv, tmp);\n        SubtractD(r, tmp);\n        if (r.lo &gt;= mv)\n            r.lo -= mv;\n        return {r.lo};\n    }\n\n    /**\n   * Barrett modulus multiplication. In-place variant.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModMulEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                             typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n#ifdef NATIVEINT_BARRET_MOD\n        auto av{*this};\n        auto bv{b};\n        auto&amp; mv{modulus.m_value};\n        typeD tmp;\n        auto&amp; muv{mu.m_value};\n        int64_t n{modulus.GetMSB() - 2};\n        if (av.m_value &gt;= mv)\n            ModMu(tmp, av, mv, muv, n);\n        if (bv.m_value &gt;= mv)\n            ModMu(tmp, bv, mv, muv, n);\n        MultD(av.m_value, bv.m_value, tmp);\n        auto rv = GetD(tmp);\n        MultD(RShiftD(tmp, n), muv, tmp);\n        rv -= DNativeInt(mv) * (GetD(tmp) &gt;&gt; n + 7);\n        m_value = static_cast&lt;NativeInt&gt;(rv);\n        if (m_value &gt;= mv)\n            m_value -= mv;\n        return *this;\n#else\n        auto&amp; mv{modulus.m_value};\n        auto bv{b.m_value};\n        auto av{m_value};\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &gt;= mv)\n            av = av % mv;\n        DNativeInt rv{static_cast&lt;DNativeInt&gt;(av) * bv};\n        DNativeInt dmv{mv};\n        if (rv &gt;= dmv)\n            return *this = static_cast&lt;NativeInt&gt;(rv % dmv);\n        return *this = static_cast&lt;NativeInt&gt;(rv);\n#endif\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModMulEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                             typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        int64_t n{modulus.GetMSB() - 2};\n        auto av{*this};\n        auto bv{b};\n        auto&amp; mv{modulus.m_value};\n        typeD tmp;\n        if (av.m_value &gt;= mv)\n            ModMu(tmp, av, mv, mu.m_value, n);\n        if (bv.m_value &gt;= mv)\n            ModMu(tmp, bv, mv, mu.m_value, n);\n        MultD(av.m_value, bv.m_value, tmp);\n        typeD r = tmp;\n        MultD(RShiftD(tmp, n), mu.m_value, tmp);\n        MultD(RShiftD(tmp, n + 7), mv, tmp);\n        SubtractD(r, tmp);\n        m_value = r.lo;\n        if (r.lo &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /**\n   * Modulus multiplication that assumes the operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMulFast(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                              typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        DNativeInt rv{static_cast&lt;DNativeInt&gt;(m_value) * b.m_value};\n        DNativeInt dmv{modulus.m_value};\n        if (rv &gt;= dmv)\n            rv %= dmv;\n        return {rv};\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMulFast(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                              typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        int64_t n = modulus.GetMSB() - 2;\n        auto&amp; mv{modulus.m_value};\n        typeD prod;\n        MultD(m_value, b.m_value, prod);\n        typeD r = prod;\n        MultD(RShiftD(prod, n), modulus.ComputeMu().m_value, prod);\n        MultD(RShiftD(prod, n + 7), mv, prod);\n        SubtractD(r, prod);\n        if (r.lo &gt;= mv)\n            r.lo -= mv;\n        return {r.lo};\n    }\n\n    /**\n   * Modulus multiplication that assumes the operands are &lt; modulus. In-place\n   * variant.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    // TODO: find what in Matrix&lt;DCRTPoly&gt; is calling ModMulFastEq incorrectly\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMulFastEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                                typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        DNativeInt rv{static_cast&lt;DNativeInt&gt;(m_value) * b.m_value};\n        DNativeInt dmv{modulus.m_value};\n        if (rv &gt;= dmv)\n            rv %= dmv;\n        return *this = static_cast&lt;NativeInt&gt;(rv);\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMulFastEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                                typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        int64_t n = modulus.GetMSB() - 2;\n        auto&amp; mv{modulus.m_value};\n        typeD prod;\n        MultD(m_value, b.m_value, prod);\n        typeD r = prod;\n        MultD(RShiftD(prod, n), modulus.ComputeMu().m_value, prod);\n        MultD(RShiftD(prod, n + 7), mv, prod);\n        SubtractD(r, prod);\n        m_value = r.lo;\n        if (r.lo &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /**\n   * Barrett modulus multiplication that assumes the operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus multiplication operation.\n   */\n    /* Source: http://homes.esat.kuleuven.be/~fvercaut/papers/bar_mont.pdf\n    @article{knezevicspeeding,\n    title={Speeding Up Barrett and Montgomery Modular Multiplications},\n    author={Knezevic, Miroslav and Vercauteren, Frederik and Verbauwhede,\n    Ingrid}\n    }\n    We use the Generalized Barrett modular reduction algorithm described in\n    Algorithm 2 of the Source. The algorithm was originally proposed in J.-F.\n    Dhem. Modified version of the Barrett algorithm. Technical report, 1994\n    and described in more detail in the PhD thesis of the author published at\n    http://users.belgacom.net/dhem/these/these_public.pdf (Section 2.2.4).\n    We take \\alpha equal to n + 3. So in our case, \\mu = 2^(n + \\alpha) =\n    2^(2*n + 3). Generally speaking, the value of \\alpha should be \\ge \\gamma\n    + 1, where \\gamma + n is the number of digits in the dividend. We use the\n    upper bound of dividend assuming that none of the dividends will be larger\n    than 2^(2*n + 3). The value of \\mu is computed by NativeVector::ComputeMu.\n    */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMulFast(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                              typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        int64_t n = modulus.GetMSB() - 2;\n        auto&amp; mv{modulus.m_value};\n        typeD tmp;\n        MultD(m_value, b.m_value, tmp);\n        auto rv = GetD(tmp);\n        MultD(RShiftD(tmp, n), mu.m_value, tmp);\n        rv -= DNativeInt(mv) * (GetD(tmp) &gt;&gt; n + 7);\n        NativeIntegerT r(rv);\n        if (r.m_value &gt;= mv)\n            r.m_value -= mv;\n        return r;\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMulFast(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                              typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        int64_t n = modulus.GetMSB() - 2;\n        auto&amp; mv{modulus.m_value};\n        typeD prod;\n        MultD(m_value, b.m_value, prod);\n        typeD r = prod;\n        MultD(RShiftD(prod, n), mu.m_value, prod);\n        MultD(RShiftD(prod, n + 7), mv, prod);\n        SubtractD(r, prod);\n        if (r.lo &gt;= mv)\n            r.lo -= mv;\n        return {r.lo};\n    }\n\n    /**\n   * Barrett modulus multiplication that assumes the operands are &lt; modulus.\n   * In-place variant.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModMulFastEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                                 typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        typeD tmp;\n        MultD(m_value, b.m_value, tmp);\n        auto rv{GetD(tmp)};\n        int64_t n{modulus.GetMSB() - 2};\n        MultD(RShiftD(tmp, n), mu.m_value, tmp);\n        auto&amp; mv{modulus.m_value};\n        rv -= DNativeInt(mv) * (GetD(tmp) &gt;&gt; n + 7);\n        m_value = NativeInt(rv);\n        if (m_value &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModMulFastEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                                 typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        int64_t n{modulus.GetMSB() - 2};\n        typeD prod;\n        MultD(m_value, b.m_value, prod);\n        typeD r{prod};\n        auto&amp; mv{modulus.m_value};\n        MultD(RShiftD(prod, n), mu.m_value, prod);\n        MultD(RShiftD(prod, n + 7), mv, prod);\n        SubtractD(r, prod);\n        m_value = r.lo;\n        if (r.lo &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /*  The next three subroutines implement the modular multiplication\n    algorithm for the case when the multiplicand is used multiple times (known\n    in advance), as in NTT. The algorithm is described in\n    https://arxiv.org/pdf/1205.2926.pdf (Dave Harvey, FASTER ARITHMETIC FOR\n    NUMBER-THEORETIC TRANSFORMS). The algorithm is described in lines 5-7 of\n    Algorithm 2. The algorithm was originally proposed and implemented in NTL\n    (https://www.shoup.net/ntl/) by Victor Shoup.\n    */\n\n    /**\n   * Precomputation for a multiplicand.\n   *\n   * @param modulus is the modulus to perform operations with.\n   * @return the precomputed factor.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT PrepModMulConst(\n        const NativeIntegerT&amp; modulus,\n        typename std::enable_if&lt;!std::is_same&lt;T, DNativeInt&gt;::value, bool&gt;::type = true) const {\n        if (modulus.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Divide by zero&quot;);\n        auto&amp;&amp; w{DNativeInt(m_value) &lt;&lt; NativeIntegerT::MaxBits()};\n        return {w / DNativeInt(modulus.m_value)};\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT PrepModMulConst(\n        const NativeIntegerT&amp; modulus,\n        typename std::enable_if&lt;std::is_same&lt;T, DNativeInt&gt;::value, bool&gt;::type = true) const {\n        if (modulus.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Divide by zero&quot;);\n        auto&amp;&amp; w{bigintbackend::BigInteger(m_value) &lt;&lt; NativeIntegerT::MaxBits()};\n        return {(w / bigintbackend::BigInteger(modulus.m_value)).template ConvertToInt&lt;NativeInt&gt;()};\n    }\n\n    /**\n   * Modular multiplication using a precomputation for the multiplicand.\n   *\n   * @param &amp;b is the NativeIntegerT to multiply.\n   * @param modulus is the modulus to perform operations with.\n   * @param &amp;bInv precomputation for b.\n   * @return is the result of the modulus multiplication operation.\n   */\n    NativeIntegerT ModMulFastConst(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                                   const NativeIntegerT&amp; bInv) const {\n        NativeInt q = MultDHi(m_value, bInv.m_value) + 1;\n        auto yprime = static_cast&lt;SignedNativeInt&gt;(m_value * b.m_value - q * modulus.m_value);\n        return {yprime &gt;= 0 ? yprime : yprime + modulus.m_value};\n    }\n\n    /**\n   * Modular multiplication using a precomputation for the multiplicand.\n   * In-place variant.\n   *\n   * @param &amp;b is the NativeIntegerT to multiply.\n   * @param modulus is the modulus to perform operations with.\n   * @param &amp;bInv precomputation for b.\n   * @return is the result of the modulus multiplication operation.\n   */\n    NativeIntegerT&amp; ModMulFastConstEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                                      const NativeIntegerT&amp; bInv) {\n        NativeInt q = MultDHi(m_value, bInv.m_value) + 1;\n        auto yprime = static_cast&lt;SignedNativeInt&gt;(m_value * b.m_value - q * modulus.m_value);\n        m_value     = static_cast&lt;NativeInt&gt;(yprime &gt;= 0 ? yprime : yprime + modulus.m_value);\n        return *this;\n    }\n\n    /**\n   * Modulus exponentiation operation.\n   *\n   * @param &amp;b is the scalar to exponentiate at all locations.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus exponentiation operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModExp(const NativeIntegerT&amp; b, const NativeIntegerT&amp; mod,\n                          typename std::enable_if&lt;!std::is_same&lt;T, DNativeInt&gt;::value, bool&gt;::type = true) const {\n        DNativeInt t{m_value};\n        DNativeInt p{b.m_value};\n        DNativeInt m{mod.m_value};\n        DNativeInt r{1};\n        if (p &amp; 0x1) {\n            r = r * t;\n            if (r &gt;= m)\n                r = r % m;\n        }\n        while (p &gt;&gt;= 1) {\n            t = t * t;\n            if (t &gt;= m)\n                t = t % m;\n            if (p &amp; 0x1) {\n                r = r * t;\n                if (r &gt;= m)\n                    r = r % m;\n            }\n        }\n        return {r};\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModExp(const NativeIntegerT&amp; b, const NativeIntegerT&amp; mod,\n                          typename std::enable_if&lt;std::is_same&lt;T, DNativeInt&gt;::value, bool&gt;::type = true) const {\n        NativeIntegerT t{m_value % mod.m_value};\n        NativeIntegerT p{b.m_value};\n        NativeIntegerT mu{mod.ComputeMu()};\n        NativeIntegerT r{1};\n        if (p.m_value &amp; 0x1)\n            r.ModMulFastEq(t, mod, mu);\n        while (p.m_value &gt;&gt;= 1) {\n            t.ModMulFastEq(t, mod, mu);\n            if (p.m_value &amp; 0x1)\n                r.ModMulFastEq(t, mod, mu);\n        }\n        return {r};\n    }\n\n    /**\n   * Modulus exponentiation operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to exponentiate at all locations.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus exponentiation operation.\n   */\n    NativeIntegerT&amp; ModExpEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; mod) {\n        return *this = this-&gt;NativeIntegerT::ModExp(b, mod);\n    }\n\n    /**\n   * Modulus inverse operation.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @return is the result of the modulus inverse operation.\n   */\n    NativeIntegerT ModInverse(const NativeIntegerT&amp; mod) const {\n        SignedNativeInt modulus(mod.m_value);\n        SignedNativeInt a(m_value % mod.m_value);\n        if (a == 0) {\n            std::string msg = NativeIntegerT::toString(m_value) + &quot; does not have a ModInverse using &quot; +\n                              NativeIntegerT::toString(mod.m_value);\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, msg);\n        }\n        if (modulus == 1)\n            return NativeIntegerT();\n\n        SignedNativeInt y{0};\n        SignedNativeInt x{1};\n        while (a &gt; 1) {\n            auto t  = modulus;\n            auto q  = a / t;\n            modulus = a % t;\n            a       = t;\n            t       = y;\n            y       = x - q * y;\n            x       = t;\n        }\n        if (x &lt; 0)\n            x += mod.m_value;\n        return {x};\n    }\n\n    /**\n   * Modulus inverse operation. In-place variant.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @return is the result of the modulus inverse operation.\n   */\n    NativeIntegerT&amp; ModInverseEq(const NativeIntegerT&amp; mod) {\n        return *this = this-&gt;NativeIntegerT::ModInverse(mod);\n    }\n\n    /**\n   * Left shift operation.\n   *\n   * @param shift # of bits.\n   * @return result of the shift operation.\n   */\n    NativeIntegerT LShift(usshort shift) const {\n        return {m_value &lt;&lt; shift};\n    }\n\n    /**\n   * Left shift operation. In-place variant.\n   *\n   * @param shift # of bits.\n   * @return result of the shift operation.\n   */\n    NativeIntegerT&amp; LShiftEq(usshort shift) {\n        return *this = m_value &lt;&lt; shift;\n    }\n\n    /**\n   * Right shift operation.\n   *\n   * @param shift # of bits.\n   * @return result of the shift operation.\n   */\n    NativeIntegerT RShift(usshort shift) const {\n        return {m_value &gt;&gt; shift};\n    }\n\n    /**\n   * Right shift operation. In-place variant.\n   *\n   * @param shift # of bits.\n   * @return result of the shift operation.\n   */\n    NativeIntegerT&amp; RShiftEq(usshort shift) {\n        return *this = m_value &gt;&gt; shift;\n    }\n\n    /**\n   * Compares the current NativeIntegerT to NativeIntegerT a.\n   *\n   * @param a is the NativeIntegerT to be compared with.\n   * @return  -1 for strictly less than, 0 for equal to and 1 for strictly\n   * greater than conditons.\n   */\n    int Compare(const NativeIntegerT&amp; a) const {\n        return (m_value &lt; a.m_value) ? -1 : (m_value &gt; a.m_value) ? 1 : 0;\n    }\n\n    /**\n   * Converts the value to an int.\n   *\n   * @return the int representation of the value as usint.\n   */\n    template &lt;typename T = NativeInt, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, bool&gt; = true&gt;\n    constexpr T ConvertToInt() const noexcept {\n        // static_assert(sizeof(T) &gt;= sizeof(m_value), &quot;ConvertToInt(): Narrowing Conversion&quot;);\n        return static_cast&lt;T&gt;(m_value);\n    }\n\n    /**\n   * Converts the value to an double.\n   *\n   * @return double representation of the value.\n   */\n    constexpr double ConvertToDouble() const noexcept {\n        return static_cast&lt;double&gt;(m_value);\n    }\n\n    /**\n   * Convert a string representation of a binary number to a NativeIntegerT.\n   *\n   * @param bitString the binary num in string.\n   * @return the binary number represented as a big binary int.\n   */\n    static NativeIntegerT FromBinaryString(const std::string&amp; bitString) {\n        if (bitString.length() &gt; NativeIntegerT::MaxBits())\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Bit string is too long to fit in an intnat&quot;);\n        NativeInt v{0};\n        for (size_t i = 0; i &lt; bitString.length(); ++i) {\n            auto n = bitString[i] - &#x27;0&#x27;;\n            if (n &lt; 0 || n &gt; 1)\n                &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Bit string must contain only 0 or 1&quot;);\n            v = (v &lt;&lt; 1) | static_cast&lt;NativeInt&gt;(n);\n        }\n        return {v};\n    }\n\n    /**\n   * Returns the MSB location of the value.\n   *\n   * @return the index of the most significant bit.\n   */\n    usint GetMSB() const {\n        return lbcrypto::GetMSB(m_value);\n    }\n\n    /**\n   * Get the number of digits using a specific base - support for arbitrary\n   * base may be needed.\n   *\n   * @param base is the base with which to determine length in.\n   * @return the length of the representation in a specific base.\n   */\n\n    // TODO: only base 2?\n    usint GetLengthForBase(usint base) const {\n        return NativeIntegerT::GetMSB();\n    }\n\n    /**\n   * Get a specific digit at &quot;digit&quot; index; big integer is seen as an array of\n   * digits, where a 0 &lt;= digit &lt; base Warning: only power-of-2 bases are\n   * currently supported. Example: for number 83, index 2 and base 4 we have:\n   *\n   *                         index:0,1,2,3\n   * 83 --base 4 decomposition--&gt; (3,0,1,1) --at index 2--&gt; 1\n   *\n   * The return number is 1.\n   *\n   * @param index is the &quot;digit&quot; index of the requested digit\n   * @param base is the base with which to determine length in.\n   * @return is the requested digit\n   */\n\n    // TODO: * i to &lt;&lt; i\n    usint GetDigitAtIndexForBase(usint index, usint base) const {\n        usint DigitLen = ceil(log2(base));\n        usint digit    = 0;\n        usint newIndex = 1 + (index - 1) * DigitLen;\n        for (usint i = 1; i &lt; base; i &lt;&lt;= 1) {\n            digit += GetBitAtIndex(newIndex++) * i;\n        }\n        return digit;\n    }\n\n    /**\n   * Gets the bit at the specified index.\n   *\n   * @param index is the index of the bit to get.\n   * @return resulting bit.\n   */\n    uschar GetBitAtIndex(usint index) const {\n        if (index == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Zero index in GetBitAtIndex&quot;);\n        return static_cast&lt;uschar&gt;((m_value &gt;&gt; (index - 1)) &amp; 0x1);\n    }\n\n    /**\n   * A zero allocator that is called by the Matrix class.\n   * It is used to initialize a Matrix of NativeIntegerT objects.\n   */\n    static constexpr NativeIntegerT Allocator() noexcept {\n        return NativeIntegerT();\n    }\n\n    // STRINGS &amp; STREAMS\n\n    /**\n   * Stores the based 10 equivalent/Decimal value of the NativeIntegerT in a\n   * string object and returns it.\n   *\n   * @return value of this NativeIntegerT in base 10 represented as a string.\n   */\n    std::string ToString() const {\n        return toString(m_value);\n    }\n\n    static const std::string IntegerTypeName() {\n        return &quot;UBNATINT&quot;;\n    }\n\n    /**\n   * Console output operation.\n   *\n   * @param os is the std ostream object.\n   * @param ptr_obj is NativeIntegerT to be printed.\n   * @return is the ostream object.\n   */\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const NativeIntegerT&amp; ptr_obj) {\n        os &lt;&lt; ptr_obj.ToString();\n        return os;\n    }\n\n    template &lt;class Archive, typename T = void&gt;\n    typename std::enable_if_t&lt;std::is_same_v&lt;NativeInt, U64BITS&gt; || std::is_same_v&lt;NativeInt, U32BITS&gt;, T&gt; load(\n        Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                           &quot; is from a later version of the library&quot;);\n        }\n        ar(::cereal::make_nvp(&quot;v&quot;, m_value));\n    }\n\n#if defined(HAVE_INT128)\n    template &lt;class Archive&gt;\n    typename std::enable_if_t&lt;std::is_same_v&lt;NativeInt, U128BITS&gt; &amp;&amp; !cereal::traits::is_text_archive&lt;Archive&gt;::value,\n                              void&gt;\n    load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                           &quot; is from a later version of the library&quot;);\n        }\n        // get an array with 2 unint64_t values for m_value\n        uint64_t vec[2];\n        ar(::cereal::binary_data(vec, sizeof(vec)));  // 2*8 - size in bytes\n        m_value = vec[1];                             // most significant word\n        m_value &lt;&lt;= 64;\n        m_value += vec[0];  // least significant word\n    }\n\n    template &lt;class Archive&gt;\n    typename std::enable_if_t&lt;std::is_same_v&lt;NativeInt, U128BITS&gt; &amp;&amp; cereal::traits::is_text_archive&lt;Archive&gt;::value,\n                              void&gt;\n    load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                           &quot; is from a later version of the library&quot;);\n        }\n        // get an array with 2 unint64_t values for m_value\n        uint64_t vec[2];\n        ar(::cereal::make_nvp(&quot;i&quot;, vec));\n        m_value = vec[1];  // most significant word\n        m_value &lt;&lt;= 64;\n        m_value += vec[0];  // least significant word\n    }\n#endif\n\n    template &lt;class Archive, typename T = void&gt;\n    typename std::enable_if_t&lt;std::is_same_v&lt;NativeInt, U64BITS&gt; || std::is_same&lt;NativeInt, U32BITS&gt;::value, T&gt; save(\n        Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::make_nvp(&quot;v&quot;, m_value));\n    }\n\n#if defined(HAVE_INT128)\n    template &lt;class Archive&gt;\n    typename std::enable_if_t&lt;std::is_same_v&lt;NativeInt, U128BITS&gt; &amp;&amp; !cereal::traits::is_text_archive&lt;Archive&gt;::value,\n                              void&gt;\n    save(Archive&amp; ar, std::uint32_t const version) const {\n        // save 2 unint64_t values instead of uint128_t\n        constexpr U128BITS mask = (static_cast&lt;U128BITS&gt;(1) &lt;&lt; 64) - 1;\n        uint64_t vec[2];\n        vec[0] = m_value &amp; mask;  // least significant word\n        vec[1] = m_value &gt;&gt; 64;   // most significant word\n        ar(::cereal::binary_data(vec, sizeof(vec)));\n    }\n\n    template &lt;class Archive&gt;\n    typename std::enable_if_t&lt;std::is_same_v&lt;NativeInt, U128BITS&gt; &amp;&amp; cereal::traits::is_text_archive&lt;Archive&gt;::value,\n                              void&gt;\n    save(Archive&amp; ar, std::uint32_t const version) const {\n        // save 2 unint64_t values instead of uint128_t\n        constexpr U128BITS mask = (static_cast&lt;U128BITS&gt;(1) &lt;&lt; 64) - 1;\n        uint64_t vec[2];\n        vec[0] = m_value &amp; mask;  // least significant word\n        vec[1] = m_value &gt;&gt; 64;   // most significant word\n        ar(::cereal::make_nvp(&quot;i&quot;, vec));\n    }\n#endif\n\n    std::string SerializedObjectName() const {\n        return &quot;NATInteger&quot;;\n    }\n\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\n    static constexpr usint MaxBits() noexcept {\n        return m_uintBitLength;\n    }\n\n    static constexpr bool IsNativeInt() noexcept {\n        return true;\n    }\n\nprivate:\n    // Computes res -= a;\n    static void SubtractD(typeD&amp; res, const typeD&amp; a) {\n        if (res.lo &lt; a.lo) {\n            res.lo += m_uintMax + 1 - a.lo;\n            res.hi--;\n        }\n        else {\n            res.lo -= a.lo;\n        }\n        res.hi -= a.hi;\n    }\n\n    /**\n   * Right shifts a typeD integer by a specific number of bits\n   * and stores the result as a single-word integer.\n   *\n   * @param &amp;x double-word input\n   * @param shift the number of bits to shift by\n   * @return the result of right-shifting\n   */\n    static NativeInt RShiftD(const typeD&amp; x, int64_t shift) {\n        return (x.lo &gt;&gt; shift) | (x.hi &lt;&lt; (NativeIntegerT::MaxBits() - shift));\n    }\n\n    /**\n   * Multiplies two single-word integers and stores the result in a\n   * typeD data structure.\n   *\n   * @param a multiplier\n   * @param b multiplicand\n   * @param &amp;x result of multiplication\n   */\n    static void MultD(U32BITS a, U32BITS b, typeD&amp; res) {\n        U64BITS c{static_cast&lt;U64BITS&gt;(a) * b};\n        res.hi = static_cast&lt;U32BITS&gt;(c &gt;&gt; 32);\n        res.lo = static_cast&lt;U32BITS&gt;(c);\n    }\n\n    static void MultD(U64BITS a, U64BITS b, typeD&amp; res) {\n#if defined(__x86_64__)\n    #if defined(HAVE_INT128)\n        U128BITS c{static_cast&lt;U128BITS&gt;(a) * b};\n        res.hi = static_cast&lt;U64BITS&gt;(c &gt;&gt; 64);\n        res.lo = static_cast&lt;U64BITS&gt;(c);\n    #else\n        // clang-format off\n    __asm__(&quot;mulq %[b]&quot;\n            : [ lo ] &quot;=a&quot;(res.lo), [ hi ] &quot;=d&quot;(res.hi)\n            : [ a ] &quot;%[lo]&quot;(a), [ b ] &quot;rm&quot;(b)\n            : &quot;cc&quot;);\n                // clang-format on\n    #endif\n#elif defined(__aarch64__)\n        typeD x;\n        x.hi = 0;\n        x.lo = a;\n        U64BITS y(b);\n        res.lo = x.lo * y;\n        asm(&quot;umulh %0, %1, %2\\n\\t&quot; : &quot;=r&quot;(res.hi) : &quot;r&quot;(x.lo), &quot;r&quot;(y));\n        res.hi += x.hi * y;\n#elif defined(__arm__)  // 32 bit processor\n        uint64_t wres(0), wa(a), wb(b);\n        wres   = wa * wb;\n        res.hi = wres &gt;&gt; 32;\n        res.lo = (uint32_t)wres &amp; 0xFFFFFFFF;\n#elif __riscv\n        U128BITS wres(0), wa(a), wb(b);\n        wres   = wa * wb;\n        res.hi = (uint64_t)(wres &gt;&gt; 64);\n        res.lo = (uint64_t)wres;\n#elif defined(__EMSCRIPTEN__)  // web assembly\n        U64BITS a1 = a &gt;&gt; 32;\n        U64BITS a2 = (uint32_t)a;\n        U64BITS b1 = b &gt;&gt; 32;\n        U64BITS b2 = (uint32_t)b;\n\n        // use schoolbook multiplication\n        res.hi            = a1 * b1;\n        res.lo            = a2 * b2;\n        U64BITS lowBefore = res.lo;\n\n        U64BITS p1   = a2 * b1;\n        U64BITS p2   = a1 * b2;\n        U64BITS temp = p1 + p2;\n        res.hi += temp &gt;&gt; 32;\n        res.lo += U64BITS((uint32_t)temp) &lt;&lt; 32;\n\n        // adds the carry to the high word\n        if (lowBefore &gt; res.lo)\n            res.hi++;\n\n        // if there is an overflow in temp, add 2^32\n        if ((temp &lt; p1) || (temp &lt; p2))\n            res.hi += (U64BITS)1 &lt;&lt; 32;\n#else\n    #error Architecture not supported for MultD()\n#endif\n    }\n\n#if defined(HAVE_INT128)\n    static void MultD(U128BITS a, U128BITS b, typeD&amp; res) {\n        static constexpr U128BITS masklo = (static_cast&lt;U128BITS&gt;(1) &lt;&lt; 64) - 1;\n        static constexpr U128BITS onehi  = static_cast&lt;U128BITS&gt;(1) &lt;&lt; 64;\n\n        U128BITS a1{a &gt;&gt; 64};\n        U128BITS a2{a &amp; masklo};\n        U128BITS b1{b &gt;&gt; 64};\n        U128BITS b2{b &amp; masklo};\n        U128BITS a1b2{a1 * b2};\n        U128BITS a2b1{a2 * b1};\n        U128BITS tmp{a1b2 + a2b1};\n        U128BITS lo{a2 * b2};\n\n        res = {a1 * b1, lo};\n        res.lo += tmp &lt;&lt; 64;\n        if (lo &gt; res.lo)\n            ++res.hi;\n        if ((tmp &lt; a1b2) || (tmp &lt; a2b1))\n            res.hi += onehi;\n        res.hi += tmp &gt;&gt; 64;\n    }\n#endif\n\n    /**\n   * Multiplies two single-word integers and stores the high word of the\n   * result\n   *\n   * @param a multiplier\n   * @param b multiplicand\n   * @return the high word of the result\n   */\n    static NativeInt MultDHi(NativeInt a, NativeInt b) {\n        typeD x;\n        MultD(a, b, x);\n        return x.hi;\n    }\n\n    /**\n   * Converts a double-word integer from typeD representation\n   * to DNativeInt.\n   *\n   * @param &amp;x double-word input\n   * @return the result as DNativeInt\n   */\n    static DNativeInt GetD(const typeD&amp; x) {\n        return (DNativeInt(x.hi) &lt;&lt; NativeIntegerT::MaxBits()) | x.lo;\n    }\n\n    static std::string toString(uint32_t value) noexcept {\n        return std::to_string(value);\n    }\n\n    static std::string toString(uint64_t value) noexcept {\n        return std::to_string(value);\n    }\n\n#if defined(HAVE_INT128)\n    // TODO\n    static std::string toString(uint128_t value) noexcept {\n        constexpr size_t maxChars = 15;\n        constexpr uint128_t divisor{0x38d7ea4c68000};  // 10**15\n        std::string tmp(46, &#x27;0&#x27;);\n        auto msd_it = tmp.end() - 1;\n        auto it     = tmp.end();\n        for (auto i = 3; i != 0; --i, it -= maxChars) {\n            auto part = static_cast&lt;uint64_t&gt;(value % divisor);\n            value /= divisor;\n            if (part) {\n                auto s{std::to_string(part)};\n                msd_it = it - s.size();\n                tmp.replace(it - s.size(), it, s.begin(), s.end());\n            }\n        }\n        return std::string(msd_it, tmp.end());\n    }\n#endif\n\n    template &lt;typename T = NativeInt&gt;\n    static void ModMu(typeD&amp; prod, NativeIntegerT&amp; a, const T&amp; mv, const T&amp; mu, int64_t n,\n                      typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        prod = {0, a.m_value};\n        MultD(RShiftD(prod, n), mu, prod);\n        a.m_value -= static_cast&lt;NativeInt&gt;((GetD(prod) &gt;&gt; n + 7) * mv);\n        if (a.m_value &gt;= mv)\n            a.m_value -= mv;\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    static void ModMu(typeD&amp; prod, NativeIntegerT&amp; a, const T&amp; mv, const T&amp; mu, int64_t n,\n                      typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        prod = {0, a.m_value};\n        MultD(RShiftD(prod, n), mu, prod);\n        MultD(RShiftD(prod, n + 7), mv, prod);\n        a.m_value -= prod.lo;\n        if (a.m_value &gt;= mv)\n            a.m_value -= mv;\n    }\n};\n\n// helper template to stream vector contents provided T has an stream operator&lt;&lt;\ntemplate &lt;typename T&gt;\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;T&gt;&amp; v) {\n    os &lt;&lt; &quot;[&quot;;\n    //    for (const auto&amp; i : v)\n    for (auto&amp;&amp; i : v)\n        os &lt;&lt; &quot; &quot; &lt;&lt; i;\n    os &lt;&lt; &quot; ]&quot;;\n    return os;\n}\n// to stream internal representation\ntemplate std::ostream&amp; operator&lt;&lt; &lt;uint64_t&gt;(std::ostream&amp; os, const std::vector&lt;uint64_t&gt;&amp; v);\n\n}  // namespace intnat\n\n#endif  // LBCRYPTO_MATH_HAL_INTNAT_UBINTNAT_H\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Represents and defines plaintext objects in OpenFHE\n */\n\n#ifndef LBCRYPTO_UTILS_PLAINTEXT_H\n#define LBCRYPTO_UTILS_PLAINTEXT_H\n\n#include &quot;encoding/plaintext-fwd.h&quot;\n\n#include &quot;encoding/encodingparams.h&quot;\n#include &quot;constants.h&quot;\n#include &quot;scheme/scheme-id.h&quot;\n\n#include &lt;initializer_list&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;utility&gt;\n\nnamespace lbcrypto {\n\n/**\n * @class PlaintextImpl\n * @brief This class represents plaintext in the OpenFHE library.\n *\n * PlaintextImpl is primarily intended to be\n * used as a container and in conjunction with specific encodings which inherit\n * from this class which depend on the application the plaintext is used with.\n * It provides virtual methods for encoding and decoding of data.\n */\nclass PlaintextImpl {\nprotected:\n    enum PtxtPolyType { IsPoly, IsDCRTPoly, IsNativePoly };\n\n    bool isEncoded;\n    PtxtPolyType typeFlag;\n    EncodingParams encodingParams;\n\n    mutable Poly encodedVector;\n    mutable NativePoly encodedNativeVector;\n    mutable DCRTPoly encodedVectorDCRT;\n\n    static constexpr int intCTOR     = 0x01;\n    static constexpr int vecintCTOR  = 0x02;\n    static constexpr int fracCTOR    = 0x04;\n    static constexpr int vecuintCTOR = 0x08;\n\n    double scalingFactor           = 1;\n    NativeInteger scalingFactorInt = 1;\n    size_t level                   = 0;\n    size_t noiseScaleDeg           = 1;\n    usint slots                    = 0;\n    SCHEME schemeID;\n\npublic:\n    PlaintextImpl(const std::shared_ptr&lt;Poly::Params&gt;&amp; vp, EncodingParams ep, SCHEME schemeTag = SCHEME::INVALID_SCHEME,\n                  bool isEncoded = false)\n        : isEncoded(isEncoded),\n          typeFlag(IsPoly),\n          encodingParams(std::move(ep)),\n          encodedVector(vp, Format::COEFFICIENT),\n          schemeID(schemeTag) {}\n\n    PlaintextImpl(const std::shared_ptr&lt;NativePoly::Params&gt;&amp; vp, EncodingParams ep, SCHEME schemeTag = SCHEME::INVALID_SCHEME,\n                  bool isEncoded = false)\n        : isEncoded(isEncoded),\n          typeFlag(IsNativePoly),\n          encodingParams(std::move(ep)),\n          encodedNativeVector(vp, Format::COEFFICIENT),\n          schemeID(schemeTag) {}\n\n    PlaintextImpl(const std::shared_ptr&lt;DCRTPoly::Params&gt;&amp; vp, EncodingParams ep, SCHEME schemeTag = SCHEME::INVALID_SCHEME,\n                  bool isEncoded = false)\n        : isEncoded(isEncoded),\n          typeFlag(IsDCRTPoly),\n          encodingParams(std::move(ep)),\n          encodedVector(vp, Format::COEFFICIENT),\n          encodedVectorDCRT(vp, Format::COEFFICIENT),\n          schemeID(schemeTag) {}\n\n    PlaintextImpl(const PlaintextImpl&amp; rhs)\n        : isEncoded(rhs.isEncoded),\n          typeFlag(rhs.typeFlag),\n          encodingParams(rhs.encodingParams),\n          encodedVector(rhs.encodedVector),\n          encodedVectorDCRT(rhs.encodedVectorDCRT),\n          scalingFactor(rhs.scalingFactor),\n          scalingFactorInt(rhs.scalingFactorInt),\n          level(rhs.level),\n          noiseScaleDeg(rhs.noiseScaleDeg),\n          slots(rhs.slots),\n          schemeID(rhs.schemeID) {}\n\n    PlaintextImpl(PlaintextImpl&amp;&amp; rhs)\n        : isEncoded(rhs.isEncoded),\n          typeFlag(rhs.typeFlag),\n          encodingParams(std::move(rhs.encodingParams)),\n          encodedVector(std::move(rhs.encodedVector)),\n          encodedVectorDCRT(std::move(rhs.encodedVectorDCRT)),\n          scalingFactor(rhs.scalingFactor),\n          scalingFactorInt(rhs.scalingFactorInt),\n          level(rhs.level),\n          noiseScaleDeg(rhs.noiseScaleDeg),\n          slots(rhs.slots),\n          schemeID(rhs.schemeID) {}\n\n    virtual ~PlaintextImpl() {}\n\n    /**\n   * GetEncodingType\n   * @return Encoding type used by this plaintext\n   */\n    virtual PlaintextEncodings GetEncodingType() const = 0;\n\n    /**\n   * Get the scaling factor of the plaintext for CKKS-based plaintexts.\n   */\n    double GetScalingFactor() const {\n        return scalingFactor;\n    }\n\n    /**\n   * Set the scaling factor of the plaintext for CKKS-based plaintexts.\n   */\n    void SetScalingFactor(double sf) {\n        scalingFactor = sf;\n    }\n\n    /**\n   * Get the scaling factor of the plaintext for BGV-based plaintexts.\n   */\n    const NativeInteger GetScalingFactorInt() const {\n        return scalingFactorInt;\n    }\n\n    /**\n   * Set the scaling factor of the plaintext for BGV-based plaintexts.\n   */\n    void SetScalingFactorInt(NativeInteger sf) {\n        scalingFactorInt = sf;\n    }\n\n    /**\n   * Get the encryption technique of the plaintext for BFV-based plaintexts.\n   */\n    SCHEME GetSchemeID() const {\n        return schemeID;\n    }\n\n    /**\n   * IsEncoded\n   * @return true when encoding is done\n   */\n    bool IsEncoded() const {\n        return isEncoded;\n    }\n\n    /**\n   * GetEncodingParams\n   * @return Encoding params used with this plaintext\n   */\n    const EncodingParams GetEncodingParams() const {\n        return encodingParams;\n    }\n\n    /**\n   * Encode the plaintext into a polynomial\n   * @return true on success\n   */\n    virtual bool Encode() = 0;\n\n    /**\n   * Decode the polynomial into the plaintext\n   * @return\n   */\n    virtual bool Decode() = 0;\n\n    /**\n   * Calculate and return lower bound that can be encoded with the plaintext\n   * modulus the number to encode MUST be greater than this value\n   * @return floor(-p/2)\n   */\n    int64_t LowBound() const {\n        uint64_t half = GetEncodingParams()-&gt;GetPlaintextModulus() &gt;&gt; 1;\n        bool odd      = (GetEncodingParams()-&gt;GetPlaintextModulus() &amp; 0x1) == 1;\n        int64_t bound = -1 * half;\n        if (odd)\n            bound--;\n        return bound;\n    }\n\n    /**\n   * Calculate and return upper bound that can be encoded with the plaintext\n   * modulus the number to encode MUST be less than or equal to this value\n   * @return floor(p/2)\n   */\n    int64_t HighBound() const {\n        return GetEncodingParams()-&gt;GetPlaintextModulus() &gt;&gt; 1;\n    }\n\n    /**\n   * SetFormat - allows format to be changed for PlaintextImpl evaluations\n   *\n   * @param fmt\n   */\n    void SetFormat(Format fmt) const {\n        if (typeFlag == IsPoly)\n            encodedVector.SetFormat(fmt);\n        else if (typeFlag == IsNativePoly)\n            encodedNativeVector.SetFormat(fmt);\n        else\n            encodedVectorDCRT.SetFormat(fmt);\n    }\n\n    /**\n   * GetElement\n   * @return the Polynomial that the element was encoded into\n   */\n    template &lt;typename Element&gt;\n    Element&amp; GetElement() {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;Generic GetElement() is not implemented&quot;);\n    }\n\n    template &lt;typename Element&gt;\n    const Element&amp; GetElement() const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;Generic GetElement() is not implemented&quot;);\n    }\n\n    /**\n   * GetElementRingDimension\n   * @return ring dimension on the underlying element\n   */\n    usint GetElementRingDimension() const {\n        return typeFlag == IsPoly ? encodedVector.GetRingDimension() :\n                                    (typeFlag == IsNativePoly ? encodedNativeVector.GetRingDimension() :\n                                                                encodedVectorDCRT.GetRingDimension());\n    }\n\n    /**\n   * GetElementModulus\n   * @return modulus on the underlying elemenbt\n   */\n    const BigInteger GetElementModulus() const {\n        return typeFlag == IsPoly ? encodedVector.GetModulus() :\n                                    (typeFlag == IsNativePoly ? BigInteger(encodedNativeVector.GetModulus()) :\n                                                                encodedVectorDCRT.GetModulus());\n    }\n\n    /**\n   * Get method to return the length of plaintext\n   *\n   * @return the length of the plaintext in terms of the number of bits.\n   */\n    virtual size_t GetLength() const = 0;\n\n    /**\n   * resize the plaintext; only works for plaintexts that support a resizable\n   * vector (coefpacked)\n   * @param newSize\n   */\n    virtual void SetLength(size_t newSize) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;resize not supported&quot;);\n    }\n\n    /*\n   * Method to get the degree of the scaling factor of a plaintext.\n   *\n   * @return the degree of the scaling factor of the plaintext\n   */\n    size_t GetNoiseScaleDeg() const {\n        return noiseScaleDeg;\n    }\n\n    /*\n   * Method to set the degree of the scaling factor of a plaintext.\n   */\n    void SetNoiseScaleDeg(size_t d) {\n        noiseScaleDeg = d;\n    }\n\n    /*\n   * Method to get the level of a plaintext.\n   *\n   * @return the level of the plaintext\n   */\n    size_t GetLevel() const {\n        return level;\n    }\n\n    /*\n   * Method to set the level of a plaintext.\n   */\n    void SetLevel(size_t l) {\n        level = l;\n    }\n\n    /*\n   * Method to get the level of a plaintext.\n   *\n   * @return the level of the plaintext\n   */\n    usint GetSlots() const {\n        return slots;\n    }\n\n    /*\n   * Method to set the level of a plaintext.\n   */\n    void SetSlots(usint l) {\n        slots = l;\n    }\n\n    virtual double GetLogError() const {\n        &quot;hey&quot;; OPENFHE_THROW(not_available_error, &quot;no estimate of noise available for the current scheme&quot;);\n    }\n\n    virtual double GetLogPrecision() const {\n        &quot;hey&quot;; OPENFHE_THROW(not_available_error, &quot;no estimate of precision available for the current scheme&quot;);\n    }\n\n    virtual const std::string&amp; GetStringValue() const {\n        &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;not a string&quot;);\n    }\n    virtual const std::vector&lt;int64_t&gt;&amp; GetCoefPackedValue() const {\n        &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;not a packed coefficient vector&quot;);\n    }\n    virtual const std::vector&lt;int64_t&gt;&amp; GetPackedValue() const {\n        &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;not a packed coefficient vector&quot;);\n    }\n    virtual const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; GetCKKSPackedValue() const {\n        &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;not a packed vector of complex numbers&quot;);\n    }\n    virtual const std::vector&lt;double&gt; GetRealPackedValue() const {\n        &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;not a packed vector of real numbers&quot;);\n    }\n    virtual void SetStringValue(const std::string&amp;) {\n        &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;does not support a string&quot;);\n    }\n    virtual void SetIntVectorValue(const std::vector&lt;int64_t&gt;&amp;) {\n        &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;does not support an int vector&quot;);\n    }\n\n    /**\n   * Method to compare two plaintext to test for equivalence.\n   * This method is called by operator==\n   *\n   * @param other - the other plaintext to compare to.\n   * @return whether the two plaintext are equivalent.\n   */\n    virtual bool CompareTo(const PlaintextImpl&amp; other) const = 0;\n\n    /**\n   * operator== for plaintexts.  This method makes sure the plaintexts are of\n   * the same type.\n   *\n   * @param other - the other plaintext to compare to.\n   * @return whether the two plaintext are the same.\n   */\n    bool operator==(const PlaintextImpl&amp; other) const {\n        return CompareTo(other);\n    }\n\n    bool operator!=(const PlaintextImpl&amp; other) const {\n        return !(*this == other);\n    }\n\n    /**\n   * operator&lt;&lt; for ostream integration - calls PrintValue\n   * @param out\n   * @param item\n   * @return\n   */\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const PlaintextImpl&amp; item);\n\n    /**\n   * PrintValue is called by operator&lt;&lt;\n   * @param out\n   */\n    virtual void PrintValue(std::ostream&amp; out) const = 0;\n};\n\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const PlaintextImpl&amp; item) {\n    item.PrintValue(out);\n    return out;\n}\n\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Plaintext&amp; item) {\n    item-&gt;PrintValue(out);\n    return out;\n}\n\ninline bool operator==(const Plaintext&amp; p1, const Plaintext&amp; p2) {\n    return *p1 == *p2;\n}\n\ninline bool operator!=(const Plaintext&amp; p1, const Plaintext&amp; p2) {\n    return *p1 != *p2;\n}\n\n/**\n * GetElement\n * @return the Polynomial that the element was encoded into\n */\ntemplate &lt;&gt;\ninline const Poly&amp; PlaintextImpl::GetElement&lt;Poly&gt;() const {\n    return encodedVector;\n}\n\ntemplate &lt;&gt;\ninline Poly&amp; PlaintextImpl::GetElement&lt;Poly&gt;() {\n    return encodedVector;\n}\n\n/**\n * GetElement\n * @return the NativePolynomial that the element was encoded into\n */\ntemplate &lt;&gt;\ninline const NativePoly&amp; PlaintextImpl::GetElement&lt;NativePoly&gt;() const {\n    return encodedNativeVector;\n}\n\ntemplate &lt;&gt;\ninline NativePoly&amp; PlaintextImpl::GetElement&lt;NativePoly&gt;() {\n    return encodedNativeVector;\n}\n\n/**\n * GetElement\n * @return the DCRTPolynomial that the element was encoded into\n */\ntemplate &lt;&gt;\ninline const DCRTPoly&amp; PlaintextImpl::GetElement&lt;DCRTPoly&gt;() const {\n    return encodedVectorDCRT;\n}\n\ntemplate &lt;&gt;\ninline DCRTPoly&amp; PlaintextImpl::GetElement&lt;DCRTPoly&gt;() {\n    return encodedVectorDCRT;\n}\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Manufactures plaintext objects in OpenFHE\n */\n\n#ifndef SRC_CORE_LIB_ENCODING_PLAINTEXTFACTORY_H_\n#define SRC_CORE_LIB_ENCODING_PLAINTEXTFACTORY_H_\n\n#include &quot;encoding/encodings.h&quot;\n#include &quot;scheme/scheme-id.h&quot;\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n// TODO: when the parms are polymorphic, reduce the tuple of methods to a\n// single one\n\nnamespace lbcrypto {\n\nclass PlaintextFactory {\n    PlaintextFactory() = delete;  // never construct one!\n\npublic:\n    template &lt;typename T, typename std::enable_if&lt;std::is_same&lt;T, Poly::Params&gt;::value ||\n                                                      std::is_same&lt;T, NativePoly::Params&gt;::value ||\n                                                      std::is_same&lt;T, DCRTPoly::Params&gt;::value,\n                                                  bool&gt;::type = true&gt;\n    static Plaintext MakePlaintext(PlaintextEncodings encoding, std::shared_ptr&lt;T&gt; vp, EncodingParams ep,\n                                   SCHEME schemeID = SCHEME::INVALID_SCHEME) {\n        switch (encoding) {\n            case COEF_PACKED_ENCODING:\n                return std::make_shared&lt;CoefPackedEncoding&gt;(vp, ep, schemeID);\n            case PACKED_ENCODING:\n                return std::make_shared&lt;PackedEncoding&gt;(vp, ep);\n            case STRING_ENCODING:\n                return std::make_shared&lt;StringEncoding&gt;(vp, ep);\n            case CKKS_PACKED_ENCODING:\n                return std::make_shared&lt;CKKSPackedEncoding&gt;(vp, ep);\n            default:\n                &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Unknown plaintext encoding type in MakePlaintext&quot;);\n        }\n    }\n\n    template &lt;typename T, typename std::enable_if&lt;std::is_same&lt;T, Poly::Params&gt;::value ||\n                                                      std::is_same&lt;T, NativePoly::Params&gt;::value ||\n                                                      std::is_same&lt;T, DCRTPoly::Params&gt;::value,\n                                                  bool&gt;::type = true&gt;\n    static Plaintext MakePlaintext(const std::vector&lt;int64_t&gt;&amp; value, PlaintextEncodings encoding,\n                                   std::shared_ptr&lt;T&gt; vp, EncodingParams ep, SCHEME schemeID = SCHEME::INVALID_SCHEME,\n                                   size_t noiseScaleDeg = 1, uint32_t level = 0, NativeInteger scalingFactor = 1) {\n        // Check if plaintext has got enough slots for data (value)\n        usint ringDim = vp-&gt;GetRingDimension();\n        size_t valueSize = value.size();\n        if (SCHEME::CKKSRNS_SCHEME == schemeID &amp;&amp; valueSize &gt; ringDim / 2) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The size [&quot; + std::to_string(valueSize) + &quot;] of the vector with values should not be greater than ringDim/2 [&quot; + std::to_string(ringDim / 2) + &quot;] if the scheme is CKKS&quot;);\n        }\n        else if (valueSize &gt; ringDim) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The size [&quot; + std::to_string(valueSize) + &quot;] of the vector with values should not be greater than ringDim [&quot; + std::to_string(ringDim) + &quot;] if the scheme is NOT CKKS&quot;);\n        }\n        Plaintext pt = MakePlaintext(encoding, vp, ep, schemeID);\n        pt-&gt;SetIntVectorValue(value);\n        pt-&gt;SetNoiseScaleDeg(noiseScaleDeg);\n        pt-&gt;SetLevel(level);\n        pt-&gt;SetScalingFactorInt(scalingFactor);\n        pt-&gt;Encode();\n        return pt;\n    }\n\n    template &lt;typename T, typename std::enable_if&lt;std::is_same&lt;T, Poly::Params&gt;::value ||\n                                                      std::is_same&lt;T, NativePoly::Params&gt;::value ||\n                                                      std::is_same&lt;T, DCRTPoly::Params&gt;::value,\n                                                  bool&gt;::type = true&gt;\n    static Plaintext MakePlaintext(const std::string&amp; value, PlaintextEncodings encoding, std::shared_ptr&lt;T&gt; vp,\n                                   EncodingParams ep, SCHEME schemeID = SCHEME::INVALID_SCHEME,\n                                   size_t noiseScaleDeg = 1, uint32_t level = 0, NativeInteger scalingFactor = 1) {\n        // Check if plaintext has got enough slots for data (value)\n        usint ringDim = vp-&gt;GetRingDimension();\n        size_t valueSize = value.size();\n        if (SCHEME::CKKSRNS_SCHEME == schemeID &amp;&amp; valueSize &gt; ringDim / 2) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The size [&quot; + std::to_string(valueSize) + &quot;] of the vector with values should not be greater than ringDim/2 [&quot; + std::to_string(ringDim / 2) + &quot;] if the scheme is CKKS&quot;);\n        }\n        else if (valueSize &gt; ringDim) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The size [&quot; + std::to_string(valueSize) + &quot;] of the vector with values should not be greater than ringDim [&quot; + std::to_string(ringDim) + &quot;] if the scheme is NOT CKKS&quot;);\n        }\n        Plaintext pt = MakePlaintext(encoding, vp, ep, schemeID);\n        pt-&gt;SetStringValue(value);\n        pt-&gt;SetNoiseScaleDeg(noiseScaleDeg);\n        pt-&gt;SetLevel(level);\n        pt-&gt;SetScalingFactorInt(scalingFactor);\n        pt-&gt;Encode();\n        return pt;\n    }\n};\n\n} /* namespace lbcrypto */\n\n#endif /* SRC_CORE_LIB_ENCODING_PLAINTEXTFACTORY_H_ */\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_UTILS_CKKSPACKEDEXTENCODING_H\n#define LBCRYPTO_UTILS_CKKSPACKEDEXTENCODING_H\n\n#include &quot;constants.h&quot;\n\n#include &quot;encoding/encodingparams.h&quot;\n#include &quot;encoding/plaintext.h&quot;\n\n#include &quot;math/hal/basicint.h&quot;\n\n#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n#include &lt;initializer_list&gt;\n#include &lt;memory&gt;\n#include &lt;numeric&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\nnamespace lbcrypto {\n\n/**\n * @class CKKSPackedEncoding\n * @brief Type used for representing IntArray types.\n * Provides conversion functions to encode and decode plaintext data as type\n * vector&lt;uint64_t&gt;. This class uses bit packing techniques to enable efficient\n * computing on vectors of integers. It is NOT supported for DCRTPoly\n */\n\nclass CKKSPackedEncoding : public PlaintextImpl {\npublic:\n    // these two constructors are used inside of Decrypt\n    template &lt;typename T, typename std::enable_if&lt;std::is_same&lt;T, Poly::Params&gt;::value ||\n                                                      std::is_same&lt;T, NativePoly::Params&gt;::value ||\n                                                      std::is_same&lt;T, DCRTPoly::Params&gt;::value,\n                                                  bool&gt;::type = true&gt;\n    CKKSPackedEncoding(std::shared_ptr&lt;T&gt; vp, EncodingParams ep) : PlaintextImpl(vp, ep, CKKSRNS_SCHEME) {\n        this-&gt;slots = GetDefaultSlotSize();\n        if (this-&gt;slots &gt; (GetElementRingDimension() / 2)) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots cannot be larger than half of ring dimension&quot;);\n        }\n    }\n\n    /*\n   * @param noiseScaleDeg degree of the scaling factor of a plaintext\n   * @param level level of plaintext to create.\n   * @param scFact scaling factor of a plaintext of this level at depth 1.\n   *\n   */\n    template &lt;typename T, typename std::enable_if&lt;std::is_same&lt;T, Poly::Params&gt;::value ||\n                                                      std::is_same&lt;T, NativePoly::Params&gt;::value ||\n                                                      std::is_same&lt;T, DCRTPoly::Params&gt;::value,\n                                                  bool&gt;::type = true&gt;\n    CKKSPackedEncoding(std::shared_ptr&lt;T&gt; vp, EncodingParams ep, const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; coeffs,\n                       size_t noiseScaleDeg, uint32_t level, double scFact, size_t slots)\n        : PlaintextImpl(vp, ep, CKKSRNS_SCHEME), value(coeffs) {\n        // validate the number of slots\n        if ((slots &amp; (slots - 1)) != 0) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots should be a power of two&quot;);\n        }\n\n        this-&gt;slots = (slots) ? slots : GetDefaultSlotSize();\n\n        if (this-&gt;slots &lt; coeffs.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots cannot be smaller than value vector size&quot;);\n        }\n        else if (this-&gt;slots &gt; (GetElementRingDimension() / 2)) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots cannot be larger than half of ring dimension&quot;);\n        }\n\n        this-&gt;noiseScaleDeg = noiseScaleDeg;\n        this-&gt;level         = level;\n        this-&gt;scalingFactor = scFact;\n    }\n\n    /**\n   * @brief Constructs a container with a copy of each of the elements in rhs,\n   * in the same order.\n   * @param rhs - The input object to copy.\n   */\n    explicit CKKSPackedEncoding(const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; rhs, size_t slots)\n        : PlaintextImpl(std::shared_ptr&lt;Poly::Params&gt;(0), nullptr, CKKSRNS_SCHEME), value(rhs) {\n        // validate the number of slots\n        if ((slots &amp; (slots - 1)) != 0) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots should be a power of two&quot;);\n        }\n\n        this-&gt;slots = (slots) ? slots : GetDefaultSlotSize();\n\n        if (this-&gt;slots &lt; rhs.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots cannot be smaller than value vector size&quot;);\n        }\n        else if (this-&gt;slots &gt; (GetElementRingDimension() / 2)) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots cannot be larger than half of ring dimension&quot;);\n        }\n    }\n\n    /**\n   * @brief Default empty constructor with empty uninitialized data elements.\n   */\n    CKKSPackedEncoding() : PlaintextImpl(std::shared_ptr&lt;Poly::Params&gt;(0), nullptr, CKKSRNS_SCHEME) {\n        this-&gt;slots = GetDefaultSlotSize();\n        if (this-&gt;slots &gt; (GetElementRingDimension() / 2)) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots cannot be larger than half of ring dimension&quot;);\n        }\n    }\n\n    CKKSPackedEncoding(const CKKSPackedEncoding&amp; rhs)\n        : PlaintextImpl(rhs), value(rhs.value), m_logError(rhs.m_logError) {}\n\n    CKKSPackedEncoding(CKKSPackedEncoding&amp;&amp; rhs)\n        : PlaintextImpl(std::move(rhs)), value(std::move(rhs.value)), m_logError(rhs.m_logError) {}\n\n    bool Encode();\n\n    bool Decode() {\n        &quot;hey&quot;; OPENFHE_THROW(not_available_error,\n                      &quot;CKKSPackedEncoding::Decode() is not implemented. Use CKKSPackedEncoding::Decode(...) instead.&quot;);\n    }\n\n    bool Decode(size_t depth, double scalingFactor, ScalingTechnique scalTech, ExecutionMode executionMode);\n\n    const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; GetCKKSPackedValue() const {\n        return value;\n    }\n\n    const std::vector&lt;double&gt; GetRealPackedValue() const {\n        std::vector&lt;double&gt; realValue(value.size());\n        std::transform(value.begin(), value.end(), realValue.begin(),\n                       [](std::complex&lt;double&gt; da) { return da.real(); });\n\n        return realValue;\n    }\n\n    /**\n   * Static utility method to multiply two numbers in CRT representation.\n   * CRT representation is stored in a vector of native integers, and each\n   * position corresponds to the remainder of the number against one of\n   * the moduli in mods.\n   *\n   * @param a is the first number in CRT representation.\n   * @param b is the second number in CRT representation.\n   * @return the product of the two numbers in CRT representation.\n   */\n    static std::vector&lt;DCRTPoly::Integer&gt; CRTMult(const std::vector&lt;DCRTPoly::Integer&gt;&amp; a,\n                                                  const std::vector&lt;DCRTPoly::Integer&gt;&amp; b,\n                                                  const std::vector&lt;DCRTPoly::Integer&gt;&amp; mods);\n\n    /**\n   * GetEncodingType\n   * @return CKKS_PACKED_ENCODING\n   */\n    PlaintextEncodings GetEncodingType() const {\n        return CKKS_PACKED_ENCODING;\n    }\n\n    /**\n   * Get method to return the length of plaintext\n   *\n   * @return the length of the plaintext in terms of the number of bits.\n   */\n    size_t GetLength() const {\n        return value.size();\n    }\n\n    /**\n   * Get method to return log2 of estimated standard deviation of approximation\n   * error\n   */\n    double GetLogError() const {\n        return m_logError;\n    }\n\n    /**\n   * Get method to return log2 of estimated precision\n   */\n    double GetLogPrecision() const {\n        return encodingParams-&gt;GetPlaintextModulus() - m_logError;\n    }\n\n    /**\n   * SetLength of the plaintext to the given size\n   * @param siz\n   */\n    void SetLength(size_t siz) {\n        value.resize(siz);\n    }\n\n    /**\n   * Method to compare two plaintext to test for equivalence.  This method does\n   * not test that the plaintext are of the same type.\n   *\n   * @param other - the other plaintext to compare to.\n   * @return whether the two plaintext are equivalent.\n   */\n    bool CompareTo(const PlaintextImpl&amp; other) const {\n        const auto&amp; rv = static_cast&lt;const CKKSPackedEncoding&amp;&gt;(other);\n        return this-&gt;value == rv.value;\n    }\n\n    /**\n   * @brief Destructor method.\n   */\n    static void Destroy();\n\n    void PrintValue(std::ostream&amp; out) const {\n        // for sanity&#x27;s sake, trailing zeros get elided into &quot;...&quot;\n        // out.precision(15);\n        out &lt;&lt; &quot;(&quot;;\n        size_t i = value.size();\n        while (--i &gt; 0)\n            if (value[i] != std::complex&lt;double&gt;(0, 0))\n                break;\n\n        for (size_t j = 0; j &lt;= i; j++) {\n            out &lt;&lt; value[j].real() &lt;&lt; &quot;, &quot;;\n        }\n\n        out &lt;&lt; &quot; ... ); &quot;;\n        out &lt;&lt; &quot;Estimated precision: &quot; &lt;&lt; encodingParams-&gt;GetPlaintextModulus() - m_logError &lt;&lt; &quot; bits&quot; &lt;&lt; std::endl;\n    }\n\nprivate:\n    std::vector&lt;std::complex&lt;double&gt;&gt; value;\n\n    double m_logError = 0;\n\nprotected:\n    usint GetDefaultSlotSize() {\n        auto batchSize = GetEncodingParams()-&gt;GetBatchSize();\n        return (0 == batchSize) ? GetElementRingDimension() / 2 : batchSize;\n    }\n    /**\n   * Set modulus and recalculates the vector values to fit the modulus\n   *\n   * @param &amp;vec input vector\n   * @param &amp;bigValue big bound of the vector values.\n   * @param &amp;modulus modulus to be set for vector.\n   */\n    void FitToNativeVector(const std::vector&lt;int64_t&gt;&amp; vec, int64_t bigBound, NativeVector* nativeVec) const;\n\n#if NATIVEINT == 128 &amp;&amp; !defined(__EMSCRIPTEN__)\n    /**\n   * Set modulus and recalculates the vector values to fit the modulus\n   *\n   * @param &amp;vec input vector\n   * @param &amp;bigValue big bound of the vector values.\n   * @param &amp;modulus modulus to be set for vector.\n   */\n    void FitToNativeVector(const std::vector&lt;int128_t&gt;&amp; vec, int128_t bigBound, NativeVector* nativeVec) const;\n#endif\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Control for encryption operations\n */\n\n#include &quot;cryptocontext.h&quot;\n\n#include &quot;key/privatekey.h&quot;\n#include &quot;key/publickey.h&quot;\n#include &quot;math/chebyshev.h&quot;\n#include &quot;schemerns/rns-scheme.h&quot;\n#include &quot;scheme/ckksrns/ckksrns-cryptoparameters.h&quot;\n\nnamespace lbcrypto {\n\ntemplate &lt;typename Element&gt;\nstd::map&lt;std::string, std::vector&lt;EvalKey&lt;Element&gt;&gt;&gt;&amp; CryptoContextImpl&lt;Element&gt;::evalMultKeyMap() {\n    return s_evalMultKeyMap;\n}\ntemplate &lt;typename Element&gt;\nstd::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt;&amp; CryptoContextImpl&lt;Element&gt;::evalSumKeyMap() {\n    return s_evalSumKeyMap;\n}\ntemplate &lt;typename Element&gt;\nstd::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt;&amp;\nCryptoContextImpl&lt;Element&gt;::evalAutomorphismKeyMap() {\n    return s_evalAutomorphismKeyMap;\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::SetKSTechniqueInScheme() {\n    // check if the scheme is an RNS scheme\n    auto schemeRNSPtr = dynamic_cast&lt;SchemeRNS*&gt;(&amp;(*scheme));\n    if (schemeRNSPtr != nullptr) {\n        // check if the parameter object is RNS-based\n        auto elPtr = dynamic_cast&lt;const CryptoParametersRNS*&gt;(&amp;(*params));\n        if (elPtr != nullptr) {\n            schemeRNSPtr-&gt;SetKeySwitchingTechnique(elPtr-&gt;GetKeySwitchTechnique());\n            return;\n        }\n        &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;Cannot set KeySwitchingTechnique as the parameter object is not RNS-based&quot;);\n    }\n}\n\n/////////////////////////////////////////\n// SHE MULTIPLICATION\n/////////////////////////////////////////\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::InsertEvalMultKey(const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; vectorToInsert) {\n    GetAllEvalMultKeys()[vectorToInsert[0]-&gt;GetKeyTag()] = vectorToInsert;\n}\n\n/////////////////////////////////////////\n// ADVANCED SHE\n/////////////////////////////////////////\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::EvalSumKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                               const PublicKey&lt;Element&gt; publicKey) {\n    if (privateKey == nullptr || Mismatched(privateKey-&gt;GetCryptoContext())) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Private key passed to EvalSumKeyGen were not generated &quot;\n                      &quot;with this crypto context&quot;);\n    }\n\n    if (publicKey != nullptr &amp;&amp; privateKey-&gt;GetKeyTag() != publicKey-&gt;GetKeyTag()) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Public key passed to EvalSumKeyGen does not match private key&quot;);\n    }\n\n    auto evalKeys = GetScheme()-&gt;EvalSumKeyGen(privateKey, publicKey);\n\n    GetAllEvalSumKeys()[privateKey-&gt;GetKeyTag()] = evalKeys;\n}\n\ntemplate &lt;typename Element&gt;\nstd::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; CryptoContextImpl&lt;Element&gt;::EvalSumRowsKeyGen(\n    const PrivateKey&lt;Element&gt; privateKey, const PublicKey&lt;Element&gt; publicKey, usint rowSize, usint subringDim) {\n    if (privateKey == nullptr || Mismatched(privateKey-&gt;GetCryptoContext())) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Private key passed to EvalSumKeyGen were not generated &quot;\n                      &quot;with this crypto context&quot;);\n    }\n\n    if (publicKey != nullptr &amp;&amp; privateKey-&gt;GetKeyTag() != publicKey-&gt;GetKeyTag()) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Public key passed to EvalSumKeyGen does not match private key&quot;);\n    }\n\n    auto evalKeys = GetScheme()-&gt;EvalSumRowsKeyGen(privateKey, publicKey, rowSize, subringDim);\n\n    return evalKeys;\n}\n\ntemplate &lt;typename Element&gt;\nstd::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; CryptoContextImpl&lt;Element&gt;::EvalSumColsKeyGen(\n    const PrivateKey&lt;Element&gt; privateKey, const PublicKey&lt;Element&gt; publicKey) {\n    if (privateKey == nullptr || Mismatched(privateKey-&gt;GetCryptoContext())) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Private key passed to EvalSumKeyGen were not generated &quot;\n                      &quot;with this crypto context&quot;);\n    }\n\n    if (publicKey != nullptr &amp;&amp; privateKey-&gt;GetKeyTag() != publicKey-&gt;GetKeyTag()) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Public key passed to EvalSumKeyGen does not match private key&quot;);\n    }\n\n    auto evalKeys = GetScheme()-&gt;EvalSumColsKeyGen(privateKey, publicKey);\n\n    return evalKeys;\n}\n\ntemplate &lt;typename Element&gt;\nconst std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; CryptoContextImpl&lt;Element&gt;::GetEvalSumKeyMap(const std::string&amp; keyID) {\n    auto ekv = GetAllEvalSumKeys().find(keyID);\n    if (ekv == GetAllEvalSumKeys().end())\n        &quot;hey&quot;; OPENFHE_THROW(not_available_error,\n                      &quot;You need to use EvalSumKeyGen so that you have EvalSumKeys &quot;\n                      &quot;available for this ID&quot;);\n    return *ekv-&gt;second;\n}\n\ntemplate &lt;typename Element&gt;\nstd::map&lt;std::string, std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt;&gt;&amp;\nCryptoContextImpl&lt;Element&gt;::GetAllEvalSumKeys() {\n    return evalSumKeyMap();\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::ClearEvalSumKeys() {\n    GetAllEvalSumKeys().clear();\n}\n\n/**\n * ClearEvalMultKeys - flush EvalMultKey cache for a given id\n * @param id\n */\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::ClearEvalSumKeys(const std::string&amp; id) {\n    auto kd = GetAllEvalSumKeys().find(id);\n    if (kd != GetAllEvalSumKeys().end())\n        GetAllEvalSumKeys().erase(kd);\n}\n\n/**\n * ClearEvalMultKeys - flush EvalMultKey cache for a given context\n * @param cc\n */\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::ClearEvalSumKeys(const CryptoContext&lt;Element&gt; cc) {\n    for (auto it = GetAllEvalSumKeys().begin(); it != GetAllEvalSumKeys().end();) {\n        if (it-&gt;second-&gt;begin()-&gt;second-&gt;GetCryptoContext() == cc) {\n            it = GetAllEvalSumKeys().erase(it);\n        }\n        else {\n            ++it;\n        }\n    }\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::InsertEvalSumKey(\n    const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; mapToInsert) {\n    // find the tag\n    if (!mapToInsert-&gt;empty()) {\n        auto onekey                                      = mapToInsert-&gt;begin();\n        GetAllEvalSumKeys()[onekey-&gt;second-&gt;GetKeyTag()] = mapToInsert;\n    }\n}\n\n/////////////////////////////////////////\n// SHE AUTOMORPHISM\n/////////////////////////////////////////\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::EvalAtIndexKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                                   const std::vector&lt;int32_t&gt;&amp; indexList,\n                                                   const PublicKey&lt;Element&gt; publicKey) {\n    if (privateKey == nullptr || Mismatched(privateKey-&gt;GetCryptoContext())) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Private key passed to EvalAtIndexKeyGen were not generated &quot;\n                      &quot;with this crypto context&quot;);\n    }\n\n    if (publicKey != nullptr &amp;&amp; privateKey-&gt;GetKeyTag() != publicKey-&gt;GetKeyTag()) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Public key passed to EvalAtIndexKeyGen does not match private key&quot;);\n    }\n\n    auto evalKeys = GetScheme()-&gt;EvalAtIndexKeyGen(publicKey, privateKey, indexList);\n\n    auto ekv = GetAllEvalAutomorphismKeys().find(privateKey-&gt;GetKeyTag());\n    if (ekv == GetAllEvalAutomorphismKeys().end()) {\n        GetAllEvalAutomorphismKeys()[privateKey-&gt;GetKeyTag()] = evalKeys;\n    }\n    else {\n        auto&amp; currRotMap = GetEvalAutomorphismKeyMap(privateKey-&gt;GetKeyTag());\n        auto iterRowKeys = evalKeys-&gt;begin();\n        while (iterRowKeys != evalKeys-&gt;end()) {\n            auto idx = iterRowKeys-&gt;first;\n            // Search current rotation key map and add key\n            // only if it doesn&#x27;t exist\n            if (currRotMap.find(idx) == currRotMap.end()) {\n                currRotMap.insert(*iterRowKeys);\n            }\n            iterRowKeys++;\n        }\n    }\n\n    //  evalAutomorphismKeyMap()[privateKey-&gt;GetKeyTag()] = evalKeys;\n}\n\ntemplate &lt;typename Element&gt;\nstd::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; CryptoContextImpl&lt;Element&gt;::GetEvalAutomorphismKeyMap(const std::string&amp; keyID) {\n    auto ekv = evalAutomorphismKeyMap().find(keyID);\n    if (ekv == evalAutomorphismKeyMap().end())\n        &quot;hey&quot;; OPENFHE_THROW(not_available_error,\n                      &quot;You need to use EvalAutomorphismKeyGen so that you have &quot;\n                      &quot;EvalAutomorphismKeys available for this ID&quot;);\n    return *ekv-&gt;second;\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::ClearEvalAutomorphismKeys() {\n    evalAutomorphismKeyMap().clear();\n}\n\n/**\n * ClearEvalAutomorphismKeys - flush EvalAutomorphismKey cache for a given id\n * @param id\n */\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::ClearEvalAutomorphismKeys(const std::string&amp; id) {\n    auto kd = evalAutomorphismKeyMap().find(id);\n    if (kd != evalAutomorphismKeyMap().end())\n        evalAutomorphismKeyMap().erase(kd);\n}\n\n/**\n * ClearEvalAutomorphismKeys - flush EvalAutomorphismKey cache for a given\n * context\n * @param cc\n */\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::ClearEvalAutomorphismKeys(const CryptoContext&lt;Element&gt; cc) {\n    for (auto it = evalAutomorphismKeyMap().begin(); it != evalAutomorphismKeyMap().end();) {\n        if (it-&gt;second-&gt;begin()-&gt;second-&gt;GetCryptoContext() == cc) {\n            it = evalAutomorphismKeyMap().erase(it);\n        }\n        else {\n            ++it;\n        }\n    }\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::InsertEvalAutomorphismKey(\n    const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; mapToInsert) {\n    // find the tag\n    auto onekey                                           = mapToInsert-&gt;begin();\n    evalAutomorphismKeyMap()[onekey-&gt;second-&gt;GetKeyTag()] = mapToInsert;\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalSum(ConstCiphertext&lt;Element&gt; ciphertext, usint batchSize) const {\n    if (ciphertext == nullptr || Mismatched(ciphertext-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Information passed to EvalSum was not generated with this &quot;\n                      &quot;crypto context&quot;);\n\n    auto evalSumKeys = CryptoContextImpl&lt;Element&gt;::GetEvalSumKeyMap(ciphertext-&gt;GetKeyTag());\n    auto rv          = GetScheme()-&gt;EvalSum(ciphertext, batchSize, evalSumKeys);\n    return rv;\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalSumRows(ConstCiphertext&lt;Element&gt; ciphertext, usint rowSize,\n                                                            const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalSumKeys,\n                                                            usint subringDim) const {\n    if (ciphertext == nullptr || Mismatched(ciphertext-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Information passed to EvalSum was not generated with this &quot;\n                      &quot;crypto context&quot;);\n\n    auto rv = GetScheme()-&gt;EvalSumRows(ciphertext, rowSize, evalSumKeys, subringDim);\n    return rv;\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalSumCols(\n    ConstCiphertext&lt;Element&gt; ciphertext, usint rowSize,\n    const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalSumKeysRight) const {\n    if (ciphertext == nullptr || Mismatched(ciphertext-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Information passed to EvalSum was not generated with this &quot;\n                      &quot;crypto context&quot;);\n\n    auto evalSumKeys = CryptoContextImpl&lt;Element&gt;::GetEvalSumKeyMap(ciphertext-&gt;GetKeyTag());\n\n    auto rv = GetScheme()-&gt;EvalSumCols(ciphertext, rowSize, evalSumKeys, evalSumKeysRight);\n    return rv;\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalAtIndex(ConstCiphertext&lt;Element&gt; ciphertext, int32_t index) const {\n    if (ciphertext == nullptr || Mismatched(ciphertext-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Information passed to EvalAtIndex was not generated with &quot;\n                      &quot;this crypto context&quot;);\n\n    // If the index is zero, no rotation is needed, copy the ciphertext and return\n    // This is done after the keyMap so that it is protected if there&#x27;s not a\n    // valid key.\n    if (0 == index) {\n        auto rv = ciphertext-&gt;Clone();\n        return rv;\n    }\n\n    auto evalAutomorphismKeys = CryptoContextImpl&lt;Element&gt;::GetEvalAutomorphismKeyMap(ciphertext-&gt;GetKeyTag());\n\n    auto rv = GetScheme()-&gt;EvalAtIndex(ciphertext, index, evalAutomorphismKeys);\n    return rv;\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalMerge(\n    const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVector) const {\n    if (ciphertextVector[0] == nullptr || Mismatched(ciphertextVector[0]-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Information passed to EvalMerge was not generated with &quot;\n                      &quot;this crypto context&quot;);\n\n    auto evalAutomorphismKeys = CryptoContextImpl&lt;Element&gt;::GetEvalAutomorphismKeyMap(ciphertextVector[0]-&gt;GetKeyTag());\n\n    auto rv = GetScheme()-&gt;EvalMerge(ciphertextVector, evalAutomorphismKeys);\n\n    return rv;\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalInnerProduct(ConstCiphertext&lt;Element&gt; ct1,\n                                                                 ConstCiphertext&lt;Element&gt; ct2, usint batchSize) const {\n    if (ct1 == nullptr || ct2 == nullptr || ct1-&gt;GetKeyTag() != ct2-&gt;GetKeyTag() || Mismatched(ct1-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Information passed to EvalInnerProduct was not generated &quot;\n                      &quot;with this crypto context&quot;);\n\n    auto evalSumKeys = CryptoContextImpl&lt;Element&gt;::GetEvalSumKeyMap(ct1-&gt;GetKeyTag());\n    auto ek          = GetEvalMultKeyVector(ct1-&gt;GetKeyTag());\n\n    auto rv = GetScheme()-&gt;EvalInnerProduct(ct1, ct2, batchSize, evalSumKeys, ek[0]);\n    return rv;\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalInnerProduct(ConstCiphertext&lt;Element&gt; ct1, ConstPlaintext ct2,\n                                                                 usint batchSize) const {\n    if (ct1 == nullptr || ct2 == nullptr || Mismatched(ct1-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Information passed to EvalInnerProduct was not generated &quot;\n                      &quot;with this crypto context&quot;);\n\n    auto evalSumKeys = CryptoContextImpl&lt;Element&gt;::GetEvalSumKeyMap(ct1-&gt;GetKeyTag());\n\n    auto rv = GetScheme()-&gt;EvalInnerProduct(ct1, ct2, batchSize, evalSumKeys);\n    return rv;\n}\n\ntemplate &lt;typename Element&gt;\nPlaintext CryptoContextImpl&lt;Element&gt;::GetPlaintextForDecrypt(PlaintextEncodings pte, std::shared_ptr&lt;ParmType&gt; evp,\n                                                             EncodingParams ep) {\n    auto vp = std::make_shared&lt;typename NativePoly::Params&gt;(evp-&gt;GetCyclotomicOrder(), ep-&gt;GetPlaintextModulus(), 1);\n\n    if (pte == CKKS_PACKED_ENCODING)\n        return PlaintextFactory::MakePlaintext(pte, evp, ep);\n\n    return PlaintextFactory::MakePlaintext(pte, vp, ep);\n}\n\ntemplate &lt;typename Element&gt;\nDecryptResult CryptoContextImpl&lt;Element&gt;::Decrypt(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                  const PrivateKey&lt;Element&gt; privateKey, Plaintext* plaintext) {\n    if (ciphertext == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ciphertext passed to Decrypt is empty&quot;);\n    if (plaintext == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;plaintext passed to Decrypt is empty&quot;);\n    if (privateKey == nullptr || Mismatched(privateKey-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Information passed to Decrypt was not generated with &quot;\n                      &quot;this crypto context&quot;);\n\n    // determine which type of plaintext that you need to decrypt into\n    // Plaintext decrypted =\n    // GetPlaintextForDecrypt(ciphertext-&gt;GetEncodingType(),\n    // this-&gt;GetElementParams(), this-&gt;GetEncodingParams());\n    Plaintext decrypted = GetPlaintextForDecrypt(ciphertext-&gt;GetEncodingType(),\n                                                 ciphertext-&gt;GetElements()[0].GetParams(), this-&gt;GetEncodingParams());\n\n    DecryptResult result;\n\n    if ((ciphertext-&gt;GetEncodingType() == CKKS_PACKED_ENCODING) &amp;&amp; (typeid(Element) != typeid(NativePoly))) {\n        result = GetScheme()-&gt;Decrypt(ciphertext, privateKey, &amp;decrypted-&gt;GetElement&lt;Poly&gt;());\n    }\n    else {\n        result = GetScheme()-&gt;Decrypt(ciphertext, privateKey, &amp;decrypted-&gt;GetElement&lt;NativePoly&gt;());\n    }\n\n    if (result.isValid == false)  // TODO (dsuponit): why don&#x27;t we throw an exception here?\n        return result;\n\n    decrypted-&gt;SetScalingFactorInt(result.scalingFactorInt);\n\n    if (ciphertext-&gt;GetEncodingType() == CKKS_PACKED_ENCODING) {\n        auto decryptedCKKS = std::dynamic_pointer_cast&lt;CKKSPackedEncoding&gt;(decrypted);\n        decryptedCKKS-&gt;SetNoiseScaleDeg(ciphertext-&gt;GetNoiseScaleDeg());\n        decryptedCKKS-&gt;SetLevel(ciphertext-&gt;GetLevel());\n        decryptedCKKS-&gt;SetScalingFactor(ciphertext-&gt;GetScalingFactor());\n        decryptedCKKS-&gt;SetSlots(ciphertext-&gt;GetSlots());\n\n        const auto cryptoParamsCKKS = std::dynamic_pointer_cast&lt;CryptoParametersRNS&gt;(this-&gt;GetCryptoParameters());\n\n        decryptedCKKS-&gt;Decode(ciphertext-&gt;GetNoiseScaleDeg(), ciphertext-&gt;GetScalingFactor(),\n                              cryptoParamsCKKS-&gt;GetScalingTechnique(), cryptoParamsCKKS-&gt;GetExecutionMode());\n    }\n    else {\n        decrypted-&gt;Decode();\n    }\n\n    *plaintext = std::move(decrypted);\n    return result;\n}\n\n//------------------------------------------------------------------------------\n// Advanced SHE CHEBYSHEV SERIES EXAMPLES\n//------------------------------------------------------------------------------\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalChebyshevFunction(std::function&lt;double(double)&gt; func,\n                                                                      ConstCiphertext&lt;Element&gt; ciphertext, double a,\n                                                                      double b, uint32_t degree) const {\n    std::vector&lt;double&gt; coefficients = EvalChebyshevCoefficients(func, a, b, degree);\n    return EvalChebyshevSeries(ciphertext, coefficients, a, b);\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalSin(ConstCiphertext&lt;Element&gt; ciphertext, double a, double b,\n                                                        uint32_t degree) const {\n    return EvalChebyshevFunction([](double x) -&gt; double { return std::sin(x); }, ciphertext, a, b, degree);\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalCos(ConstCiphertext&lt;Element&gt; ciphertext, double a, double b,\n                                                        uint32_t degree) const {\n    return EvalChebyshevFunction([](double x) -&gt; double { return std::cos(x); }, ciphertext, a, b, degree);\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalLogistic(ConstCiphertext&lt;Element&gt; ciphertext, double a, double b,\n                                                             uint32_t degree) const {\n    return EvalChebyshevFunction([](double x) -&gt; double { return 1 / (1 + std::exp(-x)); }, ciphertext, a, b, degree);\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalDivide(ConstCiphertext&lt;Element&gt; ciphertext, double a, double b,\n                                                           uint32_t degree) const {\n    return EvalChebyshevFunction([](double x) -&gt; double { return 1 / x; }, ciphertext, a, b, degree);\n}\n\n//------------------------------------------------------------------------------\n// SCHEMESWITCHING Methods\n//------------------------------------------------------------------------------\n\ntemplate &lt;typename Element&gt;\nstd::pair&lt;BinFHEContext, LWEPrivateKey&gt; CryptoContextImpl&lt;Element&gt;::EvalCKKStoFHEWSetup(\n    SecurityLevel sl, BINFHE_PARAMSET slBin, bool arbFunc, uint32_t logQ, bool dynamic, uint32_t numSlotsCKKS,\n    uint32_t logQswitch) {\n    return GetScheme()-&gt;EvalCKKStoFHEWSetup(*this, sl, slBin, arbFunc, logQ, dynamic, numSlotsCKKS, logQswitch);\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::EvalCKKStoFHEWKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk,\n                                                      uint32_t dim1, uint32_t L) {\n    if (keyPair.secretKey == nullptr || this-&gt;Mismatched(keyPair.secretKey-&gt;GetCryptoContext())) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;CKKS private key passed to EvalCKKStoFHEWKeyGen was not generated with this crypto context&quot;);\n    }\n    if (!lwesk) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;FHEW private key passed to EvalCKKStoFHEWKeyGen is null&quot;);\n    }\n    auto evalKeys = GetScheme()-&gt;EvalCKKStoFHEWKeyGen(keyPair, lwesk, dim1, L);\n\n    auto ekv = GetAllEvalAutomorphismKeys().find(keyPair.secretKey-&gt;GetKeyTag());\n    if (ekv == GetAllEvalAutomorphismKeys().end()) {\n        GetAllEvalAutomorphismKeys()[keyPair.secretKey-&gt;GetKeyTag()] = evalKeys;\n    }\n    else {\n        auto&amp; currRotMap = GetEvalAutomorphismKeyMap(keyPair.secretKey-&gt;GetKeyTag());\n        auto iterRowKeys = evalKeys-&gt;begin();\n        while (iterRowKeys != evalKeys-&gt;end()) {\n            auto idx = iterRowKeys-&gt;first;\n            // Search current rotation key map and add key\n            // only if it doesn&#x27;t exist\n            if (currRotMap.find(idx) == currRotMap.end()) {\n                currRotMap.insert(*iterRowKeys);\n            }\n            iterRowKeys++;\n        }\n    }\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::EvalCKKStoFHEWPrecompute(double scale) {\n    GetScheme()-&gt;EvalCKKStoFHEWPrecompute(*this, scale);\n}\n\ntemplate &lt;typename Element&gt;\nstd::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt; CryptoContextImpl&lt;Element&gt;::EvalCKKStoFHEW(\n    ConstCiphertext&lt;Element&gt; ciphertext, uint32_t numCtxts) {\n    if (ciphertext == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ciphertext passed to EvalCKKStoFHEW is empty&quot;);\n    return GetScheme()-&gt;EvalCKKStoFHEW(ciphertext, numCtxts);\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::EvalFHEWtoCKKSSetup(const BinFHEContext&amp; ccLWE, uint32_t numSlotsCKKS, uint32_t logQ) {\n    GetScheme()-&gt;EvalFHEWtoCKKSSetup(*this, ccLWE, numSlotsCKKS, logQ);\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::EvalFHEWtoCKKSKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk,\n                                                      uint32_t numSlots, uint32_t dim1, uint32_t L) {\n    if (keyPair.secretKey == nullptr || this-&gt;Mismatched(keyPair.secretKey-&gt;GetCryptoContext())) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Private key passed to EvalFHEWtoCKKSKeyGen was not generated with this crypto context&quot;);\n    }\n    auto evalKeys = GetScheme()-&gt;EvalFHEWtoCKKSKeyGen(keyPair, lwesk, numSlots, dim1, L);\n\n    auto ekv = GetAllEvalAutomorphismKeys().find(keyPair.secretKey-&gt;GetKeyTag());\n    if (ekv == GetAllEvalAutomorphismKeys().end()) {\n        GetAllEvalAutomorphismKeys()[keyPair.secretKey-&gt;GetKeyTag()] = evalKeys;\n    }\n    else {\n        auto&amp; currRotMap = GetEvalAutomorphismKeyMap(keyPair.secretKey-&gt;GetKeyTag());\n        auto iterRowKeys = evalKeys-&gt;begin();\n        while (iterRowKeys != evalKeys-&gt;end()) {\n            auto idx = iterRowKeys-&gt;first;\n            // Search current rotation key map and add key\n            // only if it doesn&#x27;t exist\n            if (currRotMap.find(idx) == currRotMap.end()) {\n                currRotMap.insert(*iterRowKeys);\n            }\n            iterRowKeys++;\n        }\n    }\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalFHEWtoCKKS(\n    std::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt;&amp; LWECiphertexts, uint32_t numCtxts, uint32_t numSlots, uint32_t p,\n    double pmin, double pmax) const {\n    return GetScheme()-&gt;EvalFHEWtoCKKS(LWECiphertexts, numCtxts, numSlots, p, pmin, pmax);\n}\n\ntemplate &lt;typename Element&gt;\nstd::pair&lt;BinFHEContext, LWEPrivateKey&gt; CryptoContextImpl&lt;Element&gt;::EvalSchemeSwitchingSetup(\n    SecurityLevel sl, BINFHE_PARAMSET slBin, bool arbFunc, uint32_t logQ, bool dynamic, uint32_t numSlotsCKKS,\n    uint32_t logQswitch) {\n    return GetScheme()-&gt;EvalSchemeSwitchingSetup(*this, sl, slBin, arbFunc, logQ, dynamic, numSlotsCKKS, logQswitch);\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::EvalSchemeSwitchingKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk,\n                                                           uint32_t numValues, bool oneHot, bool alt, uint32_t dim1CF,\n                                                           uint32_t dim1FC, uint32_t LCF, uint32_t LFC) {\n    if (keyPair.secretKey == nullptr || this-&gt;Mismatched(keyPair.secretKey-&gt;GetCryptoContext())) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Private key passed to EvalSchemeSwitchingKeyGen was not generated with this crypto context&quot;);\n    }\n    auto evalKeys =\n        GetScheme()-&gt;EvalSchemeSwitchingKeyGen(keyPair, lwesk, numValues, oneHot, alt, dim1CF, dim1FC, LCF, LFC);\n\n    auto ekv = GetAllEvalAutomorphismKeys().find(keyPair.secretKey-&gt;GetKeyTag());\n    if (ekv == GetAllEvalAutomorphismKeys().end()) {\n        GetAllEvalAutomorphismKeys()[keyPair.secretKey-&gt;GetKeyTag()] = evalKeys;\n    }\n    else {\n        auto&amp; currRotMap = GetEvalAutomorphismKeyMap(keyPair.secretKey-&gt;GetKeyTag());\n        auto iterRowKeys = evalKeys-&gt;begin();\n        while (iterRowKeys != evalKeys-&gt;end()) {\n            auto idx = iterRowKeys-&gt;first;\n            // Search current rotation key map and add key\n            // only if it doesn&#x27;t exist\n            if (currRotMap.find(idx) == currRotMap.end()) {\n                currRotMap.insert(*iterRowKeys);\n            }\n            iterRowKeys++;\n        }\n    }\n}\n\ntemplate &lt;typename Element&gt;\nvoid CryptoContextImpl&lt;Element&gt;::EvalCompareSwitchPrecompute(uint32_t pLWE, uint32_t initLevel, double scaleSign,\n                                                             bool unit) {\n    GetScheme()-&gt;EvalCompareSwitchPrecompute(*this, pLWE, initLevel, scaleSign, unit);\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::EvalCompareSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                                           ConstCiphertext&lt;Element&gt; ciphertext2,\n                                                                           uint32_t numCtxts, uint32_t numSlots,\n                                                                           uint32_t pLWE, double scaleSign, bool unit) {\n    if (ciphertext1 == nullptr || ciphertext2 == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ciphertexts passed to EvalCompareSchemeSwitching are empty&quot;);\n    if (Mismatched(ciphertext1-&gt;GetCryptoContext()) || Mismatched(ciphertext2-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;A ciphertext passed to EvalCompareSchemeSwitching was not &quot;\n                      &quot;generated with this crypto context&quot;);\n    return GetScheme()-&gt;EvalCompareSchemeSwitching(ciphertext1, ciphertext2, numCtxts, numSlots, pLWE, scaleSign, unit);\n}\n\ntemplate &lt;typename Element&gt;\nstd::vector&lt;Ciphertext&lt;Element&gt;&gt; CryptoContextImpl&lt;Element&gt;::EvalMinSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                                    PublicKey&lt;Element&gt; publicKey,\n                                                                                    uint32_t numValues,\n                                                                                    uint32_t numSlots, bool oneHot,\n                                                                                    uint32_t pLWE, double scaleSign) {\n    if (!ciphertext)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ciphertexts passed to EvalMinSchemeSwitching are empty&quot;);\n    if (Mismatched(ciphertext-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;The ciphertext passed to EvalMinSchemeSwitching was not &quot;\n                      &quot;generated with this crypto context&quot;);\n    return GetScheme()-&gt;EvalMinSchemeSwitching(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE, scaleSign);\n}\n\ntemplate &lt;typename Element&gt;\nstd::vector&lt;Ciphertext&lt;Element&gt;&gt; CryptoContextImpl&lt;Element&gt;::EvalMinSchemeSwitchingAlt(\n    ConstCiphertext&lt;Element&gt; ciphertext, PublicKey&lt;Element&gt; publicKey, uint32_t numValues, uint32_t numSlots,\n    bool oneHot, uint32_t pLWE, double scaleSign) {\n    if (ciphertext == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ciphertexts passed to EvalMinSchemeSwitching are empty&quot;);\n    if (Mismatched(ciphertext-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;The ciphertext passed to EvalMinSchemeSwitchingAlt was not &quot;\n                      &quot;generated with this crypto context&quot;);\n    return GetScheme()-&gt;EvalMinSchemeSwitchingAlt(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE, scaleSign);\n}\n\ntemplate &lt;typename Element&gt;\nstd::vector&lt;Ciphertext&lt;Element&gt;&gt; CryptoContextImpl&lt;Element&gt;::EvalMaxSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                                    PublicKey&lt;Element&gt; publicKey,\n                                                                                    uint32_t numValues,\n                                                                                    uint32_t numSlots, bool oneHot,\n                                                                                    uint32_t pLWE, double scaleSign) {\n    if (ciphertext == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ciphertexts passed to EvalMaxSchemeSwitching are empty&quot;);\n    if (Mismatched(ciphertext-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;The ciphertext passed to EvalMinSchemeSwitching was not &quot;\n                      &quot;generated with this crypto context&quot;);\n    return GetScheme()-&gt;EvalMaxSchemeSwitching(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE, scaleSign);\n}\n\ntemplate &lt;typename Element&gt;\nstd::vector&lt;Ciphertext&lt;Element&gt;&gt; CryptoContextImpl&lt;Element&gt;::EvalMaxSchemeSwitchingAlt(\n    ConstCiphertext&lt;Element&gt; ciphertext, PublicKey&lt;Element&gt; publicKey, uint32_t numValues, uint32_t numSlots,\n    bool oneHot, uint32_t pLWE, double scaleSign) {\n    if (ciphertext == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ciphertexts passed to EvalMaxSchemeSwitching are empty&quot;);\n    if (Mismatched(ciphertext-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;The ciphertext passed to EvalMinSchemeSwitchingAlt was not &quot;\n                      &quot;generated with this crypto context&quot;);\n    return GetScheme()-&gt;EvalMaxSchemeSwitchingAlt(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE, scaleSign);\n}\n\n}  // namespace lbcrypto\n\n// the code below is from cryptocontext-impl.cpp\nnamespace lbcrypto {\n\ntemplate &lt;&gt;\nPlaintext CryptoContextImpl&lt;DCRTPoly&gt;::GetPlaintextForDecrypt(PlaintextEncodings pte, std::shared_ptr&lt;ParmType&gt; evp,\n                                                              EncodingParams ep) {\n    if ((pte == CKKS_PACKED_ENCODING) &amp;&amp; (evp-&gt;GetParams().size() &gt; 1)) {\n        auto vp = std::make_shared&lt;typename Poly::Params&gt;(evp-&gt;GetCyclotomicOrder(), ep-&gt;GetPlaintextModulus(), 1);\n        return PlaintextFactory::MakePlaintext(pte, vp, ep);\n    }\n    else {\n        auto vp =\n            std::make_shared&lt;typename NativePoly::Params&gt;(evp-&gt;GetCyclotomicOrder(), ep-&gt;GetPlaintextModulus(), 1);\n        return PlaintextFactory::MakePlaintext(pte, vp, ep);\n    }\n}\n\ntemplate &lt;&gt;\nDecryptResult CryptoContextImpl&lt;DCRTPoly&gt;::Decrypt(ConstCiphertext&lt;DCRTPoly&gt; ciphertext,\n                                                   const PrivateKey&lt;DCRTPoly&gt; privateKey, Plaintext* plaintext) {\n    if (ciphertext == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ciphertext passed to Decrypt is empty&quot;);\n    if (plaintext == nullptr)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;plaintext passed to Decrypt is empty&quot;);\n    if (privateKey == nullptr || Mismatched(privateKey-&gt;GetCryptoContext()))\n        &quot;hey&quot;; OPENFHE_THROW(config_error,\n                      &quot;Information passed to Decrypt was not generated with &quot;\n                      &quot;this crypto context&quot;);\n\n    // determine which type of plaintext that you need to decrypt into\n    // Plaintext decrypted =\n    // GetPlaintextForDecrypt(ciphertext-&gt;GetEncodingType(),\n    // this-&gt;GetElementParams(), this-&gt;GetEncodingParams());\n    Plaintext decrypted = GetPlaintextForDecrypt(ciphertext-&gt;GetEncodingType(),\n                                                 ciphertext-&gt;GetElements()[0].GetParams(), this-&gt;GetEncodingParams());\n\n    DecryptResult result;\n\n    if ((ciphertext-&gt;GetEncodingType() == CKKS_PACKED_ENCODING) &amp;&amp;\n        (ciphertext-&gt;GetElements()[0].GetParams()-&gt;GetParams().size() &gt; 1))  // more than one tower in DCRTPoly\n        result = GetScheme()-&gt;Decrypt(ciphertext, privateKey, &amp;decrypted-&gt;GetElement&lt;Poly&gt;());\n    else\n        result = GetScheme()-&gt;Decrypt(ciphertext, privateKey, &amp;decrypted-&gt;GetElement&lt;NativePoly&gt;());\n\n    if (result.isValid == false)\n        return result;\n\n    decrypted-&gt;SetScalingFactorInt(result.scalingFactorInt);\n\n    if (ciphertext-&gt;GetEncodingType() == CKKS_PACKED_ENCODING) {\n        auto decryptedCKKS = std::dynamic_pointer_cast&lt;CKKSPackedEncoding&gt;(decrypted);\n        decryptedCKKS-&gt;SetNoiseScaleDeg(ciphertext-&gt;GetNoiseScaleDeg());\n        decryptedCKKS-&gt;SetLevel(ciphertext-&gt;GetLevel());\n        decryptedCKKS-&gt;SetScalingFactor(ciphertext-&gt;GetScalingFactor());\n        decryptedCKKS-&gt;SetSlots(ciphertext-&gt;GetSlots());\n\n        const auto cryptoParamsCKKS = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(this-&gt;GetCryptoParameters());\n\n        decryptedCKKS-&gt;Decode(ciphertext-&gt;GetNoiseScaleDeg(), ciphertext-&gt;GetScalingFactor(),\n                              cryptoParamsCKKS-&gt;GetScalingTechnique(), cryptoParamsCKKS-&gt;GetExecutionMode());\n    }\n    else {\n        decrypted-&gt;Decode();\n    }\n\n    *plaintext = std::move(decrypted);\n    return result;\n}\n\ntemplate &lt;&gt;\nDecryptResult CryptoContextImpl&lt;DCRTPoly&gt;::MultipartyDecryptFusion(\n    const std::vector&lt;Ciphertext&lt;DCRTPoly&gt;&gt;&amp; partialCiphertextVec, Plaintext* plaintext) const {\n    DecryptResult result;\n\n    // Make sure we&#x27;re processing ciphertexts.\n    size_t last_ciphertext = partialCiphertextVec.size();\n    if (last_ciphertext &lt; 1)\n        return result;\n\n    for (size_t i = 0; i &lt; last_ciphertext; i++) {\n        if (partialCiphertextVec[i] == nullptr || Mismatched(partialCiphertextVec[i]-&gt;GetCryptoContext()))\n            &quot;hey&quot;; OPENFHE_THROW(config_error,\n                          &quot;A ciphertext passed to MultipartyDecryptFusion was not &quot;\n                          &quot;generated with this crypto context&quot;);\n        if (partialCiphertextVec[i]-&gt;GetEncodingType() != partialCiphertextVec[0]-&gt;GetEncodingType())\n            &quot;hey&quot;; OPENFHE_THROW(type_error,\n                          &quot;Ciphertexts passed to MultipartyDecryptFusion have &quot;\n                          &quot;mismatched encoding types&quot;);\n    }\n\n    // determine which type of plaintext that you need to decrypt into\n    Plaintext decrypted =\n        GetPlaintextForDecrypt(partialCiphertextVec[0]-&gt;GetEncodingType(),\n                               partialCiphertextVec[0]-&gt;GetElements()[0].GetParams(), this-&gt;GetEncodingParams());\n\n    if ((partialCiphertextVec[0]-&gt;GetEncodingType() == CKKS_PACKED_ENCODING) &amp;&amp;\n        (partialCiphertextVec[0]-&gt;GetElements()[0].GetParams()-&gt;GetParams().size() &gt; 1))\n        result = GetScheme()-&gt;MultipartyDecryptFusion(partialCiphertextVec, &amp;decrypted-&gt;GetElement&lt;Poly&gt;());\n    else\n        result = GetScheme()-&gt;MultipartyDecryptFusion(partialCiphertextVec, &amp;decrypted-&gt;GetElement&lt;NativePoly&gt;());\n\n    if (result.isValid == false)\n        return result;\n\n    decrypted-&gt;SetScalingFactorInt(result.scalingFactorInt);\n\n    if (partialCiphertextVec[0]-&gt;GetEncodingType() == CKKS_PACKED_ENCODING) {\n        auto decryptedCKKS = std::dynamic_pointer_cast&lt;CKKSPackedEncoding&gt;(decrypted);\n        decryptedCKKS-&gt;SetSlots(partialCiphertextVec[0]-&gt;GetSlots());\n        const auto cryptoParamsCKKS = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(this-&gt;GetCryptoParameters());\n        decryptedCKKS-&gt;Decode(partialCiphertextVec[0]-&gt;GetNoiseScaleDeg(), partialCiphertextVec[0]-&gt;GetScalingFactor(),\n                              cryptoParamsCKKS-&gt;GetScalingTechnique(), cryptoParamsCKKS-&gt;GetExecutionMode());\n    }\n    else {\n        decrypted-&gt;Decode();\n    }\n\n    *plaintext = std::move(decrypted);\n\n    return result;\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::IntMPBootAdjustScale(ConstCiphertext&lt;Element&gt; ciphertext) const {\n    return GetScheme()-&gt;IntMPBootAdjustScale(ciphertext);\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::IntMPBootRandomElementGen(const PublicKey&lt;Element&gt; publicKey) const {\n    const auto cryptoParamsCKKS = std::dynamic_pointer_cast&lt;CryptoParametersCKKSRNS&gt;(this-&gt;GetCryptoParameters());\n    return GetScheme()-&gt;IntMPBootRandomElementGen(cryptoParamsCKKS, publicKey);\n}\n\ntemplate &lt;typename Element&gt;\nstd::vector&lt;Ciphertext&lt;Element&gt;&gt; CryptoContextImpl&lt;Element&gt;::IntMPBootDecrypt(const PrivateKey&lt;Element&gt; privateKey,\n                                                                              ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                              ConstCiphertext&lt;Element&gt; a) const {\n    return GetScheme()-&gt;IntMPBootDecrypt(privateKey, ciphertext, a);\n}\n\ntemplate &lt;typename Element&gt;\nstd::vector&lt;Ciphertext&lt;Element&gt;&gt; CryptoContextImpl&lt;Element&gt;::IntMPBootAdd(\n    std::vector&lt;std::vector&lt;Ciphertext&lt;Element&gt;&gt;&gt;&amp; sharesPairVec) const {\n    return GetScheme()-&gt;IntMPBootAdd(sharesPairVec);\n}\n\ntemplate &lt;typename Element&gt;\nCiphertext&lt;Element&gt; CryptoContextImpl&lt;Element&gt;::IntMPBootEncrypt(const PublicKey&lt;Element&gt; publicKey,\n                                                                 const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; sharesPair,\n                                                                 ConstCiphertext&lt;Element&gt; a,\n                                                                 ConstCiphertext&lt;Element&gt; ciphertext) const {\n    return GetScheme()-&gt;IntMPBootEncrypt(publicKey, sharesPair, a, ciphertext);\n}\n\n// Function for sharing and recovery of secret for Threshold FHE with aborts\ntemplate &lt;&gt;\nstd::unordered_map&lt;uint32_t, DCRTPoly&gt; CryptoContextImpl&lt;DCRTPoly&gt;::ShareKeys(const PrivateKey&lt;DCRTPoly&gt;&amp; sk, usint N,\n                                                                              usint threshold, usint index,\n                                                                              const std::string&amp; shareType) const {\n    // conditions on N and threshold for security with aborts\n    if (N &lt; 2)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Number of parties needs to be at least 3 for aborts&quot;);\n\n    if (threshold &lt;= N / 2)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Threshold required to be majority (more than N/2)&quot;);\n\n    const auto cryptoParams = sk-&gt;GetCryptoContext()-&gt;GetCryptoParameters();\n    auto elementParams      = cryptoParams-&gt;GetElementParams();\n    auto vecSize            = elementParams-&gt;GetParams().size();\n    auto ring_dimension     = elementParams-&gt;GetRingDimension();\n\n    // condition for inverse in lagrange coeff to exist.\n    for (usint k = 0; k &lt; vecSize; k++) {\n        auto modq_k = elementParams-&gt;GetParams()[k]-&gt;GetModulus();\n        if (N &gt;= modq_k)\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Number of parties N needs to be less than DCRTPoly moduli&quot;);\n    }\n\n    // secret sharing\n    const usint num_of_shares = N - 1;\n    std::unordered_map&lt;uint32_t, DCRTPoly&gt; SecretShares;\n\n    if (shareType == &quot;additive&quot;) {\n        // generate a random share of N-2 elements and create the last share as sk - (sk_1 + ... + sk_N-2)\n        typename DCRTPoly::DugType dug;\n        DCRTPoly rsum(dug, elementParams, Format::EVALUATION);\n\n        std::vector&lt;DCRTPoly&gt; SecretSharesVec;\n        SecretSharesVec.reserve(num_of_shares);\n        SecretSharesVec.push_back(rsum);\n        for (size_t i = 1; i &lt; num_of_shares - 1; ++i) {\n            DCRTPoly r(dug, elementParams, Format::EVALUATION);  // should re-generate uniform r for each share\n            rsum += r;\n            SecretSharesVec.push_back(std::move(r));\n        }\n        SecretSharesVec.push_back(sk-&gt;GetPrivateElement() - rsum);\n\n        usint ctr = 0;\n        for (size_t i = 1; i &lt;= N; i++) {\n            if (i != index) {\n                SecretShares[i] = SecretSharesVec[ctr];\n                ctr++;\n            }\n        }\n    }\n    else if (shareType == &quot;shamir&quot;) {\n        // vector to store columnwise randomly generated coefficients for polynomial f from Z_q for every secret key entry\n        std::vector&lt;DCRTPoly&gt; fs;\n        fs.reserve(threshold);\n\n        // set constant term of polynomial f_i to s_i\n        DCRTPoly ske = sk-&gt;GetPrivateElement();\n        // set the secret element in coefficient format\n        ske.SetFormat(Format::COEFFICIENT);\n\n        fs.push_back(std::move(ske));\n        // generate random coefficients\n        typename DCRTPoly::DugType dug;\n        for (size_t i = 1; i &lt; threshold; i++) {\n            fs.push_back(DCRTPoly(dug, elementParams, Format::COEFFICIENT));\n        }\n\n        // evaluate the polynomial at the index of the parties 1 to N\n\n        for (size_t i = 1; i &lt;= N; i++) {\n            if (i != index) {\n                DCRTPoly feval(elementParams, Format::COEFFICIENT, true);\n                for (size_t k = 0; k &lt; vecSize; k++) {\n                    auto modq_k = elementParams-&gt;GetParams()[k]-&gt;GetModulus();\n\n                    NativeVector powtempvec(ring_dimension, modq_k);\n                    NativePoly powtemppoly(elementParams-&gt;GetParams()[k], Format::COEFFICIENT);\n                    NativePoly fevalpoly(elementParams-&gt;GetParams()[k], Format::COEFFICIENT, true);\n\n                    NativeInteger powtemp(1);\n                    for (size_t t = 1; t &lt; threshold; t++) {\n                        powtemp = powtemp.ModMul(i, modq_k);\n\n                        for (size_t d = 0; d &lt; ring_dimension; d++) {\n                            powtempvec.at(d) = powtemp;\n                        }\n\n                        powtemppoly.SetValues(powtempvec, Format::COEFFICIENT);\n\n                        auto fst = fs[t].GetElementAtIndex(k);\n\n                        for (size_t l = 0; l &lt; ring_dimension; l++) {\n                            fevalpoly.at(l) += powtemppoly.at(l).ModMul(fst.at(l), modq_k);\n                        }\n                    }\n                    fevalpoly += fs[0].GetElementAtIndex(k);\n\n                    fevalpoly.SetFormat(Format::COEFFICIENT);\n                    feval.SetElementAtIndex(k, fevalpoly);\n                }\n                // assign fi\n                SecretShares[i] = feval;\n            }\n        }\n    }\n    return SecretShares;\n}\n\ntemplate &lt;&gt;\nvoid CryptoContextImpl&lt;DCRTPoly&gt;::RecoverSharedKey(PrivateKey&lt;DCRTPoly&gt;&amp; sk,\n                                                   std::unordered_map&lt;uint32_t, DCRTPoly&gt;&amp; sk_shares, usint N,\n                                                   usint threshold, const std::string&amp; shareType) const {\n    if (sk_shares.size() &lt; threshold)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Number of shares available less than threshold of the sharing scheme&quot;);\n\n    // conditions on N and threshold for security with aborts\n    if (N &lt; 2)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Number of parties needs to be at least 3 for aborts&quot;);\n\n    if (threshold &lt;= N / 2)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Threshold required to be majority (more than N/2)&quot;);\n\n    const auto&amp; cryptoParams  = sk-&gt;GetCryptoContext()-&gt;GetCryptoParameters();\n    const auto&amp; elementParams = cryptoParams-&gt;GetElementParams();\n    size_t ring_dimension     = elementParams-&gt;GetRingDimension();\n    size_t vecSize            = elementParams-&gt;GetParams().size();\n\n    // condition for inverse in lagrange coeff to exist.\n    for (size_t k = 0; k &lt; vecSize; k++) {\n        auto modq_k = elementParams-&gt;GetParams()[k]-&gt;GetModulus();\n        if (N &gt;= modq_k)\n            &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;Number of parties N needs to be less than DCRTPoly moduli&quot;);\n    }\n\n    // vector of indexes of the clients\n    std::vector&lt;uint32_t&gt; client_indexes;\n    for (uint32_t i = 1; i &lt;= N; ++i) {\n        if (sk_shares.find(i) != sk_shares.end())\n            client_indexes.push_back(i);\n    }\n    const uint32_t client_indexes_size = client_indexes.size();\n\n    if (client_indexes_size &lt; threshold)\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Not enough shares to recover the secret&quot;);\n\n    if (shareType == &quot;additive&quot;) {\n        DCRTPoly sum_of_elems(elementParams, Format::EVALUATION, true);\n        for (uint32_t i = 0; i &lt; threshold; ++i) {\n            sum_of_elems += sk_shares[client_indexes[i]];\n        }\n        sk-&gt;SetPrivateElement(sum_of_elems);\n    }\n    else if (shareType == &quot;shamir&quot;) {\n        // use lagrange interpolation to recover the secret\n        // vector of lagrange coefficients L_j = Pdt_i ne j (i (i-j)^-1)\n        std::vector&lt;DCRTPoly&gt; Lagrange_coeffs(client_indexes_size, DCRTPoly(elementParams, Format::EVALUATION));\n\n        // recovery of the secret with lagrange coefficients and the secret shares\n        for (uint32_t j = 0; j &lt; client_indexes_size; j++) {\n            auto cj = client_indexes[j];\n            for (size_t k = 0; k &lt; vecSize; k++) {\n                auto modq_k = elementParams-&gt;GetParams()[k]-&gt;GetModulus();\n                NativePoly multpoly(elementParams-&gt;GetParams()[k], Format::COEFFICIENT, true);\n                multpoly.AddILElementOne();\n                for (uint32_t i = 0; i &lt; client_indexes_size; i++) {\n                    auto ci = client_indexes[i];\n                    if (ci != cj) {\n                        auto&amp;&amp; denominator = (cj &lt; ci) ? NativeInteger(ci - cj) : modq_k - NativeInteger(cj - ci);\n                        auto denom_inv{denominator.ModInverse(modq_k)};\n                        for (size_t d = 0; d &lt; ring_dimension; ++d)\n                            multpoly[d].ModMulFastEq(NativeInteger(ci).ModMul(denom_inv, modq_k), modq_k);\n                    }\n                }\n                multpoly.SetFormat(Format::EVALUATION);\n                Lagrange_coeffs[j].SetElementAtIndex(k, multpoly);\n            }\n            Lagrange_coeffs[j].SetFormat(Format::COEFFICIENT);\n        }\n\n        DCRTPoly lagrange_sum_of_elems(elementParams, Format::COEFFICIENT, true);\n        for (size_t k = 0; k &lt; vecSize; ++k) {\n            NativePoly lagrange_sum_of_elems_poly(elementParams-&gt;GetParams()[k], Format::COEFFICIENT, true);\n            for (uint32_t i = 0; i &lt; client_indexes_size; ++i) {\n                const auto&amp; coeff = Lagrange_coeffs[i].GetAllElements()[k];\n                const auto&amp; share = sk_shares[client_indexes[i]].GetAllElements()[k];\n                lagrange_sum_of_elems_poly += coeff.TimesNoCheck(share);\n            }\n            lagrange_sum_of_elems.SetElementAtIndex(k, lagrange_sum_of_elems_poly);\n        }\n        lagrange_sum_of_elems.SetFormat(Format::EVALUATION);\n        sk-&gt;SetPrivateElement(lagrange_sum_of_elems);\n    }\n}\n\ntemplate class CryptoContextImpl&lt;DCRTPoly&gt;;\n\n}  // namespace lbcrypto\n"}, "/usr/include/c++/11/bits/shared_ptr.h": {"id": "/usr/include/c++/11/bits/shared_ptr.h", "filePath": "/usr/include/c++/11/bits/shared_ptr.h", "content": "// shared_ptr and weak_ptr implementation -*- C++ -*-\n\n// Copyright (C) 2007-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n// GCC Note: Based on files from version 1.32.0 of the Boost library.\n\n//  shared_count.hpp\n//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n\n//  shared_ptr.hpp\n//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  weak_ptr.hpp\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  enable_shared_from_this.hpp\n//  Copyright (C) 2002 Peter Dimov\n\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n\n/** @file\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _SHARED_PTR_H\n#define _SHARED_PTR_H 1\n\n#include &lt;iosfwd&gt;           \t  // std::basic_ostream\n#include &lt;bits/shared_ptr_base.h&gt;\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   * @addtogroup pointer_abstractions\n   * @{\n   */\n\n  // 20.7.2.2.11 shared_ptr I/O\n\n  /// Write the stored pointer to an ostream.\n  /// @relates shared_ptr\n  template&lt;typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp&gt;\n    inline std::basic_ostream&lt;_Ch, _Tr&gt;&amp;\n    operator&lt;&lt;(std::basic_ostream&lt;_Ch, _Tr&gt;&amp; __os,\n\t       const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __p)\n    {\n      __os &lt;&lt; __p.get();\n      return __os;\n    }\n\n  template&lt;typename _Del, typename _Tp, _Lock_policy _Lp&gt;\n    inline _Del*\n    get_deleter(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __p) noexcept\n    {\n#if __cpp_rtti\n      return static_cast&lt;_Del*&gt;(__p._M_get_deleter(typeid(_Del)));\n#else\n      return 0;\n#endif\n    }\n\n  /// 20.7.2.2.10 shared_ptr get_deleter\n\n  /// If `__p` has a deleter of type `_Del`, return a pointer to it.\n  /// @relates shared_ptr\n  template&lt;typename _Del, typename _Tp&gt;\n    inline _Del*\n    get_deleter(const shared_ptr&lt;_Tp&gt;&amp; __p) noexcept\n    {\n#if __cpp_rtti\n      return static_cast&lt;_Del*&gt;(__p._M_get_deleter(typeid(_Del)));\n#else\n      return 0;\n#endif\n    }\n\n  /**\n   *  @brief  A smart pointer with reference-counted copy semantics.\n   *\n   * A `shared_ptr` object is either empty or _owns_ a pointer passed\n   * to the constructor. Copies of a `shared_ptr` share ownership of\n   * the same pointer. When the last `shared_ptr` that owns the pointer\n   * is destroyed or reset, the owned pointer is freed (either by `delete`\n   * or by invoking a custom deleter that was passed to the constructor).\n   *\n   * A `shared_ptr` also stores another pointer, which is usually\n   * (but not always) the same pointer as it owns. The stored pointer\n   * can be retrieved by calling the `get()` member function.\n   *\n   * The equality and relational operators for `shared_ptr` only compare\n   * the stored pointer returned by `get()`, not the owned pointer.\n   * To test whether two `shared_ptr` objects share ownership of the same\n   * pointer see `std::shared_ptr::owner_before` and `std::owner_less`.\n  */\n  template&lt;typename _Tp&gt;\n    class shared_ptr : public __shared_ptr&lt;_Tp&gt;\n    {\n      template&lt;typename... _Args&gt;\n\tusing _Constructible = typename enable_if&lt;\n\t  is_constructible&lt;__shared_ptr&lt;_Tp&gt;, _Args...&gt;::value\n\t&gt;::type;\n\n      template&lt;typename _Arg&gt;\n\tusing _Assignable = typename enable_if&lt;\n\t  is_assignable&lt;__shared_ptr&lt;_Tp&gt;&amp;, _Arg&gt;::value, shared_ptr&amp;\n\t&gt;::type;\n\n    public:\n\n      /// The type pointed to by the stored pointer, remove_extent_t&lt;_Tp&gt;\n      using element_type = typename __shared_ptr&lt;_Tp&gt;::element_type;\n\n#if __cplusplus &gt;= 201703L\n# define __cpp_lib_shared_ptr_weak_type 201606\n      /// The corresponding weak_ptr type for this shared_ptr\n      using weak_type = weak_ptr&lt;_Tp&gt;;\n#endif\n      /**\n       *  @brief  Construct an empty %shared_ptr.\n       *  @post   use_count()==0 &amp;&amp; get()==0\n       */\n      constexpr shared_ptr() noexcept : __shared_ptr&lt;_Tp&gt;() { }\n\n      shared_ptr(const shared_ptr&amp;) noexcept = default; ///&lt; Copy constructor\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns the pointer @a __p.\n       *  @param  __p  A pointer that is convertible to element_type*.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @c delete @a __p is called.\n       */\n      template&lt;typename _Yp, typename = _Constructible&lt;_Yp*&gt;&gt;\n\texplicit\n\tshared_ptr(_Yp* __p) : __shared_ptr&lt;_Tp&gt;(__p) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns the pointer @a __p\n       *          and the deleter @a __d.\n       *  @param  __p  A pointer.\n       *  @param  __d  A deleter.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw\n       *\n       *  __shared_ptr will release __p by calling __d(__p)\n       */\n      template&lt;typename _Yp, typename _Deleter,\n\t       typename = _Constructible&lt;_Yp*, _Deleter&gt;&gt;\n\tshared_ptr(_Yp* __p, _Deleter __d)\n        : __shared_ptr&lt;_Tp&gt;(__p, std::move(__d)) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns a null pointer\n       *          and the deleter @a __d.\n       *  @param  __p  A null pointer constant.\n       *  @param  __d  A deleter.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw\n       *\n       *  The last owner will call __d(__p)\n       */\n      template&lt;typename _Deleter&gt;\n\tshared_ptr(nullptr_t __p, _Deleter __d)\n        : __shared_ptr&lt;_Tp&gt;(__p, std::move(__d)) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns the pointer @a __p\n       *          and the deleter @a __d.\n       *  @param  __p  A pointer.\n       *  @param  __d  A deleter.\n       *  @param  __a  An allocator.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw _Alloc&#x27;s copy constructor and destructor must not\n       *  throw.\n       *\n       *  __shared_ptr will release __p by calling __d(__p)\n       */\n      template&lt;typename _Yp, typename _Deleter, typename _Alloc,\n\t       typename = _Constructible&lt;_Yp*, _Deleter, _Alloc&gt;&gt;\n\tshared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)\n\t: __shared_ptr&lt;_Tp&gt;(__p, std::move(__d), std::move(__a)) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns a null pointer\n       *          and the deleter @a __d.\n       *  @param  __p  A null pointer constant.\n       *  @param  __d  A deleter.\n       *  @param  __a  An allocator.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw _Alloc&#x27;s copy constructor and destructor must not\n       *  throw.\n       *\n       *  The last owner will call __d(__p)\n       */\n      template&lt;typename _Deleter, typename _Alloc&gt;\n\tshared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)\n\t: __shared_ptr&lt;_Tp&gt;(__p, std::move(__d), std::move(__a)) { }\n\n      // Aliasing constructor\n\n      /**\n       *  @brief  Constructs a `shared_ptr` instance that stores `__p`\n       *          and shares ownership with `__r`.\n       *  @param  __r  A `shared_ptr`.\n       *  @param  __p  A pointer that will remain valid while `*__r` is valid.\n       *  @post   `get() == __p &amp;&amp; use_count() == __r.use_count()`\n       *\n       *  This can be used to construct a `shared_ptr` to a sub-object\n       *  of an object managed by an existing `shared_ptr`. The complete\n       *  object will remain valid while any `shared_ptr` owns it, even\n       *  if they don&#x27;t store a pointer to the complete object.\n       *\n       * @code\n       * shared_ptr&lt;pair&lt;int,int&gt;&gt; pii(new pair&lt;int,int&gt;());\n       * shared_ptr&lt;int&gt; pi(pii, &amp;pii-&gt;first);\n       * assert(pii.use_count() == 2);\n       * @endcode\n       */\n      template&lt;typename _Yp&gt;\n\tshared_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r, element_type* __p) noexcept\n\t: __shared_ptr&lt;_Tp&gt;(__r, __p) { }\n\n#if __cplusplus &gt; 201703L\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2996. Missing rvalue overloads for shared_ptr operations\n      /**\n       *  @brief  Constructs a `shared_ptr` instance that stores `__p`\n       *          and shares ownership with `__r`.\n       *  @param  __r  A `shared_ptr`.\n       *  @param  __p  A pointer that will remain valid while `*__r` is valid.\n       *  @post   `get() == __p &amp;&amp; !__r.use_count() &amp;&amp; !__r.get()`\n       *\n       *  This can be used to construct a `shared_ptr` to a sub-object\n       *  of an object managed by an existing `shared_ptr`. The complete\n       *  object will remain valid while any `shared_ptr` owns it, even\n       *  if they don&#x27;t store a pointer to the complete object.\n       *\n       * @code\n       * shared_ptr&lt;pair&lt;int,int&gt;&gt; pii(new pair&lt;int,int&gt;());\n       * shared_ptr&lt;int&gt; pi1(pii, &amp;pii-&gt;first);\n       * assert(pii.use_count() == 2);\n       * shared_ptr&lt;int&gt; pi2(std::move(pii), &amp;pii-&gt;second);\n       * assert(pii.use_count() == 0);\n       * @endcode\n       */\n      template&lt;typename _Yp&gt;\n\tshared_ptr(shared_ptr&lt;_Yp&gt;&amp;&amp; __r, element_type* __p) noexcept\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r), __p) { }\n#endif\n      /**\n       *  @brief  If @a __r is empty, constructs an empty %shared_ptr;\n       *          otherwise construct a %shared_ptr that shares ownership\n       *          with @a __r.\n       *  @param  __r  A %shared_ptr.\n       *  @post   get() == __r.get() &amp;&amp; use_count() == __r.use_count()\n       */\n      template&lt;typename _Yp,\n\t       typename = _Constructible&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\tshared_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n        : __shared_ptr&lt;_Tp&gt;(__r) { }\n\n      /**\n       *  @brief  Move-constructs a %shared_ptr instance from @a __r.\n       *  @param  __r  A %shared_ptr rvalue.\n       *  @post   *this contains the old value of @a __r, @a __r is empty.\n       */\n      shared_ptr(shared_ptr&amp;&amp; __r) noexcept\n      : __shared_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n      /**\n       *  @brief  Move-constructs a %shared_ptr instance from @a __r.\n       *  @param  __r  A %shared_ptr rvalue.\n       *  @post   *this contains the old value of @a __r, @a __r is empty.\n       */\n      template&lt;typename _Yp, typename = _Constructible&lt;shared_ptr&lt;_Yp&gt;&gt;&gt;\n\tshared_ptr(shared_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n      /**\n       *  @brief  Constructs a %shared_ptr that shares ownership with @a __r\n       *          and stores a copy of the pointer stored in @a __r.\n       *  @param  __r  A weak_ptr.\n       *  @post   use_count() == __r.use_count()\n       *  @throw  bad_weak_ptr when __r.expired(),\n       *          in which case the constructor has no effect.\n       */\n      template&lt;typename _Yp, typename = _Constructible&lt;const weak_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\texplicit shared_ptr(const weak_ptr&lt;_Yp&gt;&amp; __r)\n\t: __shared_ptr&lt;_Tp&gt;(__r) { }\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      template&lt;typename _Yp, typename = _Constructible&lt;auto_ptr&lt;_Yp&gt;&gt;&gt;\n\tshared_ptr(auto_ptr&lt;_Yp&gt;&amp;&amp; __r);\n#pragma GCC diagnostic pop\n#endif\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2399. shared_ptr&#x27;s constructor from unique_ptr should be constrained\n      template&lt;typename _Yp, typename _Del,\n\t       typename = _Constructible&lt;unique_ptr&lt;_Yp, _Del&gt;&gt;&gt;\n\tshared_ptr(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n#if __cplusplus &lt;= 201402L &amp;&amp; _GLIBCXX_USE_DEPRECATED\n      // This non-standard constructor exists to support conversions that\n      // were possible in C++11 and C++14 but are ill-formed in C++17.\n      // If an exception is thrown this constructor has no effect.\n      template&lt;typename _Yp, typename _Del,\n\t\t_Constructible&lt;unique_ptr&lt;_Yp, _Del&gt;, __sp_array_delete&gt;* = 0&gt;\n\tshared_ptr(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r), __sp_array_delete()) { }\n#endif\n\n      /**\n       *  @brief  Construct an empty %shared_ptr.\n       *  @post   use_count() == 0 &amp;&amp; get() == nullptr\n       */\n      constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }\n\n      shared_ptr&amp; operator=(const shared_ptr&amp;) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;\n\toperator=(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(__r);\n\t  return *this;\n\t}\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;auto_ptr&lt;_Yp&gt;&gt;\n\toperator=(auto_ptr&lt;_Yp&gt;&amp;&amp; __r)\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n#pragma GCC diagnostic pop\n#endif\n\n      shared_ptr&amp;\n      operator=(shared_ptr&amp;&amp; __r) noexcept\n      {\n\tthis-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\treturn *this;\n      }\n\n      template&lt;class _Yp&gt;\n\t_Assignable&lt;shared_ptr&lt;_Yp&gt;&gt;\n\toperator=(shared_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp, typename _Del&gt;\n\t_Assignable&lt;unique_ptr&lt;_Yp, _Del&gt;&gt;\n\toperator=(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n\n    private:\n      // This constructor is non-standard, it is used by allocate_shared.\n      template&lt;typename _Alloc, typename... _Args&gt;\n\tshared_ptr(_Sp_alloc_shared_tag&lt;_Alloc&gt; __tag, _Args&amp;&amp;... __args)\n\t: __shared_ptr&lt;_Tp&gt;(__tag, std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n      template&lt;typename _Yp, typename _Alloc, typename... _Args&gt;\n\tfriend shared_ptr&lt;_Yp&gt;\n\tallocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args);\n\n      // This constructor is non-standard, it is used by weak_ptr::lock().\n      shared_ptr(const weak_ptr&lt;_Tp&gt;&amp; __r, std::nothrow_t) noexcept\n      : __shared_ptr&lt;_Tp&gt;(__r, std::nothrow) { }\n\n      friend class weak_ptr&lt;_Tp&gt;;\n    };\n\n#if __cpp_deduction_guides &gt;= 201606\n  template&lt;typename _Tp&gt;\n    shared_ptr(weak_ptr&lt;_Tp&gt;) -&gt;  shared_ptr&lt;_Tp&gt;;\n  template&lt;typename _Tp, typename _Del&gt;\n    shared_ptr(unique_ptr&lt;_Tp, _Del&gt;) -&gt;  shared_ptr&lt;_Tp&gt;;\n#endif\n\n  // 20.7.2.2.7 shared_ptr comparisons\n\n  /// @relates shared_ptr @{\n\n  /// Equality operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator==(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return __a.get() == __b.get(); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator==(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return !__a; }\n\n#ifdef __cpp_lib_three_way_comparison\n  template&lt;typename _Tp, typename _Up&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a,\n\t\tconst shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return compare_three_way()(__a.get(), __b.get()); }\n\n  template&lt;typename _Tp&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using pointer = typename shared_ptr&lt;_Tp&gt;::element_type*;\n      return compare_three_way()(__a.get(), static_cast&lt;pointer&gt;(nullptr));\n    }\n#else\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator==(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return !__a; }\n\n  /// Inequality operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator!=(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return __a.get() != __b.get(); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator!=(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return (bool)__a; }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator!=(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return (bool)__a; }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    {\n      using _Tp_elt = typename shared_ptr&lt;_Tp&gt;::element_type;\n      using _Up_elt = typename shared_ptr&lt;_Up&gt;::element_type;\n      using _Vp = typename common_type&lt;_Tp_elt*, _Up_elt*&gt;::type;\n      return less&lt;_Vp&gt;()(__a.get(), __b.get());\n    }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using _Tp_elt = typename shared_ptr&lt;_Tp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(__a.get(), nullptr);\n    }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    {\n      using _Tp_elt = typename shared_ptr&lt;_Tp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(nullptr, __a.get());\n    }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return !(__b &lt; __a); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(nullptr &lt; __a); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;=(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return !(__a &lt; nullptr); }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return (__b &lt; __a); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return nullptr &lt; __a; }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return __a &lt; nullptr; }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return !(__a &lt; __b); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(__a &lt; nullptr); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;=(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return !(nullptr &lt; __a); }\n#endif\n\n  // 20.7.2.2.8 shared_ptr specialized algorithms.\n\n  /// Swap overload for shared_ptr\n  template&lt;typename _Tp&gt;\n    inline void\n    swap(shared_ptr&lt;_Tp&gt;&amp; __a, shared_ptr&lt;_Tp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n  // 20.7.2.2.9 shared_ptr casts.\n\n  /// Convert type of `shared_ptr`, via `static_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    static_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(__r, static_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr`, via `const_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    const_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(__r, const_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr`, via `dynamic_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    dynamic_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      if (auto* __p = dynamic_cast&lt;typename _Sp::element_type*&gt;(__r.get()))\n\treturn _Sp(__r, __p);\n      return _Sp();\n    }\n\n#if __cplusplus &gt;= 201703L\n  /// Convert type of `shared_ptr`, via `reinterpret_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    reinterpret_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(__r, reinterpret_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n#if __cplusplus &gt; 201703L\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 2996. Missing rvalue overloads for shared_ptr operations\n\n  /// Convert type of `shared_ptr` rvalue, via `static_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    static_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(std::move(__r),\n\t\t static_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr` rvalue, via `const_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    const_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(std::move(__r),\n\t\t const_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr` rvalue, via `dynamic_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    dynamic_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      if (auto* __p = dynamic_cast&lt;typename _Sp::element_type*&gt;(__r.get()))\n\treturn _Sp(std::move(__r), __p);\n      return _Sp();\n    }\n\n  /// Convert type of `shared_ptr` rvalue, via `reinterpret_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    reinterpret_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(std::move(__r),\n\t\t reinterpret_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n#endif // C++20\n#endif // C++17\n\n  /// @}\n\n  /**\n   * @brief  A non-owning observer for a pointer owned by a shared_ptr\n   *\n   * A weak_ptr provides a safe alternative to a raw pointer when you want\n   * a non-owning reference to an object that is managed by a shared_ptr.\n   *\n   * Unlike a raw pointer, a weak_ptr can be converted to a new shared_ptr\n   * that shares ownership with every other shared_ptr that already owns\n   * the pointer. In other words you can upgrade from a non-owning &quot;weak&quot;\n   * reference to an owning shared_ptr, without having access to any of\n   * the existing shared_ptr objects.\n   *\n   * Also unlike a raw pointer, a weak_ptr does not become &quot;dangling&quot; after\n   * the object it points to has been destroyed. Instead, a weak_ptr\n   * becomes _expired_ and can no longer be converted to a shared_ptr that\n   * owns the freed pointer, so you cannot accidentally access the pointed-to\n   * object after it has been destroyed.\n   */\n  template&lt;typename _Tp&gt;\n    class weak_ptr : public __weak_ptr&lt;_Tp&gt;\n    {\n      template&lt;typename _Arg&gt;\n\tusing _Constructible = typename enable_if&lt;\n\t  is_constructible&lt;__weak_ptr&lt;_Tp&gt;, _Arg&gt;::value\n\t&gt;::type;\n\n      template&lt;typename _Arg&gt;\n\tusing _Assignable = typename enable_if&lt;\n\t  is_assignable&lt;__weak_ptr&lt;_Tp&gt;&amp;, _Arg&gt;::value, weak_ptr&amp;\n\t&gt;::type;\n\n    public:\n      constexpr weak_ptr() noexcept = default;\n\n      template&lt;typename _Yp,\n\t       typename = _Constructible&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\tweak_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t: __weak_ptr&lt;_Tp&gt;(__r) { }\n\n      weak_ptr(const weak_ptr&amp;) noexcept = default;\n\n      template&lt;typename _Yp, typename = _Constructible&lt;const weak_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\tweak_ptr(const weak_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t: __weak_ptr&lt;_Tp&gt;(__r) { }\n\n      weak_ptr(weak_ptr&amp;&amp;) noexcept = default;\n\n      template&lt;typename _Yp, typename = _Constructible&lt;weak_ptr&lt;_Yp&gt;&gt;&gt;\n\tweak_ptr(weak_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t: __weak_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n      weak_ptr&amp;\n      operator=(const weak_ptr&amp; __r) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;const weak_ptr&lt;_Yp&gt;&amp;&gt;\n\toperator=(const weak_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t{\n\t  this-&gt;__weak_ptr&lt;_Tp&gt;::operator=(__r);\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;\n\toperator=(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t{\n\t  this-&gt;__weak_ptr&lt;_Tp&gt;::operator=(__r);\n\t  return *this;\n\t}\n\n      weak_ptr&amp;\n      operator=(weak_ptr&amp;&amp; __r) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;weak_ptr&lt;_Yp&gt;&gt;\n\toperator=(weak_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  this-&gt;__weak_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n\n      shared_ptr&lt;_Tp&gt;\n      lock() const noexcept\n      { return shared_ptr&lt;_Tp&gt;(*this, std::nothrow); }\n    };\n\n#if __cpp_deduction_guides &gt;= 201606\n  template&lt;typename _Tp&gt;\n    weak_ptr(shared_ptr&lt;_Tp&gt;) -&gt;  weak_ptr&lt;_Tp&gt;;\n#endif\n\n  // 20.7.2.3.6 weak_ptr specialized algorithms.\n  /// Swap overload for weak_ptr\n  /// @relates weak_ptr\n  template&lt;typename _Tp&gt;\n    inline void\n    swap(weak_ptr&lt;_Tp&gt;&amp; __a, weak_ptr&lt;_Tp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n\n  /// Primary template owner_less\n  template&lt;typename _Tp = void&gt;\n    struct owner_less;\n\n  /// Void specialization of owner_less compares either shared_ptr or weak_ptr\n  template&lt;&gt;\n    struct owner_less&lt;void&gt; : _Sp_owner_less&lt;void, void&gt;\n    { };\n\n  /// Partial specialization of owner_less for shared_ptr.\n  template&lt;typename _Tp&gt;\n    struct owner_less&lt;shared_ptr&lt;_Tp&gt;&gt;\n    : public _Sp_owner_less&lt;shared_ptr&lt;_Tp&gt;, weak_ptr&lt;_Tp&gt;&gt;\n    { };\n\n  /// Partial specialization of owner_less for weak_ptr.\n  template&lt;typename _Tp&gt;\n    struct owner_less&lt;weak_ptr&lt;_Tp&gt;&gt;\n    : public _Sp_owner_less&lt;weak_ptr&lt;_Tp&gt;, shared_ptr&lt;_Tp&gt;&gt;\n    { };\n\n  /**\n   *  @brief Base class allowing use of member function shared_from_this.\n   */\n  template&lt;typename _Tp&gt;\n    class enable_shared_from_this\n    {\n    protected:\n      constexpr enable_shared_from_this() noexcept { }\n\n      enable_shared_from_this(const enable_shared_from_this&amp;) noexcept { }\n\n      enable_shared_from_this&amp;\n      operator=(const enable_shared_from_this&amp;) noexcept\n      { return *this; }\n\n      ~enable_shared_from_this() { }\n\n    public:\n      shared_ptr&lt;_Tp&gt;\n      shared_from_this()\n      { return shared_ptr&lt;_Tp&gt;(this-&gt;_M_weak_this); }\n\n      shared_ptr&lt;const _Tp&gt;\n      shared_from_this() const\n      { return shared_ptr&lt;const _Tp&gt;(this-&gt;_M_weak_this); }\n\n#if __cplusplus &gt; 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n#define __cpp_lib_enable_shared_from_this 201603\n      weak_ptr&lt;_Tp&gt;\n      weak_from_this() noexcept\n      { return this-&gt;_M_weak_this; }\n\n      weak_ptr&lt;const _Tp&gt;\n      weak_from_this() const noexcept\n      { return this-&gt;_M_weak_this; }\n#endif\n\n    private:\n      template&lt;typename _Tp1&gt;\n\tvoid\n\t_M_weak_assign(_Tp1* __p, const __shared_count&lt;&gt;&amp; __n) const noexcept\n\t{ _M_weak_this._M_assign(__p, __n); }\n\n      // Found by ADL when this is an associated class.\n      friend const enable_shared_from_this*\n      __enable_shared_from_this_base(const __shared_count&lt;&gt;&amp;,\n\t\t\t\t     const enable_shared_from_this* __p)\n      { return __p; }\n\n      template&lt;typename, _Lock_policy&gt;\n\tfriend class __shared_ptr;\n\n      mutable weak_ptr&lt;_Tp&gt;  _M_weak_this;\n    };\n\n  /// @relates shared_ptr @{\n\n  /**\n   *  @brief  Create an object that is owned by a shared_ptr.\n   *  @param  __a     An allocator.\n   *  @param  __args  Arguments for the @a _Tp object&#x27;s constructor.\n   *  @return A shared_ptr that owns the newly created object.\n   *  @throw  An exception thrown from @a _Alloc::allocate or from the\n   *          constructor of @a _Tp.\n   *\n   *  A copy of @a __a will be used to allocate memory for the shared_ptr\n   *  and the new object.\n   */\n  template&lt;typename _Tp, typename _Alloc, typename... _Args&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args)\n    {\n      static_assert(!is_array&lt;_Tp&gt;::value, &quot;make_shared&lt;T[]&gt; not supported&quot;);\n\n      return shared_ptr&lt;_Tp&gt;(_Sp_alloc_shared_tag&lt;_Alloc&gt;{__a},\n\t\t\t     std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  /**\n   *  @brief  Create an object that is owned by a shared_ptr.\n   *  @param  __args  Arguments for the @a _Tp object&#x27;s constructor.\n   *  @return A shared_ptr that owns the newly created object.\n   *  @throw  std::bad_alloc, or an exception thrown from the\n   *          constructor of @a _Tp.\n   */\n  template&lt;typename _Tp, typename... _Args&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    make_shared(_Args&amp;&amp;... __args)\n    {\n      typedef typename std::remove_cv&lt;_Tp&gt;::type _Tp_nc;\n      return std::allocate_shared&lt;_Tp&gt;(std::allocator&lt;_Tp_nc&gt;(),\n\t\t\t\t       std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  /// std::hash specialization for shared_ptr.\n  template&lt;typename _Tp&gt;\n    struct hash&lt;shared_ptr&lt;_Tp&gt;&gt;\n    : public __hash_base&lt;size_t, shared_ptr&lt;_Tp&gt;&gt;\n    {\n      size_t\n      operator()(const shared_ptr&lt;_Tp&gt;&amp; __s) const noexcept\n      {\n\treturn std::hash&lt;typename shared_ptr&lt;_Tp&gt;::element_type*&gt;()(__s.get());\n      }\n    };\n\n  /// @} relates shared_ptr\n  /// @} group pointer_abstractions\n\n#if __cplusplus &gt;= 201703L\n  namespace __detail::__variant\n  {\n    template&lt;typename&gt; struct _Never_valueless_alt; // see &lt;variant&gt;\n\n    // Provide the strong exception-safety guarantee when emplacing a\n    // shared_ptr into a variant.\n    template&lt;typename _Tp&gt;\n      struct _Never_valueless_alt&lt;std::shared_ptr&lt;_Tp&gt;&gt;\n      : std::true_type\n      { };\n\n    // Provide the strong exception-safety guarantee when emplacing a\n    // weak_ptr into a variant.\n    template&lt;typename _Tp&gt;\n      struct _Never_valueless_alt&lt;std::weak_ptr&lt;_Tp&gt;&gt;\n      : std::true_type\n      { };\n  }  // namespace __detail::__variant\n#endif // C++17\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif // _SHARED_PTR_H\n"}, "/usr/include/c++/11/bits/shared_ptr_base.h": {"id": "/usr/include/c++/11/bits/shared_ptr_base.h", "filePath": "/usr/include/c++/11/bits/shared_ptr_base.h", "content": "// shared_ptr and weak_ptr implementation details -*- C++ -*-\n\n// Copyright (C) 2007-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n// GCC Note: Based on files from version 1.32.0 of the Boost library.\n\n//  shared_count.hpp\n//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n\n//  shared_ptr.hpp\n//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  weak_ptr.hpp\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  enable_shared_from_this.hpp\n//  Copyright (C) 2002 Peter Dimov\n\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n\n/** @file bits/shared_ptr_base.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _SHARED_PTR_BASE_H\n#define _SHARED_PTR_BASE_H 1\n\n#include &lt;typeinfo&gt;\n#include &lt;bits/allocated_ptr.h&gt;\n#include &lt;bits/allocator.h&gt;\n#include &lt;bits/exception_defines.h&gt;\n#include &lt;bits/functional_hash.h&gt;\n#include &lt;bits/refwrap.h&gt;\n#include &lt;bits/stl_function.h&gt;  // std::less\n#include &lt;bits/unique_ptr.h&gt;\n#include &lt;ext/aligned_buffer.h&gt;\n#include &lt;ext/atomicity.h&gt;\n#include &lt;ext/concurrence.h&gt;\n#if __cplusplus &gt; 201703L\n# include &lt;compare&gt;\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n  template&lt;typename&gt; class auto_ptr;\n#pragma GCC diagnostic pop\n#endif\n\n /**\n   *  @brief  Exception possibly thrown by @c shared_ptr.\n   *  @ingroup exceptions\n   */\n  class bad_weak_ptr : public std::exception\n  {\n  public:\n    virtual char const* what() const noexcept;\n\n    virtual ~bad_weak_ptr() noexcept;\n  };\n\n  // Substitute for bad_weak_ptr object in the case of -fno-exceptions.\n  inline void\n  __throw_bad_weak_ptr()\n  { _GLIBCXX_THROW_OR_ABORT(bad_weak_ptr()); }\n\n  using __gnu_cxx::_Lock_policy;\n  using __gnu_cxx::__default_lock_policy;\n  using __gnu_cxx::_S_single;\n  using __gnu_cxx::_S_mutex;\n  using __gnu_cxx::_S_atomic;\n\n  // Empty helper class except when the template argument is _S_mutex.\n  template&lt;_Lock_policy _Lp&gt;\n    class _Mutex_base\n    {\n    protected:\n      // The atomic policy uses fully-fenced builtins, single doesn&#x27;t care.\n      enum { _S_need_barriers = 0 };\n    };\n\n  template&lt;&gt;\n    class _Mutex_base&lt;_S_mutex&gt;\n    : public __gnu_cxx::__mutex\n    {\n    protected:\n      // This policy is used when atomic builtins are not available.\n      // The replacement atomic operations might not have the necessary\n      // memory barriers.\n      enum { _S_need_barriers = 1 };\n    };\n\n  template&lt;_Lock_policy _Lp = __default_lock_policy&gt;\n    class _Sp_counted_base\n    : public _Mutex_base&lt;_Lp&gt;\n    {\n    public:\n      _Sp_counted_base() noexcept\n      : _M_use_count(1), _M_weak_count(1) { }\n\n      virtual\n      ~_Sp_counted_base() noexcept\n      { }\n\n      // Called when _M_use_count drops to zero, to release the resources\n      // managed by *this.\n      virtual void\n      _M_dispose() noexcept = 0;\n\n      // Called when _M_weak_count drops to zero.\n      virtual void\n      _M_destroy() noexcept\n      { delete this; }\n\n      virtual void*\n      _M_get_deleter(const std::type_info&amp;) noexcept = 0;\n\n      void\n      _M_add_ref_copy()\n      { __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, 1); }\n\n      void\n      _M_add_ref_lock()\n      {\n\tif (!_M_add_ref_lock_nothrow())\n\t  __throw_bad_weak_ptr();\n      }\n\n      bool\n      _M_add_ref_lock_nothrow() noexcept;\n\n      void\n      _M_release() noexcept\n      {\n        // Be race-detector-friendly.  For more info see bits/c++config.\n        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);\n\tif (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, -1) == 1)\n\t  {\n            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);\n\t    _M_dispose();\n\t    // There must be a memory barrier between dispose() and destroy()\n\t    // to ensure that the effects of dispose() are observed in the\n\t    // thread that runs destroy().\n\t    // See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html\n\t    if (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)\n\t      {\n\t\t__atomic_thread_fence (__ATOMIC_ACQ_REL);\n\t      }\n\n            // Be race-detector-friendly.  For more info see bits/c++config.\n            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);\n\t    if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count,\n\t\t\t\t\t\t       -1) == 1)\n              {\n                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);\n\t        _M_destroy();\n              }\n\t  }\n      }\n\n      void\n      _M_weak_add_ref() noexcept\n      { __gnu_cxx::__atomic_add_dispatch(&amp;_M_weak_count, 1); }\n\n      void\n      _M_weak_release() noexcept\n      {\n        // Be race-detector-friendly. For more info see bits/c++config.\n        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);\n\tif (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, -1) == 1)\n\t  {\n            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);\n\t    if (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)\n\t      {\n\t        // See _M_release(),\n\t        // destroy() must observe results of dispose()\n\t\t__atomic_thread_fence (__ATOMIC_ACQ_REL);\n\t      }\n\t    _M_destroy();\n\t  }\n      }\n\n      long\n      _M_get_use_count() const noexcept\n      {\n        // No memory barrier is used here so there is no synchronization\n        // with other threads.\n        return __atomic_load_n(&amp;_M_use_count, __ATOMIC_RELAXED);\n      }\n\n    private:\n      _Sp_counted_base(_Sp_counted_base const&amp;) = delete;\n      _Sp_counted_base&amp; operator=(_Sp_counted_base const&amp;) = delete;\n\n      _Atomic_word  _M_use_count;     // #shared\n      _Atomic_word  _M_weak_count;    // #weak + (#shared != 0)\n    };\n\n  template&lt;&gt;\n    inline bool\n    _Sp_counted_base&lt;_S_single&gt;::\n    _M_add_ref_lock_nothrow() noexcept\n    {\n      if (_M_use_count == 0)\n\treturn false;\n      ++_M_use_count;\n      return true;\n    }\n\n  template&lt;&gt;\n    inline bool\n    _Sp_counted_base&lt;_S_mutex&gt;::\n    _M_add_ref_lock_nothrow() noexcept\n    {\n      __gnu_cxx::__scoped_lock sentry(*this);\n      if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, 1) == 0)\n\t{\n\t  _M_use_count = 0;\n\t  return false;\n\t}\n      return true;\n    }\n\n  template&lt;&gt;\n    inline bool\n    _Sp_counted_base&lt;_S_atomic&gt;::\n    _M_add_ref_lock_nothrow() noexcept\n    {\n      // Perform lock-free add-if-not-zero operation.\n      _Atomic_word __count = _M_get_use_count();\n      do\n\t{\n\t  if (__count == 0)\n\t    return false;\n\t  // Replace the current counter value with the old value + 1, as\n\t  // long as it&#x27;s not changed meanwhile.\n\t}\n      while (!__atomic_compare_exchange_n(&amp;_M_use_count, &amp;__count, __count + 1,\n\t\t\t\t\t  true, __ATOMIC_ACQ_REL,\n\t\t\t\t\t  __ATOMIC_RELAXED));\n      return true;\n    }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_add_ref_copy()\n    { ++_M_use_count; }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_release() noexcept\n    {\n      if (--_M_use_count == 0)\n        {\n          _M_dispose();\n          if (--_M_weak_count == 0)\n            _M_destroy();\n        }\n    }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_weak_add_ref() noexcept\n    { ++_M_weak_count; }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_weak_release() noexcept\n    {\n      if (--_M_weak_count == 0)\n        _M_destroy();\n    }\n\n  template&lt;&gt;\n    inline long\n    _Sp_counted_base&lt;_S_single&gt;::_M_get_use_count() const noexcept\n    { return _M_use_count; }\n\n\n  // Forward declarations.\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy&gt;\n    class __shared_ptr;\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy&gt;\n    class __weak_ptr;\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy&gt;\n    class __enable_shared_from_this;\n\n  template&lt;typename _Tp&gt;\n    class shared_ptr;\n\n  template&lt;typename _Tp&gt;\n    class weak_ptr;\n\n  template&lt;typename _Tp&gt;\n    struct owner_less;\n\n  template&lt;typename _Tp&gt;\n    class enable_shared_from_this;\n\n  template&lt;_Lock_policy _Lp = __default_lock_policy&gt;\n    class __weak_count;\n\n  template&lt;_Lock_policy _Lp = __default_lock_policy&gt;\n    class __shared_count;\n\n\n  // Counted ptr with no deleter or allocator support\n  template&lt;typename _Ptr, _Lock_policy _Lp&gt;\n    class _Sp_counted_ptr final : public _Sp_counted_base&lt;_Lp&gt;\n    {\n    public:\n      explicit\n      _Sp_counted_ptr(_Ptr __p) noexcept\n      : _M_ptr(__p) { }\n\n      virtual void\n      _M_dispose() noexcept\n      { delete _M_ptr; }\n\n      virtual void\n      _M_destroy() noexcept\n      { delete this; }\n\n      virtual void*\n      _M_get_deleter(const std::type_info&amp;) noexcept\n      { return nullptr; }\n\n      _Sp_counted_ptr(const _Sp_counted_ptr&amp;) = delete;\n      _Sp_counted_ptr&amp; operator=(const _Sp_counted_ptr&amp;) = delete;\n\n    private:\n      _Ptr             _M_ptr;\n    };\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_ptr&lt;nullptr_t, _S_single&gt;::_M_dispose() noexcept { }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_ptr&lt;nullptr_t, _S_mutex&gt;::_M_dispose() noexcept { }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_ptr&lt;nullptr_t, _S_atomic&gt;::_M_dispose() noexcept { }\n\n  template&lt;int _Nm, typename _Tp,\n\t   bool __use_ebo = !__is_final(_Tp) &amp;&amp; __is_empty(_Tp)&gt;\n    struct _Sp_ebo_helper;\n\n  /// Specialization using EBO.\n  template&lt;int _Nm, typename _Tp&gt;\n    struct _Sp_ebo_helper&lt;_Nm, _Tp, true&gt; : private _Tp\n    {\n      explicit _Sp_ebo_helper(const _Tp&amp; __tp) : _Tp(__tp) { }\n      explicit _Sp_ebo_helper(_Tp&amp;&amp; __tp) : _Tp(std::move(__tp)) { }\n\n      static _Tp&amp;\n      _S_get(_Sp_ebo_helper&amp; __eboh) { return static_cast&lt;_Tp&amp;&gt;(__eboh); }\n    };\n\n  /// Specialization not using EBO.\n  template&lt;int _Nm, typename _Tp&gt;\n    struct _Sp_ebo_helper&lt;_Nm, _Tp, false&gt;\n    {\n      explicit _Sp_ebo_helper(const _Tp&amp; __tp) : _M_tp(__tp) { }\n      explicit _Sp_ebo_helper(_Tp&amp;&amp; __tp) : _M_tp(std::move(__tp)) { }\n\n      static _Tp&amp;\n      _S_get(_Sp_ebo_helper&amp; __eboh)\n      { return __eboh._M_tp; }\n\n    private:\n      _Tp _M_tp;\n    };\n\n  // Support for custom deleter and/or allocator\n  template&lt;typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp&gt;\n    class _Sp_counted_deleter final : public _Sp_counted_base&lt;_Lp&gt;\n    {\n      class _Impl : _Sp_ebo_helper&lt;0, _Deleter&gt;, _Sp_ebo_helper&lt;1, _Alloc&gt;\n      {\n\ttypedef _Sp_ebo_helper&lt;0, _Deleter&gt;\t_Del_base;\n\ttypedef _Sp_ebo_helper&lt;1, _Alloc&gt;\t_Alloc_base;\n\n      public:\n\t_Impl(_Ptr __p, _Deleter __d, const _Alloc&amp; __a) noexcept\n\t: _Del_base(std::move(__d)), _Alloc_base(__a), _M_ptr(__p)\n\t{ }\n\n\t_Deleter&amp; _M_del() noexcept { return _Del_base::_S_get(*this); }\n\t_Alloc&amp; _M_alloc() noexcept { return _Alloc_base::_S_get(*this); }\n\n\t_Ptr _M_ptr;\n      };\n\n    public:\n      using __allocator_type = __alloc_rebind&lt;_Alloc, _Sp_counted_deleter&gt;;\n\n      // __d(__p) must not throw.\n      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept\n      : _M_impl(__p, std::move(__d), _Alloc()) { }\n\n      // __d(__p) must not throw.\n      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc&amp; __a) noexcept\n      : _M_impl(__p, std::move(__d), __a) { }\n\n      ~_Sp_counted_deleter() noexcept { }\n\n      virtual void\n      _M_dispose() noexcept\n      { _M_impl._M_del()(_M_impl._M_ptr); }\n\n      virtual void\n      _M_destroy() noexcept\n      {\n\t__allocator_type __a(_M_impl._M_alloc());\n\t__allocated_ptr&lt;__allocator_type&gt; __guard_ptr{ __a, this };\n\tthis-&gt;~_Sp_counted_deleter();\n      }\n\n      virtual void*\n      _M_get_deleter(const type_info&amp; __ti [[__gnu__::__unused__]]) noexcept\n      {\n#if __cpp_rtti\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// 2400. shared_ptr&#x27;s get_deleter() should use addressof()\n        return __ti == typeid(_Deleter)\n\t  ? std::__addressof(_M_impl._M_del())\n\t  : nullptr;\n#else\n        return nullptr;\n#endif\n      }\n\n    private:\n      _Impl _M_impl;\n    };\n\n  // helpers for make_shared / allocate_shared\n\n  struct _Sp_make_shared_tag\n  {\n  private:\n    template&lt;typename _Tp, typename _Alloc, _Lock_policy _Lp&gt;\n      friend class _Sp_counted_ptr_inplace;\n\n    static const type_info&amp;\n    _S_ti() noexcept _GLIBCXX_VISIBILITY(default)\n    {\n      alignas(type_info) static constexpr char __tag[sizeof(type_info)] = { };\n      return reinterpret_cast&lt;const type_info&amp;&gt;(__tag);\n    }\n\n    static bool _S_eq(const type_info&amp;) noexcept;\n  };\n\n  template&lt;typename _Alloc&gt;\n    struct _Sp_alloc_shared_tag\n    {\n      const _Alloc&amp; _M_a;\n    };\n\n  template&lt;typename _Tp, typename _Alloc, _Lock_policy _Lp&gt;\n    class _Sp_counted_ptr_inplace final : public _Sp_counted_base&lt;_Lp&gt;\n    {\n      class _Impl : _Sp_ebo_helper&lt;0, _Alloc&gt;\n      {\n\ttypedef _Sp_ebo_helper&lt;0, _Alloc&gt;\t_A_base;\n\n      public:\n\texplicit _Impl(_Alloc __a) noexcept : _A_base(__a) { }\n\n\t_Alloc&amp; _M_alloc() noexcept { return _A_base::_S_get(*this); }\n\n\t__gnu_cxx::__aligned_buffer&lt;_Tp&gt; _M_storage;\n      };\n\n    public:\n      using __allocator_type = __alloc_rebind&lt;_Alloc, _Sp_counted_ptr_inplace&gt;;\n\n      // Alloc parameter is not a reference so doesn&#x27;t alias anything in __args\n      template&lt;typename... _Args&gt;\n\t_Sp_counted_ptr_inplace(_Alloc __a, _Args&amp;&amp;... __args)\n\t: _M_impl(__a)\n\t{\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 2070.  allocate_shared should use allocator_traits&lt;A&gt;::construct\n\t  allocator_traits&lt;_Alloc&gt;::construct(__a, _M_ptr(),\n\t      std::forward&lt;_Args&gt;(__args)...); // might throw\n\t}\n\n      ~_Sp_counted_ptr_inplace() noexcept { }\n\n      virtual void\n      _M_dispose() noexcept\n      {\n\tallocator_traits&lt;_Alloc&gt;::destroy(_M_impl._M_alloc(), _M_ptr());\n      }\n\n      // Override because the allocator needs to know the dynamic type\n      virtual void\n      _M_destroy() noexcept\n      {\n\t__allocator_type __a(_M_impl._M_alloc());\n\t__allocated_ptr&lt;__allocator_type&gt; __guard_ptr{ __a, this };\n\tthis-&gt;~_Sp_counted_ptr_inplace();\n      }\n\n    private:\n      friend class __shared_count&lt;_Lp&gt;; // To be able to call _M_ptr().\n\n      // No longer used, but code compiled against old libstdc++ headers\n      // might still call it from __shared_ptr ctor to get the pointer out.\n      virtual void*\n      _M_get_deleter(const std::type_info&amp; __ti) noexcept override\n      {\n\tauto __ptr = const_cast&lt;typename remove_cv&lt;_Tp&gt;::type*&gt;(_M_ptr());\n\t// Check for the fake type_info first, so we don&#x27;t try to access it\n\t// as a real type_info object. Otherwise, check if it&#x27;s the real\n\t// type_info for this class. With RTTI enabled we can check directly,\n\t// or call a library function to do it.\n\tif (&amp;__ti == &amp;_Sp_make_shared_tag::_S_ti()\n\t    ||\n#if __cpp_rtti\n\t    __ti == typeid(_Sp_make_shared_tag)\n#else\n\t    _Sp_make_shared_tag::_S_eq(__ti)\n#endif\n\t   )\n\t  return __ptr;\n\treturn nullptr;\n      }\n\n      _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }\n\n      _Impl _M_impl;\n    };\n\n  // The default deleter for shared_ptr&lt;T[]&gt; and shared_ptr&lt;T[N]&gt;.\n  struct __sp_array_delete\n  {\n    template&lt;typename _Yp&gt;\n      void operator()(_Yp* __p) const { delete[] __p; }\n  };\n\n  template&lt;_Lock_policy _Lp&gt;\n    class __shared_count\n    {\n      template&lt;typename _Tp&gt;\n\tstruct __not_alloc_shared_tag { using type = void; };\n\n      template&lt;typename _Tp&gt;\n\tstruct __not_alloc_shared_tag&lt;_Sp_alloc_shared_tag&lt;_Tp&gt;&gt; { };\n\n    public:\n      constexpr __shared_count() noexcept : _M_pi(0)\n      { }\n\n      template&lt;typename _Ptr&gt;\n        explicit\n\t__shared_count(_Ptr __p) : _M_pi(0)\n\t{\n\t  __try\n\t    {\n\t      _M_pi = new _Sp_counted_ptr&lt;_Ptr, _Lp&gt;(__p);\n\t    }\n\t  __catch(...)\n\t    {\n\t      delete __p;\n\t      __throw_exception_again;\n\t    }\n\t}\n\n      template&lt;typename _Ptr&gt;\n\t__shared_count(_Ptr __p, /* is_array = */ false_type)\n\t: __shared_count(__p)\n\t{ }\n\n      template&lt;typename _Ptr&gt;\n\t__shared_count(_Ptr __p, /* is_array = */ true_type)\n\t: __shared_count(__p, __sp_array_delete{}, allocator&lt;void&gt;())\n\t{ }\n\n      template&lt;typename _Ptr, typename _Deleter,\n\t       typename = typename __not_alloc_shared_tag&lt;_Deleter&gt;::type&gt;\n\t__shared_count(_Ptr __p, _Deleter __d)\n\t: __shared_count(__p, std::move(__d), allocator&lt;void&gt;())\n\t{ }\n\n      template&lt;typename _Ptr, typename _Deleter, typename _Alloc,\n\t       typename = typename __not_alloc_shared_tag&lt;_Deleter&gt;::type&gt;\n\t__shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)\n\t{\n\t  typedef _Sp_counted_deleter&lt;_Ptr, _Deleter, _Alloc, _Lp&gt; _Sp_cd_type;\n\t  __try\n\t    {\n\t      typename _Sp_cd_type::__allocator_type __a2(__a);\n\t      auto __guard = std::__allocate_guarded(__a2);\n\t      _Sp_cd_type* __mem = __guard.get();\n\t      ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));\n\t      _M_pi = __mem;\n\t      __guard = nullptr;\n\t    }\n\t  __catch(...)\n\t    {\n\t      __d(__p); // Call _Deleter on __p.\n\t      __throw_exception_again;\n\t    }\n\t}\n\n      template&lt;typename _Tp, typename _Alloc, typename... _Args&gt;\n\t__shared_count(_Tp*&amp; __p, _Sp_alloc_shared_tag&lt;_Alloc&gt; __a,\n\t\t       _Args&amp;&amp;... __args)\n\t{\n\t  typedef _Sp_counted_ptr_inplace&lt;_Tp, _Alloc, _Lp&gt; _Sp_cp_type;\n\t  typename _Sp_cp_type::__allocator_type __a2(__a._M_a);\n\t  auto __guard = std::__allocate_guarded(__a2);\n\t  _Sp_cp_type* __mem = __guard.get();\n\t  auto __pi = ::new (__mem)\n\t    _Sp_cp_type(__a._M_a, std::forward&lt;_Args&gt;(__args)...);\n\t  __guard = nullptr;\n\t  _M_pi = __pi;\n\t  __p = __pi-&gt;_M_ptr();\n\t}\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      // Special case for auto_ptr&lt;_Tp&gt; to provide the strong guarantee.\n      template&lt;typename _Tp&gt;\n        explicit\n\t__shared_count(std::auto_ptr&lt;_Tp&gt;&amp;&amp; __r);\n#pragma GCC diagnostic pop\n#endif\n\n      // Special case for unique_ptr&lt;_Tp,_Del&gt; to provide the strong guarantee.\n      template&lt;typename _Tp, typename _Del&gt;\n        explicit\n\t__shared_count(std::unique_ptr&lt;_Tp, _Del&gt;&amp;&amp; __r) : _M_pi(0)\n\t{\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 2415. Inconsistency between unique_ptr and shared_ptr\n\t  if (__r.get() == nullptr)\n\t    return;\n\n\t  using _Ptr = typename unique_ptr&lt;_Tp, _Del&gt;::pointer;\n\t  using _Del2 = typename conditional&lt;is_reference&lt;_Del&gt;::value,\n\t      reference_wrapper&lt;typename remove_reference&lt;_Del&gt;::type&gt;,\n\t      _Del&gt;::type;\n\t  using _Sp_cd_type\n\t    = _Sp_counted_deleter&lt;_Ptr, _Del2, allocator&lt;void&gt;, _Lp&gt;;\n\t  using _Alloc = allocator&lt;_Sp_cd_type&gt;;\n\t  using _Alloc_traits = allocator_traits&lt;_Alloc&gt;;\n\t  _Alloc __a;\n\t  _Sp_cd_type* __mem = _Alloc_traits::allocate(__a, 1);\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 3548. shared_ptr construction from unique_ptr should move\n\t  // (not copy) the deleter\n\t  _Alloc_traits::construct(__a, __mem, __r.release(),\n\t\t\t\t   std::forward&lt;_Del&gt;(__r.get_deleter()));\n\t  _M_pi = __mem;\n\t}\n\n      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.\n      explicit __shared_count(const __weak_count&lt;_Lp&gt;&amp; __r);\n\n      // Does not throw if __r._M_get_use_count() == 0, caller must check.\n      explicit\n      __shared_count(const __weak_count&lt;_Lp&gt;&amp; __r, std::nothrow_t) noexcept;\n\n      ~__shared_count() noexcept\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_release();\n      }\n\n      __shared_count(const __shared_count&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_add_ref_copy();\n      }\n\n      __shared_count&amp;\n      operator=(const __shared_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\tif (__tmp != _M_pi)\n\t  {\n\t    if (__tmp != nullptr)\n\t      __tmp-&gt;_M_add_ref_copy();\n\t    if (_M_pi != nullptr)\n\t      _M_pi-&gt;_M_release();\n\t    _M_pi = __tmp;\n\t  }\n\treturn *this;\n      }\n\n      void\n      _M_swap(__shared_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\t__r._M_pi = _M_pi;\n\t_M_pi = __tmp;\n      }\n\n      long\n      _M_get_use_count() const noexcept\n      { return _M_pi ? _M_pi-&gt;_M_get_use_count() : 0; }\n\n      bool\n      _M_unique() const noexcept\n      { return this-&gt;_M_get_use_count() == 1; }\n\n      void*\n      _M_get_deleter(const std::type_info&amp; __ti) const noexcept\n      { return _M_pi ? _M_pi-&gt;_M_get_deleter(__ti) : nullptr; }\n\n      bool\n      _M_less(const __shared_count&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      bool\n      _M_less(const __weak_count&lt;_Lp&gt;&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      // Friend function injected into enclosing namespace and found by ADL\n      friend inline bool\n      operator==(const __shared_count&amp; __a, const __shared_count&amp; __b) noexcept\n      { return __a._M_pi == __b._M_pi; }\n\n    private:\n      friend class __weak_count&lt;_Lp&gt;;\n\n      _Sp_counted_base&lt;_Lp&gt;*  _M_pi;\n    };\n\n\n  template&lt;_Lock_policy _Lp&gt;\n    class __weak_count\n    {\n    public:\n      constexpr __weak_count() noexcept : _M_pi(nullptr)\n      { }\n\n      __weak_count(const __shared_count&lt;_Lp&gt;&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_add_ref();\n      }\n\n      __weak_count(const __weak_count&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_add_ref();\n      }\n\n      __weak_count(__weak_count&amp;&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      { __r._M_pi = nullptr; }\n\n      ~__weak_count() noexcept\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n      }\n\n      __weak_count&amp;\n      operator=(const __shared_count&lt;_Lp&gt;&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\tif (__tmp != nullptr)\n\t  __tmp-&gt;_M_weak_add_ref();\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n\t_M_pi = __tmp;\n\treturn *this;\n      }\n\n      __weak_count&amp;\n      operator=(const __weak_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\tif (__tmp != nullptr)\n\t  __tmp-&gt;_M_weak_add_ref();\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n\t_M_pi = __tmp;\n\treturn *this;\n      }\n\n      __weak_count&amp;\n      operator=(__weak_count&amp;&amp; __r) noexcept\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n\t_M_pi = __r._M_pi;\n        __r._M_pi = nullptr;\n\treturn *this;\n      }\n\n      void\n      _M_swap(__weak_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\t__r._M_pi = _M_pi;\n\t_M_pi = __tmp;\n      }\n\n      long\n      _M_get_use_count() const noexcept\n      { return _M_pi != nullptr ? _M_pi-&gt;_M_get_use_count() : 0; }\n\n      bool\n      _M_less(const __weak_count&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      bool\n      _M_less(const __shared_count&lt;_Lp&gt;&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      // Friend function injected into enclosing namespace and found by ADL\n      friend inline bool\n      operator==(const __weak_count&amp; __a, const __weak_count&amp; __b) noexcept\n      { return __a._M_pi == __b._M_pi; }\n\n    private:\n      friend class __shared_count&lt;_Lp&gt;;\n\n      _Sp_counted_base&lt;_Lp&gt;*  _M_pi;\n    };\n\n  // Now that __weak_count is defined we can define this constructor:\n  template&lt;_Lock_policy _Lp&gt;\n    inline\n    __shared_count&lt;_Lp&gt;::__shared_count(const __weak_count&lt;_Lp&gt;&amp; __r)\n    : _M_pi(__r._M_pi)\n    {\n      if (_M_pi == nullptr || !_M_pi-&gt;_M_add_ref_lock_nothrow())\n\t__throw_bad_weak_ptr();\n    }\n\n  // Now that __weak_count is defined we can define this constructor:\n  template&lt;_Lock_policy _Lp&gt;\n    inline\n    __shared_count&lt;_Lp&gt;::\n    __shared_count(const __weak_count&lt;_Lp&gt;&amp; __r, std::nothrow_t) noexcept\n    : _M_pi(__r._M_pi)\n    {\n      if (_M_pi &amp;&amp; !_M_pi-&gt;_M_add_ref_lock_nothrow())\n\t_M_pi = nullptr;\n    }\n\n#define __cpp_lib_shared_ptr_arrays 201611L\n\n  // Helper traits for shared_ptr of array:\n\n  // A pointer type Y* is said to be compatible with a pointer type T* when\n  // either Y* is convertible to T* or Y is U[N] and T is U cv [].\n  template&lt;typename _Yp_ptr, typename _Tp_ptr&gt;\n    struct __sp_compatible_with\n    : false_type\n    { };\n\n  template&lt;typename _Yp, typename _Tp&gt;\n    struct __sp_compatible_with&lt;_Yp*, _Tp*&gt;\n    : is_convertible&lt;_Yp*, _Tp*&gt;::type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], _Up(*)[]&gt;\n    : true_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], const _Up(*)[]&gt;\n    : true_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], volatile _Up(*)[]&gt;\n    : true_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], const volatile _Up(*)[]&gt;\n    : true_type\n    { };\n\n  // Test conversion from Y(*)[N] to U(*)[N] without forming invalid type Y[N].\n  template&lt;typename _Up, size_t _Nm, typename _Yp, typename = void&gt;\n    struct __sp_is_constructible_arrN\n    : false_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm, typename _Yp&gt;\n    struct __sp_is_constructible_arrN&lt;_Up, _Nm, _Yp, __void_t&lt;_Yp[_Nm]&gt;&gt;\n    : is_convertible&lt;_Yp(*)[_Nm], _Up(*)[_Nm]&gt;::type\n    { };\n\n  // Test conversion from Y(*)[] to U(*)[] without forming invalid type Y[].\n  template&lt;typename _Up, typename _Yp, typename = void&gt;\n    struct __sp_is_constructible_arr\n    : false_type\n    { };\n\n  template&lt;typename _Up, typename _Yp&gt;\n    struct __sp_is_constructible_arr&lt;_Up, _Yp, __void_t&lt;_Yp[]&gt;&gt;\n    : is_convertible&lt;_Yp(*)[], _Up(*)[]&gt;::type\n    { };\n\n  // Trait to check if shared_ptr&lt;T&gt; can be constructed from Y*.\n  template&lt;typename _Tp, typename _Yp&gt;\n    struct __sp_is_constructible;\n\n  // When T is U[N], Y(*)[N] shall be convertible to T*;\n  template&lt;typename _Up, size_t _Nm, typename _Yp&gt;\n    struct __sp_is_constructible&lt;_Up[_Nm], _Yp&gt;\n    : __sp_is_constructible_arrN&lt;_Up, _Nm, _Yp&gt;::type\n    { };\n\n  // when T is U[], Y(*)[] shall be convertible to T*;\n  template&lt;typename _Up, typename _Yp&gt;\n    struct __sp_is_constructible&lt;_Up[], _Yp&gt;\n    : __sp_is_constructible_arr&lt;_Up, _Yp&gt;::type\n    { };\n\n  // otherwise, Y* shall be convertible to T*.\n  template&lt;typename _Tp, typename _Yp&gt;\n    struct __sp_is_constructible\n    : is_convertible&lt;_Yp*, _Tp*&gt;::type\n    { };\n\n\n  // Define operator* and operator-&gt; for shared_ptr&lt;T&gt;.\n  template&lt;typename _Tp, _Lock_policy _Lp,\n\t   bool = is_array&lt;_Tp&gt;::value, bool = is_void&lt;_Tp&gt;::value&gt;\n    class __shared_ptr_access\n    {\n    public:\n      using element_type = _Tp;\n\n      element_type&amp;\n      operator*() const noexcept\n      {\n\t__glibcxx_assert(_M_get() != nullptr);\n\treturn *_M_get();\n      }\n\n      element_type*\n      operator-&gt;() const noexcept\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_get() != nullptr);\n\treturn _M_get();\n      }\n\n    private:\n      element_type*\n      _M_get() const noexcept\n      { return static_cast&lt;const __shared_ptr&lt;_Tp, _Lp&gt;*&gt;(this)-&gt;get(); }\n    };\n\n  // Define operator-&gt; for shared_ptr&lt;cv void&gt;.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __shared_ptr_access&lt;_Tp, _Lp, false, true&gt;\n    {\n    public:\n      using element_type = _Tp;\n\n      element_type*\n      operator-&gt;() const noexcept\n      {\n\tauto __ptr = static_cast&lt;const __shared_ptr&lt;_Tp, _Lp&gt;*&gt;(this)-&gt;get();\n\t_GLIBCXX_DEBUG_PEDASSERT(__ptr != nullptr);\n\treturn __ptr;\n      }\n    };\n\n  // Define operator[] for shared_ptr&lt;T[]&gt; and shared_ptr&lt;T[N]&gt;.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __shared_ptr_access&lt;_Tp, _Lp, true, false&gt;\n    {\n    public:\n      using element_type = typename remove_extent&lt;_Tp&gt;::type;\n\n#if __cplusplus &lt;= 201402L\n      [[__deprecated__(&quot;shared_ptr&lt;T[]&gt;::operator* is absent from C++17&quot;)]]\n      element_type&amp;\n      operator*() const noexcept\n      {\n\t__glibcxx_assert(_M_get() != nullptr);\n\treturn *_M_get();\n      }\n\n      [[__deprecated__(&quot;shared_ptr&lt;T[]&gt;::operator-&gt; is absent from C++17&quot;)]]\n      element_type*\n      operator-&gt;() const noexcept\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_get() != nullptr);\n\treturn _M_get();\n      }\n#endif\n\n      element_type&amp;\n      operator[](ptrdiff_t __i) const\n      {\n\t__glibcxx_assert(_M_get() != nullptr);\n\t__glibcxx_assert(!extent&lt;_Tp&gt;::value || __i &lt; extent&lt;_Tp&gt;::value);\n\treturn _M_get()[__i];\n      }\n\n    private:\n      element_type*\n      _M_get() const noexcept\n      { return static_cast&lt;const __shared_ptr&lt;_Tp, _Lp&gt;*&gt;(this)-&gt;get(); }\n    };\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __shared_ptr\n    : public __shared_ptr_access&lt;_Tp, _Lp&gt;\n    {\n    public:\n      using element_type = typename remove_extent&lt;_Tp&gt;::type;\n\n    private:\n      // Constraint for taking ownership of a pointer of type _Yp*:\n      template&lt;typename _Yp&gt;\n\tusing _SafeConv\n\t  = typename enable_if&lt;__sp_is_constructible&lt;_Tp, _Yp&gt;::value&gt;::type;\n\n      // Constraint for construction from shared_ptr and weak_ptr:\n      template&lt;typename _Yp, typename _Res = void&gt;\n\tusing _Compatible = typename\n\t  enable_if&lt;__sp_compatible_with&lt;_Yp*, _Tp*&gt;::value, _Res&gt;::type;\n\n      // Constraint for assignment from shared_ptr and weak_ptr:\n      template&lt;typename _Yp&gt;\n\tusing _Assignable = _Compatible&lt;_Yp, __shared_ptr&amp;&gt;;\n\n      // Constraint for construction from unique_ptr:\n      template&lt;typename _Yp, typename _Del, typename _Res = void,\n\t       typename _Ptr = typename unique_ptr&lt;_Yp, _Del&gt;::pointer&gt;\n\tusing _UniqCompatible = __enable_if_t&lt;__and_&lt;\n\t  __sp_compatible_with&lt;_Yp*, _Tp*&gt;,\n\t  is_convertible&lt;_Ptr, element_type*&gt;,\n\t  is_move_constructible&lt;_Del&gt;\n\t  &gt;::value, _Res&gt;;\n\n      // Constraint for assignment from unique_ptr:\n      template&lt;typename _Yp, typename _Del&gt;\n\tusing _UniqAssignable = _UniqCompatible&lt;_Yp, _Del, __shared_ptr&amp;&gt;;\n\n    public:\n\n#if __cplusplus &gt; 201402L\n      using weak_type = __weak_ptr&lt;_Tp, _Lp&gt;;\n#endif\n\n      constexpr __shared_ptr() noexcept\n      : _M_ptr(0), _M_refcount()\n      { }\n\n      template&lt;typename _Yp, typename = _SafeConv&lt;_Yp&gt;&gt;\n\texplicit\n\t__shared_ptr(_Yp* __p)\n\t: _M_ptr(__p), _M_refcount(__p, typename is_array&lt;_Tp&gt;::type())\n\t{\n\t  static_assert( !is_void&lt;_Yp&gt;::value, &quot;incomplete type&quot; );\n\t  static_assert( sizeof(_Yp) &gt; 0, &quot;incomplete type&quot; );\n\t  _M_enable_shared_from_this_with(__p);\n\t}\n\n      template&lt;typename _Yp, typename _Deleter, typename = _SafeConv&lt;_Yp&gt;&gt;\n\t__shared_ptr(_Yp* __p, _Deleter __d)\n\t: _M_ptr(__p), _M_refcount(__p, std::move(__d))\n\t{\n\t  static_assert(__is_invocable&lt;_Deleter&amp;, _Yp*&amp;&gt;::value,\n\t      &quot;deleter expression d(p) is well-formed&quot;);\n\t  _M_enable_shared_from_this_with(__p);\n\t}\n\n      template&lt;typename _Yp, typename _Deleter, typename _Alloc,\n\t       typename = _SafeConv&lt;_Yp&gt;&gt;\n\t__shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)\n\t: _M_ptr(__p), _M_refcount(__p, std::move(__d), std::move(__a))\n\t{\n\t  static_assert(__is_invocable&lt;_Deleter&amp;, _Yp*&amp;&gt;::value,\n\t      &quot;deleter expression d(p) is well-formed&quot;);\n\t  _M_enable_shared_from_this_with(__p);\n\t}\n\n      template&lt;typename _Deleter&gt;\n\t__shared_ptr(nullptr_t __p, _Deleter __d)\n\t: _M_ptr(0), _M_refcount(__p, std::move(__d))\n\t{ }\n\n      template&lt;typename _Deleter, typename _Alloc&gt;\n        __shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)\n\t: _M_ptr(0), _M_refcount(__p, std::move(__d), std::move(__a))\n\t{ }\n\n      // Aliasing constructor\n      template&lt;typename _Yp&gt;\n\t__shared_ptr(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r,\n\t\t     element_type* __p) noexcept\n\t: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws\n\t{ }\n\n      // Aliasing constructor\n      template&lt;typename _Yp&gt;\n\t__shared_ptr(__shared_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r,\n\t\t     element_type* __p) noexcept\n\t: _M_ptr(__p), _M_refcount()\n\t{\n\t  _M_refcount._M_swap(__r._M_refcount);\n\t  __r._M_ptr = nullptr;\n\t}\n\n      __shared_ptr(const __shared_ptr&amp;) noexcept = default;\n      __shared_ptr&amp; operator=(const __shared_ptr&amp;) noexcept = default;\n      ~__shared_ptr() = default;\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__shared_ptr(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)\n\t{ }\n\n      __shared_ptr(__shared_ptr&amp;&amp; __r) noexcept\n      : _M_ptr(__r._M_ptr), _M_refcount()\n      {\n\t_M_refcount._M_swap(__r._M_refcount);\n\t__r._M_ptr = nullptr;\n      }\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__shared_ptr(__shared_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t: _M_ptr(__r._M_ptr), _M_refcount()\n\t{\n\t  _M_refcount._M_swap(__r._M_refcount);\n\t  __r._M_ptr = nullptr;\n\t}\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\texplicit __shared_ptr(const __weak_ptr&lt;_Yp, _Lp&gt;&amp; __r)\n\t: _M_refcount(__r._M_refcount) // may throw\n\t{\n\t  // It is now safe to copy __r._M_ptr, as\n\t  // _M_refcount(__r._M_refcount) did not throw.\n\t  _M_ptr = __r._M_ptr;\n\t}\n\n      // If an exception is thrown this constructor has no effect.\n      template&lt;typename _Yp, typename _Del,\n\t       typename = _UniqCompatible&lt;_Yp, _Del&gt;&gt;\n\t__shared_ptr(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t: _M_ptr(__r.get()), _M_refcount()\n\t{\n\t  auto __raw = __to_address(__r.get());\n\t  _M_refcount = __shared_count&lt;_Lp&gt;(std::move(__r));\n\t  _M_enable_shared_from_this_with(__raw);\n\t}\n\n#if __cplusplus &lt;= 201402L &amp;&amp; _GLIBCXX_USE_DEPRECATED\n    protected:\n      // If an exception is thrown this constructor has no effect.\n      template&lt;typename _Tp1, typename _Del,\n\t       typename enable_if&lt;__and_&lt;\n\t\t __not_&lt;is_array&lt;_Tp&gt;&gt;, is_array&lt;_Tp1&gt;,\n\t         is_convertible&lt;typename unique_ptr&lt;_Tp1, _Del&gt;::pointer, _Tp*&gt;\n\t       &gt;::value, bool&gt;::type = true&gt;\n\t__shared_ptr(unique_ptr&lt;_Tp1, _Del&gt;&amp;&amp; __r, __sp_array_delete)\n\t: _M_ptr(__r.get()), _M_refcount()\n\t{\n\t  auto __raw = __to_address(__r.get());\n\t  _M_refcount = __shared_count&lt;_Lp&gt;(std::move(__r));\n\t  _M_enable_shared_from_this_with(__raw);\n\t}\n    public:\n#endif\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      // Postcondition: use_count() == 1 and __r.get() == 0\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__shared_ptr(auto_ptr&lt;_Yp&gt;&amp;&amp; __r);\n#pragma GCC diagnostic pop\n#endif\n\n      constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { }\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r._M_ptr;\n\t  _M_refcount = __r._M_refcount; // __shared_count::op= doesn&#x27;t throw\n\t  return *this;\n\t}\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(auto_ptr&lt;_Yp&gt;&amp;&amp; __r)\n\t{\n\t  __shared_ptr(std::move(__r)).swap(*this);\n\t  return *this;\n\t}\n#pragma GCC diagnostic pop\n#endif\n\n      __shared_ptr&amp;\n      operator=(__shared_ptr&amp;&amp; __r) noexcept\n      {\n\t__shared_ptr(std::move(__r)).swap(*this);\n\treturn *this;\n      }\n\n      template&lt;class _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(__shared_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  __shared_ptr(std::move(__r)).swap(*this);\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp, typename _Del&gt;\n\t_UniqAssignable&lt;_Yp, _Del&gt;\n\toperator=(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t{\n\t  __shared_ptr(std::move(__r)).swap(*this);\n\t  return *this;\n\t}\n\n      void\n      reset() noexcept\n      { __shared_ptr().swap(*this); }\n\n      template&lt;typename _Yp&gt;\n\t_SafeConv&lt;_Yp&gt;\n\treset(_Yp* __p) // _Yp must be complete.\n\t{\n\t  // Catch self-reset errors.\n\t  __glibcxx_assert(__p == nullptr || __p != _M_ptr);\n\t  __shared_ptr(__p).swap(*this);\n\t}\n\n      template&lt;typename _Yp, typename _Deleter&gt;\n\t_SafeConv&lt;_Yp&gt;\n\treset(_Yp* __p, _Deleter __d)\n\t{ __shared_ptr(__p, std::move(__d)).swap(*this); }\n\n      template&lt;typename _Yp, typename _Deleter, typename _Alloc&gt;\n\t_SafeConv&lt;_Yp&gt;\n\treset(_Yp* __p, _Deleter __d, _Alloc __a)\n        { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }\n\n      /// Return the stored pointer.\n      element_type*\n      get() const noexcept\n      { return _M_ptr; }\n\n      /// Return true if the stored pointer is not null.\n      explicit operator bool() const noexcept\n      { return _M_ptr != nullptr; }\n\n      /// Return true if use_count() == 1.\n      bool\n      unique() const noexcept\n      { return _M_refcount._M_unique(); }\n\n      /// If *this owns a pointer, return the number of owners, otherwise zero.\n      long\n      use_count() const noexcept\n      { return _M_refcount._M_get_use_count(); }\n\n      /// Exchange both the owned pointer and the stored pointer.\n      void\n      swap(__shared_ptr&lt;_Tp, _Lp&gt;&amp; __other) noexcept\n      {\n\tstd::swap(_M_ptr, __other._M_ptr);\n\t_M_refcount._M_swap(__other._M_refcount);\n      }\n\n      /** @brief Define an ordering based on ownership.\n       *\n       * This function defines a strict weak ordering between two shared_ptr\n       * or weak_ptr objects, such that one object is less than the other\n       * unless they share ownership of the same pointer, or are both empty.\n       * @{\n      */\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(__shared_ptr&lt;_Tp1, _Lp&gt; const&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(__weak_ptr&lt;_Tp1, _Lp&gt; const&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n      /// @}\n\n    protected:\n      // This constructor is non-standard, it is used by allocate_shared.\n      template&lt;typename _Alloc, typename... _Args&gt;\n\t__shared_ptr(_Sp_alloc_shared_tag&lt;_Alloc&gt; __tag, _Args&amp;&amp;... __args)\n\t: _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward&lt;_Args&gt;(__args)...)\n\t{ _M_enable_shared_from_this_with(_M_ptr); }\n\n      template&lt;typename _Tp1, _Lock_policy _Lp1, typename _Alloc,\n\t       typename... _Args&gt;\n\tfriend __shared_ptr&lt;_Tp1, _Lp1&gt;\n\t__allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args);\n\n      // This constructor is used by __weak_ptr::lock() and\n      // shared_ptr::shared_ptr(const weak_ptr&amp;, std::nothrow_t).\n      __shared_ptr(const __weak_ptr&lt;_Tp, _Lp&gt;&amp; __r, std::nothrow_t) noexcept\n      : _M_refcount(__r._M_refcount, std::nothrow)\n      {\n\t_M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;\n      }\n\n      friend class __weak_ptr&lt;_Tp, _Lp&gt;;\n\n    private:\n\n      template&lt;typename _Yp&gt;\n\tusing __esft_base_t = decltype(__enable_shared_from_this_base(\n\t      std::declval&lt;const __shared_count&lt;_Lp&gt;&amp;&gt;(),\n\t      std::declval&lt;_Yp*&gt;()));\n\n      // Detect an accessible and unambiguous enable_shared_from_this base.\n      template&lt;typename _Yp, typename = void&gt;\n\tstruct __has_esft_base\n\t: false_type { };\n\n      template&lt;typename _Yp&gt;\n\tstruct __has_esft_base&lt;_Yp, __void_t&lt;__esft_base_t&lt;_Yp&gt;&gt;&gt;\n\t: __not_&lt;is_array&lt;_Tp&gt;&gt; { }; // No enable shared_from_this for arrays\n\n      template&lt;typename _Yp, typename _Yp2 = typename remove_cv&lt;_Yp&gt;::type&gt;\n\ttypename enable_if&lt;__has_esft_base&lt;_Yp2&gt;::value&gt;::type\n\t_M_enable_shared_from_this_with(_Yp* __p) noexcept\n\t{\n\t  if (auto __base = __enable_shared_from_this_base(_M_refcount, __p))\n\t    __base-&gt;_M_weak_assign(const_cast&lt;_Yp2*&gt;(__p), _M_refcount);\n\t}\n\n      template&lt;typename _Yp, typename _Yp2 = typename remove_cv&lt;_Yp&gt;::type&gt;\n\ttypename enable_if&lt;!__has_esft_base&lt;_Yp2&gt;::value&gt;::type\n\t_M_enable_shared_from_this_with(_Yp*) noexcept\n\t{ }\n\n      void*\n      _M_get_deleter(const std::type_info&amp; __ti) const noexcept\n      { return _M_refcount._M_get_deleter(__ti); }\n\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __shared_ptr;\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __weak_ptr;\n\n      template&lt;typename _Del, typename _Tp1, _Lock_policy _Lp1&gt;\n\tfriend _Del* get_deleter(const __shared_ptr&lt;_Tp1, _Lp1&gt;&amp;) noexcept;\n\n      template&lt;typename _Del, typename _Tp1&gt;\n\tfriend _Del* get_deleter(const shared_ptr&lt;_Tp1&gt;&amp;) noexcept;\n\n      element_type*\t   _M_ptr;         // Contained pointer.\n      __shared_count&lt;_Lp&gt;  _M_refcount;    // Reference counter.\n    };\n\n\n  // 20.7.2.2.7 shared_ptr comparisons\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator==(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return __a.get() == __b.get(); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator==(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return !__a; }\n\n#ifdef __cpp_lib_three_way_comparison\n  template&lt;typename _Tp, typename _Up, _Lock_policy _Lp&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a,\n\t\tconst __shared_ptr&lt;_Up, _Lp&gt;&amp; __b) noexcept\n    { return compare_three_way()(__a.get(), __b.get()); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using pointer = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type*;\n      return compare_three_way()(__a.get(), static_cast&lt;pointer&gt;(nullptr));\n    }\n#else\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator==(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return !__a; }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator!=(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return __a.get() != __b.get(); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator!=(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return (bool)__a; }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator!=(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return (bool)__a; }\n\n  template&lt;typename _Tp, typename _Up, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a,\n\t      const __shared_ptr&lt;_Up, _Lp&gt;&amp; __b) noexcept\n    {\n      using _Tp_elt = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type;\n      using _Up_elt = typename __shared_ptr&lt;_Up, _Lp&gt;::element_type;\n      using _Vp = typename common_type&lt;_Tp_elt*, _Up_elt*&gt;::type;\n      return less&lt;_Vp&gt;()(__a.get(), __b.get());\n    }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using _Tp_elt = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(__a.get(), nullptr);\n    }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    {\n      using _Tp_elt = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(nullptr, __a.get());\n    }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;=(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return !(__b &lt; __a); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;=(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(nullptr &lt; __a); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;=(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return !(__a &lt; nullptr); }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t      const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return (__b &lt; __a); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return nullptr &lt; __a; }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return __a &lt; nullptr; }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;=(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return !(__a &lt; __b); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;=(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(__a &lt; nullptr); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;=(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return !(nullptr &lt; __a); }\n#endif // three-way comparison\n\n  // 20.7.2.2.8 shared_ptr specialized algorithms.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline void\n    swap(__shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, __shared_ptr&lt;_Tp, _Lp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n  // 20.7.2.2.9 shared_ptr casts\n\n  // The seemingly equivalent code:\n  // shared_ptr&lt;_Tp, _Lp&gt;(static_cast&lt;_Tp*&gt;(__r.get()))\n  // will eventually result in undefined behaviour, attempting to\n  // delete the same object twice.\n  /// static_pointer_cast\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    static_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      return _Sp(__r, static_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  // The seemingly equivalent code:\n  // shared_ptr&lt;_Tp, _Lp&gt;(const_cast&lt;_Tp*&gt;(__r.get()))\n  // will eventually result in undefined behaviour, attempting to\n  // delete the same object twice.\n  /// const_pointer_cast\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    const_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      return _Sp(__r, const_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  // The seemingly equivalent code:\n  // shared_ptr&lt;_Tp, _Lp&gt;(dynamic_cast&lt;_Tp*&gt;(__r.get()))\n  // will eventually result in undefined behaviour, attempting to\n  // delete the same object twice.\n  /// dynamic_pointer_cast\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    dynamic_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      if (auto* __p = dynamic_cast&lt;typename _Sp::element_type*&gt;(__r.get()))\n\treturn _Sp(__r, __p);\n      return _Sp();\n    }\n\n#if __cplusplus &gt; 201402L\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    reinterpret_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      return _Sp(__r, reinterpret_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n#endif\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __weak_ptr\n    {\n      template&lt;typename _Yp, typename _Res = void&gt;\n\tusing _Compatible = typename\n\t  enable_if&lt;__sp_compatible_with&lt;_Yp*, _Tp*&gt;::value, _Res&gt;::type;\n\n      // Constraint for assignment from shared_ptr and weak_ptr:\n      template&lt;typename _Yp&gt;\n\tusing _Assignable = _Compatible&lt;_Yp, __weak_ptr&amp;&gt;;\n\n    public:\n      using element_type = typename remove_extent&lt;_Tp&gt;::type;\n\n      constexpr __weak_ptr() noexcept\n      : _M_ptr(nullptr), _M_refcount()\n      { }\n\n      __weak_ptr(const __weak_ptr&amp;) noexcept = default;\n\n      ~__weak_ptr() = default;\n\n      // The &quot;obvious&quot; converting constructor implementation:\n      //\n      //  template&lt;typename _Tp1&gt;\n      //    __weak_ptr(const __weak_ptr&lt;_Tp1, _Lp&gt;&amp; __r)\n      //    : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n      //    { }\n      //\n      // has a serious problem.\n      //\n      //  __r._M_ptr may already have been invalidated. The _M_ptr(__r._M_ptr)\n      //  conversion may require access to *__r._M_ptr (virtual inheritance).\n      //\n      // It is not possible to avoid spurious access violations since\n      // in multithreaded programs __r._M_ptr may be invalidated at any point.\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__weak_ptr(const __weak_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t: _M_refcount(__r._M_refcount)\n        { _M_ptr = __r.lock().get(); }\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__weak_ptr(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)\n\t{ }\n\n      __weak_ptr(__weak_ptr&amp;&amp; __r) noexcept\n      : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount))\n      { __r._M_ptr = nullptr; }\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__weak_ptr(__weak_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t: _M_ptr(__r.lock().get()), _M_refcount(std::move(__r._M_refcount))\n        { __r._M_ptr = nullptr; }\n\n      __weak_ptr&amp;\n      operator=(const __weak_ptr&amp; __r) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(const __weak_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r.lock().get();\n\t  _M_refcount = __r._M_refcount;\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r._M_ptr;\n\t  _M_refcount = __r._M_refcount;\n\t  return *this;\n\t}\n\n      __weak_ptr&amp;\n      operator=(__weak_ptr&amp;&amp; __r) noexcept\n      {\n\t_M_ptr = __r._M_ptr;\n\t_M_refcount = std::move(__r._M_refcount);\n\t__r._M_ptr = nullptr;\n\treturn *this;\n      }\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(__weak_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r.lock().get();\n\t  _M_refcount = std::move(__r._M_refcount);\n\t  __r._M_ptr = nullptr;\n\t  return *this;\n\t}\n\n      __shared_ptr&lt;_Tp, _Lp&gt;\n      lock() const noexcept\n      { return __shared_ptr&lt;element_type, _Lp&gt;(*this, std::nothrow); }\n\n      long\n      use_count() const noexcept\n      { return _M_refcount._M_get_use_count(); }\n\n      bool\n      expired() const noexcept\n      { return _M_refcount._M_get_use_count() == 0; }\n\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(const __weak_ptr&lt;_Tp1, _Lp&gt;&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n\n      void\n      reset() noexcept\n      { __weak_ptr().swap(*this); }\n\n      void\n      swap(__weak_ptr&amp; __s) noexcept\n      {\n\tstd::swap(_M_ptr, __s._M_ptr);\n\t_M_refcount._M_swap(__s._M_refcount);\n      }\n\n    private:\n      // Used by __enable_shared_from_this.\n      void\n      _M_assign(_Tp* __ptr, const __shared_count&lt;_Lp&gt;&amp; __refcount) noexcept\n      {\n\tif (use_count() == 0)\n\t  {\n\t    _M_ptr = __ptr;\n\t    _M_refcount = __refcount;\n\t  }\n      }\n\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __shared_ptr;\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __weak_ptr;\n      friend class __enable_shared_from_this&lt;_Tp, _Lp&gt;;\n      friend class enable_shared_from_this&lt;_Tp&gt;;\n\n      element_type*\t _M_ptr;         // Contained pointer.\n      __weak_count&lt;_Lp&gt;  _M_refcount;    // Reference counter.\n    };\n\n  // 20.7.2.3.6 weak_ptr specialized algorithms.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline void\n    swap(__weak_ptr&lt;_Tp, _Lp&gt;&amp; __a, __weak_ptr&lt;_Tp, _Lp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n  template&lt;typename _Tp, typename _Tp1&gt;\n    struct _Sp_owner_less : public binary_function&lt;_Tp, _Tp, bool&gt;\n    {\n      bool\n      operator()(const _Tp&amp; __lhs, const _Tp&amp; __rhs) const noexcept\n      { return __lhs.owner_before(__rhs); }\n\n      bool\n      operator()(const _Tp&amp; __lhs, const _Tp1&amp; __rhs) const noexcept\n      { return __lhs.owner_before(__rhs); }\n\n      bool\n      operator()(const _Tp1&amp; __lhs, const _Tp&amp; __rhs) const noexcept\n      { return __lhs.owner_before(__rhs); }\n    };\n\n  template&lt;&gt;\n    struct _Sp_owner_less&lt;void, void&gt;\n    {\n      template&lt;typename _Tp, typename _Up&gt;\n\tauto\n\toperator()(const _Tp&amp; __lhs, const _Up&amp; __rhs) const noexcept\n\t-&gt; decltype(__lhs.owner_before(__rhs))\n\t{ return __lhs.owner_before(__rhs); }\n\n      using is_transparent = void;\n    };\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    struct owner_less&lt;__shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    : public _Sp_owner_less&lt;__shared_ptr&lt;_Tp, _Lp&gt;, __weak_ptr&lt;_Tp, _Lp&gt;&gt;\n    { };\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    struct owner_less&lt;__weak_ptr&lt;_Tp, _Lp&gt;&gt;\n    : public _Sp_owner_less&lt;__weak_ptr&lt;_Tp, _Lp&gt;, __shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    { };\n\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __enable_shared_from_this\n    {\n    protected:\n      constexpr __enable_shared_from_this() noexcept { }\n\n      __enable_shared_from_this(const __enable_shared_from_this&amp;) noexcept { }\n\n      __enable_shared_from_this&amp;\n      operator=(const __enable_shared_from_this&amp;) noexcept\n      { return *this; }\n\n      ~__enable_shared_from_this() { }\n\n    public:\n      __shared_ptr&lt;_Tp, _Lp&gt;\n      shared_from_this()\n      { return __shared_ptr&lt;_Tp, _Lp&gt;(this-&gt;_M_weak_this); }\n\n      __shared_ptr&lt;const _Tp, _Lp&gt;\n      shared_from_this() const\n      { return __shared_ptr&lt;const _Tp, _Lp&gt;(this-&gt;_M_weak_this); }\n\n#if __cplusplus &gt; 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n      __weak_ptr&lt;_Tp, _Lp&gt;\n      weak_from_this() noexcept\n      { return this-&gt;_M_weak_this; }\n\n      __weak_ptr&lt;const _Tp, _Lp&gt;\n      weak_from_this() const noexcept\n      { return this-&gt;_M_weak_this; }\n#endif\n\n    private:\n      template&lt;typename _Tp1&gt;\n\tvoid\n\t_M_weak_assign(_Tp1* __p, const __shared_count&lt;_Lp&gt;&amp; __n) const noexcept\n\t{ _M_weak_this._M_assign(__p, __n); }\n\n      friend const __enable_shared_from_this*\n      __enable_shared_from_this_base(const __shared_count&lt;_Lp&gt;&amp;,\n\t\t\t\t     const __enable_shared_from_this* __p)\n      { return __p; }\n\n      template&lt;typename, _Lock_policy&gt;\n\tfriend class __shared_ptr;\n\n      mutable __weak_ptr&lt;_Tp, _Lp&gt;  _M_weak_this;\n    };\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy,\n\t   typename _Alloc, typename... _Args&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    __allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args)\n    {\n      static_assert(!is_array&lt;_Tp&gt;::value, &quot;make_shared&lt;T[]&gt; not supported&quot;);\n\n      return __shared_ptr&lt;_Tp, _Lp&gt;(_Sp_alloc_shared_tag&lt;_Alloc&gt;{__a},\n\t\t\t\t    std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy,\n\t   typename... _Args&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    __make_shared(_Args&amp;&amp;... __args)\n    {\n      typedef typename std::remove_const&lt;_Tp&gt;::type _Tp_nc;\n      return std::__allocate_shared&lt;_Tp, _Lp&gt;(std::allocator&lt;_Tp_nc&gt;(),\n\t\t\t\t\t      std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  /// std::hash specialization for __shared_ptr.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    struct hash&lt;__shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    : public __hash_base&lt;size_t, __shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    {\n      size_t\n      operator()(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __s) const noexcept\n      {\n\treturn hash&lt;typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type*&gt;()(\n\t    __s.get());\n      }\n    };\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif // _SHARED_PTR_BASE_H\n"}, "/usr/include/c++/11/bits/alloc_traits.h": {"id": "/usr/include/c++/11/bits/alloc_traits.h", "filePath": "/usr/include/c++/11/bits/alloc_traits.h", "content": "// Allocator traits -*- C++ -*-\n\n// Copyright (C) 2011-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n/** @file bits/alloc_traits.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _ALLOC_TRAITS_H\n#define _ALLOC_TRAITS_H 1\n\n#include &lt;bits/stl_construct.h&gt;\n#include &lt;bits/memoryfwd.h&gt;\n#if __cplusplus &gt;= 201103L\n# include &lt;bits/allocator.h&gt;\n# include &lt;bits/ptr_traits.h&gt;\n# include &lt;ext/numeric_traits.h&gt;\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#if __cplusplus &gt;= 201103L\n#define __cpp_lib_allocator_traits_is_always_equal 201411\n\n  /// @cond undocumented\n  struct __allocator_traits_base\n  {\n    template&lt;typename _Tp, typename _Up, typename = void&gt;\n      struct __rebind : __replace_first_arg&lt;_Tp, _Up&gt; { };\n\n    template&lt;typename _Tp, typename _Up&gt;\n      struct __rebind&lt;_Tp, _Up,\n\t\t      __void_t&lt;typename _Tp::template rebind&lt;_Up&gt;::other&gt;&gt;\n      { using type = typename _Tp::template rebind&lt;_Up&gt;::other; };\n\n  protected:\n    template&lt;typename _Tp&gt;\n      using __pointer = typename _Tp::pointer;\n    template&lt;typename _Tp&gt;\n      using __c_pointer = typename _Tp::const_pointer;\n    template&lt;typename _Tp&gt;\n      using __v_pointer = typename _Tp::void_pointer;\n    template&lt;typename _Tp&gt;\n      using __cv_pointer = typename _Tp::const_void_pointer;\n    template&lt;typename _Tp&gt;\n      using __pocca = typename _Tp::propagate_on_container_copy_assignment;\n    template&lt;typename _Tp&gt;\n      using __pocma = typename _Tp::propagate_on_container_move_assignment;\n    template&lt;typename _Tp&gt;\n      using __pocs = typename _Tp::propagate_on_container_swap;\n    template&lt;typename _Tp&gt;\n      using __equal = typename _Tp::is_always_equal;\n  };\n\n  template&lt;typename _Alloc, typename _Up&gt;\n    using __alloc_rebind\n      = typename __allocator_traits_base::template __rebind&lt;_Alloc, _Up&gt;::type;\n  /// @endcond\n\n  /**\n   * @brief  Uniform interface to all allocator types.\n   * @headerfile memory\n   * @ingroup allocators\n   * @since C++11\n  */\n  template&lt;typename _Alloc&gt;\n    struct allocator_traits : __allocator_traits_base\n    {\n      /// The allocator type\n      typedef _Alloc allocator_type;\n      /// The allocated type\n      typedef typename _Alloc::value_type value_type;\n\n      /**\n       * @brief   The allocator&#x27;s pointer type.\n       *\n       * @c Alloc::pointer if that type exists, otherwise @c value_type*\n      */\n      using pointer = __detected_or_t&lt;value_type*, __pointer, _Alloc&gt;;\n\n    private:\n      // Select _Func&lt;_Alloc&gt; or pointer_traits&lt;pointer&gt;::rebind&lt;_Tp&gt;\n      template&lt;template&lt;typename&gt; class _Func, typename _Tp, typename = void&gt;\n\tstruct _Ptr\n\t{\n\t  using type = typename pointer_traits&lt;pointer&gt;::template rebind&lt;_Tp&gt;;\n\t};\n\n      template&lt;template&lt;typename&gt; class _Func, typename _Tp&gt;\n\tstruct _Ptr&lt;_Func, _Tp, __void_t&lt;_Func&lt;_Alloc&gt;&gt;&gt;\n\t{\n\t  using type = _Func&lt;_Alloc&gt;;\n\t};\n\n      // Select _A2::difference_type or pointer_traits&lt;_Ptr&gt;::difference_type\n      template&lt;typename _A2, typename _PtrT, typename = void&gt;\n\tstruct _Diff\n\t{ using type = typename pointer_traits&lt;_PtrT&gt;::difference_type; };\n\n      template&lt;typename _A2, typename _PtrT&gt;\n\tstruct _Diff&lt;_A2, _PtrT, __void_t&lt;typename _A2::difference_type&gt;&gt;\n\t{ using type = typename _A2::difference_type; };\n\n      // Select _A2::size_type or make_unsigned&lt;_DiffT&gt;::type\n      template&lt;typename _A2, typename _DiffT, typename = void&gt;\n\tstruct _Size : make_unsigned&lt;_DiffT&gt; { };\n\n      template&lt;typename _A2, typename _DiffT&gt;\n\tstruct _Size&lt;_A2, _DiffT, __void_t&lt;typename _A2::size_type&gt;&gt;\n\t{ using type = typename _A2::size_type; };\n\n    public:\n      /**\n       * @brief   The allocator&#x27;s const pointer type.\n       *\n       * @c Alloc::const_pointer if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::rebind&lt;const value_type&gt; &lt;/tt&gt;\n      */\n      using const_pointer = typename _Ptr&lt;__c_pointer, const value_type&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s void pointer type.\n       *\n       * @c Alloc::void_pointer if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::rebind&lt;void&gt; &lt;/tt&gt;\n      */\n      using void_pointer = typename _Ptr&lt;__v_pointer, void&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s const void pointer type.\n       *\n       * @c Alloc::const_void_pointer if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::rebind&lt;const void&gt; &lt;/tt&gt;\n      */\n      using const_void_pointer = typename _Ptr&lt;__cv_pointer, const void&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s difference type\n       *\n       * @c Alloc::difference_type if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::difference_type &lt;/tt&gt;\n      */\n      using difference_type = typename _Diff&lt;_Alloc, pointer&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s size type\n       *\n       * @c Alloc::size_type if that type exists, otherwise\n       * &lt;tt&gt; make_unsigned&lt;difference_type&gt;::type &lt;/tt&gt;\n      */\n      using size_type = typename _Size&lt;_Alloc, difference_type&gt;::type;\n\n      /**\n       * @brief   How the allocator is propagated on copy assignment\n       *\n       * @c Alloc::propagate_on_container_copy_assignment if that type exists,\n       * otherwise @c false_type\n      */\n      using propagate_on_container_copy_assignment\n\t= __detected_or_t&lt;false_type, __pocca, _Alloc&gt;;\n\n      /**\n       * @brief   How the allocator is propagated on move assignment\n       *\n       * @c Alloc::propagate_on_container_move_assignment if that type exists,\n       * otherwise @c false_type\n      */\n      using propagate_on_container_move_assignment\n\t= __detected_or_t&lt;false_type, __pocma, _Alloc&gt;;\n\n      /**\n       * @brief   How the allocator is propagated on swap\n       *\n       * @c Alloc::propagate_on_container_swap if that type exists,\n       * otherwise @c false_type\n      */\n      using propagate_on_container_swap\n\t= __detected_or_t&lt;false_type, __pocs, _Alloc&gt;;\n\n      /**\n       * @brief   Whether all instances of the allocator type compare equal.\n       *\n       * @c Alloc::is_always_equal if that type exists,\n       * otherwise @c is_empty&lt;Alloc&gt;::type\n      */\n      using is_always_equal\n\t= __detected_or_t&lt;typename is_empty&lt;_Alloc&gt;::type, __equal, _Alloc&gt;;\n\n      template&lt;typename _Tp&gt;\n\tusing rebind_alloc = __alloc_rebind&lt;_Alloc, _Tp&gt;;\n      template&lt;typename _Tp&gt;\n\tusing rebind_traits = allocator_traits&lt;rebind_alloc&lt;_Tp&gt;&gt;;\n\n    private:\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr auto\n\t_S_allocate(_Alloc2&amp; __a, size_type __n, const_void_pointer __hint, int)\n\t-&gt; decltype(__a.allocate(__n, __hint))\n\t{ return __a.allocate(__n, __hint); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr pointer\n\t_S_allocate(_Alloc2&amp; __a, size_type __n, const_void_pointer, ...)\n\t{ return __a.allocate(__n); }\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstruct __construct_helper\n\t{\n\t  template&lt;typename _Alloc2,\n\t    typename = decltype(std::declval&lt;_Alloc2*&gt;()-&gt;construct(\n\t\t  std::declval&lt;_Tp*&gt;(), std::declval&lt;_Args&gt;()...))&gt;\n\t    static true_type __test(int);\n\n\t  template&lt;typename&gt;\n\t    static false_type __test(...);\n\n\t  using type = decltype(__test&lt;_Alloc&gt;(0));\n\t};\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tusing __has_construct\n\t  = typename __construct_helper&lt;_Tp, _Args...&gt;::type;\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstatic _GLIBCXX14_CONSTEXPR _Require&lt;__has_construct&lt;_Tp, _Args...&gt;&gt;\n\t_S_construct(_Alloc&amp; __a, _Tp* __p, _Args&amp;&amp;... __args)\n\tnoexcept(noexcept(__a.construct(__p, std::forward&lt;_Args&gt;(__args)...)))\n\t{ __a.construct(__p, std::forward&lt;_Args&gt;(__args)...); }\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstatic _GLIBCXX14_CONSTEXPR\n\t_Require&lt;__and_&lt;__not_&lt;__has_construct&lt;_Tp, _Args...&gt;&gt;,\n\t\t\t       is_constructible&lt;_Tp, _Args...&gt;&gt;&gt;\n\t_S_construct(_Alloc&amp;, _Tp* __p, _Args&amp;&amp;... __args)\n\tnoexcept(std::is_nothrow_constructible&lt;_Tp, _Args...&gt;::value)\n\t{\n#if __cplusplus &lt;= 201703L\n\t  ::new((void*)__p) _Tp(std::forward&lt;_Args&gt;(__args)...);\n#else\n\t  std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...);\n#endif\n\t}\n\n      template&lt;typename _Alloc2, typename _Tp&gt;\n\tstatic _GLIBCXX14_CONSTEXPR auto\n\t_S_destroy(_Alloc2&amp; __a, _Tp* __p, int)\n\tnoexcept(noexcept(__a.destroy(__p)))\n\t-&gt; decltype(__a.destroy(__p))\n\t{ __a.destroy(__p); }\n\n      template&lt;typename _Alloc2, typename _Tp&gt;\n\tstatic _GLIBCXX14_CONSTEXPR void\n\t_S_destroy(_Alloc2&amp;, _Tp* __p, ...)\n\tnoexcept(std::is_nothrow_destructible&lt;_Tp&gt;::value)\n\t{ std::_Destroy(__p); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr auto\n\t_S_max_size(_Alloc2&amp; __a, int)\n\t-&gt; decltype(__a.max_size())\n\t{ return __a.max_size(); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr size_type\n\t_S_max_size(_Alloc2&amp;, ...)\n\t{\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 2466. allocator_traits::max_size() default behavior is incorrect\n\t  return __gnu_cxx::__numeric_traits&lt;size_type&gt;::__max\n\t    / sizeof(value_type);\n\t}\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr auto\n\t_S_select(_Alloc2&amp; __a, int)\n\t-&gt; decltype(__a.select_on_container_copy_construction())\n\t{ return __a.select_on_container_copy_construction(); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr _Alloc2\n\t_S_select(_Alloc2&amp; __a, ...)\n\t{ return __a; }\n\n    public:\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *\n       *  Calls @c a.allocate(n)\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(_Alloc&amp; __a, size_type __n)\n      { return __a.allocate(__n); }\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *  @param  __hint Aid to locality.\n       *  @return Memory of suitable size and alignment for @a n objects\n       *          of type @c value_type\n       *\n       *  Returns &lt;tt&gt; a.allocate(n, hint) &lt;/tt&gt; if that expression is\n       *  well-formed, otherwise returns @c a.allocate(n)\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(_Alloc&amp; __a, size_type __n, const_void_pointer __hint)\n      { return _S_allocate(__a, __n, __hint, 0); }\n\n      /**\n       *  @brief  Deallocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the memory to deallocate.\n       *  @param  __n  The number of objects space was allocated for.\n       *\n       *  Calls &lt;tt&gt; a.deallocate(p, n) &lt;/tt&gt;\n      */\n      static _GLIBCXX20_CONSTEXPR void\n      deallocate(_Alloc&amp; __a, pointer __p, size_type __n)\n      { __a.deallocate(__p, __n); }\n\n      /**\n       *  @brief  Construct an object of type `_Tp`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to memory of suitable size and alignment for Tp\n       *  @param  __args Constructor arguments.\n       *\n       *  Calls &lt;tt&gt; __a.construct(__p, std::forward&lt;Args&gt;(__args)...) &lt;/tt&gt;\n       *  if that expression is well-formed, otherwise uses placement-new\n       *  to construct an object of type @a _Tp at location @a __p from the\n       *  arguments @a __args...\n      */\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstatic _GLIBCXX20_CONSTEXPR auto\n\tconstruct(_Alloc&amp; __a, _Tp* __p, _Args&amp;&amp;... __args)\n\tnoexcept(noexcept(_S_construct(__a, __p,\n\t\t\t\t       std::forward&lt;_Args&gt;(__args)...)))\n\t-&gt; decltype(_S_construct(__a, __p, std::forward&lt;_Args&gt;(__args)...))\n\t{ _S_construct(__a, __p, std::forward&lt;_Args&gt;(__args)...); }\n\n      /**\n       *  @brief  Destroy an object of type @a _Tp\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the object to destroy\n       *\n       *  Calls @c __a.destroy(__p) if that expression is well-formed,\n       *  otherwise calls @c __p-&gt;~_Tp()\n      */\n      template&lt;typename _Tp&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tdestroy(_Alloc&amp; __a, _Tp* __p)\n\tnoexcept(noexcept(_S_destroy(__a, __p, 0)))\n\t{ _S_destroy(__a, __p, 0); }\n\n      /**\n       *  @brief  The maximum supported allocation size\n       *  @param  __a  An allocator.\n       *  @return @c __a.max_size() or @c numeric_limits&lt;size_type&gt;::max()\n       *\n       *  Returns @c __a.max_size() if that expression is well-formed,\n       *  otherwise returns @c numeric_limits&lt;size_type&gt;::max()\n      */\n      static _GLIBCXX20_CONSTEXPR size_type\n      max_size(const _Alloc&amp; __a) noexcept\n      { return _S_max_size(__a, 0); }\n\n      /**\n       *  @brief  Obtain an allocator to use when copying a container.\n       *  @param  __rhs  An allocator.\n       *  @return @c __rhs.select_on_container_copy_construction() or @a __rhs\n       *\n       *  Returns @c __rhs.select_on_container_copy_construction() if that\n       *  expression is well-formed, otherwise returns @a __rhs\n      */\n      static _GLIBCXX20_CONSTEXPR _Alloc\n      select_on_container_copy_construction(const _Alloc&amp; __rhs)\n      { return _S_select(__rhs, 0); }\n    };\n\n#if __cplusplus &gt; 201703L\n# define __cpp_lib_constexpr_dynamic_alloc 201907L\n#endif\n\n  /// Partial specialization for std::allocator.\n  template&lt;typename _Tp&gt;\n    struct allocator_traits&lt;allocator&lt;_Tp&gt;&gt;\n    {\n      /// The allocator type\n      using allocator_type = allocator&lt;_Tp&gt;;\n\n      /// The allocated type\n      using value_type = _Tp;\n\n      /// The allocator&#x27;s pointer type.\n      using pointer = _Tp*;\n\n      /// The allocator&#x27;s const pointer type.\n      using const_pointer = const _Tp*;\n\n      /// The allocator&#x27;s void pointer type.\n      using void_pointer = void*;\n\n      /// The allocator&#x27;s const void pointer type.\n      using const_void_pointer = const void*;\n\n      /// The allocator&#x27;s difference type\n      using difference_type = std::ptrdiff_t;\n\n      /// The allocator&#x27;s size type\n      using size_type = std::size_t;\n\n      /// How the allocator is propagated on copy assignment\n      using propagate_on_container_copy_assignment = false_type;\n\n      /// How the allocator is propagated on move assignment\n      using propagate_on_container_move_assignment = true_type;\n\n      /// How the allocator is propagated on swap\n      using propagate_on_container_swap = false_type;\n\n      /// Whether all instances of the allocator type compare equal.\n      using is_always_equal = true_type;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_alloc = allocator&lt;_Up&gt;;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_traits = allocator_traits&lt;allocator&lt;_Up&gt;&gt;;\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *\n       *  Calls @c a.allocate(n)\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(allocator_type&amp; __a, size_type __n)\n      { return __a.allocate(__n); }\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *  @param  __hint Aid to locality.\n       *  @return Memory of suitable size and alignment for @a n objects\n       *          of type @c value_type\n       *\n       *  Returns &lt;tt&gt; a.allocate(n, hint) &lt;/tt&gt;\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(allocator_type&amp; __a, size_type __n, const_void_pointer __hint)\n      {\n#if __cplusplus &lt;= 201703L\n\treturn __a.allocate(__n, __hint);\n#else\n\treturn __a.allocate(__n);\n#endif\n      }\n\n      /**\n       *  @brief  Deallocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the memory to deallocate.\n       *  @param  __n  The number of objects space was allocated for.\n       *\n       *  Calls &lt;tt&gt; a.deallocate(p, n) &lt;/tt&gt;\n      */\n      static _GLIBCXX20_CONSTEXPR void\n      deallocate(allocator_type&amp; __a, pointer __p, size_type __n)\n      { __a.deallocate(__p, __n); }\n\n      /**\n       *  @brief  Construct an object of type `_Up`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to memory of suitable size and alignment for\n       *\t       an object of type `_Up`.\n       *  @param  __args Constructor arguments.\n       *\n       *  Calls `__a.construct(__p, std::forward&lt;_Args&gt;(__args)...)`\n       *  in C++11, C++14 and C++17. Changed in C++20 to call\n       *  `std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...)` instead.\n      */\n      template&lt;typename _Up, typename... _Args&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tconstruct(allocator_type&amp; __a __attribute__((__unused__)), _Up* __p,\n\t\t  _Args&amp;&amp;... __args)\n\tnoexcept(std::is_nothrow_constructible&lt;_Up, _Args...&gt;::value)\n\t{\n#if __cplusplus &lt;= 201703L\n\t  __a.construct(__p, std::forward&lt;_Args&gt;(__args)...);\n#else\n\t  std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...);\n#endif\n\t}\n\n      /**\n       *  @brief  Destroy an object of type @a _Up\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the object to destroy\n       *\n       *  Calls @c __a.destroy(__p).\n      */\n      template&lt;typename _Up&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tdestroy(allocator_type&amp; __a __attribute__((__unused__)), _Up* __p)\n\tnoexcept(is_nothrow_destructible&lt;_Up&gt;::value)\n\t{\n#if __cplusplus &lt;= 201703L\n\t  __a.destroy(__p);\n#else\n\t  std::destroy_at(__p);\n#endif\n\t}\n\n      /**\n       *  @brief  The maximum supported allocation size\n       *  @param  __a  An allocator.\n       *  @return @c __a.max_size()\n      */\n      static _GLIBCXX20_CONSTEXPR size_type\n      max_size(const allocator_type&amp; __a __attribute__((__unused__))) noexcept\n      {\n#if __cplusplus &lt;= 201703L\n\treturn __a.max_size();\n#else\n\treturn size_t(-1) / sizeof(value_type);\n#endif\n      }\n\n      /**\n       *  @brief  Obtain an allocator to use when copying a container.\n       *  @param  __rhs  An allocator.\n       *  @return @c __rhs\n      */\n      static _GLIBCXX20_CONSTEXPR allocator_type\n      select_on_container_copy_construction(const allocator_type&amp; __rhs)\n      { return __rhs; }\n    };\n\n  /// Explicit specialization for std::allocator&lt;void&gt;.\n  template&lt;&gt;\n    struct allocator_traits&lt;allocator&lt;void&gt;&gt;\n    {\n      /// The allocator type\n      using allocator_type = allocator&lt;void&gt;;\n\n      /// The allocated type\n      using value_type = void;\n\n      /// The allocator&#x27;s pointer type.\n      using pointer = void*;\n\n      /// The allocator&#x27;s const pointer type.\n      using const_pointer = const void*;\n\n      /// The allocator&#x27;s void pointer type.\n      using void_pointer = void*;\n\n      /// The allocator&#x27;s const void pointer type.\n      using const_void_pointer = const void*;\n\n      /// The allocator&#x27;s difference type\n      using difference_type = std::ptrdiff_t;\n\n      /// The allocator&#x27;s size type\n      using size_type = std::size_t;\n\n      /// How the allocator is propagated on copy assignment\n      using propagate_on_container_copy_assignment = false_type;\n\n      /// How the allocator is propagated on move assignment\n      using propagate_on_container_move_assignment = true_type;\n\n      /// How the allocator is propagated on swap\n      using propagate_on_container_swap = false_type;\n\n      /// Whether all instances of the allocator type compare equal.\n      using is_always_equal = true_type;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_alloc = allocator&lt;_Up&gt;;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_traits = allocator_traits&lt;allocator&lt;_Up&gt;&gt;;\n\n      /// allocate is ill-formed for allocator&lt;void&gt;\n      static void*\n      allocate(allocator_type&amp;, size_type, const void* = nullptr) = delete;\n\n      /// deallocate is ill-formed for allocator&lt;void&gt;\n      static void\n      deallocate(allocator_type&amp;, void*, size_type) = delete;\n\n      /**\n       *  @brief  Construct an object of type `_Up`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to memory of suitable size and alignment for\n       *\t       an object of type `_Up`.\n       *  @param  __args Constructor arguments.\n       *\n       *  Calls `__a.construct(__p, std::forward&lt;_Args&gt;(__args)...)`\n       *  in C++11, C++14 and C++17. Changed in C++20 to call\n       *  `std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...)` instead.\n      */\n      template&lt;typename _Up, typename... _Args&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tconstruct(allocator_type&amp;, _Up* __p, _Args&amp;&amp;... __args)\n\tnoexcept(std::is_nothrow_constructible&lt;_Up, _Args...&gt;::value)\n\t{ std::_Construct(__p, std::forward&lt;_Args&gt;(__args)...); }\n\n      /**\n       *  @brief  Destroy an object of type `_Up`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the object to destroy\n       *\n       *  Invokes the destructor for `*__p`.\n      */\n      template&lt;typename _Up&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tdestroy(allocator_type&amp;, _Up* __p)\n\tnoexcept(is_nothrow_destructible&lt;_Up&gt;::value)\n\t{ std::_Destroy(__p); }\n\n      /// max_size is ill-formed for allocator&lt;void&gt;\n      static size_type\n      max_size(const allocator_type&amp;) = delete;\n\n      /**\n       *  @brief  Obtain an allocator to use when copying a container.\n       *  @param  __rhs  An allocator.\n       *  @return `__rhs`\n      */\n      static _GLIBCXX20_CONSTEXPR allocator_type\n      select_on_container_copy_construction(const allocator_type&amp; __rhs)\n      { return __rhs; }\n    };\n\n#if __cplusplus &lt; 201703L\n  template&lt;typename _Alloc&gt;\n    inline void\n    __do_alloc_on_copy(_Alloc&amp; __one, const _Alloc&amp; __two, true_type)\n    { __one = __two; }\n\n  template&lt;typename _Alloc&gt;\n    inline void\n    __do_alloc_on_copy(_Alloc&amp;, const _Alloc&amp;, false_type)\n    { }\n#endif\n\n  template&lt;typename _Alloc&gt;\n    _GLIBCXX14_CONSTEXPR inline void\n    __alloc_on_copy(_Alloc&amp; __one, const _Alloc&amp; __two)\n    {\n      typedef allocator_traits&lt;_Alloc&gt; __traits;\n      typedef typename __traits::propagate_on_container_copy_assignment __pocca;\n#if __cplusplus &gt;= 201703L\n      if constexpr (__pocca::value)\n\t__one = __two;\n#else\n      __do_alloc_on_copy(__one, __two, __pocca());\n#endif\n    }\n\n  template&lt;typename _Alloc&gt;\n    constexpr _Alloc\n    __alloc_on_copy(const _Alloc&amp; __a)\n    {\n      typedef allocator_traits&lt;_Alloc&gt; __traits;\n      return __traits::select_on_container_copy_construction(__a);\n    }\n\n#if __cplusplus &lt; 201703L\n  template&lt;typename _Alloc&gt;\n    inline void __do_alloc_on_move(_Alloc&amp; __one, _Alloc&amp; __two, true_type)\n    { __one = std::move(__two); }\n\n  template&lt;typename _Alloc&gt;\n    inline void __do_alloc_on_move(_Alloc&amp;, _Alloc&amp;, false_type)\n    { }\n#endif\n\n  template&lt;typename _Alloc&gt;\n    _GLIBCXX14_CONSTEXPR inline void\n    __alloc_on_move(_Alloc&amp; __one, _Alloc&amp; __two)\n    {\n      typedef allocator_traits&lt;_Alloc&gt; __traits;\n      typedef typename __traits::propagate_on_container_move_assignment __pocma;\n#if __cplusplus &gt;= 201703L\n      if constexpr (__pocma::value)\n\t__one = std::move(__two);\n#else\n      __do_alloc_on_move(__one, __two, __pocma());\n#endif\n    }\n\n#if __cplusplus &lt; 201703L\n  template&lt;typename _Alloc&gt;\n    inline void __do_alloc_on_swap(_Alloc&amp; __one, _Alloc&amp; __two, true_type)\n    {\n      using std::swap;\n      swap(__one, __two);\n    }\n\n  template&lt;typename _Alloc&gt;\n    inline void __do_alloc_on_swap(_Alloc&amp;, _Alloc&amp;, false_type)\n    { }\n#endif\n\n  template&lt;typename _Alloc&gt;\n    _GLIBCXX14_CONSTEXPR inline void\n    __alloc_on_swap(_Alloc&amp; __one, _Alloc&amp; __two)\n    {\n      typedef allocator_traits&lt;_Alloc&gt; __traits;\n      typedef typename __traits::propagate_on_container_swap __pocs;\n#if __cplusplus &gt;= 201703L\n      if constexpr (__pocs::value)\n\t{\n\t  using std::swap;\n\t  swap(__one, __two);\n\t}\n#else\n      __do_alloc_on_swap(__one, __two, __pocs());\n#endif\n    }\n\n  template&lt;typename _Alloc, typename _Tp,\n\t   typename _ValueT = __remove_cvref_t&lt;typename _Alloc::value_type&gt;,\n\t   typename = void&gt;\n    struct __is_alloc_insertable_impl\n    : false_type\n    { };\n\n  template&lt;typename _Alloc, typename _Tp, typename _ValueT&gt;\n    struct __is_alloc_insertable_impl&lt;_Alloc, _Tp, _ValueT,\n      __void_t&lt;decltype(allocator_traits&lt;_Alloc&gt;::construct(\n\t\t   std::declval&lt;_Alloc&amp;&gt;(), std::declval&lt;_ValueT*&gt;(),\n\t\t   std::declval&lt;_Tp&gt;()))&gt;&gt;\n    : true_type\n    { };\n\n  // true if _Alloc::value_type is CopyInsertable into containers using _Alloc\n  // (might be wrong if _Alloc::construct exists but is not constrained,\n  // i.e. actually trying to use it would still be invalid. Use with caution.)\n  template&lt;typename _Alloc&gt;\n    struct __is_copy_insertable\n    : __is_alloc_insertable_impl&lt;_Alloc,\n\t\t\t\t typename _Alloc::value_type const&amp;&gt;::type\n    { };\n\n  // std::allocator&lt;_Tp&gt; just requires CopyConstructible\n  template&lt;typename _Tp&gt;\n    struct __is_copy_insertable&lt;allocator&lt;_Tp&gt;&gt;\n    : is_copy_constructible&lt;_Tp&gt;\n    { };\n\n  // true if _Alloc::value_type is MoveInsertable into containers using _Alloc\n  // (might be wrong if _Alloc::construct exists but is not constrained,\n  // i.e. actually trying to use it would still be invalid. Use with caution.)\n  template&lt;typename _Alloc&gt;\n    struct __is_move_insertable\n    : __is_alloc_insertable_impl&lt;_Alloc, typename _Alloc::value_type&gt;::type\n    { };\n\n  // std::allocator&lt;_Tp&gt; just requires MoveConstructible\n  template&lt;typename _Tp&gt;\n    struct __is_move_insertable&lt;allocator&lt;_Tp&gt;&gt;\n    : is_move_constructible&lt;_Tp&gt;\n    { };\n\n  // Trait to detect Allocator-like types.\n  template&lt;typename _Alloc, typename = void&gt;\n    struct __is_allocator : false_type { };\n\n  template&lt;typename _Alloc&gt;\n    struct __is_allocator&lt;_Alloc,\n      __void_t&lt;typename _Alloc::value_type,\n\t       decltype(std::declval&lt;_Alloc&amp;&gt;().allocate(size_t{}))&gt;&gt;\n    : true_type { };\n\n  template&lt;typename _Alloc&gt;\n    using _RequireAllocator\n      = typename enable_if&lt;__is_allocator&lt;_Alloc&gt;::value, _Alloc&gt;::type;\n\n  template&lt;typename _Alloc&gt;\n    using _RequireNotAllocator\n      = typename enable_if&lt;!__is_allocator&lt;_Alloc&gt;::value, _Alloc&gt;::type;\n\n#if __cpp_concepts &gt;= 201907L\n  template&lt;typename _Alloc&gt;\n    concept __allocator_like = requires (_Alloc&amp; __a) {\n      typename _Alloc::value_type;\n      __a.deallocate(__a.allocate(1u), 1u);\n    };\n#endif\n#endif // C++11\n\n  /**\n   * Destroy a range of objects using the supplied allocator.  For\n   * non-default allocators we do not optimize away invocation of\n   * destroy() even if _Tp has a trivial destructor.\n   */\n\n  template&lt;typename _ForwardIterator, typename _Allocator&gt;\n    void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n\t     _Allocator&amp; __alloc)\n    {\n      for (; __first != __last; ++__first)\n#if __cplusplus &lt; 201103L\n\t__alloc.destroy(std::__addressof(*__first));\n#else\n\tallocator_traits&lt;_Allocator&gt;::destroy(__alloc,\n\t\t\t\t\t      std::__addressof(*__first));\n#endif\n    }\n\n  template&lt;typename _ForwardIterator, typename _Tp&gt;\n    inline void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n\t     allocator&lt;_Tp&gt;&amp;)\n    {\n      _Destroy(__first, __last);\n    }\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n#endif // _ALLOC_TRAITS_H\n"}, "/usr/include/c++/11/ext/new_allocator.h": {"id": "/usr/include/c++/11/ext/new_allocator.h", "filePath": "/usr/include/c++/11/ext/new_allocator.h", "content": "// Allocator that wraps operator new -*- C++ -*-\n\n// Copyright (C) 2001-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n/** @file ext/new_allocator.h\n *  This file is a GNU extension to the Standard C++ Library.\n */\n\n#ifndef _NEW_ALLOCATOR_H\n#define _NEW_ALLOCATOR_H 1\n\n#include &lt;bits/c++config.h&gt;\n#include &lt;new&gt;\n#include &lt;bits/functexcept.h&gt;\n#include &lt;bits/move.h&gt;\n#if __cplusplus &gt;= 201103L\n#include &lt;type_traits&gt;\n#endif\n\nnamespace __gnu_cxx _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   *  @brief  An allocator that uses global new, as per C++03 [20.4.1].\n   *  @ingroup allocators\n   *\n   *  This is precisely the allocator defined in the C++ Standard.\n   *    - all allocation calls operator new\n   *    - all deallocation calls operator delete\n   *\n   *  @tparam  _Tp  Type of allocated object.\n   */\n  template&lt;typename _Tp&gt;\n    class new_allocator\n    {\n    public:\n      typedef _Tp        value_type;\n      typedef std::size_t     size_type;\n      typedef std::ptrdiff_t  difference_type;\n#if __cplusplus &lt;= 201703L\n      typedef _Tp*       pointer;\n      typedef const _Tp* const_pointer;\n      typedef _Tp&amp;       reference;\n      typedef const _Tp&amp; const_reference;\n\n      template&lt;typename _Tp1&gt;\n\tstruct rebind\n\t{ typedef new_allocator&lt;_Tp1&gt; other; };\n#endif\n\n#if __cplusplus &gt;= 201103L\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2103. propagate_on_container_move_assignment\n      typedef std::true_type propagate_on_container_move_assignment;\n#endif\n\n      _GLIBCXX20_CONSTEXPR\n      new_allocator() _GLIBCXX_USE_NOEXCEPT { }\n\n      _GLIBCXX20_CONSTEXPR\n      new_allocator(const new_allocator&amp;) _GLIBCXX_USE_NOEXCEPT { }\n\n      template&lt;typename _Tp1&gt;\n\t_GLIBCXX20_CONSTEXPR\n\tnew_allocator(const new_allocator&lt;_Tp1&gt;&amp;) _GLIBCXX_USE_NOEXCEPT { }\n\n#if __cplusplus &lt;= 201703L\n      ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }\n\n      pointer\n      address(reference __x) const _GLIBCXX_NOEXCEPT\n      { return std::__addressof(__x); }\n\n      const_pointer\n      address(const_reference __x) const _GLIBCXX_NOEXCEPT\n      { return std::__addressof(__x); }\n#endif\n\n      // NB: __n is permitted to be 0.  The C++ standard says nothing\n      // about what the return value is when __n == 0.\n      _GLIBCXX_NODISCARD _Tp*\n      allocate(size_type __n, const void* = static_cast&lt;const void*&gt;(0))\n      {\n#if __cplusplus &gt;= 201103L\n\t // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t // 3308. std::allocator&lt;void&gt;().allocate(n)\n\t static_assert(sizeof(_Tp) != 0, &quot;cannot allocate incomplete types&quot;);\n#endif\n\n\tif (__builtin_expect(__n &gt; this-&gt;_M_max_size(), false))\n\t  {\n\t    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t    // 3190. allocator::allocate sometimes returns too little storage\n\t    if (__n &gt; (std::size_t(-1) / sizeof(_Tp)))\n\t      std::__throw_bad_array_new_length();\n\t    std::__throw_bad_alloc();\n\t  }\n\n#if __cpp_aligned_new\n\tif (alignof(_Tp) &gt; __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n\t  {\n\t    std::align_val_t __al = std::align_val_t(alignof(_Tp));\n\t    return static_cast&lt;_Tp*&gt;(::operator new(__n * sizeof(_Tp), __al));\n\t  }\n#endif\n\treturn static_cast&lt;_Tp*&gt;(::operator new(__n * sizeof(_Tp)));\n      }\n\n      // __p is not permitted to be a null pointer.\n      void\n      deallocate(_Tp* __p, size_type __t __attribute__ ((__unused__)))\n      {\n#if __cpp_aligned_new\n\tif (alignof(_Tp) &gt; __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n\t  {\n\t    ::operator delete(__p,\n# if __cpp_sized_deallocation\n\t\t\t      __t * sizeof(_Tp),\n# endif\n\t\t\t      std::align_val_t(alignof(_Tp)));\n\t    return;\n\t  }\n#endif\n\t::operator delete(__p\n#if __cpp_sized_deallocation\n\t\t\t  , __t * sizeof(_Tp)\n#endif\n\t\t\t );\n      }\n\n#if __cplusplus &lt;= 201703L\n      size_type\n      max_size() const _GLIBCXX_USE_NOEXCEPT\n      { return _M_max_size(); }\n\n#if __cplusplus &gt;= 201103L\n      template&lt;typename _Up, typename... _Args&gt;\n\tvoid\n\tconstruct(_Up* __p, _Args&amp;&amp;... __args)\n\tnoexcept(std::is_nothrow_constructible&lt;_Up, _Args...&gt;::value)\n\t{ ::new((void *)__p) _Up(std::forward&lt;_Args&gt;(__args)...); }\n\n      template&lt;typename _Up&gt;\n\tvoid\n\tdestroy(_Up* __p)\n\tnoexcept(std::is_nothrow_destructible&lt;_Up&gt;::value)\n\t{ __p-&gt;~_Up(); }\n#else\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 402. wrong new expression in [some_] allocator::construct\n      void\n      construct(pointer __p, const _Tp&amp; __val)\n      { ::new((void *)__p) _Tp(__val); }\n\n      void\n      destroy(pointer __p) { __p-&gt;~_Tp(); }\n#endif\n#endif // ! C++20\n\n      template&lt;typename _Up&gt;\n\tfriend _GLIBCXX20_CONSTEXPR bool\n\toperator==(const new_allocator&amp;, const new_allocator&lt;_Up&gt;&amp;)\n\t_GLIBCXX_NOTHROW\n\t{ return true; }\n\n#if __cpp_impl_three_way_comparison &lt; 201907L\n      template&lt;typename _Up&gt;\n\tfriend _GLIBCXX20_CONSTEXPR bool\n\toperator!=(const new_allocator&amp;, const new_allocator&lt;_Up&gt;&amp;)\n\t_GLIBCXX_NOTHROW\n\t{ return false; }\n#endif\n\n    private:\n      _GLIBCXX_CONSTEXPR size_type\n      _M_max_size() const _GLIBCXX_USE_NOEXCEPT\n      {\n#if __PTRDIFF_MAX__ &lt; __SIZE_MAX__\n\treturn std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);\n#else\n\treturn std::size_t(-1) / sizeof(_Tp);\n#endif\n      }\n    };\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_BASE_LEVELEDSHE_H\n#define LBCRYPTO_CRYPTO_BASE_LEVELEDSHE_H\n\n#include &quot;lattice/lat-hal.h&quot;\n#include &quot;key/publickey-fwd.h&quot;\n#include &quot;key/privatekey-fwd.h&quot;\n#include &quot;key/evalkey-fwd.h&quot;\n#include &quot;encoding/plaintext-fwd.h&quot;\n#include &quot;ciphertext-fwd.h&quot;\n#include &quot;utils/caller_info.h&quot;\n#include &quot;utils/inttypes.h&quot;\n#include &quot;utils/exception.h&quot;\n\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\n/**\n * @brief Abstract interface class for LBC SHE algorithms\n * @tparam Element a ring element.\n */\ntemplate &lt;class Element&gt;\nclass LeveledSHEBase {\n    using ParmType = typename Element::Params;\n    using IntType  = typename Element::Integer;\n    using DugType  = typename Element::DugType;\n    using DggType  = typename Element::DggType;\n    using TugType  = typename Element::TugType;\n\npublic:\n    virtual ~LeveledSHEBase() {}\n\n    /////////////////////////////////////////\n    // SHE NEGATION\n    /////////////////////////////////////////\n\n    /**\n   * Virtual function to define the homomorphic negation of\n   * ciphertext.\n   *\n   * @param &amp;ciphertext the input ciphertext.\n   * @return new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalNegate(ConstCiphertext&lt;Element&gt; ciphertext) const;\n\n    /**\n   * Virtual function to define the interface for homomorphic negation of\n   * ciphertext.\n   *\n   * @param &amp;ciphertext the input ciphertext.\n   * @return new ciphertext.\n   */\n    virtual void EvalNegateInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext) const;\n\n    /////////////////////////////////////////\n    // SHE ADDITION\n    /////////////////////////////////////////\n\n    /**\n   * Virtual function to define the interface for homomorphic addition of\n   * ciphertexts.\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                        ConstCiphertext&lt;Element&gt; ciphertext2) const;\n\n    /**\n   * Virtual function to define the interface for in-place homomorphic addition\n   * of ciphertexts.\n   *\n   * @param ciphertext1 the input/output ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   */\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const;\n\n    /**\n   * Virtual function to define the interface for homomorphic addition of\n   * ciphertexts. This is the mutable version - input ciphertexts may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalAddMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1,\n                                               Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalAddMutable is not implemented for this scheme&quot;);\n    }\n\n    virtual void EvalAddMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalAddMutable is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the interface for homomorphic addition of\n   * ciphertexts.\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const;\n\n    /**\n   * Virtual function to define the interface for homomorphic addition of\n   * ciphertexts.\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   */\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, ConstPlaintext plaintext) const;\n\n    /**\n   * Virtual function to define the interface for homomorphic addition of\n   * ciphertexts. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalAddMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalAddMutable is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the interface for homomorphic addition of\n   * ciphertexts. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    virtual void EvalAddMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalAddMutable is not implemented for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, const NativeInteger&amp; constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;integer scalar addition is not implemented for this scheme&quot;);\n    }\n\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const NativeInteger&amp; constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;integer scalar addition is not implemented for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;double scalar addition is not implemented for this scheme&quot;);\n    }\n\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;double scalar addition is not implemented for this scheme&quot;);\n    }\n\n    /////////////////////////////////////////\n    // SHE SUBTRACTION\n    /////////////////////////////////////////\n\n    /**\n   * Virtual function to define the interface for homomorphic subtraction of\n   * ciphertexts.\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                        ConstCiphertext&lt;Element&gt; ciphertext2) const;\n\n    /**\n   * Virtual function to define the interface for homomorphic subtraction of\n   * ciphertexts.\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   */\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const;\n\n    /**\n   * Virtual function to define the interface for homomorphic subtraction of\n   * ciphertexts. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalSubMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1,\n                                               Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalSubMutable is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the interface for homomorphic subtraction of\n   * ciphertexts. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    virtual void EvalSubMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalSubMutable is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the interface for homomorphic subtraction of\n   * ciphertexts.\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const;\n\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, ConstPlaintext plaintext) const;\n\n    /**\n   * Virtual function to define the interface for homomorphic subtraction of\n   * ciphertexts. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalSubMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalSubMutable is not implemented for this scheme&quot;);\n    }\n\n    virtual void EvalSubMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalSubMutable is not implemented for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, const NativeInteger&amp; constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;integer scalar subtraction is not implemented for this scheme&quot;);\n    }\n\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const NativeInteger&amp; constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;integer scalar subtraction is not implemented for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;double scalar subtraction is not implemented for this scheme&quot;);\n    }\n\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;double scalar subtraction is not implemented for this scheme&quot;);\n    }\n\n    //------------------------------------------------------------------------------\n    // SHE MULTIPLICATION\n    //------------------------------------------------------------------------------\n\n    /**\n   * Virtual function to define the interface for generating a evaluation key\n   * which is used after each multiplication.\n   *\n   * @param &amp;ciphertext1 first input ciphertext.\n   * @param &amp;ciphertext2 second input ciphertext.\n   * @param &amp;ek is the evaluation key to make the newCiphertext decryptable by\n   * the same secret key as that of ciphertext1 and ciphertext2.\n   * @param *newCiphertext the new resulting ciphertext.\n   */\n    virtual EvalKey&lt;Element&gt; EvalMultKeyGen(const PrivateKey&lt;Element&gt; privateKey) const;\n\n    /**\n   * Virtual function to define the interface for generating a evaluation key\n   * which is used after each multiplication for depth more than 2.\n   *\n   * @param &amp;originalPrivateKey Original private key used for encryption.\n   * @param *evalMultKeys the resulting evalution key vector list.\n   */\n    virtual std::vector&lt;EvalKey&lt;Element&gt;&gt; EvalMultKeysGen(const PrivateKey&lt;Element&gt; privateKey) const;\n\n    //------------------------------------------------------------------------------\n    // EVAL MULTIPLICATION CIPHERTEXT &amp; CIPHERTEXT\n    //------------------------------------------------------------------------------\n\n    /**\n   * Virtual function to define the interface for multiplicative homomorphic\n   * evaluation of ciphertext.\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                         ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalMult is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the interface for multiplicative homomorphic\n   * evaluation of ciphertext. This is the mutable version - input ciphertexts\n   * may change (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalMultMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1,\n                                                Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalMultMutable is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the interface for multiplicative homomorphic\n   * evaluation of ciphertext.\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalSquare(ConstCiphertext&lt;Element&gt; ciphertext1) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalSquare is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the interface for multiplicative homomorphic\n   * evaluation of ciphertext. This is the mutable version - input ciphertexts\n   * may change (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalSquareMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalSquareMutable is not implemented for this scheme&quot;);\n    }\n\n    //------------------------------------------------------------------------------\n    // EVAL MULTIPLICATION CIPHERTEXT &amp; PLAINTEXT\n    //------------------------------------------------------------------------------\n\n    /**\n   * Virtual function to define the interface for multiplication of ciphertext\n   * by plaintext.\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const;\n\n    virtual void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, ConstPlaintext plaintext) const;\n\n    /**\n   * Virtual function to define the interface for multiplication of ciphertext\n   * by plaintext. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalMultMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalMultMutable C,P is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the interface for multiplication of ciphertext\n   * by plaintext. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    virtual void EvalMultMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalMultMutableInPlace C P is not implemented for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; MultByMonomial(ConstCiphertext&lt;Element&gt; ciphertext, usint power) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;MultByMonomial is not implemented for this scheme&quot;);\n    }\n\n    virtual void MultByMonomialInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, usint power) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;MultByMonomialInPlace is not implemented for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext, const NativeInteger&amp; constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;integer scalar multiplication is not implemented for this scheme&quot;);\n    }\n\n    virtual void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const NativeInteger&amp; constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;integer scalar multiplication is not implemented for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;double scalar multiplication is not implemented for this scheme&quot;);\n    }\n\n    virtual void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;double scalar multiplication is not implemented for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;DCRTPoly&gt; MultByInteger(ConstCiphertext&lt;DCRTPoly&gt; ciphertext, uint64_t integer) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;MultByInteger is not implemented for this scheme&quot;);\n    }\n\n    virtual void MultByIntegerInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, uint64_t integer) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;MultByIntegerInPlace is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the interface for multiplicative homomorphic\n   * evaluation of ciphertext using the evaluation key.\n   *\n   * @param &amp;ciphertext1 first input ciphertext.\n   * @param &amp;ciphertext2 second input ciphertext.\n   * @param &amp;ek is the evaluation key to make the newCiphertext decryptable by\n   * the same secret key as that of ciphertext1 and ciphertext2.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2,\n                                         const EvalKey&lt;Element&gt; evalKey) const;\n\n    virtual void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2,\n                                 const EvalKey&lt;Element&gt; evalKey) const;\n\n    /**\n   * Virtual function to define the interface for multiplicative homomorphic\n   * evaluation of ciphertext using the evaluation key. This is the mutable\n   * version - input ciphertext may change (automatically rescaled, or towers\n   * dropped).\n   *\n   * @param &amp;ciphertext1 first input ciphertext.\n   * @param &amp;ciphertext2 second input ciphertext.\n   * @param &amp;ek is the evaluation key to make the newCiphertext decryptable by\n   * the same secret key as that of ciphertext1 and ciphertext2.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalMultMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2,\n                                                const EvalKey&lt;Element&gt; evalKey) const;\n\n    /**\n   * Virtual function to define the interface for multiplicative homomorphic\n   * evaluation of ciphertext using the evaluation key. This is the mutable\n   * version - input ciphertext may change (automatically rescaled, or towers\n   * dropped).\n   *\n   * @param &amp;ciphertext1 first input ciphertext.\n   * @param &amp;ciphertext2 second input ciphertext.\n   * @param &amp;ek is the evaluation key to make the newCiphertext decryptable by\n   * the same secret key as that of ciphertext1 and ciphertext2.\n   * @return the new ciphertext.\n   */\n    virtual void EvalMultMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2,\n                                        const EvalKey&lt;Element&gt; evalKey) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalSquare(ConstCiphertext&lt;Element&gt; ciphertext, const EvalKey&lt;Element&gt; evalKey) const;\n\n    virtual void EvalSquareInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, const EvalKey&lt;Element&gt; evalKey) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalSquareMutable(Ciphertext&lt;Element&gt;&amp; ciphertext,\n                                                  const EvalKey&lt;Element&gt; evalKey) const;\n    /**\n   * Virtual function to define the interface for multiplicative homomorphic\n   * evaluation of ciphertext using the evaluation key.\n   *\n   * @param ct1 first input ciphertext.\n   * @param ct2 second input ciphertext.\n   * @param ek is the evaluation key to make the newCiphertext\n   *  decryptable by the same secret key as that of ciphertext1 and\n   * ciphertext2.\n   * @param *newCiphertext the new resulting ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalMultAndRelinearize(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                       ConstCiphertext&lt;Element&gt; ciphertext2,\n                                                       const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec) const;\n\n    /**\n   * Virtual function to do relinearization\n   *\n   * @param ciphertext input ciphertext.\n   * @param ek are the evaluation keys to make the newCiphertext\n   *  decryptable by the same secret key as that of ciphertext1 and\n   * ciphertext2.\n   * @return the new resulting ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; Relinearize(ConstCiphertext&lt;Element&gt; ciphertext,\n                                            const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec) const;\n\n    /**\n   * Virtual function to do relinearization\n   *\n   * @param ciphertext input ciphertext.\n   * @param ek are the evaluation keys to make the newCiphertext\n   *  decryptable by the same secret key as that of ciphertext1 and\n   * ciphertext2.\n   * @return the new resulting ciphertext.\n   */\n    virtual void RelinearizeInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext,\n                                    const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec) const;\n\n    //------------------------------------------------------------------------------\n    // SHE AUTOMORPHISM\n    //------------------------------------------------------------------------------\n\n    /**\n   * Virtual function to generate automophism keys for a given private key;\n   * Uses the private key for encryption\n   *\n   * @param privateKey private key.\n   * @param indexList list of automorphism indices to be computed\n   * @return returns the evaluation keys\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalAutomorphismKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::vector&lt;usint&gt;&amp; indexList) const;\n\n    /**\n   * Virtual function to generate all isomorphism keys for a given private key\n   *\n   * @param publicKey encryption key for the new ciphertext.\n   * @param origPrivateKey original private key used for decryption.\n   * @param indexList list of automorphism indices to be computed\n   * @return returns the evaluation keys\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalAutomorphismKeyGen(\n        const PublicKey&lt;Element&gt; publicKey, const PrivateKey&lt;Element&gt; privateKey,\n        const std::vector&lt;usint&gt;&amp; indexList) const {\n        std::string errMsg = &quot;EvalAutomorphismKeyGen is not implemented for this scheme.&quot;;\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, errMsg);\n    }\n\n    /**\n   * Virtual function for evaluating automorphism of ciphertext at index i\n   *\n   * @param ciphertext the input ciphertext.\n   * @param i automorphism index\n   * @param &amp;evalKeys - reference to the vector of evaluation keys generated\n   * by EvalAutomorphismKeyGen.\n   * @return resulting ciphertext\n   */\n    virtual Ciphertext&lt;Element&gt; EvalAutomorphism(ConstCiphertext&lt;Element&gt; ciphertext, usint i,\n                                                 const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap,\n                                                 CALLER_INFO_ARGS_HDR) const;\n\n    /**\n   * Virtual function for the automorphism and key switching step of\n   * hoisted automorphisms.\n   *\n   * @param ct the input ciphertext to perform the automorphism on\n   * @param index the index of the rotation. Positive indices correspond to\n   * left rotations and negative indices correspond to right rotations.\n   * @param m is the cyclotomic order\n   * @param digits the digit decomposition created by\n   * EvalFastRotationPrecompute at the precomputation step.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalFastRotation(ConstCiphertext&lt;Element&gt; ciphertext, const usint index, const usint m,\n                                                 const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits) const;\n\n    /**\n   * Virtual function for the precomputation step of hoisted\n   * automorphisms.\n   *\n   * @param ct the input ciphertext on which to do the precomputation (digit\n   * decomposition)\n   */\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EvalFastRotationPrecompute(ConstCiphertext&lt;Element&gt; ciphertext) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalFastRotationExt(ConstCiphertext&lt;Element&gt; ciphertext, usint index,\n                                                    const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; expandedCiphertext,\n                                                    bool addFirst,\n                                                    const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeys) const {\n        std::string errMsg = &quot;EvalFastRotationExt is not implemented for this scheme.&quot;;\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, errMsg);\n    }\n\n    /**\n   * Generates evaluation keys for a list of indices\n   * Currently works only for power-of-two and cyclic-group cyclotomics\n   *\n   * @param publicKey encryption key for the new ciphertext.\n   * @param origPrivateKey original private key used for decryption.\n   * @param indexList list of indices to be computed\n   * @return returns the evaluation keys\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalAtIndexKeyGen(\n        const PublicKey&lt;Element&gt; publicKey, const PrivateKey&lt;Element&gt; privateKey,\n        const std::vector&lt;int32_t&gt;&amp; indexList) const;\n\n    /**\n   * Moves i-th slot to slot 0\n   *\n   * @param ciphertext.\n   * @param i the index.\n   * @param &amp;evalAtIndexKeys - reference to the map of evaluation keys\n   * generated by EvalAtIndexKeyGen.\n   * @return resulting ciphertext\n   */\n    virtual Ciphertext&lt;Element&gt; EvalAtIndex(ConstCiphertext&lt;Element&gt; ciphertext, int32_t index,\n                                            const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap) const;\n\n    virtual usint FindAutomorphismIndex(usint index, usint m) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;FindAutomorphismIndex is not supported for this scheme&quot;);\n    }\n\n    /////////////////////////////////////////\n    // SHE LEVELED Mod Reduce\n    /////////////////////////////////////////\n\n    /**\n   * Method for Modulus Reduction.\n   *\n   * @param &amp;cipherText Ciphertext to perform mod reduce on.\n   * @param levels the number of towers to drop.\n   */\n    virtual Ciphertext&lt;Element&gt; ModReduce(ConstCiphertext&lt;Element&gt; ciphertext, size_t levels) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ModReduce is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Method for In-place Modulus Reduction.\n   *\n   * @param &amp;cipherText Ciphertext to perform mod reduce on.\n   * @param levels the number of towers to drop.\n   */\n    virtual void ModReduceInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, size_t levels) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ModReduce is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Method for Composed EvalMult\n   *\n   * @param &amp;cipherText1 ciphertext1, first input ciphertext to perform\n   * multiplication on.\n   * @param &amp;cipherText2 cipherText2, second input ciphertext to perform\n   * multiplication on.\n   * @param &amp;quadKeySwitchHint is for resultant quadratic secret key after\n   * multiplication to the secret key of the particular level.\n   * @param &amp;cipherTextResult is the resulting ciphertext that can be\n   * decrypted with the secret key of the particular level.\n   */\n    virtual Ciphertext&lt;Element&gt; ComposedEvalMult(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                 ConstCiphertext&lt;Element&gt; ciphertext2,\n                                                 const EvalKey&lt;Element&gt; evalKey) const;\n\n    /**\n   * Method for Level Reduction from sk -&gt; sk1. This method peforms a\n   * keyswitch on the ciphertext and then performs a modulus reduction.\n   *\n   * @param &amp;cipherText1 is the original ciphertext to be key switched and mod\n   * reduced.\n   * @param &amp;linearKeySwitchHint is the linear key switch hint to perform the\n   * key switch operation.\n   * @param &amp;cipherTextResult is the resulting ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; LevelReduce(ConstCiphertext&lt;Element&gt; ciphertext1, const EvalKey&lt;Element&gt; evalKey,\n                                            size_t levels) const;\n\n    /**\n   * Method for Level Reduction from sk -&gt; sk1. This method peforms a\n   * keyswitch on the ciphertext and then performs a modulus reduction.\n   *\n   * @param &amp;cipherText1 is the original ciphertext to be key switched and mod\n   * reduced.\n   * @param &amp;linearKeySwitchHint is the linear key switch hint to perform the\n   * key switch operation.\n   * @param &amp;cipherTextResult is the resulting ciphertext.\n   */\n    virtual void LevelReduceInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, const EvalKey&lt;Element&gt; evalKey,\n                                    size_t levels) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;LevelReduceInPlace is not supported for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; Compress(ConstCiphertext&lt;Element&gt; ciphertext, size_t towersLeft) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Compress is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Method for rescaling.\n   *\n   * @param cipherText is the ciphertext to perform modreduce on.\n   * @param levels the number of towers to drop.\n   * @return ciphertext after the modulus reduction performed.\n   */\n    virtual Ciphertext&lt;Element&gt; ModReduceInternal(ConstCiphertext&lt;Element&gt; ciphertext, size_t levels) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ModReduce is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Method for rescaling in-place.\n   *\n   * @param cipherText is the ciphertext to perform modreduce on.\n   * @param levels the number of towers to drop.\n   * @details \\p cipherText will have modulus reduction performed in-place.\n   */\n    virtual void ModReduceInternalInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, size_t levels) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ModReduce is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Method for Level Reduction in the CKKS scheme. It just drops &quot;levels&quot;\n   * number of the towers of the ciphertext without changing the underlying\n   * plaintext.\n   *\n   * @param cipherText1 is the original ciphertext to be level reduced.\n   * @param levels the number of towers to drop.\n   * @return resulting ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; LevelReduceInternal(ConstCiphertext&lt;Element&gt; ciphertext, size_t levels) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;LevelReduce is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Method for in-place Level Reduction in the CKKS scheme. It just drops\n   * &quot;levels&quot; number of the towers of the ciphertext without changing the\n   * underlying plaintext.\n   *\n   * @param cipherText1 is the ciphertext to be level reduced in-place\n   * @param levels the number of towers to drop.\n   */\n    virtual void LevelReduceInternalInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, size_t levels) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;LevelReduce is not supported for this scheme&quot;);\n    }\n\n    virtual void AdjustLevelsInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Leveled Operations are not supported for this scheme&quot;);\n    }\n\n    virtual void AdjustLevelsAndDepthInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Mutable Operations are not supported for this scheme&quot;);\n    }\n\n    virtual void AdjustLevelsAndDepthToOneInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1,\n                                                  Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Mutable Operations are not supported for this scheme&quot;);\n    }\n\n    // TODO (Andrey) : Move these functions to protected or to rns?\n    virtual void AdjustForAddOrSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Mutable Operations are not supported for this scheme&quot;);\n    }\n\n    virtual void AdjustForMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Mutable Operations are not supported for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; MorphPlaintext(ConstPlaintext plaintext, ConstCiphertext&lt;Element&gt; ciphertext) const;\n\nprotected:\n    /////////////////////////////////////////\n    // CORE OPERATIONS\n    /////////////////////////////////////////\n\n    /**\n   * Internal function for in-place homomorphic addition of ciphertexts.\n   * This method does not check whether input ciphertexts are\n   * at the same level.\n   *\n   * @param ciphertext1 first input/output ciphertext.\n   * @param ciphertext2 second input ciphertext.\n   * @return \\p ciphertext1 contains the result of the homomorphic addition of\n   * input ciphertexts.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalAddCore(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                            ConstCiphertext&lt;Element&gt; ciphertext2) const;\n\n    /**\n   * Internal function for in-place homomorphic addition of ciphertexts.\n   * This method does not check whether input ciphertexts are\n   * at the same level.\n   *\n   * @param ciphertext1 first input/output ciphertext.\n   * @param ciphertext2 second input ciphertext.\n   * @return \\p ciphertext1 contains the result of the homomorphic addition of\n   * input ciphertexts.\n   */\n    void EvalAddCoreInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalSubCore(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                            ConstCiphertext&lt;Element&gt; ciphertext2) const;\n\n    /**\n   * Internal function for in-place homomorphic addition of ciphertexts.\n   * This method does not check whether input ciphertexts are\n   * at the same level.\n   *\n   * @param ciphertext1 first input/output ciphertext.\n   * @param ciphertext2 second input ciphertext.\n   * @return \\p ciphertext1 contains the result of the homomorphic addition of\n   * input ciphertexts.\n   */\n    void EvalSubCoreInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const;\n\n    /**\n   * Internal function for homomorphic multiplication of ciphertexts.\n   * This method does not check whether input ciphertexts are\n   * at the same level.\n   *\n   * @param ciphertext1 first input ciphertext.\n   * @param ciphertext2 second input ciphertext.\n   * @return result of homomorphic multiplication of input ciphertexts.\n   */\n    Ciphertext&lt;Element&gt; EvalMultCore(ConstCiphertext&lt;Element&gt; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const;\n\n    Ciphertext&lt;Element&gt; EvalSquareCore(ConstCiphertext&lt;Element&gt; ciphertext) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalAddCore(ConstCiphertext&lt;Element&gt; ciphertext, const Element plaintext) const;\n\n    void EvalAddCoreInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const Element plaintext) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalSubCore(ConstCiphertext&lt;Element&gt; ciphertext1, const Element plaintext) const;\n\n    void EvalSubCoreInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, const Element plaintext) const;\n\n    Ciphertext&lt;Element&gt; EvalMultCore(ConstCiphertext&lt;Element&gt; ciphertext, const Element plaintext) const;\n\n    void EvalMultCoreInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const Element plaintext) const;\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_BASE_SCHEME_H\n#define LBCRYPTO_CRYPTO_BASE_SCHEME_H\n\n#include &quot;key/evalkey-fwd.h&quot;\n#include &quot;schemebase/base-parametergeneration.h&quot;\n#include &quot;keyswitch/keyswitch-base.h&quot;\n#include &quot;schemebase/base-advancedshe.h&quot;\n#include &quot;schemebase/base-leveledshe.h&quot;\n#include &quot;schemebase/base-multiparty.h&quot;\n#include &quot;schemebase/base-fhe.h&quot;\n#include &quot;schemebase/base-pke.h&quot;\n#include &quot;schemebase/base-pre.h&quot;\n#include &quot;ciphertext.h&quot;\n\n#include &quot;key/keypair.h&quot;\n\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/caller_info.h&quot;\n\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;memory&gt;\n#include &lt;utility&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\n\ntemplate &lt;typename Element&gt;\nclass KeyPair;\n\n// TODO: fix DCRTPoly passed by value\n\n/**\n * @brief Abstract interface for public key encryption schemes\n * @tparam Element a ring element.\n */\ntemplate &lt;typename Element&gt;\nclass SchemeBase {\n    using ParmType = typename Element::Params;\n    using IntType  = typename Element::Integer;\n    using DugType  = typename Element::DugType;\n    using DggType  = typename Element::DggType;\n    using TugType  = typename Element::TugType;\n\nprotected:\n    inline void CheckMultipartyDecryptCompatibility(ConstCiphertext&lt;Element&gt;&amp; ciphertext, CALLER_INFO_ARGS_HDR) const {\n        if (ciphertext-&gt;GetElements().size() &gt; 2) {\n            std::string errorMsg(std::string(&quot;ciphertext&#x27;s number of elements is [&quot;) +\n                                 std::to_string(ciphertext-&gt;GetElements().size()) +\n                                 &quot;]. Must be 2 or less for Multiparty Decryption.&quot; + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(openfhe_error, errorMsg);\n        }\n    }\n\npublic:\n    SchemeBase() {}\n\n    virtual ~SchemeBase() {}\n\n    virtual bool operator==(const SchemeBase&amp; sch) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;operator== is not supported&quot;);\n    }\n\n    virtual bool operator!=(const SchemeBase&amp; sch) const {\n        return !(*this == sch);\n    }\n\n    /**\n   * Enable features with a bit mast of PKESchemeFeature codes\n   * @param mask\n   */\n    virtual void Enable(usint mask) {\n        if (mask &amp; PKE)\n            Enable(PKE);\n        if (mask &amp; KEYSWITCH)\n            Enable(KEYSWITCH);\n        if (mask &amp; LEVELEDSHE)\n            Enable(LEVELEDSHE);\n        if (mask &amp; ADVANCEDSHE)\n            Enable(ADVANCEDSHE);\n        if (mask &amp; PRE)\n            Enable(PRE);\n        if (mask &amp; MULTIPARTY)\n            Enable(MULTIPARTY);\n        if (mask &amp; FHE)\n            Enable(FHE);\n        if (mask &amp; SCHEMESWITCH)\n            Enable(SCHEMESWITCH);\n    }\n\n    virtual usint GetEnabled() const {\n        usint flag = 0;\n        if (m_PKE != nullptr)\n            flag |= PKE;\n        if (m_KeySwitch != nullptr)\n            flag |= KEYSWITCH;\n        if (m_LeveledSHE != nullptr)\n            flag |= LEVELEDSHE;\n        if (m_AdvancedSHE != nullptr)\n            flag |= ADVANCEDSHE;\n        if (m_PRE != nullptr)\n            flag |= PRE;\n        if (m_Multiparty != nullptr)\n            flag |= MULTIPARTY;\n        if (m_FHE != nullptr)\n            flag |= FHE;\n        if (m_SchemeSwitch != nullptr)\n            flag |= SCHEMESWITCH;\n        return flag;\n    }\n\n    // instantiated in the scheme implementation class\n    virtual void Enable(PKESchemeFeature feature) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Enable is not implemented&quot;);\n    }\n\n    //------------------------------------------------------------------------------\n    // PARAMETER GENERATION WRAPPER\n    //------------------------------------------------------------------------------\n\n    virtual bool ParamsGenBFVRNS(std::shared_ptr&lt;CryptoParametersBase&lt;Element&gt;&gt; cryptoParams, uint32_t evalAddCount,\n                                 uint32_t multiplicativeDepth, uint32_t keySwitchCount, size_t dcrtBits, uint32_t n,\n                                 uint32_t numPartQ) const {\n        if (!m_ParamsGen)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;m_ParamsGen is nullptr&quot;);\n        return m_ParamsGen-&gt;ParamsGenBFVRNS(cryptoParams, evalAddCount, multiplicativeDepth, keySwitchCount, dcrtBits,\n                                            n, numPartQ);\n    }\n\n    virtual bool ParamsGenCKKSRNS(std::shared_ptr&lt;CryptoParametersBase&lt;Element&gt;&gt; cryptoParams, usint cyclOrder,\n                                  usint numPrimes, usint scalingModSize, usint firstModSize, uint32_t numPartQ,\n                                  COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel) const {\n        if (!m_ParamsGen)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;m_ParamsGen is nullptr&quot;);\n        return m_ParamsGen-&gt;ParamsGenCKKSRNS(cryptoParams, cyclOrder, numPrimes, scalingModSize, firstModSize, numPartQ,\n                                             mPIntBootCiphertextCompressionLevel);\n    }\n\n    virtual bool ParamsGenBGVRNS(std::shared_ptr&lt;CryptoParametersBase&lt;DCRTPoly&gt;&gt; cryptoParams, uint32_t evalAddCount,\n                                 uint32_t keySwitchCount, usint cyclOrder, usint numPrimes, usint firstModSize,\n                                 usint dcrtBits, uint32_t numPartQ, usint multihopQBound) const {\n        if (!m_ParamsGen)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;m_ParamsGen is nullptr&quot;);\n        return m_ParamsGen-&gt;ParamsGenBGVRNS(cryptoParams, evalAddCount, keySwitchCount, cyclOrder, numPrimes,\n                                            firstModSize, dcrtBits, numPartQ, multihopQBound);\n    }\n\n    /////////////////////////////////////////\n    // PKE WRAPPER\n    /////////////////////////////////////////\n\n    virtual KeyPair&lt;Element&gt; KeyGen(CryptoContext&lt;Element&gt; cc, bool makeSparse) {\n        VerifyPKEEnabled(__func__);\n        return m_PKE-&gt;KeyGenInternal(cc, makeSparse);\n    }\n\n    virtual Ciphertext&lt;Element&gt; Encrypt(const Element&amp; plaintext, const PrivateKey&lt;Element&gt; privateKey) const {\n        VerifyPKEEnabled(__func__);\n        //      if (!plaintext)\n        //        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n\n        return m_PKE-&gt;Encrypt(plaintext, privateKey);\n    }\n\n    virtual Ciphertext&lt;Element&gt; Encrypt(const Element&amp; plaintext, const PublicKey&lt;Element&gt; publicKey) const {\n        VerifyPKEEnabled(__func__);\n        //      if (!plaintext)\n        //        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        if (!publicKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input public key is nullptr&quot;);\n\n        return m_PKE-&gt;Encrypt(plaintext, publicKey);\n    }\n\n    virtual DecryptResult Decrypt(ConstCiphertext&lt;Element&gt; ciphertext, const PrivateKey&lt;Element&gt; privateKey,\n                                  NativePoly* plaintext) const {\n        VerifyPKEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        return m_PKE-&gt;Decrypt(ciphertext, privateKey, plaintext);\n    }\n\n    virtual DecryptResult Decrypt(ConstCiphertext&lt;Element&gt; ciphertext, const PrivateKey&lt;Element&gt; privateKey,\n                                  Poly* plaintext) const {\n        VerifyPKEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        return m_PKE-&gt;Decrypt(ciphertext, privateKey, plaintext);\n    }\n\n    std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EncryptZeroCore(const PrivateKey&lt;Element&gt; privateKey) const {\n        VerifyPKEEnabled(__func__);\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        return m_PKE-&gt;EncryptZeroCore(privateKey, nullptr);\n    }\n\n    std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EncryptZeroCore(const PublicKey&lt;Element&gt; publicKey) const {\n        VerifyPKEEnabled(__func__);\n        if (!publicKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input public key is nullptr&quot;);\n        return m_PKE-&gt;EncryptZeroCore(publicKey, nullptr);\n    }\n\n    Element DecryptCore(ConstCiphertext&lt;Element&gt; ciphertext, const PrivateKey&lt;Element&gt; privateKey) const {\n        VerifyPKEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        return m_PKE-&gt;DecryptCore(ciphertext-&gt;GetElements(), privateKey);\n    }\n\n    /////////////////////////////////////////\n    // KEY SWITCH WRAPPER\n    /////////////////////////////////////////\n\n    virtual EvalKey&lt;Element&gt; KeySwitchGen(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                          const PrivateKey&lt;Element&gt; newPrivateKey) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!oldPrivateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first private key is nullptr&quot;);\n        if (!newPrivateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second private key is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchGenInternal(oldPrivateKey, newPrivateKey);\n    }\n\n    virtual EvalKey&lt;Element&gt; KeySwitchGen(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                          const PrivateKey&lt;Element&gt; newPrivateKey,\n                                          const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!oldPrivateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first private key is nullptr&quot;);\n        if (!newPrivateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second private key is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input eval key is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchGenInternal(oldPrivateKey, newPrivateKey, evalKey);\n    }\n\n    virtual EvalKey&lt;Element&gt; KeySwitchGen(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                          const PublicKey&lt;Element&gt; newPublicKey) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!oldPrivateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first private key is nullptr&quot;);\n        if (!newPublicKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second public key is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchGenInternal(oldPrivateKey, newPublicKey);\n    }\n\n    virtual Ciphertext&lt;Element&gt; KeySwitch(ConstCiphertext&lt;Element&gt; ciphertext, const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitch(ciphertext, evalKey);\n    }\n\n    virtual void KeySwitchInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        m_KeySwitch-&gt;KeySwitchInPlace(ciphertext, evalKey);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; KeySwitchDown(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchDown(ciphertext);\n    }\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EvalKeySwitchPrecomputeCore(\n        const Element&amp; c, std::shared_ptr&lt;CryptoParametersBase&lt;Element&gt;&gt; cryptoParamsBase) const {\n        VerifyKeySwitchEnabled(__func__);\n        return m_KeySwitch-&gt;EvalKeySwitchPrecomputeCore(c, cryptoParamsBase);\n    }\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EvalFastKeySwitchCoreExt(\n        const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits, const EvalKey&lt;Element&gt; evalKey,\n        const std::shared_ptr&lt;ParmType&gt; params) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (nullptr == digits)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input digits is nullptr&quot;);\n        if (digits-&gt;size() == 0)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input digits size is 0&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        if (!params)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input params is nullptr&quot;);\n        return m_KeySwitch-&gt;EvalFastKeySwitchCoreExt(digits, evalKey, params);\n    }\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EvalFastKeySwitchCore(\n        const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits, const EvalKey&lt;Element&gt; evalKey,\n        const std::shared_ptr&lt;ParmType&gt; params) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (nullptr == digits)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input digits is nullptr&quot;);\n        if (digits-&gt;size() == 0)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input digits size is 0&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        if (!params)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input params is nullptr&quot;);\n        return m_KeySwitch-&gt;EvalFastKeySwitchCore(digits, evalKey, params);\n    }\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; KeySwitchCore(const Element&amp; a,\n                                                                const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchCore(a, evalKey);\n    }\n\n    /////////////////////////////////////////\n    // PRE WRAPPER\n    /////////////////////////////////////////\n\n    virtual EvalKey&lt;Element&gt; ReKeyGen(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                      const PublicKey&lt;Element&gt; newPublicKey) const;\n\n    virtual Ciphertext&lt;Element&gt; ReEncrypt(ConstCiphertext&lt;Element&gt; ciphertext, const EvalKey&lt;Element&gt; evalKey,\n                                          const PublicKey&lt;Element&gt; publicKey) const;\n\n    /////////////////////////////////////////\n    // SHE NEGATION WRAPPER\n    /////////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalNegate(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalNegate(ciphertext);\n    }\n\n    virtual void EvalNegateInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalNegateInPlace(ciphertext);\n        return;\n    }\n\n    /////////////////////////////////////////\n    // SHE ADDITION Wrapper\n    /////////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                        ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalAdd(ciphertext1, ciphertext2);\n    }\n\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalAddInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalAddMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1,\n                                               Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalAddMutable(ciphertext1, ciphertext2);\n    }\n\n    virtual void EvalAddMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalAddMutableInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalAdd(ciphertext, plaintext);\n    }\n\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, ConstPlaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalAddInPlace(ciphertext, plaintext);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalAddMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalAddMutable(ciphertext, plaintext);\n    }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, const NativeInteger &amp;constant) const {\n    //  VerifyLeveledSHEEnabled(__func__);\n    //  if (!ciphertext)\n    //      &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n\n    //  return m_LeveledSHE-&gt;EvalAdd(ciphertext, constant);\n    //}\n\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const NativeInteger&amp; constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalAddInPlace(ciphertext, constant);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalAdd(ciphertext, constant);\n    }\n\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalAddInPlace(ciphertext, constant);\n        return;\n    }\n\n    /////////////////////////////////////////\n    // SHE SUBTRACTION Wrapper\n    /////////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                        ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSub(ciphertext1, ciphertext2);\n    }\n\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalSubInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSubMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1,\n                                               Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSubMutable(ciphertext1, ciphertext2);\n    }\n\n    virtual void EvalSubMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalSubMutableInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSub(ciphertext, plaintext);\n    }\n\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, ConstPlaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalSubInPlace(ciphertext, plaintext);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSubMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSubMutable(ciphertext, plaintext);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, const NativeInteger&amp; constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSub(ciphertext, constant);\n    }\n\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const NativeInteger&amp; constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalSubInPlace(ciphertext, constant);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSub(ciphertext, constant);\n    }\n\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalSubInPlace(ciphertext, constant);\n        return;\n    }\n\n    /////////////////////////////////////////\n    // SHE MULTIPLICATION Wrapper\n    /////////////////////////////////////////\n\n    virtual EvalKey&lt;Element&gt; EvalMultKeyGen(const PrivateKey&lt;Element&gt; privateKey) const;\n\n    virtual std::vector&lt;EvalKey&lt;Element&gt;&gt; EvalMultKeysGen(const PrivateKey&lt;Element&gt; privateKey) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                         ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMult(ciphertext1, ciphertext2);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMultMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1,\n                                                Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMultMutable(ciphertext1, ciphertext2);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSquare(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSquare(ciphertext);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSquareMutable(Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSquareMutable(ciphertext);\n    }\n\n    /////////////////////////////////////////\n    // MULTIPLICATION With Eval Key\n    /////////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2,\n                                         const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMult(ciphertext1, ciphertext2, evalKey);\n    }\n\n    virtual void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2,\n                                 const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalMultInPlace(ciphertext1, ciphertext2, evalKey);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMultMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2,\n                                                const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMultMutable(ciphertext1, ciphertext2, evalKey);\n    }\n\n    virtual void EvalMultMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2,\n                                        const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalMultMutableInPlace(ciphertext1, ciphertext2, evalKey);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSquare(ConstCiphertext&lt;Element&gt; ciphertext, const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSquare(ciphertext, evalKey);\n    }\n\n    virtual void EvalSquareInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalSquareInPlace(ciphertext, evalKey);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSquareMutable(Ciphertext&lt;Element&gt;&amp; ciphertext,\n                                                  const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSquareMutable(ciphertext, evalKey);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMultAndRelinearize(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                       ConstCiphertext&lt;Element&gt; ciphertext2,\n                                                       const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        if (!evalKeyVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key vector is empty&quot;);\n        return m_LeveledSHE-&gt;EvalMultAndRelinearize(ciphertext1, ciphertext2, evalKeyVec);\n    }\n\n    virtual Ciphertext&lt;Element&gt; Relinearize(ConstCiphertext&lt;Element&gt; ciphertext,\n                                            const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKeyVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key vector is empty&quot;);\n        return m_LeveledSHE-&gt;Relinearize(ciphertext, evalKeyVec);\n    }\n\n    virtual void RelinearizeInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext,\n                                    const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKeyVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key vector is empty&quot;);\n        m_LeveledSHE-&gt;RelinearizeInPlace(ciphertext, evalKeyVec);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMult(ciphertext, plaintext);\n    }\n\n    virtual void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, ConstPlaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalMultInPlace(ciphertext, plaintext);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMultMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMultMutable(ciphertext, plaintext);\n    }\n\n    virtual Ciphertext&lt;Element&gt; MultByMonomial(ConstCiphertext&lt;Element&gt; ciphertext, usint power) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;MultByMonomial(ciphertext, power);\n    }\n\n    virtual void MultByMonomialInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, usint power) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;MultByMonomialInPlace(ciphertext, power);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMult(ciphertext, constant);\n    }\n\n    virtual void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalMultInPlace(ciphertext, constant);\n        return;\n    }\n\n    virtual Ciphertext&lt;DCRTPoly&gt; MultByInteger(ConstCiphertext&lt;DCRTPoly&gt; ciphertext, uint64_t integer) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;MultByInteger(ciphertext, integer);\n    }\n\n    virtual void MultByIntegerInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, uint64_t integer) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;MultByIntegerInPlace(ciphertext, integer);\n        return;\n    }\n\n    /////////////////////////////////////////\n    // SHE AUTOMORPHISM Wrapper\n    /////////////////////////////////////////\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalAutomorphismKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::vector&lt;usint&gt;&amp; indexList) const;\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalAutomorphismKeyGen(\n        const PublicKey&lt;Element&gt; publicKey, const PrivateKey&lt;Element&gt; privateKey,\n        const std::vector&lt;usint&gt;&amp; indexList) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalAutomorphism(ConstCiphertext&lt;Element&gt; ciphertext, usint i,\n                                                 const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap,\n                                                 CALLER_INFO_ARGS_HDR) const {\n        if (m_LeveledSHE) {\n            if (!ciphertext)\n                &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n            if (!evalKeyMap.size())\n                &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is empty&quot;);\n\n            return m_LeveledSHE-&gt;EvalAutomorphism(ciphertext, i, evalKeyMap);\n        }\n        std::string errorMsg(std::string(&quot;EvalAutomorphism operation has not been enabled&quot;) + CALLER_INFO);\n        &quot;hey&quot;; OPENFHE_THROW(config_error, errorMsg);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalFastRotation(ConstCiphertext&lt;Element&gt; ciphertext, const usint index, const usint m,\n                                                 const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalFastRotation(ciphertext, index, m, digits);\n    }\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EvalFastRotationPrecompute(\n        ConstCiphertext&lt;Element&gt; ciphertext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalFastRotationPrecompute(ciphertext);\n    }\n\n    /**\n   * Only supported for hybrid key switching.\n   * Performs fast (hoisted) rotation and returns the results\n   * in the extended CRT basis P*Q\n   *\n   * @param ciphertext input ciphertext\n   * @param index the rotation index.\n   * @param precomp the precomputed digits for the ciphertext\n   * @param addFirst if true, the the first element c0 is also computed (otherwise ignored)\n   * @return resulting ciphertext\n   */\n    virtual Ciphertext&lt;Element&gt; EvalFastRotationExt(ConstCiphertext&lt;Element&gt; ciphertext, usint index,\n                                                    const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits, bool addFirst,\n                                                    const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeys) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalFastRotationExt(ciphertext, index, digits, addFirst, evalKeys);\n    }\n\n    /**\n   * Only supported for hybrid key switching.\n   * Scales down the polynomial c0 from extended basis P*Q to Q.\n   *\n   * @param ciphertext input ciphertext in the extended basis\n   * @return resulting polynomial\n   */\n    Element KeySwitchDownFirstElement(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchDownFirstElement(ciphertext);\n    }\n\n    virtual Ciphertext&lt;Element&gt; KeySwitchExt(ConstCiphertext&lt;Element&gt; ciphertext, bool addFirst) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchExt(ciphertext, addFirst);\n    }\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalAtIndexKeyGen(\n        const PublicKey&lt;Element&gt; publicKey, const PrivateKey&lt;Element&gt; privateKey,\n        const std::vector&lt;int32_t&gt;&amp; indexList) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalAtIndex(ConstCiphertext&lt;Element&gt; ciphertext, usint i,\n                                            const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is empty&quot;);\n        return m_LeveledSHE-&gt;EvalAtIndex(ciphertext, i, evalKeyMap);\n    }\n\n    virtual usint FindAutomorphismIndex(usint index, usint m) {\n        VerifyLeveledSHEEnabled(__func__);\n        return m_LeveledSHE-&gt;FindAutomorphismIndex(index, m);\n    }\n\n    /////////////////////////////////////////\n    // SHE Leveled Methods Wrapper\n    /////////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; ComposedEvalMult(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                 ConstCiphertext&lt;Element&gt; ciphertext2,\n                                                 const EvalKey&lt;Element&gt; evalKey) const;\n\n    virtual Ciphertext&lt;Element&gt; ModReduce(ConstCiphertext&lt;Element&gt; ciphertext, size_t levels) const;\n\n    virtual void ModReduceInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;ModReduceInPlace(ciphertext, levels);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; ModReduceInternal(ConstCiphertext&lt;Element&gt; ciphertext, size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;ModReduceInternal(ciphertext, levels);\n    }\n\n    virtual void ModReduceInternalInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (levels == 0)\n            return;\n        m_LeveledSHE-&gt;ModReduceInternalInPlace(ciphertext, levels);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; LevelReduce(ConstCiphertext&lt;Element&gt; ciphertext, const EvalKey&lt;Element&gt; evalKey,\n                                            size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        auto result = m_LeveledSHE-&gt;LevelReduce(ciphertext, evalKey, levels);\n        result-&gt;SetKeyTag(ciphertext-&gt;GetKeyTag());\n        return result;\n    }\n\n    virtual void LevelReduceInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const EvalKey&lt;Element&gt; evalKey,\n                                    size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;LevelReduceInPlace(ciphertext, evalKey, levels);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; LevelReduceInternal(ConstCiphertext&lt;Element&gt; ciphertext, size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;LevelReduceInternal(ciphertext, levels);\n    }\n\n    virtual void LevelReduceInternalInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;LevelReduceInternalInPlace(ciphertext, levels);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; Compress(ConstCiphertext&lt;Element&gt; ciphertext, size_t towersLeft) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;Compress(ciphertext, towersLeft);\n    }\n\n    virtual void AdjustLevelsInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1, Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext1 is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext2 is nullptr&quot;);\n        m_LeveledSHE-&gt;AdjustLevelsInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    virtual void AdjustLevelsAndDepthInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1,\n                                             Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext1 is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext2 is nullptr&quot;);\n        m_LeveledSHE-&gt;AdjustLevelsAndDepthInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    virtual void AdjustLevelsAndDepthToOneInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1,\n                                                  Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext1 is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext2 is nullptr&quot;);\n        m_LeveledSHE-&gt;AdjustLevelsAndDepthToOneInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    /////////////////////////////////////////\n    // Advanced SHE Wrapper\n    /////////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalAddMany(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalAddMany(ciphertextVec);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalAddManyInPlace(std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n\n        return m_AdvancedSHE-&gt;EvalAddManyInPlace(ciphertextVec);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMultMany(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                             const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n        if (!evalKeyVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key vector is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalMultMany(ciphertextVec, evalKeyVec);\n    }\n\n    /////////////////////////////////////\n    // Advanced SHE LINEAR WEIGHTED SUM\n    /////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalLinearWSum(std::vector&lt;ConstCiphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                               const std::vector&lt;double&gt;&amp; constantVec) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalLinearWSum(ciphertextVec, constantVec);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalLinearWSumMutable(std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                                      const std::vector&lt;double&gt;&amp; constantVec) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalLinearWSumMutable(ciphertextVec, constantVec);\n    }\n\n    /////////////////////////////////////\n    // Advanced SHE EVAL POLYNOMIAL\n    /////////////////////////////////////\n\n    Ciphertext&lt;Element&gt; EvalPoly(ConstCiphertext&lt;Element&gt; ciphertext, const std::vector&lt;double&gt;&amp; coefficients) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;EvalPoly(ciphertext, coefficients);\n    }\n\n    Ciphertext&lt;Element&gt; EvalPolyLinear(ConstCiphertext&lt;Element&gt; ciphertext,\n                                       const std::vector&lt;double&gt;&amp; coefficients) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;EvalPolyLinear(ciphertext, coefficients);\n    }\n\n    Ciphertext&lt;Element&gt; EvalPolyPS(ConstCiphertext&lt;Element&gt; ciphertext, const std::vector&lt;double&gt;&amp; coefficients) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;EvalPolyPS(ciphertext, coefficients);\n    }\n\n    /////////////////////////////////////\n    // Advanced SHE EVAL CHEBYSHEV SERIES\n    /////////////////////////////////////\n\n    Ciphertext&lt;Element&gt; EvalChebyshevSeries(ConstCiphertext&lt;Element&gt; ciphertext,\n                                            const std::vector&lt;double&gt;&amp; coefficients, double a, double b) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;EvalChebyshevSeries(ciphertext, coefficients, a, b);\n    }\n\n    Ciphertext&lt;Element&gt; EvalChebyshevSeriesLinear(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                  const std::vector&lt;double&gt;&amp; coefficients, double a, double b) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;EvalChebyshevSeriesLinear(ciphertext, coefficients, a, b);\n    }\n\n    Ciphertext&lt;Element&gt; EvalChebyshevSeriesPS(ConstCiphertext&lt;Element&gt; ciphertext,\n                                              const std::vector&lt;double&gt;&amp; coefficients, double a, double b) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;EvalChebyshevSeriesPS(ciphertext, coefficients, a, b);\n    }\n\n    /////////////////////////////////////\n    // Advanced SHE EVAL SUM\n    /////////////////////////////////////\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSumKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                                                             const PublicKey&lt;Element&gt; publicKey) const;\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSumRowsKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                                                                 const PublicKey&lt;Element&gt; publicKey,\n                                                                                 usint rowSize, usint subringDim) const;\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSumColsKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const PublicKey&lt;Element&gt; publicKey) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalSum(ConstCiphertext&lt;Element&gt; ciphertext, usint batchSize,\n                                        const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalSum(ciphertext, batchSize, evalKeyMap);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSumRows(ConstCiphertext&lt;Element&gt; ciphertext, usint rowSize,\n                                            const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap,\n                                            usint subringDim) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalSumRows(ciphertext, rowSize, evalKeyMap, subringDim);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSumCols(ConstCiphertext&lt;Element&gt; ciphertext, usint batchSize,\n                                            const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap,\n                                            const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; rightEvalKeyMap) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!evalKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first evaluation key map is empty&quot;);\n        if (!rightEvalKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second evaluation key map is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalSumCols(ciphertext, batchSize, evalKeyMap, rightEvalKeyMap);\n    }\n\n    /////////////////////////////////////\n    // Advanced SHE EVAL INNER PRODUCT\n    /////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalInnerProduct(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                 ConstCiphertext&lt;Element&gt; ciphertext2, usint batchSize,\n                                                 const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalSumKeyMap,\n                                                 const EvalKey&lt;Element&gt; evalMultKey) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalInnerProduct(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext,\n                                                 usint batchSize,\n                                                 const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalSumKeyMap) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        if (!evalSumKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalInnerProduct(ciphertext, plaintext, batchSize, evalSumKeyMap);\n    }\n\n    virtual Ciphertext&lt;Element&gt; AddRandomNoise(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;AddRandomNoise(ciphertext);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMerge(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                          const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n        if (!evalKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalMerge(ciphertextVec, evalKeyMap);\n    }\n\n    /////////////////////////////////////////\n    // MULTIPARTY WRAPPER\n    /////////////////////////////////////////\n\n    virtual KeyPair&lt;Element&gt; MultipartyKeyGen(CryptoContext&lt;Element&gt; cc,\n                                              const std::vector&lt;PrivateKey&lt;Element&gt;&gt;&amp; privateKeyVec, bool makeSparse);\n\n    virtual KeyPair&lt;Element&gt; MultipartyKeyGen(CryptoContext&lt;Element&gt; cc, const PublicKey&lt;Element&gt; publicKey,\n                                              bool makeSparse, bool PRE);\n\n    virtual Ciphertext&lt;Element&gt; MultipartyDecryptMain(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                      const PrivateKey&lt;Element&gt; privateKey) const;\n\n    virtual Ciphertext&lt;Element&gt; MultipartyDecryptLead(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                      const PrivateKey&lt;Element&gt; privateKey) const;\n\n    virtual DecryptResult MultipartyDecryptFusion(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                                  NativePoly* plaintext) const {\n        VerifyMultipartyEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n\n        return m_Multiparty-&gt;MultipartyDecryptFusion(ciphertextVec, plaintext);\n    }\n\n    virtual DecryptResult MultipartyDecryptFusion(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                                  Poly* plaintext) const {\n        VerifyMultipartyEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n        return m_Multiparty-&gt;MultipartyDecryptFusion(ciphertextVec, plaintext);\n    }\n\n    virtual EvalKey&lt;Element&gt; MultiKeySwitchGen(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                               const PrivateKey&lt;Element&gt; newPrivateKey,\n                                               const EvalKey&lt;Element&gt; evalKey) const;\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiEvalAutomorphismKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalAutoKeyMap,\n        const std::vector&lt;usint&gt;&amp; indexList, const std::string&amp; keyId);\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiEvalAtIndexKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalAutoKeyMap,\n        const std::vector&lt;int32_t&gt;&amp; indexList, const std::string&amp; keyId);\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiEvalSumKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalSumKeyMap,\n        const std::string&amp; keyId = &quot;&quot;);\n\n    virtual EvalKey&lt;Element&gt; MultiAddEvalKeys(EvalKey&lt;Element&gt; evalKey1, EvalKey&lt;Element&gt; evalKey2,\n                                              const std::string&amp; keyId);\n\n    virtual EvalKey&lt;Element&gt; MultiMultEvalKey(PrivateKey&lt;Element&gt; privateKey, EvalKey&lt;Element&gt; evalKey,\n                                              const std::string&amp; keyId);\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiAddEvalSumKeys(\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalSumKeyMap1,\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalSumKeyMap2, const std::string&amp; keyId);\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiAddEvalAutomorphismKeys(\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalSumKeyMap1,\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalSumKeyMap2, const std::string&amp; keyId);\n\n    virtual PublicKey&lt;Element&gt; MultiAddPubKeys(PublicKey&lt;Element&gt; publicKey1, PublicKey&lt;Element&gt; publicKey2,\n                                               const std::string&amp; keyId);\n\n    virtual EvalKey&lt;Element&gt; MultiAddEvalMultKeys(EvalKey&lt;Element&gt; evalKey1, EvalKey&lt;Element&gt; evalKey2,\n                                                  const std::string&amp; keyId);\n\n    virtual Ciphertext&lt;Element&gt; IntMPBootAdjustScale(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        if (m_Multiparty) {\n            return m_Multiparty-&gt;IntMPBootAdjustScale(ciphertext);\n        }\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;IntMPBootAdjustScale operation has not been enabled&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; IntMPBootRandomElementGen(std::shared_ptr&lt;CryptoParametersCKKSRNS&gt; cryptoParameters,\n                                                          const PublicKey&lt;Element&gt; publicKey) const {\n        if (m_Multiparty) {\n            return m_Multiparty-&gt;IntMPBootRandomElementGen(cryptoParameters, publicKey);\n        }\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;IntMPBootRandomElementGen operation has not been enabled&quot;);\n    }\n\n    virtual std::vector&lt;Ciphertext&lt;Element&gt;&gt; IntMPBootDecrypt(const PrivateKey&lt;Element&gt; privateKey,\n                                                              ConstCiphertext&lt;Element&gt; ciphertext,\n                                                              ConstCiphertext&lt;Element&gt; a) const {\n        if (m_Multiparty) {\n            return m_Multiparty-&gt;IntMPBootDecrypt(privateKey, ciphertext, a);\n        }\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;IntMPBootDecrypt operation has not been enabled&quot;);\n    }\n\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; IntMPBootAdd(std::vector&lt;std::vector&lt;Ciphertext&lt;Element&gt;&gt;&gt;&amp; sharesPairVec) const {\n        if (m_Multiparty) {\n            return m_Multiparty-&gt;IntMPBootAdd(sharesPairVec);\n        }\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;IntMPBootAdd operation has not been enabled&quot;);\n    }\n\n    Ciphertext&lt;Element&gt; IntMPBootEncrypt(const PublicKey&lt;Element&gt; publicKey,\n                                         const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; sharesPair, ConstCiphertext&lt;Element&gt; a,\n                                         ConstCiphertext&lt;Element&gt; ciphertext) const {\n        if (m_Multiparty) {\n            return m_Multiparty-&gt;IntMPBootEncrypt(publicKey, sharesPair, a, ciphertext);\n        }\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;IntMPBootEncrypt operation has not been enabled&quot;);\n    }\n\n    // FHE METHODS\n\n    // TODO Andrey: do we need this method?\n    //  const std::shared_ptr&lt;PKEBase&lt;Element&gt;&gt; getAlgorithm() const { return m_PKE; }\n\n    void EvalBootstrapSetup(const CryptoContextImpl&lt;Element&gt;&amp; cc, const std::vector&lt;uint32_t&gt;&amp; levelBudget = {5, 4},\n                            const std::vector&lt;uint32_t&gt;&amp; dim1 = {0, 0}, uint32_t slots = 0,\n                            uint32_t correctionFactor = 0) {\n        VerifyFHEEnabled(__func__);\n        m_FHE-&gt;EvalBootstrapSetup(cc, levelBudget, dim1, slots, correctionFactor);\n        return;\n    }\n\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalBootstrapKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                                                           uint32_t slots) {\n        VerifyFHEEnabled(__func__);\n        return m_FHE-&gt;EvalBootstrapKeyGen(privateKey, slots);\n    }\n\n    Ciphertext&lt;Element&gt; EvalBootstrap(ConstCiphertext&lt;Element&gt; ciphertext, uint32_t numIterations = 1,\n                                      uint32_t precision = 0) const {\n        VerifyFHEEnabled(__func__);\n        return m_FHE-&gt;EvalBootstrap(ciphertext, numIterations, precision);\n    }\n\n    // SCHEMESWITCHING methods\n\n    std::pair&lt;BinFHEContext, LWEPrivateKey&gt; EvalCKKStoFHEWSetup(const CryptoContextImpl&lt;Element&gt;&amp; cc,\n                                                                SecurityLevel sl      = HEStd_128_classic,\n                                                                BINFHE_PARAMSET slBin = STD128, bool arbFunc = false,\n                                                                uint32_t logQ = 29, bool dynamic = false,\n                                                                uint32_t numSlotsCKKS = 0, uint32_t logQswitch = 27) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalCKKStoFHEWSetup(cc, sl, slBin, arbFunc, logQ, dynamic, numSlotsCKKS, logQswitch);\n    }\n\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalCKKStoFHEWKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair,\n                                                                            ConstLWEPrivateKey&amp; lwesk,\n                                                                            uint32_t dim1 = 0, uint32_t L = 1) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalCKKStoFHEWKeyGen(keyPair, lwesk, dim1, L);\n    }\n\n    void EvalCKKStoFHEWPrecompute(const CryptoContextImpl&lt;Element&gt;&amp; cc, double scale = 1.0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalCKKStoFHEWPrecompute(cc, scale);\n    }\n\n    std::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt; EvalCKKStoFHEW(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                   uint32_t numCtxts = 0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalCKKStoFHEW(ciphertext, numCtxts);\n    }\n\n    void EvalFHEWtoCKKSSetup(const CryptoContextImpl&lt;DCRTPoly&gt;&amp; ccCKKS, const BinFHEContext&amp; ccLWE,\n                             uint32_t numSlotsCKKS = 0, uint32_t logQ = 25) {\n        VerifySchemeSwitchEnabled(__func__);\n        m_SchemeSwitch-&gt;EvalFHEWtoCKKSSetup(ccCKKS, ccLWE, numSlotsCKKS, logQ);\n        return;\n    }\n\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalFHEWtoCKKSKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair,\n                                                                            ConstLWEPrivateKey&amp; lwesk,\n                                                                            uint32_t numSlots = 0, uint32_t dim1 = 0,\n                                                                            uint32_t L = 0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalFHEWtoCKKSKeyGen(keyPair, lwesk, numSlots, dim1, L);\n    }\n\n    void EvalCompareSwitchPrecompute(const CryptoContextImpl&lt;Element&gt;&amp; ccCKKS, uint32_t pLWE = 0,\n                                     uint32_t initLevel = 0, double scaleSign = 1.0, bool unit = false) {\n        VerifySchemeSwitchEnabled(__func__);\n        m_SchemeSwitch-&gt;EvalCompareSwitchPrecompute(ccCKKS, pLWE, initLevel, scaleSign, unit);\n        return;\n    }\n\n    Ciphertext&lt;Element&gt; EvalFHEWtoCKKS(std::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt;&amp; LWECiphertexts,\n                                       uint32_t numCtxts = 0, uint32_t numSlots = 0, uint32_t p = 4, double pmin = 0.0,\n                                       double pmax = 2.0) const {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalFHEWtoCKKS(LWECiphertexts, numCtxts, numSlots, p, pmin, pmax);\n    }\n\n    std::pair&lt;BinFHEContext, LWEPrivateKey&gt; EvalSchemeSwitchingSetup(const CryptoContextImpl&lt;DCRTPoly&gt;&amp; cc,\n                                                                     SecurityLevel sl      = HEStd_128_classic,\n                                                                     BINFHE_PARAMSET slBin = STD128,\n                                                                     bool arbFunc = false, uint32_t logQ = 29,\n                                                                     bool dynamic = false, uint32_t numSlotsCKKS = 0,\n                                                                     uint32_t logQswitch = 27) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalSchemeSwitchingSetup(cc, sl, slBin, arbFunc, logQ, dynamic, numSlotsCKKS,\n                                                        logQswitch);\n    }\n\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSchemeSwitchingKeyGen(\n        const KeyPair&lt;Element&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk, uint32_t numValues = 0, bool oneHot = true,\n        bool alt = false, uint32_t dim1CF = 0, uint32_t dim1FC = 0, uint32_t LCF = 1, uint32_t LFC = 0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalSchemeSwitchingKeyGen(keyPair, lwesk, numValues, oneHot, alt, dim1CF, dim1FC, LCF,\n                                                         LFC);\n    }\n\n    Ciphertext&lt;Element&gt; EvalCompareSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                   ConstCiphertext&lt;Element&gt; ciphertext2, uint32_t numCtxts = 0,\n                                                   uint32_t numSlots = 0, uint32_t pLWE = 0, double scaleSign = 1.0,\n                                                   bool unit = false) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalCompareSchemeSwitching(ciphertext1, ciphertext2, numCtxts, numSlots, pLWE, scaleSign,\n                                                          unit);\n    }\n\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMinSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                            PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                            uint32_t numSlots = 0, bool oneHot = true,\n                                                            uint32_t pLWE = 0, double scaleSign = 1.0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalMinSchemeSwitching(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE,\n                                                      scaleSign);\n    }\n\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMinSchemeSwitchingAlt(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                               PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                               uint32_t numSlots = 0, bool oneHot = true,\n                                                               uint32_t pLWE = 0, double scaleSign = 1.0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalMinSchemeSwitchingAlt(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE,\n                                                         scaleSign);\n    }\n\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMaxSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                            PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                            uint32_t numSlots = 0, bool oneHot = true,\n                                                            uint32_t pLWE = 0, double scaleSign = 1.0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalMaxSchemeSwitching(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE,\n                                                      scaleSign);\n    }\n\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMaxSchemeSwitchingAlt(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                               PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                               uint32_t numSlots = 0, bool oneHot = true,\n                                                               uint32_t pLWE = 0, double scaleSign = 1.0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalMaxSchemeSwitchingAlt(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE,\n                                                         scaleSign);\n    }\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::make_nvp(&quot;enabled&quot;, GetEnabled()));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                 &quot; is from a later version of the library&quot;);\n        }\n\n        usint enabled;\n        ar(::cereal::make_nvp(&quot;enabled&quot;, enabled));\n        Enable(enabled);\n    }\n\n    virtual std::string SerializedObjectName() const {\n        return &quot;SchemeBase&quot;;\n    }\n\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\n    //=================================================================================================================\n    // Functions to check enabled features in the cryptocontext\n    //=================================================================================================================\n    /**\n    * @brief VerifyAdvancedSHEEnabled is to check if Enable(ADVANCEDSHE) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyAdvancedSHEEnabled(const std::string&amp; functionName) const {\n        if (m_AdvancedSHE == nullptr) {\n            std::string errMsg = std::string(functionName) +\n                                 &quot; operation has not been enabled. Enable(ADVANCEDSHE) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n    /**\n    * @brief VerifyMultipartyEnabled is to check if Enable(MULTIPARTY) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyMultipartyEnabled(const std::string&amp; functionName) const {\n        if (m_Multiparty == nullptr) {\n            std::string errMsg = std::string(functionName) +\n                                 &quot; operation has not been enabled. Enable(MULTIPARTY) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n    /**\n    * @brief VerifyLeveledSHEEnabled is to check if Enable(LEVELEDSHE) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyLeveledSHEEnabled(const std::string&amp; functionName) const {\n        if (m_LeveledSHE == nullptr) {\n            std::string errMsg = std::string(functionName) +\n                                 &quot; operation has not been enabled. Enable(LEVELEDSHE) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n    /**\n    * @brief VerifyPKEEnabled is to check if Enable(PKE) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyPKEEnabled(const std::string&amp; functionName) const {\n        if (m_PKE == nullptr) {\n            std::string errMsg =\n                std::string(functionName) + &quot; operation has not been enabled. Enable(PKE) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n    /**\n    * @brief VerifyPREEnabled is to check if Enable(PRE) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyPREEnabled(const std::string&amp; functionName) const {\n        if (m_PRE == nullptr) {\n            std::string errMsg =\n                std::string(functionName) + &quot; operation has not been enabled. Enable(PRE) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n    /**\n    * @brief VerifyKeySwitchEnabled is to check if Enable(KEYSWITCH) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyKeySwitchEnabled(const std::string&amp; functionName) const {\n        if (m_KeySwitch == nullptr) {\n            std::string errMsg = std::string(functionName) +\n                                 &quot; operation has not been enabled. Enable(KEYSWITCH) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n    /**\n    * @brief VerifyFHEEnabled is to check if Enable(FHE) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyFHEEnabled(const std::string&amp; functionName) const {\n        if (m_FHE == nullptr) {\n            std::string errMsg =\n                std::string(functionName) + &quot; operation has not been enabled. Enable(FHE) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n\n    /**\n    * @brief VerifySchemeSwitchEnabled is to check if Enable(SCHEMESWITCH) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifySchemeSwitchEnabled(const std::string&amp; functionName) const {\n        if (m_SchemeSwitch == nullptr) {\n            std::string errMsg = std::string(functionName) +\n                                 &quot; operation has not been enabled. Enable(SCHEMESWITCH) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const SchemeBase&lt;Element&gt;&amp; s) {\n        out &lt;&lt; typeid(s).name() &lt;&lt; &quot;:&quot;;\n        out &lt;&lt; &quot; ParamsGen &quot; &lt;&lt; (s.m_ParamsGen == 0 ? &quot;none&quot; : typeid(*s.m_ParamsGen).name());\n        out &lt;&lt; &quot;, PKE &quot; &lt;&lt; (s.m_PKE == 0 ? &quot;none&quot; : typeid(*s.m_PKE).name());\n        out &lt;&lt; &quot;, KeySwitch &quot; &lt;&lt; (s.m_KeySwitch == 0 ? &quot;none&quot; : typeid(*s.m_KeySwitch).name());\n        out &lt;&lt; &quot;, PRE &quot; &lt;&lt; (s.m_PRE == 0 ? &quot;none&quot; : typeid(*s.m_PRE).name());\n        out &lt;&lt; &quot;, LeveledSHE &quot; &lt;&lt; (s.m_LeveledSHE == 0 ? &quot;none&quot; : typeid(*s.m_LeveledSHE).name());\n        out &lt;&lt; &quot;, AdvancedSHE &quot; &lt;&lt; (s.m_AdvancedSHE == 0 ? &quot;none&quot; : typeid(*s.m_AdvancedSHE).name());\n        out &lt;&lt; &quot;, Multiparty &quot; &lt;&lt; (s.m_Multiparty == 0 ? &quot;none&quot; : typeid(*s.m_Multiparty).name());\n        out &lt;&lt; &quot;, FHE &quot; &lt;&lt; (s.m_FHE == 0 ? &quot;none&quot; : typeid(*s.m_FHE).name());\n        out &lt;&lt; &quot;, SchemeSwitch &quot; &lt;&lt; (s.m_SchemeSwitch == 0 ? &quot;none&quot; : typeid(*s.m_SchemeSwitch).name());\n\n        return out;\n    }\n\nprotected:\n    std::shared_ptr&lt;ParameterGenerationBase&lt;Element&gt;&gt; m_ParamsGen;\n    std::shared_ptr&lt;PKEBase&lt;Element&gt;&gt; m_PKE;\n    std::shared_ptr&lt;KeySwitchBase&lt;Element&gt;&gt; m_KeySwitch;\n    std::shared_ptr&lt;PREBase&lt;Element&gt;&gt; m_PRE;\n    std::shared_ptr&lt;LeveledSHEBase&lt;Element&gt;&gt; m_LeveledSHE;\n    std::shared_ptr&lt;AdvancedSHEBase&lt;Element&gt;&gt; m_AdvancedSHE;\n    std::shared_ptr&lt;MultipartyBase&lt;Element&gt;&gt; m_Multiparty;\n    std::shared_ptr&lt;FHEBase&lt;Element&gt;&gt; m_FHE;\n    std::shared_ptr&lt;FHEBase&lt;Element&gt;&gt; m_SchemeSwitch;\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_BASE_FHE_H\n#define LBCRYPTO_CRYPTO_BASE_FHE_H\n\n#include &quot;key/privatekey-fwd.h&quot;\n#include &quot;key/evalkey-fwd.h&quot;\n#include &quot;ciphertext-fwd.h&quot;\n#include &quot;cryptocontext-fwd.h&quot;\n#include &quot;utils/exception.h&quot;\n\n#include &quot;binfhecontext.h&quot;\n#include &quot;key/keypair.h&quot;\n\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;utility&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\n\n/**\n * @brief Abstract interface class for LBC PRE algorithms\n * @tparam Element a ring element.\n */\ntemplate &lt;class Element&gt;\nclass FHEBase {\npublic:\n    virtual ~FHEBase() {}\n\n    /**\n   * Bootstrap functionality:\n   * There are three methods that have to be called in this specific order:\n   * 1. EvalBootstrapSetup: computes and encodes the coefficients for encoding and\n   * decoding and stores the necessary parameters\n   * 2. EvalBootstrapKeyGen: computes and stores the keys for rotations and conjugation\n   * 3. EvalBootstrap: refreshes the given ciphertext\n   */\n\n    /**\n   * Sets all parameters for the linear method for the FFT-like method\n   *\n   * @param levelBudget - vector of budgets for the amount of levels in encoding\n   * and decoding\n   * @param dim1 - vector of inner dimension in the baby-step giant-step routine\n   * for encoding and decoding\n   * @param slots - number of slots to be bootstrapped\n   * @param correctionFactor - value to rescale message by to improve precision. If set to 0, we use the default logic. This value is only used when NATIVE_SIZE=64.\n   */\n    virtual void EvalBootstrapSetup(const CryptoContextImpl&lt;Element&gt;&amp; cc, std::vector&lt;uint32_t&gt; levelBudget,\n                                    std::vector&lt;uint32_t&gt; dim1, uint32_t slots, uint32_t correctionFactor) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;Not supported&quot;);\n    }\n\n    /**\n   * Virtual function to define the generation of all automorphism keys for EvalBT (with FFT evaluation).\n   * EvalBTKeyGen uses the baby-step/giant-step strategy.\n   *\n   * @param privateKey private key.\n   * @param slots - number of slots to be bootstrapped\n   * @return the dictionary of evaluation key indices.\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalBootstrapKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                                                                   uint32_t slots) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;Not supported&quot;);\n    }\n\n    /**\n   * Defines the bootstrapping evaluation of ciphertext\n   *\n   * The flavor of bootstrapping that uses the numIterations and precision parameters is described\n   * in the Meta-BTS paper.\n   * Source: Bae Y., Cheon J., Cho W., Kim J., and Kim T. META-BTS: Bootstrapping Precision\n   * Beyond the Limit. Cryptology ePrint Archive, Report\n   * 2022/1167. (https://eprint.iacr.org/2022/1167.pdf)\n   *\n   * @param ciphertext the input ciphertext.\n   * @param numIterations number of iterations to run iterative bootstrapping (Meta-BTS). Increasing the iterations increases the precision of bootstrapping.\n   * @param precision precision of initial bootstrapping algorithm. This value is\n   * determined by the user experimentally by first running EvalBootstrap with numIterations = 1 and precision = 0 (unused).\n   * @return the refreshed ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalBootstrap(ConstCiphertext&lt;Element&gt; ciphertext, uint32_t numIterations,\n                                              uint32_t precision) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalBootstrap is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Sets all parameters for switching from CKKS to FHEW\n   *\n   * @param cc the CKKS cryptocontext from which to switch\n   * @param sl security level for CKKS cryptocontext\n   * @param slBin security level for FHEW cryptocontext\n   * @param arbFunc whether the binfhecontext should be created for arbitrary function evaluation or not\n   * @param logQ size of ciphertext modulus in FHEW for large-precision evaluation\n   * @param dynamic whether to use dynamic mode for FHEW\n   * @param numSlotsCKKS number of slots in CKKS encryption\n   * @param logQswitch size of ciphertext modulus in intermediate switch for security with the FHEW ring dimension\n   * @return the FHEW cryptocontext and its secret key (if a method from extracting the binfhecontext\n   * from the secret key is created, then we can only return the secret key)\n   */\n    virtual std::pair&lt;BinFHEContext, LWEPrivateKey&gt; EvalCKKStoFHEWSetup(const CryptoContextImpl&lt;Element&gt;&amp; cc,\n                                                                        SecurityLevel sl, BINFHE_PARAMSET slBin,\n                                                                        bool arbFunc, uint32_t logQ, bool dynamic,\n                                                                        uint32_t numSlotsCKKS, uint32_t logQswitch) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalCKKStoFHEWSetup is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the generation of all keys for scheme switching between CKKS and FHEW:\n   * the rotation keys for the baby-step/giant-step strategy,\n   * conjugation keys, switching key from CKKS to FHEW\n   * @param keypair CKKS key pair\n   * @param lwesk FHEW secret key\n   * @param dim1 baby-step for the linear transform\n   * @param L level on which the hom. decoding matrix should be. We want the hom. decoded ciphertext to be on the last level\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalCKKStoFHEWKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair,\n                                                                                    ConstLWEPrivateKey&amp; lwesk,\n                                                                                    uint32_t dim1, uint32_t L) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalCKKStoFHEWKeyGen is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Performs precomputations for the homomorphic decoding in CKKS. Given as a separate method than EvalCKKStoFHEWSetup\n   * to allow the user to specify a scale that depends on the CKKS and FHEW cryptocontexts\n   *\n   * @param cc the CKKS cryptocontext from which to switch\n   * @param scale factor with which to scale the matrix in the linear transform\n   * @param dim1 baby-step for the linear transform\n   * @param L level on which the hom. decoding matrix should be. We want the hom. decoded ciphertext to be on the last level\n   */\n    virtual void EvalCKKStoFHEWPrecompute(const CryptoContextImpl&lt;Element&gt;&amp; cc, double scale) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalCKKStoFHEWPrecompute is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Performs the scheme switching on a CKKS ciphertext\n   * @param ciphertext CKKS ciphertext to switch\n   * @param numCtxts number of coefficients to extract from the CKKS ciphertext. If it is zero, it defaults to number of slots\n   * @return a vector of LWE ciphertexts of length the numCtxts\n   */\n    virtual std::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt; EvalCKKStoFHEW(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                           uint32_t numCtxts) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalCKKStoFHEW is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Sets all parameters for switching from FHEW to CKKS. The CKKS cryptocontext to switch to is\n   * already generated.\n   *\n   * @param ccCKKS the CKKS cryptocontext to switch to\n   * @param ccLWE the FHEW cryptocontext from which to switch\n   * @param numSlotsCKKS number of FHEW ciphertexts that becomes the number of slots in CKKS encryption\n   * @param logQ the logarithm of a ciphertext modulus in FHEW\n   */\n    virtual void EvalFHEWtoCKKSSetup(const CryptoContextImpl&lt;Element&gt;&amp; ccCKKS, const BinFHEContext&amp; ccLWE,\n                                     uint32_t numSlotsCKKS, uint32_t logQ) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalFHEWtoCKKSSetup is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Generates all keys for scheme switching: the rotation keys for the baby-step/giant-step strategy\n   * in the linear transform for the partial decryption, the switching key from FHEW to CKKS\n   *\n   * @param keypair CKKS key pair\n   * @param lwesk FHEW secret key\n   * @param numSlots number of slots for the CKKS encryption of the FHEW secret key\n   * @param dim1 baby-step for the linear transform\n   * @param L level on which the hom. decoding matrix should be. We want the hom. decoded ciphertext to be on the last level\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalFHEWtoCKKSKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair,\n                                                                                    ConstLWEPrivateKey&amp; lwesk,\n                                                                                    uint32_t numSlots,\n                                                                                    uint32_t dim1 = 0, uint32_t L = 0) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalFHEWtoCKKSKeyGen is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Performs precomputations for the homomorphic decoding in CKKS. Given as a separate method than EvalSchemeSwitchingSetup\n   * to allow the user to specify a scale that depends on the CKKS and FHEW cryptocontexts\n   *\n   * @param cc the CKKS cryptocontext from which to switch\n   * @param pLWE the desired plaintext modulus for the new FHEW ciphertexts\n   * @param initLevel the level of the ciphertext that will be switched\n   * @param scaleSign factor to multiply the CKKS ciphertext when switching to FHEW in case the messages are too small;\n   * the resulting FHEW ciphertexts will encrypt values modulo pLWE, so scaleSign should account for this\n   * @param unit whether the input messages are normalized to the unit circle\n   */\n    virtual void EvalCompareSwitchPrecompute(const CryptoContextImpl&lt;Element&gt;&amp; ccCKKS, uint32_t pLWE,\n                                             uint32_t initLevel, double scaleSign, bool unit) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalCompareSwitchPrecompute is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Performs the scheme switching on a vector of FHEW ciphertexts\n   *\n   * @param LWECiphertexts FHEW/LWE ciphertexts to switch\n   * @param numCtxts number of values to encrypt from the LWE ciphertexts in the new CKKS ciphertext\n   * @param numSlots number of slots to encode in the new CKKS/RLWE ciphertext\n   * @param p plaintext modulus to use to decide postscaling, by default p = 4\n   * @param pmin, pmax plaintext space of the resulting messages (by default [0,2] assuming\n   * the LWE ciphertext had plaintext modulus p = 4 and only bits were encrypted)\n   * @return a CKKS ciphertext encrypting in its slots the messages in the LWE ciphertexts\n   */\n    virtual Ciphertext&lt;Element&gt; EvalFHEWtoCKKS(std::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt;&amp; LWECiphertexts,\n                                               uint32_t numCtxts, uint32_t numSlots, uint32_t p, double pmin,\n                                               double pmax) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalFHEWtoCKKS is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Sets all parameters for switching from CKKS to FHEW and back\n   *\n   * @param sl security level for CKKS cryptocontext\n   * @param slBin security level for FHEW cryptocontext\n   * @param arbFunc whether the binfhecontext should be created for arbitrary function evaluation or not\n   * @param logQ size of ciphertext modulus in FHEW for large-precision evaluation\n   * @param dynamic whether to use dynamic mode for FHEW\n   * @param numSlotsCKKS number of slots in CKKS encryption\n   * @param logQswitch size of ciphertext modulus in intermediate switch for security with the FHEW ring dimension\n   * @return the FHEW cryptocontext and its secret key (if a method from extracting the binfhecontext\n   * from the secret key is created, then we can only return the secret key)\n   * TODO: add an overload for when BinFHEContext is already generated and fed as a parameter\n   */\n    virtual std::pair&lt;BinFHEContext, LWEPrivateKey&gt; EvalSchemeSwitchingSetup(const CryptoContextImpl&lt;DCRTPoly&gt;&amp; ccCKKS,\n                                                                             SecurityLevel sl, BINFHE_PARAMSET slBin,\n                                                                             bool arbFunc, uint32_t logQ, bool dynamic,\n                                                                             uint32_t numSlotsCKKS,\n                                                                             uint32_t logQswitch) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalSchemeSwitchingSetup is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Generates all keys for scheme switching: the rotation keys for the baby-step/giant-step strategy\n   * in the linear transform for the homomorphic encoding and partial decryption, the switching key from\n   * FHEW to CKKS\n   *\n   * @param keypair CKKS key pair\n   * @param lwesk FHEW secret key\n   * @param numValues parameter of argmin computation, set to zero if not needed\n   * @param oneHot flag that indicates if the argmin encoding should be one hot\n   * @param alt flag that indicates whether to use the alternative version of argmin which requires fewer automorphism keys\n   * @param dim1CF baby-step for the linear transform in CKKS to FHEW\n   * @param dim1FC baby-step for the linear transform in FHEW to CKKS\n   * @param LCF level on which to do the linear transform in CKKS to FHEW\n   * @param LFC level on which to do the linear transform in FHEW to CKKS\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSchemeSwitchingKeyGen(\n        const KeyPair&lt;Element&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk, uint32_t numValues, bool oneHot, bool alt,\n        uint32_t dim1CF, uint32_t dim1FC, uint32_t LCF, uint32_t LFC) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalSchemeSwitchingKeyGen is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Performs the scheme switching on the difference of two CKKS ciphertexts to compare, evaluates the sign function\n   * over the resulting FHEW ciphertexts, then performs the scheme switching back to a CKKS ciphertext\n   *\n   * @param ciphertext1, ciphertext2 CKKS ciphertexts of messages that need to be compared\n   * @param numCtxts number of coefficients to extract from the CKKS ciphertext. If it is zero, it defaults to number of slots\n   * @param numSlots number of slots to encode the new CKKS ciphertext with\n   * @param pLWE the desired plaintext modulus for the new FHEW ciphertexts. If it is zero, it defaults to the large precision\n   * plaintext modulus Q/2beta\n   * @param scaleSign factor to multiply the CKKS ciphertext when switching to FHEW in case the messages are too small;\n   * the resulting FHEW ciphertexts will encrypt values modulo pLWE, so scaleSign should account for this\n   * @param unit whether the input messages are normalized to the unit circle\n   * @return a CKKS ciphertext encrypting in its slots the sign of  messages in the LWE ciphertexts\n   */\n    virtual Ciphertext&lt;Element&gt; EvalCompareSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                           ConstCiphertext&lt;Element&gt; ciphertext2, uint32_t numCtxts,\n                                                           uint32_t numSlots, uint32_t pLWE, double scaleSign,\n                                                           bool unit) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalCompareSchemeSwitching is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Computes the minimum and argument of the first numValues packed in a CKKS ciphertext via repeated\n   * scheme switchings to FHEW and back.\n   *\n   * @param ciphertext CKKS ciphertexts of values that need to be compared\n   * @param publicKey public key of the CKKS cryptocontext\n   * @param numValues number of values to extract from the CKKS ciphertext. We always assume for the moment numValues is a power of two\n   * @param numSlots number of slots to encode the new CKKS ciphertext with\n   * @param oneHot whether the argmin result is given as a one hot/elementary vector or as the index\n   * @param pLWE the desired plaintext modulus for the new FHEW ciphertexts\n   * @param scaleSign factor to multiply the CKKS ciphertext when switching to FHEW in case the messages are too small;\n   * the resulting FHEW ciphertexts will encrypt values modulo pLWE, so scaleSign should account for this\n   * pLWE and scaleSign are given here only if the homomorphic decoding matrix is not scaled with the desired values\n   * @return a vector of two CKKS ciphertexts where the first encrypts the minimum value and the second encrypts the\n   * index (in the representation specified by oneHot). The ciphertexts have junk after the first slot in the first ciphertext\n   * and after numValues in the second ciphertext if oneHot=true and after the first slot if oneHot=false.\n   */\n    virtual std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMinSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                    PublicKey&lt;Element&gt; publicKey, uint32_t numValues,\n                                                                    uint32_t numSlots, bool oneHot, uint32_t pLWE,\n                                                                    double scaleSign) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalMinSchemeSwitching is not supported for this scheme&quot;);\n    }\n\n    /**\n     * Performs more operations in FHEW than in CKKS. Slightly better precision but slower.\n    */\n    virtual std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMinSchemeSwitchingAlt(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                       PublicKey&lt;Element&gt; publicKey, uint32_t numValues,\n                                                                       uint32_t numSlots, bool oneHot, uint32_t pLWE,\n                                                                       double scaleSign) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalMinSchemeSwitchingAlt is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Computes the maximum and argument of the first numValues packed in a CKKS ciphertext via repeated\n   * scheme switchings to FHEW and back.\n   *\n   * @param ciphertext CKKS ciphertexts of values that need to be compared\n   * @param publicKey public key of the CKKS cryptocontext\n   * @param numValues number of values to extract from the CKKS ciphertext. We always assume for the moment numValues is a power of two\n   * @param numSlots number of slots to encode the new CKKS ciphertext with\n   * @param oneHot whether the argmax result is given as a one hot/elementary vector or as the index\n   * @param pLWE the desired plaintext modulus for the new FHEW ciphertexts\n   * @param scaleSign factor to multiply the CKKS ciphertext when switching to FHEW in case the messages are too small;\n   * the resulting FHEW ciphertexts will encrypt values modulo pLWE, so scaleSign should account for this\n   * pLWE and scaleSign are given here only if the homomorphic decoding matrix is not scaled with the desired values\n   * @return a vector of two CKKS ciphertexts where the first encrypts the maximum value and the second encrypts the\n   * index (in the representation specified by oneHot). The ciphertexts have junk after the first slot in the first ciphertext\n   * and after numValues in the second ciphertext if oneHot=true and after the first slot if oneHot=false.\n   */\n    virtual std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMaxSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                    PublicKey&lt;Element&gt; publicKey, uint32_t numValues,\n                                                                    uint32_t numSlots, bool oneHot, uint32_t pLWE,\n                                                                    double scaleSign) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalMaxSchemeSwitching is not supported for this scheme&quot;);\n    }\n\n    /**\n     * Performs more operations in FHEW than in CKKS. Slightly better precision but slower.\n    */\n    virtual std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMaxSchemeSwitchingAlt(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                       PublicKey&lt;Element&gt; publicKey, uint32_t numValues,\n                                                                       uint32_t numSlots, bool oneHot, uint32_t pLWE,\n                                                                       double scaleSign) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalMaxSchemeSwitchingAlt is not supported for this scheme&quot;);\n    }\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_RNS_SCHEME_H\n#define LBCRYPTO_CRYPTO_RNS_SCHEME_H\n\n#include &quot;lattice/lat-hal.h&quot;\n\n#include &quot;schemebase/base-scheme.h&quot;\n\n#include &quot;schemerns/rns-cryptoparameters.h&quot;\n#include &quot;schemerns/rns-parametergeneration.h&quot;\n#include &quot;schemerns/rns-pke.h&quot;\n#include &quot;schemerns/rns-pre.h&quot;\n#include &quot;schemerns/rns-leveledshe.h&quot;\n#include &quot;schemerns/rns-advancedshe.h&quot;\n#include &quot;schemerns/rns-multiparty.h&quot;\n\n#include &quot;keyswitch/keyswitch-hybrid.h&quot;\n#include &quot;keyswitch/keyswitch-bv.h&quot;\n#include &quot;constants.h&quot;\n#include &quot;utils/exception.h&quot;\n\n#include &lt;string&gt;\n#include &lt;memory&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\n\n/**\n * @brief Abstract interface class for LBC PRE algorithms\n * @tparam Element a ring element.\n */\nclass SchemeRNS : public SchemeBase&lt;DCRTPoly&gt; {\npublic:\n    SchemeRNS() {}\n\n    virtual ~SchemeRNS() {}\n\n    void SetKeySwitchingTechnique(KeySwitchTechnique ksTech) {\n        if (ksTech == BV) {\n            m_KeySwitch = std::make_shared&lt;KeySwitchBV&gt;();\n        }\n        else if (ksTech == HYBRID) {\n            m_KeySwitch = std::make_shared&lt;KeySwitchHYBRID&gt;();\n        }\n        else\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ksTech is invalid&quot;);\n    }\n\n    /////////////////////////////////////\n    // SERIALIZATION\n    /////////////////////////////////////\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(cereal::base_class&lt;SchemeBase&lt;DCRTPoly&gt;&gt;(this));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        ar(cereal::base_class&lt;SchemeBase&lt;DCRTPoly&gt;&gt;(this));\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;SchemeRNS&quot;;\n    }\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}}, "reports": [{"fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "reportHash": "e241682556be611535e28fddcf21d7ff", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 206, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'level' is > 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 105, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 110, "column": 18}, {"message": "Assuming 'level' is < 'numModuli'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 113, "column": 17}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 143, "column": 38}, {"message": "Calling 'ILDCRTParams::PopLastParam'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 144, "column": 21}, {"message": "Entered call from 'CryptoContextImpl::MakeCKKSPackedPlaintextInternal'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "line": 280, "column": 5}, {"message": "Calling 'operator/='", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "line": 281, "column": 9}, {"message": "Entered call from 'ILDCRTParams::PopLastParam'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/integer.h", "line": 144, "column": 5}, {"message": "Calling 'ubint::DividedByEq'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/integer.h", "line": 145, "column": 16}, {"message": "Entered call from 'operator/='", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 204, "column": 1}, {"message": "Assuming field 'm_MSB' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 205, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 206, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "reportHash": "215d3532ee5df6fdf0f987c842c6d871", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1568, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'a' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 1565, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 1568, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "reportHash": "4222817fae84824a774d6b88632abfbe", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 373, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'level' is <= 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 196, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 223, "column": 13}, {"message": "Calling 'PlaintextFactory::MakePlaintext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 240, "column": 17}, {"message": "Entered call from 'CryptoContextImpl::MakePlaintext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "line": 79, "column": 5}, {"message": "Assuming 'schemeID' is not equal to CKKSRNS_SCHEME", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "line": 85, "column": 13}, {"message": "Assuming 'valueSize' is <= 'ringDim'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "line": 88, "column": 18}, {"message": "Calling 'PlaintextImpl::SetIntVectorValue'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "line": 92, "column": 9}, {"message": "Entered call from 'PlaintextFactory::MakePlaintext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "line": 372, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "line": 373, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "reportHash": "0079bede77d9e46ce7818cfdc8cdbf42", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 70, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'pte' is equal to CKKS_PACKED_ENCODING", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 713, "column": 10}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 713, "column": 43}, {"message": "Calling 'PlaintextFactory::MakePlaintext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 720, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::GetPlaintextForDecrypt'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "line": 59, "column": 5}, {"message": "Calling 'make_shared<lbcrypto::CKKSPackedEncoding, std::shared_ptr<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>> &, std::shared_ptr<lbcrypto::EncodingParamsImpl> &>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "line": 69, "column": 24}, {"message": "Entered call from 'PlaintextFactory::MakePlaintext'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 874, "column": 5}, {"message": "Calling 'allocate_shared<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, std::shared_ptr<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>> &, std::shared_ptr<lbcrypto::EncodingParamsImpl> &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 878, "column": 14}, {"message": "Entered call from 'make_shared<lbcrypto::CKKSPackedEncoding, std::shared_ptr<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>> &, std::shared_ptr<lbcrypto::EncodingParamsImpl> &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 857, "column": 5}, {"message": "Calling constructor for 'shared_ptr<lbcrypto::CKKSPackedEncoding>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 862, "column": 14}, {"message": "Entered call from 'allocate_shared<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, std::shared_ptr<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>> &, std::shared_ptr<lbcrypto::EncodingParamsImpl> &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 408, "column": 2}, {"message": "Calling constructor for '__shared_ptr<lbcrypto::CKKSPackedEncoding, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 409, "column": 4}, {"message": "Entered call from constructor for 'shared_ptr<lbcrypto::CKKSPackedEncoding>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1341, "column": 2}, {"message": "Calling constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1342, "column": 14}, {"message": "Entered call from constructor for '__shared_ptr<lbcrypto::CKKSPackedEncoding, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 643, "column": 2}, {"message": "Calling constructor for '_Sp_counted_ptr_inplace<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 651, "column": 6}, {"message": "Entered call from constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 514, "column": 2}, {"message": "Calling 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 519, "column": 4}, {"message": "Entered call from constructor for '_Sp_counted_ptr_inplace<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 510, "column": 2}, {"message": "Calling 'new_allocator::construct'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 516, "column": 4}, {"message": "Entered call from 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 159, "column": 2}, {"message": "Calling constructor for 'CKKSPackedEncoding'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 162, "column": 23}, {"message": "Entered call from 'new_allocator::construct'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 67, "column": 5}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 69, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 70, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "reportHash": "2df6f990857565d14399fb6556f12174", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 89, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'level' is <= 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 105, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 127, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 167, "column": 17}, {"message": "Calling 'make_shared<lbcrypto::CKKSPackedEncoding, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 173, "column": 27}, {"message": "Entered call from 'CryptoContextImpl::MakeCKKSPackedPlaintextInternal'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 874, "column": 5}, {"message": "Calling 'allocate_shared<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 878, "column": 14}, {"message": "Entered call from 'make_shared<lbcrypto::CKKSPackedEncoding, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 857, "column": 5}, {"message": "Calling constructor for 'shared_ptr<lbcrypto::CKKSPackedEncoding>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 862, "column": 14}, {"message": "Entered call from 'allocate_shared<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 408, "column": 2}, {"message": "Calling constructor for '__shared_ptr<lbcrypto::CKKSPackedEncoding, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 409, "column": 4}, {"message": "Entered call from constructor for 'shared_ptr<lbcrypto::CKKSPackedEncoding>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1341, "column": 2}, {"message": "Calling constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1342, "column": 14}, {"message": "Entered call from constructor for '__shared_ptr<lbcrypto::CKKSPackedEncoding, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 643, "column": 2}, {"message": "Calling constructor for '_Sp_counted_ptr_inplace<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 651, "column": 6}, {"message": "Entered call from constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 514, "column": 2}, {"message": "Calling 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 519, "column": 4}, {"message": "Entered call from constructor for '_Sp_counted_ptr_inplace<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 510, "column": 2}, {"message": "Calling 'new_allocator::construct'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 516, "column": 4}, {"message": "Entered call from 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 159, "column": 2}, {"message": "Calling constructor for 'CKKSPackedEncoding'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 162, "column": 23}, {"message": "Entered call from 'new_allocator::construct'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 84, "column": 5}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 88, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 89, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "reportHash": "066c14df91360504fa45dee1da4b759e", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 95, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'level' is <= 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 105, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 127, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 167, "column": 17}, {"message": "Calling 'make_shared<lbcrypto::CKKSPackedEncoding, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 173, "column": 27}, {"message": "Entered call from 'CryptoContextImpl::MakeCKKSPackedPlaintextInternal'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 874, "column": 5}, {"message": "Calling 'allocate_shared<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 878, "column": 14}, {"message": "Entered call from 'make_shared<lbcrypto::CKKSPackedEncoding, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 857, "column": 5}, {"message": "Calling constructor for 'shared_ptr<lbcrypto::CKKSPackedEncoding>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 862, "column": 14}, {"message": "Entered call from 'allocate_shared<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 408, "column": 2}, {"message": "Calling constructor for '__shared_ptr<lbcrypto::CKKSPackedEncoding, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 409, "column": 4}, {"message": "Entered call from constructor for 'shared_ptr<lbcrypto::CKKSPackedEncoding>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1341, "column": 2}, {"message": "Calling constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1342, "column": 14}, {"message": "Entered call from constructor for '__shared_ptr<lbcrypto::CKKSPackedEncoding, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 643, "column": 2}, {"message": "Calling constructor for '_Sp_counted_ptr_inplace<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 651, "column": 6}, {"message": "Entered call from constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 514, "column": 2}, {"message": "Calling 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 519, "column": 4}, {"message": "Entered call from constructor for '_Sp_counted_ptr_inplace<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 510, "column": 2}, {"message": "Calling 'new_allocator::construct'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 516, "column": 4}, {"message": "Entered call from 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 159, "column": 2}, {"message": "Calling constructor for 'CKKSPackedEncoding'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 162, "column": 23}, {"message": "Entered call from 'new_allocator::construct'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 84, "column": 5}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 88, "column": 13}, {"message": "Assuming 'slots' is not equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 92, "column": 23}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 94, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 95, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "reportHash": "8e5eea636e66e4619a89d2fcfaf26314", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 98, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'level' is <= 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 105, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 127, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 167, "column": 17}, {"message": "Calling 'make_shared<lbcrypto::CKKSPackedEncoding, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 173, "column": 27}, {"message": "Entered call from 'CryptoContextImpl::MakeCKKSPackedPlaintextInternal'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 874, "column": 5}, {"message": "Calling 'allocate_shared<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 878, "column": 14}, {"message": "Entered call from 'make_shared<lbcrypto::CKKSPackedEncoding, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 857, "column": 5}, {"message": "Calling constructor for 'shared_ptr<lbcrypto::CKKSPackedEncoding>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 862, "column": 14}, {"message": "Entered call from 'allocate_shared<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, const std::shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>> &, const std::shared_ptr<lbcrypto::EncodingParamsImpl>, const std::vector<std::complex<double>> &, unsigned long &, unsigned int &, double &, unsigned int &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 408, "column": 2}, {"message": "Calling constructor for '__shared_ptr<lbcrypto::CKKSPackedEncoding, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 409, "column": 4}, {"message": "Entered call from constructor for 'shared_ptr<lbcrypto::CKKSPackedEncoding>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1341, "column": 2}, {"message": "Calling constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1342, "column": 14}, {"message": "Entered call from constructor for '__shared_ptr<lbcrypto::CKKSPackedEncoding, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 643, "column": 2}, {"message": "Calling constructor for '_Sp_counted_ptr_inplace<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 651, "column": 6}, {"message": "Entered call from constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 514, "column": 2}, {"message": "Calling 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 519, "column": 4}, {"message": "Entered call from constructor for '_Sp_counted_ptr_inplace<lbcrypto::CKKSPackedEncoding, std::allocator<lbcrypto::CKKSPackedEncoding>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 510, "column": 2}, {"message": "Calling 'new_allocator::construct'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 516, "column": 4}, {"message": "Entered call from 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 159, "column": 2}, {"message": "Calling constructor for 'CKKSPackedEncoding'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 162, "column": 23}, {"message": "Entered call from 'new_allocator::construct'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 84, "column": 5}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 88, "column": 13}, {"message": "Assuming 'slots' is not equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 92, "column": 23}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 94, "column": 13}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 97, "column": 18}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 98, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "reportHash": "425069956fa329a61b24b98d1f27c3d6", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 71, "column": 17, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'pte' is not equal to CKKS_PACKED_ENCODING", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 713, "column": 10}, {"message": "Calling 'PlaintextFactory::MakePlaintext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 720, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::GetPlaintextForDecrypt'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "line": 59, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "line": 71, "column": 17}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "reportHash": "7a07a594486a3f01ae7170df90ec648b", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 86, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'level' is <= 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 196, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 223, "column": 13}, {"message": "Calling 'PlaintextFactory::MakePlaintext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 240, "column": 17}, {"message": "Entered call from 'CryptoContextImpl::MakePlaintext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "line": 79, "column": 5}, {"message": "Assuming 'schemeID' is equal to CKKSRNS_SCHEME", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "line": 85, "column": 13}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "line": 85, "column": 51}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "line": 86, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "reportHash": "d102ef422bab93df27c12fe277f84059", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 89, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'level' is <= 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 196, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 223, "column": 13}, {"message": "Calling 'PlaintextFactory::MakePlaintext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 240, "column": 17}, {"message": "Entered call from 'CryptoContextImpl::MakePlaintext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "line": 79, "column": 5}, {"message": "Assuming 'schemeID' is not equal to CKKSRNS_SCHEME", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "line": 85, "column": 13}, {"message": "Assuming 'valueSize' is > 'ringDim'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "line": 88, "column": 18}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "line": 89, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "reportHash": "aa3cb304fd07958577fd151d5fd39d57", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 114, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'PlaintextFactory::MakePlaintext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1046, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::MakeStringPlaintext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "line": 104, "column": 5}, {"message": "Assuming 'valueSize' is > 'ringDim'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "line": 113, "column": 18}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintextfactory.h", "line": 114, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "275e9ec1dc3c71046a31536004f6fff7", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 637, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2069, "column": 29}, {"message": "Calling 'CryptoContextImpl::FindAutomorphismIndex'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2070, "column": 37}, {"message": "Entered call from 'CryptoContextImpl::FindAutomorphismIndices'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2054, "column": 5}, {"message": "Calling 'SchemeBase::FindAutomorphismIndex'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2058, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::FindAutomorphismIndex'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 926, "column": 5}, {"message": "Calling 'LeveledSHEBase::FindAutomorphismIndex'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 928, "column": 16}, {"message": "Entered call from 'SchemeBase::FindAutomorphismIndex'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 636, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 637, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "6d66744ab8e5e2ece73fb50e5619489f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 85, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalBootstrapSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 3215, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalBootstrapSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1341, "column": 5}, {"message": "Calling 'FHEBase::EvalBootstrapSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1345, "column": 9}, {"message": "Entered call from 'SchemeBase::EvalBootstrapSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 83, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 85, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "fc5b1fedecd1f1af0be399130c86d35a", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 98, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalBootstrapKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 3230, "column": 25}, {"message": "Entered call from 'CryptoContextImpl::EvalBootstrapKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1349, "column": 5}, {"message": "Calling 'FHEBase::EvalBootstrapKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1352, "column": 16}, {"message": "Entered call from 'SchemeBase::EvalBootstrapKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 96, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 98, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "7ae2150978eaff40b26f1c5058a21443", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 118, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalBootstrap'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 3262, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalBootstrap'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1355, "column": 5}, {"message": "Calling 'FHEBase::EvalBootstrap'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1358, "column": 16}, {"message": "Entered call from 'SchemeBase::EvalBootstrap'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 116, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 118, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "3e98184b8f2ce36403916ee0674b65c9", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 139, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalCKKStoFHEWSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 505, "column": 12}, {"message": "Entered call from 'CryptoContextImpl::EvalCKKStoFHEWSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1363, "column": 5}, {"message": "Calling 'FHEBase::EvalCKKStoFHEWSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1369, "column": 16}, {"message": "Entered call from 'SchemeBase::EvalCKKStoFHEWSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 135, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 139, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "e648248da220fef766c9f27a4f4a5852", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 154, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalCKKStoFHEWKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 518, "column": 21}, {"message": "Entered call from 'CryptoContextImpl::EvalCKKStoFHEWKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1372, "column": 5}, {"message": "Calling 'FHEBase::EvalCKKStoFHEWKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1376, "column": 16}, {"message": "Entered call from 'SchemeBase::EvalCKKStoFHEWKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 151, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 154, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "a90b98144f64780be3046fab7deeb243", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 167, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalCKKStoFHEWPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 541, "column": 5}, {"message": "Entered call from 'CryptoContextImpl::EvalCKKStoFHEWPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1379, "column": 5}, {"message": "Calling 'FHEBase::EvalCKKStoFHEWPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1381, "column": 16}, {"message": "Entered call from 'SchemeBase::EvalCKKStoFHEWPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 166, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 167, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "ccd42fb10855baa29420c8221b012a37", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 192, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalFHEWtoCKKSSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 554, "column": 5}, {"message": "Entered call from 'CryptoContextImpl::EvalFHEWtoCKKSSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1390, "column": 5}, {"message": "Calling 'FHEBase::EvalFHEWtoCKKSSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1393, "column": 9}, {"message": "Entered call from 'SchemeBase::EvalFHEWtoCKKSSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 190, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 192, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "683853662d77d87cc4e2a1efcafc98a0", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 209, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalFHEWtoCKKSKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 564, "column": 21}, {"message": "Entered call from 'CryptoContextImpl::EvalFHEWtoCKKSKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1397, "column": 5}, {"message": "Calling 'FHEBase::EvalFHEWtoCKKSKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1402, "column": 16}, {"message": "Entered call from 'SchemeBase::EvalFHEWtoCKKSKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 205, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 209, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "181f854ddd592ce0bb0e773a3146cef9", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 225, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalCompareSwitchPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 632, "column": 5}, {"message": "Entered call from 'CryptoContextImpl::EvalCompareSwitchPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1405, "column": 5}, {"message": "Calling 'FHEBase::EvalCompareSwitchPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1408, "column": 9}, {"message": "Entered call from 'SchemeBase::EvalCompareSwitchPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 223, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 225, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "e36581caa25a4f4b1bdf7f2666193b3a", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 242, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalFHEWtoCKKS'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 589, "column": 12}, {"message": "Entered call from 'CryptoContextImpl::EvalFHEWtoCKKS'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1412, "column": 5}, {"message": "Calling 'FHEBase::EvalFHEWtoCKKS'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1416, "column": 16}, {"message": "Entered call from 'SchemeBase::EvalFHEWtoCKKS'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 239, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 242, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "1df389f451bba93d61e8b450744de424", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 264, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalSchemeSwitchingSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 596, "column": 12}, {"message": "Entered call from 'CryptoContextImpl::EvalSchemeSwitchingSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1419, "column": 5}, {"message": "Calling 'FHEBase::EvalSchemeSwitchingSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1426, "column": 16}, {"message": "Entered call from 'SchemeBase::EvalSchemeSwitchingSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 259, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 264, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "c87d115d89cd409505fb7f30c2c8f0c4", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 285, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalSchemeSwitchingKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 608, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalSchemeSwitchingKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1430, "column": 5}, {"message": "Calling 'FHEBase::EvalSchemeSwitchingKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1434, "column": 16}, {"message": "Entered call from 'SchemeBase::EvalSchemeSwitchingKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 282, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 285, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "ef99d8af6174376e7021dd17044d6dc7", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 314, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::KeySwitchDown'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2189, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::KeySwitchDown'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 311, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 314, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "7b541f5b86ec4521ff3ba09c8a583e0c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 419, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalAddMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1350, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalAddMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 415, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 419, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "7c01258d393940a8a057edcebdc62ed0", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 428, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalAddMutableInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1361, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalAddMutableInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 425, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 428, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "c40c11b6e7c49bf6deaf21760b6bfc6c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 447, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::EvalAddInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1403, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalAddInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1391, "column": 5}, {"message": "Calling 'SchemeBase::EvalAddInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1394, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalAddInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 444, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 447, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "a9462fc6c621d06a947ca48db4991bbc", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 457, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::EvalAddMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1425, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalAddMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1412, "column": 5}, {"message": "Calling 'SchemeBase::EvalAddMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1415, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalAddMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 454, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 457, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "f86d9e830ee67d6d5ed9fb90b20de7bc", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 490, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'constant' is < 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1616, "column": 13}, {"message": "Calling 'SchemeBase::EvalAddInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1620, "column": 13}, {"message": "Entered call from 'CryptoContextImpl::EvalSubInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 487, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 490, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "6f55dc591239299ff797ea62b01d72a9", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 503, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalSub'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1507, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalSub'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 499, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 503, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "0d3e0f8bcde152823a6eb553353e4c32", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 512, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalSubInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1518, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalSubInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 509, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 512, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "8e34def1e5eec390ff941c06646f3fa9", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 523, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalSubMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1529, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalSubMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 519, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 523, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "9e14330c50ce15daea7799316d935e15", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 532, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalSubMutableInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1540, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalSubMutableInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 529, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 532, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "c104d38a2729befdabade41a410a9963", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 542, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalSub'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1551, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalSub'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 539, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 542, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "b5d0be4517c750262055197e9830e43e", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 561, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalSubMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1572, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalSubMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 558, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 561, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "38ab2c5221e90b6f7f2d07d4d222c949", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 592, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'constant' is >= 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1616, "column": 13}, {"message": "Calling 'SchemeBase::EvalSubInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1617, "column": 13}, {"message": "Entered call from 'CryptoContextImpl::EvalSubInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 589, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 592, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "ec82fb74d6108e7a395d45be962ac7b5", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 852, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2030, "column": 13}, {"message": "Calling 'SchemeBase::EvalAutomorphism'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2046, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalAutomorphism'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 840, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 852, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "a1f2901a47eec8d859e79c10b4f452a4", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 859, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalFastRotation'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2159, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalFastRotation'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 855, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 859, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "8d645bd7d2b0b8bf0033666e5ef644d7", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 867, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalFastRotationPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2118, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalFastRotationPrecompute'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 863, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 867, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "55d92fb3e372fa60bc73ab7164db06d4", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 901, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::KeySwitchDownFirstElement'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2200, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::KeySwitchDownFirstElement'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 898, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 901, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "5bdb5fe77f1b478c665e9d9c60f1a7c6", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 908, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::KeySwitchExt'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2212, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::KeySwitchExt'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 905, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 908, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "98f4d3be3b49fcb7ccb931669edd3426", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1062, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2411, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2415, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2420, "column": 13}, {"message": "Calling 'SchemeBase::EvalMultMany'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2424, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalMultMany'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1058, "column": 5}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1061, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1062, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "5ad496c87f1aff93200fa4a8eca72237", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1076, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::EvalLinearWSum'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2454, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalLinearWSum'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2439, "column": 5}, {"message": "Calling 'SchemeBase::EvalLinearWSum'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2441, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalLinearWSum'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1072, "column": 5}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1075, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1076, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "98a3399dab5678231e869c15af8f31f1", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1084, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::EvalLinearWSumMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2480, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalLinearWSumMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2465, "column": 5}, {"message": "Calling 'SchemeBase::EvalLinearWSumMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2467, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalLinearWSumMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1080, "column": 5}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1083, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1084, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "506b7e248d77c52034d270e39cfa03ca", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1300, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::IntMPBootAdjustScale'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 831, "column": 12}, {"message": "Entered call from 'CryptoContextImpl::IntMPBootAdjustScale'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1296, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1300, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "3feb5e8b01b68add5c1f53ef238e1ff4", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1308, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::IntMPBootRandomElementGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 837, "column": 12}, {"message": "Entered call from 'CryptoContextImpl::IntMPBootRandomElementGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1303, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1308, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "76c7658792ecf0fd00220bc060bcc965", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1317, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::IntMPBootDecrypt'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 844, "column": 12}, {"message": "Entered call from 'CryptoContextImpl::IntMPBootDecrypt'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1311, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1317, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "2e42a744efb8d82c6dc87048dc04abea", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1324, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::IntMPBootAdd'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 850, "column": 12}, {"message": "Entered call from 'CryptoContextImpl::IntMPBootAdd'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1320, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1324, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "86e80e4056c5ada4f41bb50328c40030", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1333, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::IntMPBootEncrypt'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 858, "column": 12}, {"message": "Entered call from 'CryptoContextImpl::IntMPBootEncrypt'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1327, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1333, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "ffe875e463e5881c844dfb3122a96017", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1592, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::EvalBootstrapSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 3215, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalBootstrapSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1341, "column": 5}, {"message": "Calling 'SchemeBase::VerifyFHEEnabled'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1344, "column": 9}, {"message": "Entered call from 'SchemeBase::EvalBootstrapSetup'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1588, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1592, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "a04dfb9c5785af165dca8724209d3fd1", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 98, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::GetContextForPointer'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1150, "column": 36}, {"message": "Entered call from 'CryptoContextImpl::SparseKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 92, "column": 5}, {"message": "Loop body skipped when range is empty", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 94, "column": 30}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 98, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "f94228e382fbb25840066b70f2173d16", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 200, "column": 17, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'level' is > 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 196, "column": 13}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 197, "column": 17}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 200, "column": 17}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "f94228e382fbb25840066b70f2173d16", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 218, "column": 17, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'level' is > 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 196, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 197, "column": 17}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 206, "column": 18}, {"message": "Assuming 'level' is >= 'numModuli'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 209, "column": 17}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 218, "column": 17}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "7a336b4a1ed2f9158c325fc8830f5da7", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 296, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::TypeCheck'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1797, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalMultNoRelin'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 293, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 296, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "7a336b4a1ed2f9158c325fc8830f5da7", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 300, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::TypeCheck'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1797, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalMultNoRelin'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 293, "column": 5}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 298, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 300, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "7a336b4a1ed2f9158c325fc8830f5da7", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 304, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::TypeCheck'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1797, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalMultNoRelin'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 293, "column": 5}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 298, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 304, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "7a336b4a1ed2f9158c325fc8830f5da7", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 308, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::TypeCheck'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1797, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalMultNoRelin'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 293, "column": 5}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 298, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 308, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "3e84e470fc7ba453576a355f19252ab5", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 316, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::TypeCheck'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1797, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalMultNoRelin'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 293, "column": 5}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 298, "column": 13}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 310, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 316, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "044c56598b3d6df22176dd4e44746ba1", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 329, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::EvalMultMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1903, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalMultMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1891, "column": 5}, {"message": "Calling 'CryptoContextImpl::TypeCheck'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1892, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalMultMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 326, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 329, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "044c56598b3d6df22176dd4e44746ba1", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 333, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::EvalMultMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1903, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalMultMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1891, "column": 5}, {"message": "Calling 'CryptoContextImpl::TypeCheck'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1892, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalMultMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 326, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 333, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "044c56598b3d6df22176dd4e44746ba1", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 337, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::EvalMultMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1903, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalMultMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1891, "column": 5}, {"message": "Calling 'CryptoContextImpl::TypeCheck'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1892, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalMultMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 326, "column": 5}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 335, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 337, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "133cb604c2a679b3e99bd631eb4ff43c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 345, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::EvalMultMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1903, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalMultMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1891, "column": 5}, {"message": "Calling 'CryptoContextImpl::TypeCheck'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1892, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalMultMutable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 326, "column": 5}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 335, "column": 13}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 339, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 345, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "dd9cdb3fb07b6c532695bca81e81a1c5", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 360, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::CheckKey'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2878, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::MultipartyDecryptMain'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 357, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 360, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "dd9cdb3fb07b6c532695bca81e81a1c5", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 364, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::CheckKey'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2878, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::MultipartyDecryptMain'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 357, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 364, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "6657ed6ed15ab339c6e863f46ecedb72", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 371, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::CheckCiphertext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2803, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::ReEncrypt'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 368, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 371, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "6657ed6ed15ab339c6e863f46ecedb72", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 376, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::CheckCiphertext'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2803, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::ReEncrypt'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 368, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 376, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "0b0dd40ef491a10bbfbf07fba2c5ed5b", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 414, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 414, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "9df3d44900c9966cd916745afd024f96", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 446, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 446, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "b4f291e89f0a18a9c497013c3896dc04", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1006, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::GetEvalMultKeyVector'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2262, "column": 27}, {"message": "Entered call from 'CryptoContextImpl::ComposedEvalMult'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1003, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1006, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "d2ab124a09dd564a1dc478b5cc585750", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1060, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1059, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1060, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "cc00b241f6a213ed330a6368fd497c5b", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1075, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1074, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1075, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "a1339053c7844daa96326af5ad3745aa", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1095, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1094, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1095, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "133c9a4825f86d5ce3e602dc4320b30d", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1684, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1684, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "c43ae65604687df71f494a92b4073696", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1719, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1718, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1719, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "c1ad9373f6932b8e45b801797637f467", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1735, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1734, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1735, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "f2e25406b6e9ca2d7f28272e45c9919d", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1751, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1750, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1751, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "2b0fce3ffb1ecb123e211a0e50a0325d", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1767, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1766, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1767, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "19e44a6e574da844861856239544534c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1783, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1782, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1783, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "eb99d724fa18cf15b05a53e7d1f6b20c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1809, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1809, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "f5d35bf06fb557937da6fbdbc82a9f97", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1829, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1829, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "5f924f728460e5ecf1721bd0b618596e", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1851, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1851, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "cf6ba5326502b1f7d41a26ef6e4f88f6", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1944, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::EvalMult'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1956, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::EvalMult'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1942, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1944, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "db24bec2ced9dff4a3d27b41a926293a", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1966, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::EvalMultInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1978, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalMultInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1964, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1966, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "c7b3da8ee54cced78d85344c7fff91a3", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1997, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1996, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1997, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "a20fabaea8e6a6bdbae591ab61f5035e", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 2011, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2010, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2011, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "1d38d606fc50a0f8b02c1dbc7c6bdbdd", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 2032, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2030, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2032, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "1d38d606fc50a0f8b02c1dbc7c6bdbdd", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 2039, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2030, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2039, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "311d59b76ac832f79a70cf9d55c363c8", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 2264, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2263, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2264, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "8a484553f7dbb10bbf88437f3d1fc298", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 2351, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2351, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "2968fe471b7c6d4dd3e472be9bfad338", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 2370, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2369, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2370, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "cb91949e89fec839608c0b0e3b584046", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 2392, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2391, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2392, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "2fca2e64f5953d9db19ad62f9bac054d", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 2412, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2411, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2412, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "3a5cbc7368ef9b96d7fdc156cb93960c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 2421, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2411, "column": 13}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2415, "column": 13}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2420, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2421, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "da658897ab8a84f7b275830172d89d3c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 2823, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2822, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2823, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "a8d89a321ff543e45eedc67c255f7aa3", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 2842, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2842, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "704009af95b85e65e616ab4123c51ae9", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 2916, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2916, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "0a4420e624d53824c74872077957cdfa", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 2940, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2940, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "91a594ac1c410ea7d20dab6997ed8778", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 2964, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2964, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "f79f46c7e934abaa9b979aafc2e896b1", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 2987, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2987, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "98a2b23da89efc9fa2bd0c8d645513ca", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 3004, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 3004, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "3b49c51882775841b0ffaa81abbfd772", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 3024, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 3024, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "b93139306af66a3c50d80ec0c684d995", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 3043, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 3043, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "e16cc83962e525a3ba524cf2b2466a90", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 3062, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 3062, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "eb9e4f1d84871844687d4341254e057a", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 3080, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 3080, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "2feaccfa7e1bede08598f8096284f8b8", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 3098, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 3098, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "reportHash": "f046d3b72427b9d536a24deaf7036294", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 3226, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 3226, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "reportHash": "d132ed6a836949e6521bc9548e13fbdf", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 79, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 64, "column": 9}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 67, "column": 13}, {"message": "Calling 'SchemeRNS::SetKeySwitchingTechnique'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 68, "column": 13}, {"message": "Entered call from 'CryptoContextImpl::SetKSTechniqueInScheme'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "line": 71, "column": 5}, {"message": "Assuming 'ksTech' is not equal to BV", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "line": 72, "column": 13}, {"message": "Assuming 'ksTech' is not equal to HYBRID", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "line": 75, "column": 18}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "line": 79, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "4bae6f1c4c68147402467e962dc44144", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 71, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 64, "column": 9}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 67, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 71, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "e7dea27c01756a02e752d63f0dad43c2", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 92, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 92, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "0167f639d30974595e0375978cd927e8", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 98, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 98, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "f39d8341127f8f599a83bf5c55739ae1", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 110, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 110, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "940723239873fcd2552c9dcbab3409f5", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 116, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 116, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "e5cc6e9d941fc43daf936eb74d6e07dc", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 128, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 128, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "ab9d4bd0db9d0d50e063e5fd8bb26175", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 134, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 134, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "a6aa7849a26c43d5556b60b875eb7406", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 146, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 146, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "49161f83c03a43a5c8cc06a88f9cf26d", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 209, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::EvalAtIndexKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2235, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalRotateKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 205, "column": 1}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 209, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "5f6d9178e273b54c81ffba11595a1d93", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 215, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::EvalAtIndexKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2235, "column": 9}, {"message": "Entered call from 'CryptoContextImpl::EvalRotateKeyGen'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 205, "column": 1}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 215, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "b2e5a3d5d0a4c6051fe5161a7e67ce65", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 245, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::GetEvalAutomorphismKeyMap'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 2175, "column": 27}, {"message": "Entered call from 'CryptoContextImpl::EvalFastRotationExt'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 242, "column": 1}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 245, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "ad2b5496224f1f09302a0f36006741ec", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 295, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 295, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "020b261da89d99fceba3e782c6858647", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 309, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 309, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "ae15cced8cc4e522be0964fe3986cc61", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 322, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 322, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "f609ccfb2af74ed1c125a9d6ea748de8", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 335, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 335, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "7c6e0ffa128242b4655cb62451cd38b3", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 357, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 357, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "82a5f9d117a7621a69f765f9d368eb00", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 372, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 372, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "390ecb5ee45a9ec7cb441f1268c6e467", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 387, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 387, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "bfe5979a373452cc90d016de48ee1414", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 512, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 512, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "a9fde09c34b0baec266ff2addb836e2f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 516, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 516, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "eaba235fac53790badc0529855124294", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 548, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 548, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "bf5ed826544f2f2f2bbc56fdd870a9b2", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 561, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 561, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "9625102fe5e3c618426bf894134cc743", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 604, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 604, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "552da9ea5b11c924feb9547f1e55337a", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 641, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 641, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "4c2cfc10079acde164c12f6ff11ea1ff", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 656, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 656, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "4d66e9f635560b85de5bf50fe7758299", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 669, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 669, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "23d76f210fe0e08c72e7157bca45800c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 684, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 684, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "bbad411f62ba2efcd52d040fb59eac14", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 697, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 697, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "9a9d11dcf5774ff2b5c298d785ec4ada", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 728, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'CryptoContextImpl::Decrypt'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/cryptocontext.h", "line": 1244, "column": 16}, {"message": "Entered call from 'CryptoContextImpl::Decrypt'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 724, "column": 1}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 728, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "d24214e8d6451b20caf385beb88fd643", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 788, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'last_ciphertext' is >= 1", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 783, "column": 9}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 786, "column": 24}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 788, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "e22980282a1b9601b90f234841de8d04", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 868, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'N' is < 2", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 867, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 868, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "reportHash": "204042d128ac28b2f3ea73c31775542c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 975, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 974, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/cryptocontext.cpp", "line": 975, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>

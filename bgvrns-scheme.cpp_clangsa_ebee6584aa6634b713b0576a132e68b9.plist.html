<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 3px;
  height: 97%;
}

#side-bar {
  overflow: auto;
}

#editor-wrapper {
  overflow: hidden;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijn@haverbeke.berlin> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report.events;
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report.events;
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setChecker(report.checker);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.fileId]);
    this.drawBugPath();

    this.jumpTo(event.line, 0);
    this.highlightBugEvent(idx);
  },

  highlightBugEvent : function (idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setChecker : function (checker) {
    var content = checker.name;
    if (checker.url) {
      content = '<a href="' + checker.url + '" target="_blank">' +
        checker.name + '</a>';
    }

    this._checkerName.innerHTML = content;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.filePath;
    let e = document.createElement('div');
    e.innerHTML = file.content;
    this._codeMirror.doc.setValue(e.innerText);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.fileId !== that._currentBugEvent.fileId) {
        return;
      }

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.fileId !== that._currentBugEvent.fileId)
        return;

      var left = that._codeMirror.defaultCharWidth() * event.column + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp": {"id": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  This file contains the main class for unsigned big integers: ubint. Big integers are represented as arrays of\n  machine native unsigned integers. The native integer type is supplied as a template parameter.\n  Currently implementation based on uint32_t and uint64_t is supported. a native double the base integer size is also needed.\n */\n\n#include &quot;config_core.h&quot;\n#ifdef WITH_BE4\n\n    #include &quot;math/math-hal.h&quot;\n\n    #include &quot;utils/exception.h&quot;\n    #include &quot;utils/inttypes.h&quot;\n    #include &quot;utils/serializable.h&quot;\n\n    #include &lt;iostream&gt;\n    #include &lt;string&gt;\n    #include &lt;vector&gt;\n\nnamespace bigintdyn {\n\n// Sum and Carry algorithm with radix 2^m_bitLength.\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::Add(const ubint&amp; b) const {\n    const ubint* A = this;\n    auto sizeA     = m_value.size();\n    const ubint* B = &amp;b;\n    auto sizeB     = b.m_value.size();\n    if (sizeA &lt; sizeB) {\n        std::swap(A, B);\n        std::swap(sizeA, sizeB);\n    }\n\n    if (B-&gt;m_MSB == 0)\n        return *A;\n\n    std::vector&lt;limb_t&gt; r(sizeA + 1);\n    Dlimb_t c{0};\n    for (size_t i = 0; i &lt; sizeA; ++i, c &gt;&gt;= m_limbBitLength) {\n        auto av = static_cast&lt;Dlimb_t&gt;(A-&gt;m_value[i]);\n        auto bv = static_cast&lt;Dlimb_t&gt;(i &lt; sizeB ? B-&gt;m_value[i] : 0);\n        r[i]    = static_cast&lt;limb_t&gt;(c += av + bv);\n    }\n    r[sizeA] = static_cast&lt;limb_t&gt;(c);\n    return ubint(std::move(r));\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::AddEq(const ubint&amp; b) {\n    const ubint* A = this;\n    auto sizeA     = m_value.size();\n    const ubint* B = &amp;b;\n    auto sizeB     = B-&gt;m_value.size();\n    if (sizeA &lt; sizeB) {\n        std::swap(A, B);\n        std::swap(sizeA, sizeB);\n    }\n\n    if (B-&gt;m_MSB == 0)\n        return *this = *A;\n\n    std::vector&lt;limb_t&gt; r(sizeA + 1);\n    Dlimb_t c{0};\n    for (size_t i = 0; i &lt; sizeA; ++i, c &gt;&gt;= m_limbBitLength) {\n        auto av = static_cast&lt;Dlimb_t&gt;(A-&gt;m_value[i]);\n        auto bv = static_cast&lt;Dlimb_t&gt;(i &lt; sizeB ? B-&gt;m_value[i] : 0);\n        r[i]    = static_cast&lt;limb_t&gt;(c += av + bv);\n    }\n    r[sizeA] = static_cast&lt;limb_t&gt;(c);\n    m_value  = std::move(r);\n    ubint&lt;limb_t&gt;::NormalizeLimbs();\n    return *this;\n}\n\n// TODO: convert to vector constructor method\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::Sub(const ubint&amp; b) const {\n    // return 0 if b is higher than *this as there is no support for negative numbers\n    if (*this &lt;= b)\n        return ubint();\n    ubint result(*this);\n    for (size_t i = 0; i &lt; b.m_value.size(); ++i) {\n        if (result.m_value[i] &lt; b.m_value[i]) {  // carryover condition need to\n                                                 // borrow from higher limbs.\n            size_t cntr{i};\n            result.m_value[cntr] += (m_MaxLimb - b.m_value[cntr]) + 1;\n            // set all the zero limbs to all FFs (propagate the 1)\n            while (0 == result.m_value[++cntr])\n                result.m_value[cntr] = m_MaxLimb;\n            // and eventually borrow 1 from the first nonzero limb we find\n            result.m_value[cntr]--;\n        }\n        else {  // usual subtraction condition\n            result.m_value[i] -= b.m_value[i];\n        }\n    }\n    result.NormalizeLimbs();\n    return result;\n}\n\n// TODO: convert to vector constructor method\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::SubEq(const ubint&amp; b) {\n    if (*this &lt;= b) {\n        m_MSB      = 0;\n        m_value[0] = 0;\n        m_value.resize(1);\n        return *this;\n    }\n    for (size_t i = 0; i &lt; b.m_value.size(); ++i) {\n        if (m_value[i] &lt; b.m_value[i]) {\n            size_t cntr{i};\n            m_value[cntr] += (m_MaxLimb - b.m_value[cntr]) + 1;\n            while (0 == m_value[++cntr])\n                m_value[cntr] = m_MaxLimb;\n            m_value[cntr]--;\n        }\n        else {\n            m_value[i] -= b.m_value[i];\n        }\n    }\n    ubint&lt;limb_t&gt;::NormalizeLimbs();\n    return *this;\n}\n\n// Multiply operation: usual school book shift and add after multiplication\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::Mul(const ubint&amp; b) const {\n    if (m_MSB == 0 || b.m_MSB == 0)\n        return ubint();\n    if (b.m_MSB == 1)\n        return *this;\n    if (m_MSB == 1)\n        return b;\n\n    const ubint* A = this;\n    auto aSize     = m_value.size();\n    const ubint* B = &amp;b;\n    auto bSize     = b.m_value.size();\n    if (aSize &lt; bSize) {\n        std::swap(A, B);\n        std::swap(aSize, bSize);\n    }\n\n    ubint ans;\n    for (size_t i = 0; i &lt; bSize; ++i) {\n        std::vector&lt;limb_t&gt; c(i + aSize + 1);\n        Dlimb_t limbb = static_cast&lt;Dlimb_t&gt;(B-&gt;m_value[i]);\n        Dlimb_t ofl{0};\n        for (size_t j = 0; j &lt; aSize; ++j, ofl &gt;&gt;= m_limbBitLength)\n            c[i + j] = static_cast&lt;limb_t&gt;(ofl += limbb * A-&gt;m_value[j]);\n        c[i + aSize] = static_cast&lt;limb_t&gt;(ofl);\n\n        ans = std::move(ans.Add(ubint(std::move(c))));\n    }\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::DividedBy(const ubint&amp; b) const {\n    if (b.m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Divisor is zero&quot;);\n    if (b.m_MSB &gt; m_MSB)\n        return ubint();\n    if ((b.m_MSB == m_MSB) &amp;&amp; (b.m_value.back() == m_value.back()))\n        return ubint(1);\n    ubint ans;\n    divq_vect(ans, *this, b);\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::DividedByEq(const ubint&amp; b) {\n    if (b.m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Divisor is zero&quot;);\n    if (b.m_MSB &gt; m_MSB) {\n        m_MSB = 0;\n        m_value.resize(1);\n        m_value[0] = 0;\n        return *this;\n    }\n    if ((b.m_MSB == m_MSB) &amp;&amp; (b.m_value.back() == m_value.back())) {\n        m_MSB = 1;\n        m_value.resize(1);\n        m_value[0] = 1;\n        return *this;\n    }\n    ubint ans;\n    divq_vect(ans, *this, b);\n    return *this = std::move(ans);\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::Exp(usint p) const {\n    if (p == 0)\n        return ubint(1);\n    if (p == 1)\n        return *this;\n    ubint tmp{ubint&lt;limb_t&gt;::Exp(p &gt;&gt; 1)};\n    tmp = tmp.Mul(tmp);\n    if (p &amp; 0x1)\n        return tmp.Mul(*this);\n    return tmp;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::MultiplyAndRound(const ubint&amp; p, const ubint&amp; q) const {\n    if (q.m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;MultiplyAndRound() Divisor is zero&quot;);\n    auto t{ubint&lt;limb_t&gt;::Mul(p)};\n    ubint halfQ(q &gt;&gt; 1);\n    if (t &lt;= halfQ)\n        return ubint();\n    if ((t.m_MSB == halfQ.m_MSB) || ((t.m_MSB == q.m_MSB) &amp;&amp; (t.m_value.back() &lt; q.m_value.back())))\n        return ubint(1);\n    ubint ans, rv;\n    divqr_vect(ans, rv, t, q);\n    if (rv &gt; halfQ)\n        return ans.Add(ubint(1));\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::DivideAndRound(const ubint&amp; q) const {\n    if (q.m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;DivideAndRound() Divisor is zero&quot;);\n    ubint halfQ(q &gt;&gt; 1);\n    if (*this &lt;= halfQ)\n        return ubint();\n    if ((m_MSB == halfQ.m_MSB) || ((m_MSB == q.m_MSB) &amp;&amp; (m_value.back() &lt; q.m_value.back())))\n        return ubint(1);\n    ubint ans, rv;\n    divqr_vect(ans, rv, *this, q);\n    if (rv &gt; halfQ)\n        return ans.Add(ubint(1));\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::Mod(const ubint&amp; modulus) const {\n    if (modulus.m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Mod() using zero modulus&quot;);\n    if (*this &lt; modulus)\n        return *this;\n    if (modulus.m_MSB == 2 &amp;&amp; modulus.m_value[0] == 2)\n        return ubint(m_value[0] &amp; 0x1);\n    ubint ans;\n    divr_vect(ans, *this, modulus);\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::ModEq(const ubint&amp; modulus) {\n    if (modulus.m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Mod() using zero modulus&quot;);\n    if (*this &lt; modulus)\n        return *this;\n    if (modulus.m_MSB == 2 &amp;&amp; modulus.m_value[0] == 2) {\n        m_value.resize(1);\n        m_value[0] &amp;= 0x1;\n        m_MSB = m_value[0];\n        return *this;\n    }\n    ubint ans;\n    divr_vect(ans, *this, modulus);\n    return *this = std::move(ans);\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModAdd(const ubint&amp; b, const ubint&amp; modulus) const {\n    ubint bv(b);\n    if (bv &gt;= modulus)\n        bv.ModEq(modulus);\n    ubint av(*this);\n    if (av &gt;= modulus)\n        av.ModEq(modulus);\n    av = av.Add(bv);\n    if (av &gt;= modulus)\n        return av.Sub(modulus);\n    return av;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::ModAddEq(const ubint&amp; b, const ubint&amp; modulus) {\n    ubint bv(b);\n    if (bv &gt;= modulus)\n        bv.ModEq(modulus);\n    if (*this &gt;= modulus)\n        ubint&lt;limb_t&gt;::ModEq(modulus);\n    *this = bv.Add(*this);\n    if (*this &gt;= modulus)\n        return ubint&lt;limb_t&gt;::SubEq(modulus);\n    return *this;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModAddFast(const ubint&amp; b, const ubint&amp; modulus) const {\n    ubint ans(b.Add(*this));\n    if (ans &gt;= modulus)\n        return ans.Sub(modulus);\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::ModAddFastEq(const ubint&amp; b, const ubint&amp; modulus) {\n    *this = b.Add(*this);\n    if (*this &gt;= modulus)\n        return ubint&lt;limb_t&gt;::SubEq(modulus);\n    return *this;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModSub(const ubint&amp; b, const ubint&amp; modulus) const {\n    auto av(*this);\n    auto bv(b);\n    if (bv &gt;= modulus)\n        bv.ModEq(modulus);\n    if (av &gt;= modulus)\n        av.ModEq(modulus);\n    if (av &lt; bv)\n        av = modulus.Add(av);\n    return av.Sub(bv);\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::ModSubEq(const ubint&amp; b, const ubint&amp; modulus) {\n    auto bv(b);\n    if (bv &gt;= modulus)\n        bv.ModEq(modulus);\n    if (*this &gt;= modulus)\n        ubint&lt;limb_t&gt;::ModEq(modulus);\n    if (*this &lt; bv)\n        *this = modulus.Add(*this);\n    return ubint&lt;limb_t&gt;::SubEq(bv);\n}\n\ntemplate &lt;typename limb_t&gt;\ninline ubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModSubFast(const ubint&amp; b, const ubint&amp; modulus) const {\n    if (*this &lt; b)\n        return modulus.Add(*this).Sub(b);\n    return ubint&lt;limb_t&gt;::Sub(b);\n}\n\ntemplate &lt;typename limb_t&gt;\ninline ubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::ModSubFastEq(const ubint&amp; b, const ubint&amp; modulus) {\n    if (*this &lt; b)\n        return *this = std::move(modulus.Add(*this).Sub(b));\n    return ubint&lt;limb_t&gt;::SubEq(b);\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModMulFast(const ubint&amp; b, const ubint&amp; modulus) const {\n    if (m_MSB == 0 || b.m_MSB == 0)\n        return ubint();\n    if (b.m_MSB == 1)\n        return *this;\n    if (m_MSB == 1)\n        return b;\n\n    const ubint* A = this;\n    auto aSize     = m_value.size();\n    const ubint* B = &amp;b;\n    auto bSize     = b.m_value.size();\n    if (aSize &lt; bSize) {\n        std::swap(A, B);\n        std::swap(aSize, bSize);\n    }\n\n    ubint ans;\n    for (size_t i = 0; i &lt; bSize; ++i) {\n        std::vector&lt;limb_t&gt; c(i + aSize + 1);\n        Dlimb_t limbb = static_cast&lt;Dlimb_t&gt;(B-&gt;m_value[i]);\n        Dlimb_t ofl{0};\n        for (size_t j = 0; j &lt; aSize; ++j, ofl &gt;&gt;= m_limbBitLength)\n            c[i + j] = static_cast&lt;limb_t&gt;(ofl += limbb * A-&gt;m_value[j]);\n        c[i + aSize] = static_cast&lt;limb_t&gt;(ofl);\n\n        ans = std::move(ans.Add(ubint(std::move(c))));\n    }\n    if (ans &gt;= modulus)\n        return ans.Mod(modulus);\n    return ans;\n}\n\n// Extended Euclid algorithm used to find the multiplicative inverse\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModInverse(const ubint&amp; modulus) const {\n    if (m_MSB == 0)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Zero has no inverse&quot;);\n\n    ubint second(*this);\n    if (second &gt;= modulus)\n        second = second.Mod(modulus);\n    if (second.m_MSB == 1)\n        return second;\n\n    // NORTH ALGORITHM\n    ubint first(modulus);\n    std::vector&lt;ubint&gt; quotient;\n    quotient.reserve(8);  // TODO\n\n    ubint q, mod_back;\n    divqr_vect(q, mod_back, first, second);\n    quotient.emplace_back(std::move(q));\n\n    if (mod_back.m_MSB == 0) {\n        std::string msg = ubint&lt;limb_t&gt;::ToString() + &quot; does not have a ModInverse using &quot; + modulus.ToString();\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, msg);\n    }\n\n    // max number of iterations should be &lt; 2^k where k == min(bitsize(inputs))\n    // TODO: consider breaking out of the loop if this limit exceeded.\n    //       loop counter would need to be a ubint.\n    while (mod_back.m_MSB != 1) {\n        first  = second;\n        second = mod_back;\n\n        ubint q;\n        divqr_vect(q, mod_back, first, second);\n        quotient.emplace_back(std::move(q));\n    }\n\n    // SOUTH ALGORITHM\n    first  = ubint();\n    second = ubint(1);\n    for (auto it = quotient.rbegin(); it != quotient.rend(); ++it) {\n        mod_back = *it * second + first;\n        first    = second;\n        second   = mod_back;\n    }\n    if (quotient.size() &amp; 0x1)\n        return modulus - mod_back;\n    return mod_back;\n}\n\n// Modular Exponentiation using Square and Multiply Algorithm\n// reference:http://guan.cse.nsysu.edu.tw/note/expn.pdf\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::ModExp(const ubint&amp; b, const ubint&amp; modulus) const {\n    ubint t(this-&gt;Mod(modulus));\n    ubint p(b);\n    ubint r(1);\n    if (p.m_value[0] &amp; 0x1)\n        r = r.ModMulFast(t, modulus);\n    while ((p &gt;&gt;= 1).m_MSB) {\n        t = t.ModMulFast(t, modulus);\n        if (p.m_value[0] &amp; 0x1)\n            r = r.ModMulFast(t, modulus);\n    }\n    return r;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::LShift(usshort shift) const {\n    static constexpr usshort mask{m_limbBitLength - 1};\n    if (m_MSB == 0)\n        return ubint();\n    auto ans(*this);\n    ans.m_MSB += shift;\n    size_t shiftByLimb{static_cast&lt;size_t&gt;(shift) &gt;&gt; m_log2LimbBitLength};\n    shift &amp;= mask;\n    if (shift) {\n        Dlimb_t ofl{0};\n        for (auto&amp; v : ans.m_value) {\n            ofl |= static_cast&lt;Dlimb_t&gt;(v) &lt;&lt; shift;\n            v = static_cast&lt;limb_t&gt;(ofl);\n            ofl &gt;&gt;= m_limbBitLength;\n        }\n        if (ofl)\n            ans.m_value.push_back(static_cast&lt;limb_t&gt;(ofl));\n    }\n    if (shiftByLimb) {\n        size_t j = ans.m_value.size();\n        size_t i = j + shiftByLimb;\n        ans.m_value.resize(i);\n        while (i &gt; 0)\n            ans.m_value[--i] = (j &gt; 0) ? ans.m_value[--j] : 0;\n    }\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::LShiftEq(usshort shift) {\n    static constexpr usshort mask{m_limbBitLength - 1};\n    if (m_MSB == 0)\n        return *this;\n    m_MSB += shift;\n    size_t shiftByLimb{static_cast&lt;size_t&gt;(shift) &gt;&gt; m_log2LimbBitLength};\n    shift &amp;= mask;\n    if (shift) {\n        Dlimb_t ofl{0};\n        for (auto&amp; v : m_value) {\n            ofl |= static_cast&lt;Dlimb_t&gt;(v) &lt;&lt; shift;\n            v = static_cast&lt;limb_t&gt;(ofl);\n            ofl &gt;&gt;= m_limbBitLength;\n        }\n        if (ofl)\n            m_value.push_back(static_cast&lt;limb_t&gt;(ofl));\n    }\n    if (shiftByLimb) {\n        size_t j = m_value.size();\n        size_t i = j + shiftByLimb;\n        m_value.resize(i);\n        while (i &gt; 0)\n            m_value[--i] = (j &gt; 0) ? m_value[--j] : 0;\n    }\n    return *this;\n}\n\n/**Right Shift is done by splitting the number of shifts into\n *1. Multiple of the bit length of limb data type.\n *  Shifting is done by the shifting the limb type numbers in the array to\n *the right.\n *2. Shifts between 1 to bit length of limb data type.\n *   Shifting is done by using bit shift operations and carry over propagation.\n */\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::RShift(usshort shift) const {\n    static constexpr usshort mask{m_limbBitLength - 1};\n    if (m_MSB &lt;= shift)\n        return ubint(0);\n    ubint ans(*this);\n    ans.m_MSB -= shift;\n    size_t shiftByLimb{static_cast&lt;size_t&gt;(shift) &gt;&gt; m_log2LimbBitLength};\n    shift &amp;= mask;\n    Dlimb_t tmp{ans.m_value[shiftByLimb++] &gt;&gt; shift};\n    usint lshift{m_limbBitLength - shift};\n    size_t size{ans.m_value.size() - shiftByLimb};\n    for (size_t i = 0; i &lt; size; ++i, tmp &gt;&gt;= m_limbBitLength) {\n        tmp |= static_cast&lt;Dlimb_t&gt;(ans.m_value[i + shiftByLimb]) &lt;&lt; lshift;\n        ans.m_value[i] = static_cast&lt;limb_t&gt;(tmp);\n    }\n    ans.m_value.resize(size);\n    if (tmp)\n        ans.m_value.push_back(static_cast&lt;limb_t&gt;(tmp));\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt;&amp; ubint&lt;limb_t&gt;::RShiftEq(usshort shift) {\n    static constexpr usshort mask{m_limbBitLength - 1};\n    if (m_MSB &lt;= shift) {\n        m_MSB = 0;\n        m_value.resize(1);\n        m_value[0] = 0;\n        return *this;\n    }\n    m_MSB -= shift;\n    size_t shiftByLimb{static_cast&lt;size_t&gt;(shift) &gt;&gt; m_log2LimbBitLength};\n    shift &amp;= mask;\n    Dlimb_t tmp{m_value[shiftByLimb++] &gt;&gt; shift};\n    usint lshift{m_limbBitLength - shift};\n    size_t size{m_value.size() - shiftByLimb};\n    for (size_t i = 0; i &lt; size; ++i, tmp &gt;&gt;= m_limbBitLength) {\n        tmp |= static_cast&lt;Dlimb_t&gt;(m_value[i + shiftByLimb]) &lt;&lt; lshift;\n        m_value[i] = static_cast&lt;limb_t&gt;(tmp);\n    }\n    m_value.resize(size);\n    if (tmp)\n        m_value.push_back(static_cast&lt;limb_t&gt;(tmp));\n    return *this;\n}\n\n// Converts the ubint to float using the std library functions.\ntemplate &lt;typename limb_t&gt;\nfloat ubint&lt;limb_t&gt;::ConvertToFloat() const {\n    float ans{-1.0f};\n    try {\n        ans = std::stof(ubint&lt;limb_t&gt;::ToString());\n    }\n    catch (const std::exception&amp; e) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::type_error, &quot;ConvertToFloat() parse error converting to float&quot;);\n    }\n    return ans;\n}\n\ntemplate &lt;typename limb_t&gt;\ndouble ubint&lt;limb_t&gt;::ConvertToDouble() const {\n    double ans{-1.0};\n    try {\n        // ans = std::stod(this-&gt;ToString());\n        usint ceilInt = MSBToLimbs(m_MSB);\n        double factor = pow(2, m_limbBitLength);\n        double power  = 1.0;\n\n        ans = 0.0;\n        for (usint i = 0; i &lt; ceilInt; ++i, power *= factor)\n            ans += power * m_value[i];\n    }\n    catch (const std::exception&amp; e) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::type_error, &quot;ConvertToDouble() parse error converting to double&quot;);\n    }\n    return ans;\n}\n\n// Converts the ubint to long double using the std library functions.\ntemplate &lt;typename limb_t&gt;\nlong double ubint&lt;limb_t&gt;::ConvertToLongDouble() const {\n    long double ans{-1.0};\n    try {\n        ans = std::stold(ubint&lt;limb_t&gt;::ToString());\n    }\n    catch (const std::exception&amp; e) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::type_error, &quot;ConvertToLongDouble() parse error converting to long double&quot;);\n    }\n    return ans;\n}\n\n// TODO\n// Splits binary string to equi sized chunks then populates internal array values\ntemplate &lt;typename limb_t&gt;\nubint&lt;limb_t&gt; ubint&lt;limb_t&gt;::FromBinaryString(const std::string&amp; vin) {\n    std::string v = vin;\n    // v.erase(0, v.find_first_not_of(&#x27; &#x27;));\n    v.erase(0, v.find_first_not_of(&#x27;0&#x27;));\n    if (v.size() == 0)\n        return ubint();\n    ubint value;\n    value.m_value.clear();\n    usint len  = v.length();\n    usint cntr = MSBToLimbs(len);\n    std::string val;\n    Dlimb_t partial_value = 0;\n    for (usint i = 0; i &lt; cntr; i++) {\n        if (len &gt; ((i + 1) * m_limbBitLength)) {\n            val = v.substr((len - (i + 1) * m_limbBitLength), m_limbBitLength);\n        }\n        else {\n            val = v.substr(0, len % m_limbBitLength);\n        }\n        for (usint j = 0; j &lt; val.length(); j++) {\n            partial_value += std::stoi(val.substr(j, 1));\n            partial_value &lt;&lt;= 1;\n        }\n        partial_value &gt;&gt;= 1;\n        value.m_value.push_back((limb_t)partial_value);\n        partial_value = 0;\n    }\n    value.SetMSB();\n    return value;\n}\n\n// TODO: * i to &lt;&lt; i\ntemplate &lt;typename limb_t&gt;\nusint ubint&lt;limb_t&gt;::GetDigitAtIndexForBase(usint index, usint base) const {\n    usint DigitLen = ceil(log2(base));\n    usint digit    = 0;\n    usint newIndex = 1 + (index - 1) * DigitLen;\n    for (usint i = 1; i &lt; base; i &lt;&lt;= 1) {\n        digit += GetBitAtIndex(newIndex++) * i;\n    }\n    return digit;\n}\n\ntemplate &lt;typename limb_t&gt;\nconst std::string ubint&lt;limb_t&gt;::ToString() const {\n    std::vector&lt;uschar&gt; val{0};\n    val.reserve(m_MSB &gt;&gt; 1);\n    for (usint i = m_MSB; i &gt; 0; --i) {\n        auto ofl = GetBitAtIndex(i);  // TODO: needlessly expensive here\n        for (auto&amp; a : val) {\n            a = (a &lt;&lt; 1) + ofl;\n            if ((ofl = (a &gt; 9)))\n                a -= 10;\n        }\n        if (ofl)\n            val.push_back(1);\n    }\n    for (auto&amp; a : val)\n        a += &#x27;0&#x27;;\n    return std::string(val.rbegin(), val.rend());\n}\n\n/* q[0], r[0], u[0], and v[0] contain the LEAST significant words.\n (The sequence is in little-endian order).\n\n This is a fairly precise implementation of Knuth&#x27;s Algorithm D, for a\n binary computer with base b = 2**(32|64). The caller supplies:\n 1. Space q for the quotient, m - n + 1 words (at least one).\n 2. Space r for the remainder (optional), n words.\n 3. The dividend u, m words, m &gt;= 1.\n 4. The divisor v, n words, n &gt;= 2.\n The most significant digit of the divisor, v[n-1], must be nonzero.  The\n dividend u may have leading zeros; this just makes the algorithm take\n longer and makes the quotient contain more leading zeros.  A value of\n nullptr may be given for the address of the remainder to signify that the\n caller does not want the remainder.\n The program does not alter the input parameters u and v.\n The quotient and remainder returned may have leading zeros.  The\n function itself returns a value of 0 for success and 1 for invalid\n parameters (e.g., division by 0).\n For now, we must have m &gt;= n.  Knuth&#x27;s Algorithm D also requires\n that the dividend be at least as long as the divisor.  (In his terms,\n m &gt;= 0 (unstated).  Therefore m+n &gt;= n.) */\n\ntemplate &lt;typename limb_t&gt;\nvoid ubint&lt;limb_t&gt;::divqr_vect(ubint&amp; qin, ubint&amp; rin, const ubint&amp; uin, const ubint&amp; vin) const noexcept {\n    auto&amp; u = uin.m_value;\n    int m   = u.size();\n    auto&amp; v = vin.m_value;\n    int n   = v.size();\n    auto&amp; q = qin.m_value;\n    q.resize(m - n + 1);\n    auto&amp; r = rin.m_value;\n    Dlimb_t ofl{0};\n\n    if (n == 1) {\n        for (int i = m - 1; i &gt;= 0; --i) {\n            ofl  = (ofl &lt;&lt; m_limbBitLength) | u[i];\n            q[i] = static_cast&lt;limb_t&gt;(ofl / v[0]);\n            ofl %= v[0];\n        }\n        qin.NormalizeLimbs();\n\n        r.resize(1);\n        r[0]      = static_cast&lt;limb_t&gt;(ofl);\n        rin.m_MSB = lbcrypto::GetMSB(r[0]);\n        return;\n    }\n\n    // Normalize by shifting v left just enough so that its high-order\n    // bit is set, and shift u left the same amount. We may have to append a\n    // high-order digit on the dividend; we do that unconditionally.\n\n    auto sl{m_limbBitLength - lbcrypto::GetMSB(v.back())};\n    std::vector&lt;limb_t&gt; vn(n);\n    ofl = 0;\n    for (int i = 0; i &lt; n; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(v[i]) &lt;&lt; sl;\n        vn[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    std::vector&lt;limb_t&gt; un(m + 1);\n    ofl = 0;\n    for (int i = 0; i &lt; m; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(u[i]) &lt;&lt; sl;\n        un[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    un[m] = static_cast&lt;limb_t&gt;(ofl);\n    Dlimb_t qhat, rhat, p;\n    for (int j = m - n; j &gt;= 0; --j) {\n        ofl  = (static_cast&lt;Dlimb_t&gt;(un[j + n]) &lt;&lt; m_limbBitLength) | un[j + n - 1];\n        qhat = ofl / vn[n - 1];\n        rhat = ofl % vn[n - 1];\n        while ((qhat &gt;&gt; m_limbBitLength) || ((qhat * vn[n - 2]) &gt; ((rhat &lt;&lt; m_limbBitLength) | un[j + n - 2]))) {\n            qhat -= 1;\n            rhat += vn[n - 1];\n            if (rhat &gt;&gt; m_limbBitLength)\n                break;\n        }\n        SDlimb_t k{0}, t;\n        for (int i = 0; i &lt; n; ++i) {\n            p         = qhat * vn[i];\n            t         = un[i + j] - k - (p &amp; m_MaxLimb);\n            un[i + j] = static_cast&lt;limb_t&gt;(t);\n            k         = (p &gt;&gt; m_limbBitLength) - (t &gt;&gt; m_limbBitLength);\n        }\n        t         = un[j + n] - k;\n        un[j + n] = static_cast&lt;limb_t&gt;(t);\n        q[j]      = qhat;\n        if (t &lt; 0) {\n            q[j] -= 1;\n            k = 0;\n            for (int i = 0; i &lt; n; ++i) {\n                t         = static_cast&lt;Dlimb_t&gt;(un[i + j]) + vn[i] + k;\n                un[i + j] = static_cast&lt;limb_t&gt;(t);\n                k         = t &gt;&gt; m_limbBitLength;\n            }\n            un[j + n] += k;\n        }\n    }\n    qin.NormalizeLimbs();\n\n    ofl = un[0] &gt;&gt; sl;\n    auto sr{m_limbBitLength - sl};\n    r.resize(n--);\n    for (int i = 0; i &lt; n; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(un[i + 1]) &lt;&lt; sr;\n        r[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    r[n] = un[n] &gt;&gt; sl;\n    rin.NormalizeLimbs();\n}\n\ntemplate &lt;typename limb_t&gt;\nvoid ubint&lt;limb_t&gt;::divq_vect(ubint&amp; qin, const ubint&amp; uin, const ubint&amp; vin) const noexcept {\n    auto&amp; u = uin.m_value;\n    int m   = u.size();\n    auto&amp; v = vin.m_value;\n    int n   = v.size();\n    auto&amp; q = qin.m_value;\n    q.resize(m - n + 1);\n    Dlimb_t ofl{0};\n\n    if (n == 1) {\n        for (int i = m - 1; i &gt;= 0; --i) {\n            ofl  = (ofl &lt;&lt; m_limbBitLength) | u[i];\n            q[i] = static_cast&lt;limb_t&gt;(ofl / v[0]);\n            ofl %= v[0];\n        }\n        qin.NormalizeLimbs();\n        return;\n    }\n\n    auto sl{m_limbBitLength - lbcrypto::GetMSB(v.back())};\n    std::vector&lt;limb_t&gt; vn(n);\n    ofl = 0;\n    for (int i = 0; i &lt; n; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(v[i]) &lt;&lt; sl;\n        vn[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    std::vector&lt;limb_t&gt; un(m + 1);\n    ofl = 0;\n    for (int i = 0; i &lt; m; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(u[i]) &lt;&lt; sl;\n        un[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    un[m] = static_cast&lt;limb_t&gt;(ofl);\n    Dlimb_t qhat, rhat, p;\n    for (int j = m - n; j &gt;= 0; --j) {\n        ofl  = (static_cast&lt;Dlimb_t&gt;(un[j + n]) &lt;&lt; m_limbBitLength) | un[j + n - 1];\n        qhat = ofl / vn[n - 1];\n        rhat = ofl % vn[n - 1];\n        while ((qhat &gt;&gt; m_limbBitLength) || ((qhat * vn[n - 2]) &gt; ((rhat &lt;&lt; m_limbBitLength) | un[j + n - 2]))) {\n            qhat -= 1;\n            rhat += vn[n - 1];\n            if (rhat &gt;&gt; m_limbBitLength)\n                break;\n        }\n        SDlimb_t k{0}, t;\n        for (int i = 0; i &lt; n; ++i) {\n            p         = qhat * vn[i];\n            t         = un[i + j] - k - (p &amp; m_MaxLimb);\n            un[i + j] = static_cast&lt;limb_t&gt;(t);\n            k         = (p &gt;&gt; m_limbBitLength) - (t &gt;&gt; m_limbBitLength);\n        }\n        t         = un[j + n] - k;\n        un[j + n] = static_cast&lt;limb_t&gt;(t);\n        q[j]      = qhat;\n        if (t &lt; 0) {\n            q[j] -= 1;\n            k = 0;\n            for (int i = 0; i &lt; n; ++i) {\n                t         = static_cast&lt;Dlimb_t&gt;(un[i + j]) + vn[i] + k;\n                un[i + j] = static_cast&lt;limb_t&gt;(t);\n                k         = t &gt;&gt; m_limbBitLength;\n            }\n            un[j + n] += k;\n        }\n    }\n    qin.NormalizeLimbs();\n}\n\ntemplate &lt;typename limb_t&gt;\nvoid ubint&lt;limb_t&gt;::divr_vect(ubint&amp; rin, const ubint&amp; uin, const ubint&amp; vin) const noexcept {\n    auto&amp; u = uin.m_value;\n    int m   = u.size();\n    auto&amp; v = vin.m_value;\n    int n   = v.size();\n    auto&amp; r = rin.m_value;\n    Dlimb_t ofl{0};\n\n    if (n == 1) {\n        std::vector&lt;limb_t&gt; q(m - n + 1);\n        for (int i = m - 1; i &gt;= 0; --i) {\n            ofl  = (ofl &lt;&lt; m_limbBitLength) | u[i];\n            q[i] = static_cast&lt;limb_t&gt;(ofl / v[0]);\n            ofl %= v[0];\n        }\n        r[0]      = static_cast&lt;limb_t&gt;(ofl);\n        rin.m_MSB = lbcrypto::GetMSB(r[0]);\n        return;\n    }\n\n    auto sl{m_limbBitLength - lbcrypto::GetMSB(v.back())};\n    std::vector&lt;limb_t&gt; vn(n);\n    ofl = 0;\n    for (int i = 0; i &lt; n; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(v[i]) &lt;&lt; sl;\n        vn[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    std::vector&lt;limb_t&gt; un(m + 1);\n    ofl = 0;\n    for (int i = 0; i &lt; m; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(u[i]) &lt;&lt; sl;\n        un[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    un[m] = static_cast&lt;limb_t&gt;(ofl);\n    Dlimb_t qhat, rhat, p;\n    for (int j = m - n; j &gt;= 0; --j) {\n        ofl  = (static_cast&lt;Dlimb_t&gt;(un[j + n]) &lt;&lt; m_limbBitLength) | un[j + n - 1];\n        qhat = ofl / vn[n - 1];\n        rhat = ofl % vn[n - 1];\n        while ((qhat &gt;&gt; m_limbBitLength) || ((qhat * vn[n - 2]) &gt; ((rhat &lt;&lt; m_limbBitLength) | un[j + n - 2]))) {\n            qhat -= 1;\n            rhat += vn[n - 1];\n            if (rhat &gt;&gt; m_limbBitLength)\n                break;\n        }\n        SDlimb_t k{0}, t;\n        for (int i = 0; i &lt; n; ++i) {\n            p         = qhat * vn[i];\n            t         = un[i + j] - k - (p &amp; m_MaxLimb);\n            un[i + j] = static_cast&lt;limb_t&gt;(t);\n            k         = (p &gt;&gt; m_limbBitLength) - (t &gt;&gt; m_limbBitLength);\n        }\n        t         = un[j + n] - k;\n        un[j + n] = static_cast&lt;limb_t&gt;(t);\n        if (t &lt; 0) {\n            k = 0;\n            for (int i = 0; i &lt; n; ++i) {\n                t         = static_cast&lt;Dlimb_t&gt;(un[i + j]) + vn[i] + k;\n                un[i + j] = static_cast&lt;limb_t&gt;(t);\n                k         = t &gt;&gt; m_limbBitLength;\n            }\n            un[j + n] += k;\n        }\n    }\n\n    r.resize(n--);\n    ofl = un[0] &gt;&gt; sl;\n    auto sr{m_limbBitLength - sl};\n    for (int i = 0; i &lt; n; ++i, ofl &gt;&gt;= m_limbBitLength) {\n        ofl |= static_cast&lt;Dlimb_t&gt;(un[i + 1]) &lt;&lt; sr;\n        r[i] = static_cast&lt;limb_t&gt;(ofl);\n    }\n    r[n] = un[n] &gt;&gt; sl;\n    rin.NormalizeLimbs();\n}\n\n// Initializes the vector of limbs from the string equivalent of ubint\n// Algorithm used is repeated division by 2\n// Reference:http://pctechtips.org/convert-from-decimal-to-binary-with-recursion-in-java/\ntemplate &lt;typename limb_t&gt;\nvoid ubint&lt;limb_t&gt;::SetValue(const std::string&amp; vin) {\n    std::string v{vin};\n    // v.erase(0, v.find_first_not_of(&#x27; &#x27;));\n    v.erase(0, v.find_first_not_of(&#x27;0&#x27;));\n    if (v.size() == 0)\n        v = &quot;0&quot;;\n\n    size_t arrSize = v.length() - 1;\n    for (size_t i = 0; i &lt;= arrSize; ++i)\n        v[i] -= &#x27;0&#x27;;\n\n    m_value.clear();\n    //    m_value.reserve(MSBToLimbs(arrSize &lt;&lt; 2));\n    usint cnt{0};\n    limb_t val{0};\n    size_t zptr{0};\n    while (zptr &lt;= arrSize) {\n        val |= static_cast&lt;limb_t&gt;(v[arrSize] &amp; 0x1) &lt;&lt; cnt++;\n        for (size_t i = zptr; i &lt; arrSize; ++i) {\n            v[i + 1] += (v[i] &amp; 0x1) * 10;\n            v[i] &gt;&gt;= 1;\n        }\n        v[arrSize] &gt;&gt;= 1;\n        if (v[zptr] == 0)\n            zptr++;\n\n        if ((cnt == m_limbBitLength) || (zptr &gt; arrSize)) {\n            m_value.push_back(val);\n            cnt = val = 0;\n        }\n    }\n    ubint&lt;limb_t&gt;::NormalizeLimbs();\n}\n\ntemplate &lt;typename limb_t&gt;\nuschar ubint&lt;limb_t&gt;::GetBitAtIndex(usint index) const {\n    constexpr usint mask{m_limbBitLength - 1};\n    if (index &gt; m_MSB)\n        return 0;\n    size_t idx{MSBToLimbs(index) - 1};\n    index &amp;= mask;\n    return static_cast&lt;uschar&gt;((m_value[idx] &gt;&gt; (index ? index - 1 : mask)) &amp; 0x1);\n}\n\ntemplate class bigintdyn::ubint&lt;expdtype&gt;;\n\n    #if 0\n// to stream internal representation\ntemplate std::ostream&amp; operator&lt;&lt;&lt;expdtype&gt;(std::ostream&amp; os, const std::vector&lt;expdtype&gt;&amp; v);\n    #endif\n\n}  // namespace bigintdyn\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Creates Represents integer lattice elements\n */\n\n#ifndef LBCRYPTO_INC_LATTICE_HAL_DEFAULT_POLY_H\n#define LBCRYPTO_INC_LATTICE_HAL_DEFAULT_POLY_H\n\n#include &quot;lattice/hal/poly-interface.h&quot;\n#include &quot;lattice/ildcrtparams.h&quot;\n#include &quot;lattice/ilparams.h&quot;\n\n#include &quot;math/distrgen.h&quot;\n#include &quot;math/math-hal.h&quot;\n#include &quot;math/nbtheory.h&quot;\n\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/inttypes.h&quot;\n\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\nnamespace lbcrypto {\n\n/**\n * @class PolyImpl\n * @file poly.h\n * @brief Ideal lattice using a vector representation\n */\ntemplate &lt;typename VecType&gt;\nclass PolyImpl final : public PolyInterface&lt;PolyImpl&lt;VecType&gt;, VecType, PolyImpl&gt; {\npublic:\n    using Vector            = VecType;\n    using Integer           = typename VecType::Integer;\n    using Params            = ILParamsImpl&lt;Integer&gt;;\n    using PolyNative        = PolyImpl&lt;NativeVector&gt;;\n    using PolyType          = PolyImpl&lt;VecType&gt;;\n    using PolyLargeType     = PolyImpl&lt;VecType&gt;;\n    using PolyInterfaceType = PolyInterface&lt;PolyImpl&lt;VecType&gt;, VecType, PolyImpl&gt;;\n    using DggType           = typename PolyInterfaceType::DggType;\n    using DugType           = typename PolyInterfaceType::DugType;\n    using TugType           = typename PolyInterfaceType::TugType;\n    using BugType           = typename PolyInterfaceType::BugType;\n\n    constexpr PolyImpl() = default;\n\n    PolyImpl(const std::shared_ptr&lt;Params&gt;&amp; params, Format format = Format::EVALUATION,\n             bool initializeElementToZero = false)\n        : m_format{format}, m_params{params} {\n        if (initializeElementToZero)\n            PolyImpl::SetValuesToZero();\n    }\n    PolyImpl(const std::shared_ptr&lt;ILDCRTParams&lt;Integer&gt;&gt;&amp; params, Format format = Format::EVALUATION,\n             bool initializeElementToZero = false);\n\n    PolyImpl(bool initializeElementToMax, const std::shared_ptr&lt;Params&gt;&amp; params, Format format = Format::EVALUATION)\n        : m_format{format}, m_params{params} {\n        if (initializeElementToMax)\n            PolyImpl::SetValuesToMax();\n    }\n    PolyImpl(const DggType&amp; dgg, const std::shared_ptr&lt;Params&gt;&amp; params, Format format = Format::EVALUATION);\n    PolyImpl(DugType&amp; dug, const std::shared_ptr&lt;Params&gt;&amp; params, Format format = Format::EVALUATION);\n    PolyImpl(const BugType&amp; bug, const std::shared_ptr&lt;Params&gt;&amp; params, Format format = Format::EVALUATION);\n    PolyImpl(const TugType&amp; tug, const std::shared_ptr&lt;Params&gt;&amp; params, Format format = Format::EVALUATION,\n             uint32_t h = 0);\n\n    template &lt;typename T = VecType&gt;\n    PolyImpl(const PolyNative&amp; rhs, Format format,\n             typename std::enable_if_t&lt;std::is_same_v&lt;T, NativeVector&gt;, bool&gt; = true)\n        : m_format{rhs.m_format},\n          m_params{rhs.m_params},\n          m_values{rhs.m_values ? std::make_unique&lt;VecType&gt;(*rhs.m_values) : nullptr} {\n        PolyImpl&lt;VecType&gt;::SetFormat(format);\n    }\n\n    template &lt;typename T = VecType&gt;\n    PolyImpl(const PolyNative&amp; rhs, Format format,\n             typename std::enable_if_t&lt;!std::is_same_v&lt;T, NativeVector&gt;, bool&gt; = true)\n        : m_format{rhs.GetFormat()} {\n        auto c{rhs.GetParams()-&gt;GetCyclotomicOrder()};\n        auto m{rhs.GetParams()-&gt;GetModulus().ConvertToInt()};\n        auto r{rhs.GetParams()-&gt;GetRootOfUnity().ConvertToInt()};\n        m_params = std::make_shared&lt;PolyImpl::Params&gt;(c, m, r);\n\n        const auto&amp; v{rhs.GetValues()};\n        uint32_t vlen{m_params-&gt;GetRingDimension()};\n        VecType tmp(vlen);\n        tmp.SetModulus(m_params-&gt;GetModulus());\n        for (uint32_t i{0}; i &lt; vlen; ++i)\n            tmp[i] = Integer(v[i]);\n        m_values = std::make_unique&lt;VecType&gt;(tmp);\n        PolyImpl&lt;VecType&gt;::SetFormat(format);\n    }\n\n    PolyImpl(const PolyType&amp; p) noexcept\n        : m_format{p.m_format},\n          m_params{p.m_params},\n          m_values{p.m_values ? std::make_unique&lt;VecType&gt;(*p.m_values) : nullptr} {}\n\n    PolyImpl(PolyType&amp;&amp; p) noexcept\n        : m_format{p.m_format}, m_params{std::move(p.m_params)}, m_values{std::move(p.m_values)} {}\n\n    PolyType&amp; operator=(const PolyType&amp; rhs) noexcept override;\n    PolyType&amp; operator=(PolyType&amp;&amp; rhs) noexcept override {\n        m_format = std::move(rhs.m_format);\n        m_params = std::move(rhs.m_params);\n        m_values = std::move(rhs.m_values);\n        return *this;\n    }\n    PolyType&amp; operator=(const std::vector&lt;int32_t&gt;&amp; rhs);\n    PolyType&amp; operator=(const std::vector&lt;int64_t&gt;&amp; rhs);\n    PolyType&amp; operator=(std::initializer_list&lt;uint64_t&gt; rhs) override;\n    PolyType&amp; operator=(std::initializer_list&lt;std::string&gt; rhs);\n    PolyType&amp; operator=(uint64_t val);\n\n    PolyNative DecryptionCRTInterpolate(PlaintextModulus ptm) const override;\n    PolyNative ToNativePoly() const final {\n        usint vlen{m_params-&gt;GetRingDimension()};\n        auto c{m_params-&gt;GetCyclotomicOrder()};\n        NativeInteger m{std::numeric_limits&lt;BasicInteger&gt;::max()};\n        auto params{std::make_shared&lt;ILParamsImpl&lt;NativeInteger&gt;&gt;(c, m, 1)};\n        typename PolyImpl&lt;VecType&gt;::PolyNative tmp(params, m_format, true);\n        for (usint i = 0; i &lt; vlen; ++i)\n            tmp[i] = NativeInteger((*m_values)[i]);\n        return tmp;\n    }\n\n    void SetValues(const VecType&amp; values, Format format) override;\n    void SetValues(VecType&amp;&amp; values, Format format) override;\n\n    void SetValuesToZero() override {\n        usint r{m_params-&gt;GetRingDimension()};\n        m_values = std::make_unique&lt;VecType&gt;(r, m_params-&gt;GetModulus());\n    }\n\n    void SetValuesToMax() override {\n        usint r{m_params-&gt;GetRingDimension()};\n        auto max{m_params-&gt;GetModulus() - Integer(1)};\n        m_values = std::make_unique&lt;VecType&gt;(r, m_params-&gt;GetModulus(), max);\n    }\n\n    inline Format GetFormat() const final {\n        return m_format;\n    }\n\n    void OverrideFormat(const Format f) final {\n        m_format = f;\n    }\n\n    inline const std::shared_ptr&lt;Params&gt;&amp; GetParams() const {\n        return m_params;\n    }\n\n    inline const VecType&amp; GetValues() const final {\n        if (m_values == nullptr)\n            &quot;hey&quot;; OPENFHE_THROW(not_available_error, &quot;No values in PolyImpl&quot;);\n        return *m_values;\n    }\n\n    inline bool IsEmpty() const final {\n        return m_values == nullptr;\n    }\n\n    inline Integer&amp; at(usint i) final {\n        if (m_values == nullptr)\n            &quot;hey&quot;; OPENFHE_THROW(not_available_error, &quot;No values in PolyImpl&quot;);\n        return m_values-&gt;at(i);\n    }\n\n    inline const Integer&amp; at(usint i) const final {\n        if (m_values == nullptr)\n            &quot;hey&quot;; OPENFHE_THROW(not_available_error, &quot;No values in PolyImpl&quot;);\n        return m_values-&gt;at(i);\n    }\n\n    inline Integer&amp; operator[](usint i) final {\n        return (*m_values)[i];\n    }\n\n    inline const Integer&amp; operator[](usint i) const final {\n        return (*m_values)[i];\n    }\n\n    PolyImpl Plus(const PolyImpl&amp; rhs) const override {\n        if (m_params-&gt;GetRingDimension() != rhs.m_params-&gt;GetRingDimension())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;RingDimension missmatch&quot;);\n        if (m_params-&gt;GetModulus() != rhs.m_params-&gt;GetModulus())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Modulus missmatch&quot;);\n        if (m_format != rhs.m_format)\n            &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;Format missmatch&quot;);\n        auto tmp(*this);\n        tmp.m_values-&gt;ModAddNoCheckEq(*rhs.m_values);\n        return tmp;\n    }\n    PolyImpl PlusNoCheck(const PolyImpl&amp; rhs) const {\n        auto tmp(*this);\n        tmp.m_values-&gt;ModAddNoCheckEq(*rhs.m_values);\n        return tmp;\n    }\n    PolyImpl&amp; operator+=(const PolyImpl&amp; element) override;\n\n    PolyImpl Plus(const Integer&amp; element) const override;\n    PolyImpl&amp; operator+=(const Integer&amp; element) override {\n        return *this = this-&gt;Plus(element);  // don&#x27;t change this\n    }\n\n    PolyImpl Minus(const PolyImpl&amp; element) const override;\n    PolyImpl&amp; operator-=(const PolyImpl&amp; element) override;\n\n    PolyImpl Minus(const Integer&amp; element) const override;\n    PolyImpl&amp; operator-=(const Integer&amp; element) override {\n        m_values-&gt;ModSubEq(element);\n        return *this;\n    }\n\n    PolyImpl Times(const PolyImpl&amp; rhs) const override {\n        if (m_params-&gt;GetRingDimension() != rhs.m_params-&gt;GetRingDimension())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;RingDimension missmatch&quot;);\n        if (m_params-&gt;GetModulus() != rhs.m_params-&gt;GetModulus())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Modulus missmatch&quot;);\n        if (m_format != Format::EVALUATION || rhs.m_format != Format::EVALUATION)\n            &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;operator* for PolyImpl supported only in Format::EVALUATION&quot;);\n        auto tmp(*this);\n        tmp.m_values-&gt;ModMulNoCheckEq(*rhs.m_values);\n        return tmp;\n    }\n    PolyImpl TimesNoCheck(const PolyImpl&amp; rhs) const {\n        auto tmp(*this);\n        tmp.m_values-&gt;ModMulNoCheckEq(*rhs.m_values);\n        return tmp;\n    }\n    PolyImpl&amp; operator*=(const PolyImpl&amp; rhs) override {\n        if (m_params-&gt;GetRingDimension() != rhs.m_params-&gt;GetRingDimension())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;RingDimension missmatch&quot;);\n        if (m_params-&gt;GetModulus() != rhs.m_params-&gt;GetModulus())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Modulus missmatch&quot;);\n        if (m_format != Format::EVALUATION || rhs.m_format != Format::EVALUATION)\n            &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;operator* for PolyImpl supported only in Format::EVALUATION&quot;);\n        if (m_values) {\n            m_values-&gt;ModMulNoCheckEq(*rhs.m_values);\n            return *this;\n        }\n        m_values = std::make_unique&lt;VecType&gt;(m_params-&gt;GetRingDimension(), m_params-&gt;GetModulus());\n        return *this;\n    }\n\n    PolyImpl Times(const Integer&amp; element) const override;\n    PolyImpl&amp; operator*=(const Integer&amp; element) override {\n        m_values-&gt;ModMulEq(element);\n        return *this;\n    }\n\n    PolyImpl Times(NativeInteger::SignedNativeInt element) const override;\n#if NATIVEINT != 64\n    inline PolyImpl Times(int64_t element) const {\n        return this-&gt;Times(static_cast&lt;NativeInteger::SignedNativeInt&gt;(element));\n    }\n#endif\n\n    PolyImpl MultiplyAndRound(const Integer&amp; p, const Integer&amp; q) const override;\n    PolyImpl DivideAndRound(const Integer&amp; q) const override;\n\n    PolyImpl Negate() const override;\n    inline PolyImpl operator-() const override {\n        return PolyImpl(m_params, m_format, true) -= *this;\n    }\n\n    inline bool operator==(const PolyImpl&amp; rhs) const override {\n        return ((m_format == rhs.GetFormat()) &amp;&amp; (m_params-&gt;GetRootOfUnity() == rhs.GetRootOfUnity()) &amp;&amp;\n                (this-&gt;GetValues() == rhs.GetValues()));\n    }\n\n    void AddILElementOne() override;\n    PolyImpl AutomorphismTransform(uint32_t k) const override;\n    PolyImpl AutomorphismTransform(uint32_t k, const std::vector&lt;uint32_t&gt;&amp; vec) const override;\n    PolyImpl MultiplicativeInverse() const override;\n    PolyImpl ModByTwo() const override;\n    PolyImpl Mod(const Integer&amp; modulus) const override;\n\n    void SwitchModulus(const Integer&amp; modulus, const Integer&amp; rootOfUnity, const Integer&amp; modulusArb,\n                       const Integer&amp; rootOfUnityArb) override;\n    void SwitchFormat() override;\n    void MakeSparse(uint32_t wFactor) override;\n    bool InverseExists() const override;\n    double Norm() const override;\n    std::vector&lt;PolyImpl&gt; BaseDecompose(usint baseBits, bool evalModeAnswer) const override;\n    std::vector&lt;PolyImpl&gt; PowersOfBase(usint baseBits) const override;\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::make_nvp(&quot;v&quot;, m_values));\n        ar(::cereal::make_nvp(&quot;f&quot;, m_format));\n        ar(::cereal::make_nvp(&quot;p&quot;, m_params));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                 &quot; is from a later version of the library&quot;);\n        }\n        ar(::cereal::make_nvp(&quot;v&quot;, m_values));\n        ar(::cereal::make_nvp(&quot;f&quot;, m_format));\n        ar(::cereal::make_nvp(&quot;p&quot;, m_params));\n    }\n\n    static const std::string GetElementName() {\n        return &quot;PolyImpl&quot;;\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;Poly&quot;;\n    }\n\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\nprotected:\n    Format m_format{Format::EVALUATION};\n    std::shared_ptr&lt;Params&gt; m_params{nullptr};\n    std::unique_ptr&lt;VecType&gt; m_values{nullptr};\n    void ArbitrarySwitchFormat();\n};\n\n// TODO: fix issue with pke build system so this can be moved back to implementation file\ntemplate &lt;&gt;\ninline PolyImpl&lt;BigVector&gt;::PolyImpl(const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt;&amp; params, Format format,\n                                     bool initializeElementToZero)\n    : m_format(format), m_params(nullptr), m_values(nullptr) {\n    const auto c = params-&gt;GetCyclotomicOrder();\n    const auto m = params-&gt;GetModulus();\n    m_params     = std::make_shared&lt;ILParams&gt;(c, m, 1);\n    if (initializeElementToZero)\n        this-&gt;SetValuesToZero();\n}\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp": {"id": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  This file contains the cpp implementation of  mubintvec, a &lt;vector&gt; of ubint, with associated math operators\n */\n\n#include &quot;config_core.h&quot;\n#ifdef WITH_BE4\n\n    #include &quot;math/math-hal.h&quot;\n    #include &quot;math/hal/bigintdyn/mubintvecdyn.h&quot;\n\n    #include &quot;utils/exception.h&quot;\n    #include &quot;utils/inttypes.h&quot;\n    #include &quot;utils/serializable.h&quot;\n\n//    #include &quot;time.h&quot;\n//    #include &lt;chrono&gt;\n    #include &lt;initializer_list&gt;\n    #include &lt;string&gt;\n    #include &lt;vector&gt;\n\nnamespace bigintdyn {\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;::mubintvec(usint length, const ubint_el_t&amp; modulus,\n                                 std::initializer_list&lt;std::string&gt; rhs) noexcept\n    : m_modulus{modulus}, m_modulus_state{State::INITIALIZED}, m_data(length) {\n    const size_t len = (rhs.size() &lt; m_data.size()) ? rhs.size() : m_data.size();\n    for (size_t i = 0; i &lt; len; ++i)\n        m_data[i] = ubint_el_t(*(rhs.begin() + i)) % m_modulus;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;::mubintvec(usint length, const ubint_el_t&amp; modulus, std::initializer_list&lt;uint64_t&gt; rhs) noexcept\n    : m_modulus{modulus}, m_modulus_state{State::INITIALIZED}, m_data(length) {\n    const size_t len = (rhs.size() &lt; m_data.size()) ? rhs.size() : m_data.size();\n    for (size_t i = 0; i &lt; len; ++i)\n        m_data[i] = ubint_el_t(*(rhs.begin() + i)) % m_modulus;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;::mubintvec(const std::vector&lt;std::string&gt;&amp; s, const ubint_el_t&amp; modulus) noexcept\n    : m_modulus{modulus}, m_modulus_state{State::INITIALIZED}, m_data(s.size()) {\n    for (size_t i = 0; i &lt; s.size(); ++i)\n        m_data[i] = ubint_el_t(s[i]) % m_modulus;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;::mubintvec(const std::vector&lt;std::string&gt;&amp; s, const std::string&amp; modulus) noexcept\n    : m_modulus{modulus}, m_modulus_state{State::INITIALIZED}, m_data(s.size()) {\n    for (size_t i = 0; i &lt; s.size(); ++i)\n        m_data[i] = ubint_el_t(s[i]) % m_modulus;\n}\n\n// if two vectors are different sized, then it will resize target vector\n// will overwrite target modulus\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::operator=(const mubintvec&amp; rhs) noexcept {\n    m_modulus       = rhs.m_modulus;\n    m_modulus_state = rhs.m_modulus_state;\n    if (rhs.m_data.size() &gt; m_data.size()) {\n        m_data = rhs.m_data;\n        return *this;\n    }\n    std::copy(rhs.m_data.begin(), rhs.m_data.end(), m_data.begin());\n    if (m_data.size() &gt; rhs.m_data.size())\n        m_data.resize(rhs.m_data.size());\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::operator=(std::initializer_list&lt;std::string&gt; rhs) noexcept {\n    const size_t len = rhs.size();\n    if (m_data.size() &lt; len)\n        m_data.resize(len);\n    const auto reduce = (m_modulus_state == State::INITIALIZED &amp;&amp; m_modulus);\n    for (size_t i = 0; i &lt; m_data.size(); ++i) {\n        if (i &lt; len) {\n            m_data[i] = ubint_el_t(*(rhs.begin() + i));\n            if (reduce)\n                m_data[i].ModEq(m_modulus);\n        }\n        else {\n            m_data[i] = 0;\n        }\n    }\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::operator=(std::initializer_list&lt;uint64_t&gt; rhs) noexcept {\n    const size_t len = rhs.size();\n    if (m_data.size() &lt; len)\n        m_data.resize(len);\n    const auto reduce = (m_modulus_state == State::INITIALIZED &amp;&amp; m_modulus);\n    for (size_t i = 0; i &lt; m_data.size(); ++i) {\n        if (i &lt; len) {\n            m_data[i] = ubint_el_t(*(rhs.begin() + i));\n            if (reduce)\n                m_data[i].ModEq(m_modulus);\n        }\n        else {\n            m_data[i] = 0;\n        }\n    }\n    return *this;\n}\n\n/**Switches the integers in the vector to values corresponding to the new\n * modulus Algorithm: Integer i, Old Modulus om, New Modulus nm, delta =\n * abs(om-nm): Case 1: om &lt; nm if i &gt; i &gt; om/2 i&#x27; = i + delta Case 2: om &gt; nm i\n * &gt; om/2 i&#x27; = i-delta\n */\ntemplate &lt;class ubint_el_t&gt;\nvoid mubintvec&lt;ubint_el_t&gt;::SwitchModulus(const ubint_el_t&amp; modulus) {\n    auto size{m_data.size()};\n    auto halfQ{m_modulus &gt;&gt; 1};\n    if (modulus &gt; m_modulus) {\n        auto diff{modulus - m_modulus};\n        for (size_t i = 0; i &lt; size; ++i) {\n            if (m_data[i] &gt; halfQ)\n                m_data[i] += diff;\n        }\n    }\n    else {\n        auto diff{modulus - (m_modulus % modulus)};\n        for (size_t i = 0; i &lt; size; ++i) {\n            if (m_data[i] &gt; halfQ)\n                m_data[i] += diff;\n            if (m_data[i] &gt;= modulus)\n                m_data[i] %= modulus;\n        }\n    }\n    this-&gt;SetModulus(modulus);\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::Mod(const ubint_el_t&amp; modulus) const {\n    auto ans(*this);\n    if (modulus == 2)\n        return ans.ModByTwoEq();\n    auto size{m_data.size()};\n    auto halfQ{m_modulus &gt;&gt; 1};\n    if (modulus &gt; m_modulus) {\n        auto diff{modulus - m_modulus};\n        for (size_t i = 0; i &lt; size; ++i) {\n            if (ans.m_data[i] &gt; halfQ)\n                ans.m_data[i] += diff;\n        }\n    }\n    else {\n        auto diff{modulus - (m_modulus % modulus)};\n        for (size_t i = 0; i &lt; size; ++i) {\n            if (ans.m_data[i] &gt; halfQ)\n                ans.m_data[i] += diff;\n            if (ans.m_data[i] &gt;= modulus)\n                ans.m_data[i] %= modulus;\n        }\n    }\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModEq(const ubint_el_t&amp; modulus) {\n    if (modulus == 2)\n        return this-&gt;ModByTwoEq();\n    auto size{m_data.size()};\n    auto halfQ{m_modulus &gt;&gt; 1};\n    if (modulus &gt; m_modulus) {\n        auto diff{modulus - m_modulus};\n        for (size_t i = 0; i &lt; size; ++i) {\n            if (m_data[i] &gt; halfQ)\n                m_data[i] += diff;\n        }\n    }\n    else {\n        auto diff{modulus - (m_modulus % modulus)};\n        for (size_t i = 0; i &lt; size; ++i) {\n            if (m_data[i] &gt; halfQ)\n                m_data[i] += diff;\n            if (m_data[i] &gt;= modulus)\n                m_data[i] %= modulus;\n        }\n    }\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModAdd(const ubint_el_t&amp; b) const {\n    auto ans(*this);\n    auto modulus(m_modulus);\n    auto bLocal(b);\n    if (bLocal &gt;= modulus)\n        bLocal.ModEq(modulus);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModAddFastEq(bLocal, modulus);\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModAddEq(const ubint_el_t&amp; b) {\n    auto modulus{m_modulus};\n    auto bLocal{b};\n    if (bLocal &gt;= modulus)\n        bLocal.ModEq(modulus);\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModAddFastEq(bLocal, modulus);\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModAddAtIndex(size_t i, const ubint_el_t&amp; b) const {\n    auto ans(*this);\n    ans.at(i).ModAddEq(b, m_modulus);\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModAddAtIndexEq(size_t i, const ubint_el_t&amp; b) {\n    this-&gt;mubintvec::at(i).ModAddEq(b, m_modulus);\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModAdd(const mubintvec&amp; b) const {\n    if (m_modulus != b.m_modulus)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec adding vectors of different moduli&quot;);\n    if (m_data.size() != b.m_data.size())\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec adding vectors of different lengths&quot;);\n    auto ans(*this);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModAddEq(b.m_data[i], ans.m_modulus);\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModAddEq(const mubintvec&amp; b) {\n    if (m_modulus != b.m_modulus)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec adding vectors of different moduli&quot;);\n    if (m_data.size() != b.m_data.size())\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec adding vectors of different lengths&quot;);\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModAddEq(b.m_data[i], m_modulus);\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModAddNoCheckEq(const mubintvec&amp; b) {\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModAddEq(b.m_data[i], m_modulus);\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModSub(const ubint_el_t&amp; b) const {\n    auto ans(*this);\n    auto modulus{m_modulus};\n    auto bLocal{b};\n    if (bLocal &gt;= modulus)\n        bLocal.ModEq(modulus);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModSubFastEq(bLocal, modulus);\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModSubEq(const ubint_el_t&amp; b) {\n    auto modulus{m_modulus};\n    auto bLocal{b};\n    if (bLocal &gt;= modulus)\n        bLocal.ModEq(modulus);\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModSubFastEq(bLocal, modulus);\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModSub(const mubintvec&amp; b) const {\n    if (m_modulus != b.m_modulus)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec subtractiong vectors of different moduli&quot;);\n    if (m_data.size() != b.m_data.size())\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec subtractiong vectors of different lengths&quot;);\n    auto ans(*this);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModSubEq(b.m_data[i], ans.m_modulus);\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModSubEq(const mubintvec&amp; b) {\n    if (m_modulus != b.m_modulus)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec subtractiong vectors of different moduli&quot;);\n    if (m_data.size() != b.m_data.size())\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec subtractiong vectors of different lengths&quot;);\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModSubEq(b.m_data[i], m_modulus);\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModMul(const ubint_el_t&amp; b) const {\n    auto ans(*this);\n    auto bLocal{b};\n    if (bLocal &gt;= ans.m_modulus)\n        bLocal.ModEq(ans.m_modulus);\n    #ifdef NO_BARRETT\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModMulFastEq(bLocal, ans.m_modulus);\n    #else\n    auto mu(ans.m_modulus.ComputeMu());\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModMulFastEq(bLocal, ans.m_modulus, mu);\n    #endif\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModMulEq(const ubint_el_t&amp; b) {\n    auto bLocal(b);\n    if (bLocal &gt;= m_modulus)\n        bLocal.ModEq(m_modulus);\n    #ifdef NO_BARRETT\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModMulFastEq(bLocal, m_modulus);\n    #else\n    auto mu(m_modulus.ComputeMu());\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModMulFastEq(bLocal, m_modulus, mu);\n    #endif\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModMul(const mubintvec&amp; b) const {\n    if (m_modulus != b.m_modulus)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec multiplying vectors of different moduli&quot;);\n    if (m_data.size() != b.m_data.size())\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec multiplying vectors of different lengths&quot;);\n    auto ans(*this);\n    #ifdef NO_BARRETT\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        ans[i].ModMulFastEq(b[i], ans.m_modulus);\n    #else\n    auto mu(ans.m_modulus.ComputeMu());\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModMulFastEq(b[i], ans.m_modulus, mu);\n    #endif\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModMulEq(const mubintvec&amp; b) {\n    if (m_modulus != b.m_modulus)\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec multiplying vectors of different moduli&quot;);\n    if (m_data.size() != b.m_data.size())\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;mubintvec multiplying vectors of different lengths&quot;);\n    #ifdef NO_BARRETT\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModMulFastEq(b[i], m_modulus);\n    #else\n    auto mu(m_modulus.ComputeMu());\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModMulFastEq(b[i], m_modulus, mu);\n    #endif\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModMulNoCheckEq(const mubintvec&amp; b) {\n    #ifdef NO_BARRETT\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModMulFastEq(b[i], m_modulus);\n    #else\n    auto mu(m_modulus.ComputeMu());\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModMulFastEq(b[i], m_modulus, mu);\n    #endif\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModExp(const ubint_el_t&amp; b) const {\n    auto ans(*this);\n    auto modulus{m_modulus};\n    auto bLocal{b};\n    if (bLocal &gt;= modulus)\n        bLocal.ModEq(modulus);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModExpEq(bLocal, modulus);\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModExpEq(const ubint_el_t&amp; b) {\n    auto modulus{m_modulus};\n    auto bLocal{b};\n    if (bLocal &gt;= modulus)\n        bLocal.ModEq(modulus);\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModExpEq(bLocal, modulus);\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModInverse() const {\n    auto ans(*this);\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i].ModInverseEq(ans.m_modulus);\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModInverseEq() {\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i].ModInverseEq(m_modulus);\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::ModByTwo() const {\n    auto ans(*this);\n    auto halfQ{m_modulus &gt;&gt; 1};\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i)\n        ans[i] = ubint_el_t((ans[i].m_value[0] &amp; 0x1) ^ (ans[i] &gt; halfQ));\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::ModByTwoEq() {\n    auto halfQ{m_modulus &gt;&gt; 1};\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        m_data[i] = ubint_el_t((m_data[i].m_value[0] &amp; 0x1) ^ (m_data[i] &gt; halfQ));\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::MultiplyAndRound(const ubint_el_t&amp; p, const ubint_el_t&amp; q) const {\n    auto ans(*this);\n    auto mv(m_modulus);\n    auto halfQ{m_modulus &gt;&gt; 1};\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i) {\n        if (ans.m_data[i] &gt; halfQ) {\n            auto&amp;&amp; tmp{mv - ans[i]};\n            ans[i] = mv - tmp.MultiplyAndRound(p, q);\n        }\n        else {\n            ans[i] = ans[i].MultiplyAndRound(p, q).Mod(mv);\n        }\n    }\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::MultiplyAndRoundEq(const ubint_el_t&amp; p, const ubint_el_t&amp; q) {\n    auto mv{m_modulus};\n    auto halfQ{m_modulus &gt;&gt; 1};\n    for (size_t i = 0; i &lt; m_data.size(); ++i) {\n        if (m_data[i] &gt; halfQ) {\n            auto&amp;&amp; tmp{mv - m_data[i]};\n            m_data[i] = mv - tmp.MultiplyAndRound(p, q);\n        }\n        else {\n            m_data[i] = m_data[i].MultiplyAndRound(p, q).Mod(mv);\n        }\n    }\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::DivideAndRound(const ubint_el_t&amp; q) const {\n    auto ans(*this);\n    auto mv{m_modulus};\n    auto halfQ{m_modulus &gt;&gt; 1};\n    for (size_t i = 0; i &lt; ans.m_data.size(); ++i) {\n        if (ans[i] &gt; halfQ) {\n            auto&amp;&amp; tmp{mv - ans[i]};\n            ans[i] = mv - tmp.DivideAndRound(q);\n        }\n        else {\n            ans[i] = ans[i].DivideAndRoundEq(q);\n        }\n    }\n    return ans;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt;&amp; mubintvec&lt;ubint_el_t&gt;::DivideAndRoundEq(const ubint_el_t&amp; q) {\n    auto mv{m_modulus};\n    auto halfQ{m_modulus &gt;&gt; 1};\n    for (size_t i = 0; i &lt; m_data.size(); ++i) {\n        if (m_data[i] &gt; halfQ) {\n            auto&amp;&amp; tmp{mv - m_data[i]};\n            m_data[i] = mv - tmp.DivideAndRound(q);\n        }\n        else {\n            m_data[i] = m_data[i].DivideAndRound(q);\n        }\n    }\n    return *this;\n}\n\ntemplate &lt;class ubint_el_t&gt;\nmubintvec&lt;ubint_el_t&gt; mubintvec&lt;ubint_el_t&gt;::GetDigitAtIndexForBase(usint index, usint base) const {\n    auto ans(*this);\n    for (size_t i = 0; i &lt; m_data.size(); ++i)\n        ans[i] = static_cast&lt;ubint_el_t&gt;(ans[i].GetDigitAtIndexForBase(index, base));\n    return ans;\n}\n\ntemplate class mubintvec&lt;BigInteger&gt;;\n\n}  // namespace bigintdyn\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/bigintdyn/ubintdyn.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/bigintdyn/ubintdyn.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/bigintdyn/ubintdyn.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  This file contains the main class for unsigned big integers: ubint. Big integers are\n  represented as arrays of machine native unsigned integers. The native integer type is\n  supplied as a template parameter. Currently implementation based on uint32_t and uint64_t is\n  supported. a native double the base integer size is also needed.\n */\n\n#include &quot;config_core.h&quot;\n#ifdef WITH_BE4\n\n    #ifndef LBCRYPTO_MATH_HAL_BIGINTDYN_UBINTDYN_H\n        #define LBCRYPTO_MATH_HAL_BIGINTDYN_UBINTDYN_H\n\n        #include &quot;math/hal/basicint.h&quot;\n        #include &quot;math/hal/integer.h&quot;\n        #include &quot;math/nbtheory.h&quot;\n\n        #include &quot;utils/exception.h&quot;\n        #include &quot;utils/inttypes.h&quot;\n        #include &quot;utils/serializable.h&quot;\n        #include &quot;utils/utilities.h&quot;\n\n        // #include &lt;fstream&gt;\n        #include &lt;functional&gt;\n        #include &lt;iostream&gt;\n        #include &lt;limits&gt;\n        // #include &lt;memory&gt;\n        #include &lt;string&gt;\n        #include &lt;type_traits&gt;\n        // #include &lt;typeinfo&gt;\n        #include &lt;utility&gt;\n        #include &lt;vector&gt;\n\n        #if NATIVEINT &gt;= 64\n// TODO: fix shifting issues with expdtype = uint128_t\n// using expdtype = BasicInteger;\nusing expdtype = uint64_t;\n        #elif NATIVEINT == 32\nusing expdtype = BasicInteger;\n        #endif\n\n        #define _SECURE_SCL 0  // to speed up VS\n        #define NO_BARRETT     // currently barrett is slower than mod\n\nnamespace bigintdyn {\n\ntemplate &lt;typename limb_t&gt;\nclass ubint;\n\n/** Define the mapping for ExpBigInteger (experimental) */\nusing xubint     = ubint&lt;expdtype&gt;;\nusing BigInteger = xubint;\n\ntemplate &lt;class ubint_el_t&gt;\nclass mubintvec;\n\n/**\n * @brief Struct to find log 2 value of N.\n * Used in preprocessing of ubint to determine bitwidth.\n */\ntemplate &lt;usint N&gt;\nstruct Log2 {\n    static constexpr usint value = 1 + Log2&lt;N / 2&gt;::value;\n};\ntemplate &lt;&gt;\nstruct Log2&lt;2&gt; {\n    static constexpr usint value = 1;\n};\n\n// @brief A pre-computed constant of Log base 2 of 10.\n// constexpr double LOG2_10 = 3.32192809489;\n\n/**\n * @brief Struct to determine other datatyps based on utype.\n * @tparam utype primitive integer data type.\n */\ntemplate &lt;typename utype&gt;\nstruct DataTypes {\n    using SignedType       = void;\n    using DoubleType       = void;\n    using SignedDoubleType = void;\n};\ntemplate &lt;&gt;\nstruct DataTypes&lt;uint32_t&gt; {\n    using SignedType       = int32_t;\n    using DoubleType       = uint64_t;\n    using SignedDoubleType = int64_t;\n};\ntemplate &lt;&gt;\nstruct DataTypes&lt;uint64_t&gt; {\n    using SignedType = int64_t;\n        #if defined(HAVE_INT128)\n    using DoubleType       = uint128_t;\n    using SignedDoubleType = int128_t;\n        #else\n    using DoubleType       = uint64_t;\n    using SignedDoubleType = int64_t;\n        #endif\n};\n        #if defined(HAVE_INT128)\ntemplate &lt;&gt;\nstruct DataTypes&lt;uint128_t&gt; {\n    using SignedType       = int128_t;\n    using DoubleType       = uint128_t;\n    using SignedDoubleType = int128_t;\n};\n        #endif\n\ntemplate &lt;typename limb_t&gt;\nclass ubint final : public lbcrypto::BigIntegerInterface&lt;ubint&lt;limb_t&gt;&gt; {\nprivate:\n    // variable that stores the MOST SIGNIFICANT BIT position in the\n    usint m_MSB{0};\n    // vector storing the native integers. stored little endian\n    std::vector&lt;limb_t&gt; m_value{0};\n    // variable to store the maximum value of the limb data type\n    static constexpr limb_t m_MaxLimb{std::numeric_limits&lt;limb_t&gt;::max()};\n    // variable to store the bitlength of the limb data type\n    static constexpr usint m_limbBitLength{sizeof(limb_t) * 8};\n    // variable to store the log2 of the number of bits in the limb data type\n    static constexpr usint m_log2LimbBitLength{Log2&lt;sizeof(limb_t) * 8&gt;::value};\n\n    friend class mubintvec&lt;ubint&lt;limb_t&gt;&gt;;\n\npublic:\n    using Integer  = limb_t;\n    using Slimb_t  = typename DataTypes&lt;limb_t&gt;::SignedType;\n    using Dlimb_t  = typename DataTypes&lt;limb_t&gt;::DoubleType;\n    using SDlimb_t = typename DataTypes&lt;limb_t&gt;::SignedDoubleType;\n\n    ubint() = default;\n\n    explicit operator bool() noexcept {\n        return m_MSB != 0;\n    }\n\n    /**\n   * Copy constructor.\n   * @param &amp;val is the ubint to be copied.\n   */\n    ubint(const ubint&amp; val) noexcept : m_MSB{val.m_MSB}, m_value{val.m_value} {}\n\n    ubint(const std::vector&lt;limb_t&gt;&amp; v) noexcept : m_value{v} {\n        this-&gt;ubint::NormalizeLimbs();\n    }\n\n    /**\n   * Move constructor.\n   * @param &amp;&amp;val is the ubint to be copied.\n   */\n    ubint(ubint&amp;&amp; val) noexcept : m_MSB{std::move(val.m_MSB)}, m_value{std::move(val.m_value)} {}\n\n    ubint(std::vector&lt;limb_t&gt;&amp;&amp; v) noexcept : m_value{std::move(v)} {\n        this-&gt;ubint::NormalizeLimbs();\n    }\n\n    /**\n   * Constructor from a string.\n   * @param &amp;strval is the initial integer represented as a string.\n   */\n    explicit ubint(const std::string&amp; strval) {\n        this-&gt;ubint::SetValue(strval);\n    }\n    explicit ubint(const char* strval) {\n        this-&gt;ubint::SetValue(std::string(strval));\n    }\n    explicit ubint(const char strval) : ubint(limb_t(strval - &#x27;0&#x27;)) {}\n\n    /**\n   * Constructor from an unsigned integer.\n   * @param val is the initial integer represented as a uint64_t.\n   */\n    template &lt;typename T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, bool&gt; = true&gt;\n    ubint(T val) : m_MSB{lbcrypto::GetMSB(val)}, m_value{limb_t(val)} {\n        if constexpr (sizeof(T) &gt; sizeof(limb_t)) {\n            if ((val &gt;&gt;= m_limbBitLength) &gt; 0) {\n                m_value.resize(ubint::MSBToLimbs(m_MSB));\n                for (size_t i{1}; i &lt; m_value.size(); ++i, val &gt;&gt;= m_limbBitLength)\n                    m_value[i] = limb_t(val);\n            }\n        }\n    }\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;, bool&gt; = true&gt;\n    ubint(T val) = delete;\n\n    template &lt;typename T, std::enable_if_t&lt;!std::is_integral_v&lt;T&gt; &amp;&amp; !std::is_floating_point_v&lt;T&gt;, bool&gt; = true&gt;\n    ubint(T val) : ubint(BasicInteger(val)) {}\n\n    /**\n   * Copy assignment operator\n   *\n   * @param &amp;val is the ubint to be assigned from.\n   * @return assigned ubint ref.\n   */\n    ubint&amp; operator=(const ubint&amp; val) noexcept {\n        m_MSB   = val.m_MSB;\n        m_value = val.m_value;\n        return *this;\n    }\n\n    ubint&amp; operator=(const limb_t&amp; val) noexcept {\n        m_MSB = lbcrypto::GetMSB(val);\n        m_value.resize(1);\n        m_value[0] = val;\n        return *this;\n    }\n\n    ubint&amp; operator=(ubint&amp;&amp; val) noexcept {\n        if (this != &amp;val) {\n            m_MSB   = std::move(val.m_MSB);\n            m_value = std::move(val.m_value);\n        }\n        return *this;\n    }\n\n    /**\n   * Assignment operator for all other types that have not already got their own\n   * assignment operators.\n   * @param &amp;val is the value to be assign from\n   * @return the assigned BigInteger ref.\n   */\n    template &lt;typename T, std::enable_if_t&lt;!std::is_same_v&lt;T, const ubint&gt;, bool&gt; = true&gt;\n    ubint&amp; operator=(T val) {\n        return *this = ubint(val);\n    }\n\n    /**\n   * Basic set method for setting the value of a ubint\n   * @param strval is the string representation of the ubint to be copied.\n   */\n    void SetValue(const std::string&amp; strval);\n\n    /**\n   * Basic set method for setting the value of a ubint\n   * @param val is the ubint representation of the ubint to be assigned.\n   */\n    void SetValue(const ubint&amp; val) noexcept {\n        m_MSB   = val.m_MSB;\n        m_value = val.m_value;\n    }\n\n    void SetIdentity() noexcept {\n        m_MSB = 1;\n        m_value.resize(1);\n        m_value[0] = 1;\n    }\n\n    /**\n   * Addition operation.\n   *\n   * @param &amp;b is the value to add.\n   * @return result of the addition operation.\n   */\n    ubint Add(const ubint&amp; b) const;\n    ubint&amp; AddEq(const ubint&amp; b);\n\n    /**\n   * Subtraction operation.\n   *\n   * @param &amp;b is the value to subtract.\n   * @return is the result of the subtraction operation.\n   */\n    ubint Sub(const ubint&amp; b) const;\n    ubint&amp; SubEq(const ubint&amp; b);\n\n    // this is a negation operator which really doesn&#x27;t make sense for ubint\n    // TODO: returns zero due to saturated subtraction\n    ubint operator-() const {\n        // return ubint().Sub(*this);\n        return ubint();\n    }\n\n    /**\n   * Multiplication operation.\n   *\n   * @param &amp;b is the value to multiply with.\n   * @return is the result of the multiplication operation.\n   */\n    ubint Mul(const ubint&amp; b) const;\n    ubint&amp; MulEq(const ubint&amp; b) {\n        return *this = this-&gt;ubint::Mul(b);\n    }\n\n    /**\n   * Division operation.\n   *\n   * @param &amp;b is the value to divide by.\n   * @return is the result of the division operation.\n   */\n    ubint DividedBy(const ubint&amp; b) const;\n    ubint&amp; DividedByEq(const ubint&amp; b);\n\n    /**\n   * Exponentiation operation. Returns x^p.\n   *\n   * @param p the exponent.\n   * @return is the result of the exponentiation operation.\n   */\n    ubint Exp(usint p) const;\n    ubint&amp; ExpEq(usint p) {\n        return *this = this-&gt;ubint::Exp(p);\n    }\n\n    /**\n   * Multiply and Rounding operation. Returns [x*p/q] where [] is the rounding\n   * operation.\n   *\n   * @param &amp;p is the numerator to be multiplied.\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of multiply and round operation.\n   */\n    ubint MultiplyAndRound(const ubint&amp; p, const ubint&amp; q) const;\n    ubint&amp; MultiplyAndRoundEq(const ubint&amp; p, const ubint&amp; q) {\n        return *this = this-&gt;ubint::MultiplyAndRound(p, q);\n    }\n\n    /**\n   * Divide and Rounding operation. Returns [x/q] where [] is the rounding\n   * operation.\n   *\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of divide and round operation.\n   */\n    ubint DivideAndRound(const ubint&amp; q) const;\n    ubint&amp; DivideAndRoundEq(const ubint&amp; q) {\n        return *this = this-&gt;ubint::DivideAndRound(q);\n    }\n\n    /**\n   * Naive modulus operation.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @return is the result of the modulus operation.\n   */\n    ubint Mod(const ubint&amp; modulus) const;\n    ubint&amp; ModEq(const ubint&amp; modulus);\n\n    /**\n   * Pre-computes the mu factor that is used in Barrett modulo reduction\n   *\n   * @return the value of mu\n   */\n    ubint ComputeMu() const {\n        return (ubint(1) &lt;&lt; (2 * m_MSB + 3)).DividedBy(*this);\n    }\n\n    /**\n   * Barrett modulus operation.\n   * Implements generalized Barrett modular reduction algorithm. Uses one\n   * precomputed value of mu.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus operation.\n   */\n    template &lt;typename T = limb_t&gt;\n    ubint Mod(const ubint&amp; modulus, const ubint&amp; mu,\n              typename std::enable_if_t&lt;!std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) const {\n        return this-&gt;ubint::Mod(modulus);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint Mod(const ubint&amp; modulus, const ubint&amp; mu,\n              typename std::enable_if_t&lt;std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) const {\n        if (*this &lt; modulus)\n            return *this;\n        int n(modulus.m_MSB);\n        int alpha(n + 3);\n        int beta(-2);\n        ubint q(mu * this-&gt;ubint::RShift(n + beta));\n        q &gt;&gt;= alpha - beta;\n        ubint z(this-&gt;ubint::Sub(q * modulus));\n        if (z &gt;= modulus)\n            return z.Sub(modulus);\n        return z;\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint&amp; ModEq(const ubint&amp; modulus, const ubint&amp; mu,\n                 typename std::enable_if_t&lt;!std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) {\n        return this-&gt;ubint::ModEq(modulus);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint&amp; ModEq(const ubint&amp; modulus, const ubint&amp; mu,\n                 typename std::enable_if_t&lt;std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) {\n        if (*this &lt; modulus)\n            return *this;\n        int n(modulus.m_MSB);\n        int alpha(n + 3);\n        int beta(-2);\n        ubint q(mu * this-&gt;ubint::RShift(n + beta));\n        q &gt;&gt;= alpha - beta;\n        this-&gt;ubint::SubEq(q * modulus);\n        if (*this &gt;= modulus)\n            return this-&gt;ubint::SubEq(modulus);\n        return *this;\n    }\n\n    /**\n   * Modulus addition operation.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus addition operation.\n   */\n    ubint ModAdd(const ubint&amp; b, const ubint&amp; modulus) const;\n    ubint&amp; ModAddEq(const ubint&amp; b, const ubint&amp; modulus);\n\n    /**\n   * Modulus addition where operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus addition operation.\n   */\n    ubint ModAddFast(const ubint&amp; b, const ubint&amp; modulus) const;\n    ubint&amp; ModAddFastEq(const ubint&amp; b, const ubint&amp; modulus);\n\n    /**\n   * Barrett modulus addition operation.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus addition operation.\n   */\n    template &lt;typename T = limb_t&gt;\n    ubint ModAdd(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu,\n                 typename std::enable_if_t&lt;!std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) const {\n        return b.ModAdd(*this, modulus);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint ModAdd(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu,\n                 typename std::enable_if_t&lt;std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) const {\n        return b.Add(*this).Mod(modulus, mu);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint&amp; ModAddEq(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu,\n                    typename std::enable_if_t&lt;!std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) {\n        return this-&gt;ubint::ModAddEq(b, modulus);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint&amp; ModAddEq(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu,\n                    typename std::enable_if_t&lt;std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) {\n        return *this = b.Add(*this).Mod(modulus, mu);\n    }\n\n    /**\n   * Modulus subtraction operation.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    ubint ModSub(const ubint&amp; b, const ubint&amp; modulus) const;\n    ubint&amp; ModSubEq(const ubint&amp; b, const ubint&amp; modulus);\n\n    /**\n   * Modulus subtraction where operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    ubint ModSubFast(const ubint&amp; b, const ubint&amp; modulus) const;\n    ubint&amp; ModSubFastEq(const ubint&amp; b, const ubint&amp; modulus);\n\n    /**\n   * Barrett modulus subtraction operation.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus subtraction operation.\n   */\n    template &lt;typename T = limb_t&gt;\n    ubint ModSub(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu,\n                 typename std::enable_if_t&lt;!std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) const {\n        return this-&gt;ubint::ModSub(b, modulus);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint ModSub(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu,\n                 typename std::enable_if_t&lt;std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) const {\n        auto bv(b);\n        auto av(*this);\n        if (bv &gt;= modulus)\n            bv.ModEq(modulus, mu);\n        if (av &gt;= modulus)\n            av.ModEq(modulus, mu);\n        if (av &lt; bv)\n            av = modulus.Add(av);\n        return av.SubEq(bv);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint&amp; ModSubEq(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu,\n                    typename std::enable_if_t&lt;!std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) {\n        return this-&gt;ubint::ModSubEq(b, modulus);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint&amp; ModSubEq(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu,\n                    typename std::enable_if_t&lt;std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) {\n        auto bv(b);\n        if (bv &gt;= modulus)\n            bv.ModEq(modulus, mu);\n        if (*this &gt;= modulus)\n            this-&gt;ubint::ModEq(modulus, mu);\n        if (*this &lt; bv)\n            *this = modulus.Add(*this);\n        return this-&gt;ubint::SubEq(bv);\n    }\n\n    /**\n   * Modulus multiplication operation.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = limb_t&gt;\n    ubint ModMul(const ubint&amp; b, const ubint&amp; modulus,\n                 typename std::enable_if_t&lt;!std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) const {\n        auto bv(b);\n        auto av(*this);\n        if (bv &gt;= modulus)\n            bv.ModEq(modulus);\n        if (av &gt;= modulus)\n            av.ModEq(modulus);\n        return av.ModMulFast(bv, modulus);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint ModMul(const ubint&amp; b, const ubint&amp; modulus,\n                 typename std::enable_if_t&lt;std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) const {\n        return b.ModMul(*this, modulus, modulus.ComputeMu());\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint&amp; ModMulEq(const ubint&amp; b, const ubint&amp; modulus,\n                    typename std::enable_if_t&lt;!std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) {\n        auto bv(b);\n        if (bv &gt;= modulus)\n            bv.ModEq(modulus);\n        if (*this &gt;= modulus)\n            this-&gt;ubint::ModEq(modulus);\n        return *this = bv.ModMulFast(*this, modulus);\n    }\n\n    template &lt;typename T = limb_t&gt;\n    ubint&amp; ModMulEq(const ubint&amp; b, const ubint&amp; modulus,\n                    typename std::enable_if_t&lt;std::is_same_v&lt;T, Dlimb_t&gt;, bool&gt; = true) {\n        return *this = b.ModMul(*this, modulus, modulus.ComputeMu());\n    }\n\n    /**\n   * Barrett modulus multiplication.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus multiplication operation.\n   */\n    ubint ModMul(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu) const {\n        auto bv(b);\n        auto av(*this);\n        if (bv &gt;= modulus)\n            bv.ModEq(modulus, mu);\n        if (av &gt;= modulus)\n            av.ModEq(modulus, mu);\n        return av.Mul(bv).Mod(modulus, mu);\n    }\n\n    ubint&amp; ModMulEq(const ubint&amp; b, const ubint&amp; modulus, ubint&amp; mu) {\n        auto bv(b);\n        if (bv &gt;= modulus)\n            bv.ModEq(modulus, mu);\n        if (*this &gt;= modulus)\n            this-&gt;ubint::ModEq(modulus, mu);\n        return *this = bv.Mul(*this).Mod(modulus, mu);\n    }\n\n    /**\n   * Modulus multiplication that assumes the operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    ubint ModMulFast(const ubint&amp; b, const ubint&amp; modulus) const;\n    ubint&amp; ModMulFastEq(const ubint&amp; b, const ubint&amp; modulus) {\n        return *this = this-&gt;ubint::ModMulFast(b, modulus);\n    }\n\n    /**\n   * Barrett modulus multiplication that assumes the operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus multiplication operation.\n   */\n    ubint ModMulFast(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu) const {\n        return b.Mul(*this).Mod(modulus, mu);\n    }\n\n    ubint&amp; ModMulFastEq(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; mu) {\n        return *this = b.Mul(*this).Mod(modulus, mu);\n    }\n\n    ubint ModMulFastConst(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; bInv) const {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::not_implemented_error, &quot;ModMulFastConst is not implemented for backend 4&quot;);\n    }\n    ubint&amp; ModMulFastConstEq(const ubint&amp; b, const ubint&amp; modulus, const ubint&amp; bInv) {\n        &quot;hey&quot;; OPENFHE_THROW(lbcrypto::not_implemented_error, &quot;ModMulFastConstEq is not implemented for backend 4&quot;);\n    }\n\n    /**\n   * Modulus exponentiation operation. Square-and-multiply algorithm is used.\n   *\n   * @param &amp;b is the scalar to exponentiate at all locations.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus exponentiation operation.\n   */\n    ubint ModExp(const ubint&amp; b, const ubint&amp; modulus) const;\n    ubint&amp; ModExpEq(const ubint&amp; b, const ubint&amp; modulus) {\n        return *this = this-&gt;ubint::ModExp(b, modulus);\n    }\n\n    /**\n   * Modulus inverse operation.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @return is the result of the modulus inverse operation.\n   */\n    ubint ModInverse(const ubint&amp; modulus) const;\n    ubint&amp; ModInverseEq(const ubint&amp; modulus) {\n        return *this = this-&gt;ubint::ModInverse(modulus);\n    }\n\n    /**\n   * Left shift operation.\n   *\n   * @param shift # of bits.\n   * @return result of the shift operation.\n   */\n    ubint LShift(usshort shift) const;\n    ubint&amp; LShiftEq(usshort shift);\n\n    /**\n   * Right shift operation.\n   *\n   * @param shift # of bits.\n   * @return result of the shift operation.\n   */\n    ubint RShift(usshort shift) const;\n    ubint&amp; RShiftEq(usshort shift);\n\n    /**\n   * Compares the current ubint to ubint a.\n   *\n   * @param a is the ubint to be compared with.\n   * @return  -1 for strictly less than, 0 for equal to and 1 for strictly\n   * greater than conditons.\n   */\n    int Compare(const ubint&amp; a) const noexcept {\n        if (m_MSB &lt; a.m_MSB)\n            return -1;\n        if (m_MSB &gt; a.m_MSB)\n            return 1;\n        for (int i = m_value.size() - 1; i &gt;= 0; --i) {\n            if (m_value[i] &lt; a.m_value[i])\n                return -1;\n            if (m_value[i] &gt; a.m_value[i])\n                return 1;\n        }\n        return 0;\n    }\n\n    template &lt;typename T = BasicInteger&gt;\n    T ConvertToInt() const noexcept {\n        constexpr usint limblen{sizeof(T) * 8};\n        if constexpr (m_limbBitLength &gt;= limblen) {\n            return static_cast&lt;T&gt;(m_value[0]);\n        }\n        if constexpr (m_limbBitLength &lt; limblen) {\n            auto ceilInt = MSBToLimbs(limblen &gt; m_MSB ? m_MSB : limblen);\n            auto result  = static_cast&lt;T&gt;(m_value[0]);\n            for (usint i{1}; i &lt; ceilInt; ++i)\n                result |= static_cast&lt;T&gt;(m_value[i]) &lt;&lt; (i * m_limbBitLength);\n            return result;\n        }\n    }\n\n    /**\n   * Converts the value to a float\n   * if the ubint is uninitialized error is thrown\n   * if the ubint is larger than the max value representable\n   * or if conversion fails, and error is reported to cerr\n   */\n    float ConvertToFloat() const;\n    double ConvertToDouble() const;\n    long double ConvertToLongDouble() const;\n\n    /**\n   * Convert a string representation of a binary number to a ubint.\n   * @param bitString the binary num in string.\n   * @return the  number represented as a ubint.\n   */\n    static ubint FromBinaryString(const std::string&amp; bitString);\n\n    /**\n   * Returns the MSB location of the value.\n   * @return the index of the most significant bit.\n   */\n    usint GetMSB() const {\n        return m_MSB;\n    }\n\n    /**\n   * Returns the size of the underlying vector of Limbs\n   * @return the size\n   */\n    size_t GetNumberOfLimbs() const {\n        return m_value.size();\n    }\n\n    /**\n   * Tests whether the ubint is a power of 2.\n   *\n   * @param x is the value to check.\n   * @return true if the input is a power of 2, false otherwise.\n   */\n    /*\n    static bool isPowerOfTwo(const ubint&amp; x) {\n        if (x.m_MSB == 0)\n            return false;\n        const size_t limbs{x.m_value.size() - 1};\n        for (size_t i = 0; i &lt; limbs; ++i) {\n            if (0 != x.m_value[i])\n                return false;\n        }\n        auto msb{lbcrypto::GetMSB(x.m_value[limbs]) - 1};\n        auto mask{(1 &lt;&lt; msb) - 1};\n        return (0 == (x.m_value[limbs] &amp; mask));\n    }\n*/\n\n    /**\n   * Get the number of digits using a specific base - support for arbitrary base\n   * may be needed.\n   *\n   * @param base is the base with which to determine length in.\n   * @return the length of the representation in a specific base.\n   */\n\n    // TODO hardcoded for base 2?\n    usint GetLengthForBase(usint base) const {\n        return GetMSB();\n    }\n\n    /**\n   * Get the number of digits using a specific base.\n   * Warning: only power-of-2 bases are currently supported.\n   * Example: for number 83, index 2 and base 4 we have:\n   *\n   *                         index:0,1,2,3\n   * 83 --base 4 decomposition--&gt; (3,0,1,1) --at index 2--&gt; 1\n   *\n   * The return number is 1.\n   *\n   * @param index is the location to return value from in the specific base.\n   * @param base is the base with which to determine length in.\n   * @return the length of the representation in a specific base.\n   */\n    usint GetDigitAtIndexForBase(usint index, usint base) const;\n\n    /**\n   * Gets the bit at the specified index.\n   *\n   * @param index is the index of the bit to get.\n   * @return resulting bit.\n   */\n    uschar GetBitAtIndex(usint index) const;\n\n    /**\n   * A zero allocator that is called by the Matrix class. It is used to\n   * initialize a Matrix of ubint objects.\n   */\n    static ubint Allocator() noexcept {\n        return ubint();\n    }\n\n    // STRINGS &amp; STREAMS\n\n    /**\n   * Stores the based 10 equivalent/Decimal value of the ubint in a string\n   * object and returns it.\n   *\n   * @return value of this ubint in base 10 represented as a string.\n   */\n    const std::string ToString() const;\n\n    static const std::string IntegerTypeName() {\n        if constexpr (std::is_same_v&lt;limb_t, uint32_t&gt;)\n            return &quot;UBDYNINT_32&quot;;\n        if constexpr (std::is_same_v&lt;limb_t, uint64_t&gt;)\n            return &quot;UBDYNINT_64&quot;;\n        if constexpr (std::is_same_v&lt;limb_t, uint128_t&gt;)\n            return &quot;UBDYNINT_128&quot;;\n        static_assert(true, &quot;Configuration Error: ubintdyn.h&quot;);\n    }\n\n    /**\n   * Delivers value of the internal limb storage\n   * Used primarily for debugging\n   * @return STL vector of uint_type\n   */\n    std::string GetInternalRepresentation() const {\n        std::string ret{};\n        for (size_t i = 0; i &lt; m_value.size(); i++) {\n            ret += std::to_string(m_value[i]);\n            if (i &lt; (m_value.size() - 1)) {\n                ret += &quot; &quot;;\n            }\n        }\n        return ret;\n    }\n\n    /**\n   * ostream output &lt;&lt; operator\n   * Algorithm used is double and add\n   * http://www.wikihow.com/Convert-from-Binary-to-Decimal\n   *\n   * @param os is the std ostream object.\n   * @param ptr_obj is ubint to be printed.\n   * @return is the returned ostream object.\n   */\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ubint&amp; ptr_obj) {\n        os &lt;&lt; ptr_obj.ToString();\n        return os;\n    }\n\n    /**\n   * documentation function, prints sizes of constats.\n   */\n    static void PrintIntegerConstants() {\n        std::cout &lt;&lt; &quot;sizeof UINT8_C  &quot; &lt;&lt; sizeof(UINT8_C(1)) &lt;&lt; std::endl;\n        std::cout &lt;&lt; &quot;sizeof UINT16_C &quot; &lt;&lt; sizeof(UINT16_C(1)) &lt;&lt; std::endl;\n        std::cout &lt;&lt; &quot;sizeof UINT32_C &quot; &lt;&lt; sizeof(UINT32_C(1)) &lt;&lt; std::endl;\n        std::cout &lt;&lt; &quot;sizeof UINT64_C &quot; &lt;&lt; sizeof(UINT64_C(1)) &lt;&lt; std::endl;\n        std::cout &lt;&lt; &quot;sizeof uint8_t  &quot; &lt;&lt; sizeof(uint8_t) &lt;&lt; std::endl;\n        std::cout &lt;&lt; &quot;sizeof uint16_t &quot; &lt;&lt; sizeof(uint16_t) &lt;&lt; std::endl;\n        std::cout &lt;&lt; &quot;sizeof uint32_t &quot; &lt;&lt; sizeof(uint32_t) &lt;&lt; std::endl;\n        std::cout &lt;&lt; &quot;sizeof uint64_t &quot; &lt;&lt; sizeof(uint64_t) &lt;&lt; std::endl;\n        #if defined(HAVE_INT128)\n        // std::cout &lt;&lt; &quot;sizeof UINT128_C &quot;&lt;&lt; sizeof (UINT128_C(1)) &lt;&lt; std::endl;\n        // dbc commented out  unsupported on some machines\n        std::cout &lt;&lt; &quot;sizeof uint128_t &quot; &lt;&lt; sizeof(uint128_t) &lt;&lt; std::endl;\n        #endif\n    }\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::make_nvp(&quot;v&quot;, m_value));\n        ar(::cereal::make_nvp(&quot;m&quot;, m_MSB));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                           &quot; is from a later version of the library&quot;);\n        }\n        ar(::cereal::make_nvp(&quot;v&quot;, m_value));\n        ar(::cereal::make_nvp(&quot;m&quot;, m_MSB));\n    }\n\n    std::string SerializedObjectName() const {\n        return &quot;DYNInteger&quot;;\n    }\n\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\nprivate:\n    /**\n   * Sets the MSB to the correct value as computed from the internal value.\n   */\n    void SetMSB() {\n        m_MSB = m_limbBitLength * static_cast&lt;usint&gt;(m_value.size() - 1);\n        m_MSB += lbcrypto::GetMSB(m_value.back());\n    }\n\n    /**\n   * Normalize limb storage of the ubint by making sure the most\n   * significant limb is non-zero (all higher zero limbs are\n   * removed).\n   *\n   * @return resulting bit.\n   */\n    void NormalizeLimbs() {\n        auto size = m_value.size() - 1;\n        while (size &gt; 0 &amp;&amp; m_value[size--] == 0)\n            m_value.pop_back();\n        m_MSB = m_limbBitLength * static_cast&lt;usint&gt;(m_value.size() - 1);\n        m_MSB += lbcrypto::GetMSB(m_value.back());\n    }\n\n    /**\n   * helper function for Div\n   * @param defined in ubint.cpp\n   */\n    void divqr_vect(ubint&amp; q, ubint&amp; r, const ubint&amp; u, const ubint&amp; v) const noexcept;\n    void divq_vect(ubint&amp; q, const ubint&amp; u, const ubint&amp; v) const noexcept;\n    void divr_vect(ubint&amp; r, const ubint&amp; u, const ubint&amp; v) const noexcept;\n\n    /**\n   * function to return the ceiling of the input number divided by\n   * the number of bits in the limb data type.  DBC this is to\n   * determine how many limbs are needed for an input bitsize.\n   * @param Number is the number to be divided.\n   * @return the ceiling of Number/(bits in the limb data type)\n   */\n    static constexpr usint MSBToLimbs(usint msb) noexcept {\n        constexpr usint mask{m_limbBitLength - 1};\n        if (msb == 0)\n            return 1;\n        return (msb &gt;&gt; m_log2LimbBitLength) + ((msb &amp; mask) != 0);\n    }\n};\n\n        #if 0\n// stream helper function for vector of objects\ntemplate &lt;typename limb_t&gt;\nstd::ostream &amp;operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;limb_t&gt;&amp; v) {\n  os &lt;&lt; &quot;[&quot;;\n  for (auto&amp;&amp; itr : v)\n    os &lt;&lt; &quot; &quot; &lt;&lt; itr;\n  os &lt;&lt; &quot; ]&quot;;\n  return os;\n}\n        #endif\n\n}  // namespace bigintdyn\n\n    #endif  // LBCRYPTO_MATH_HAL_BIGINTDYN_UBINTDYN_H\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/bigintdyn/mubintvecdyn.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/bigintdyn/mubintvecdyn.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/bigintdyn/mubintvecdyn.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  This file contains mubintvecdyn, a &lt;vector&gt; of buintdyn, with associated modulus and modulo math operators\n */\n\n#include &quot;config_core.h&quot;\n#ifdef WITH_BE4\n\n    #ifndef LBCRYPTO_MATH_HAL_BIGINTDYN_MUBINTVECDYN_H\n        #define LBCRYPTO_MATH_HAL_BIGINTDYN_MUBINTVECDYN_H\n\n        #include &quot;math/hal/vector.h&quot;\n        #include &quot;math/hal/bigintdyn/ubintdyn.h&quot;\n\n        #include &quot;utils/exception.h&quot;\n        #include &quot;utils/inttypes.h&quot;\n        #include &quot;utils/serializable.h&quot;\n\n        #include &lt;initializer_list&gt;\n        #include &lt;iostream&gt;\n        #include &lt;string&gt;\n        #include &lt;utility&gt;\n        #include &lt;vector&gt;\n\n/**\n * @namespace bigintdyn\n * The namespace of bigintdyn\n */\nnamespace bigintdyn {\n\ntemplate &lt;class ubint_el_t&gt;\nclass mubintvec;\n\n/** Define the mapping for modulo Big Integer Vector */\nusing xmubintvec = mubintvec&lt;BigInteger&gt;;\nusing BigVector  = xmubintvec;\n\n/**\n * @brief The class for representing vectors of ubint with associated modulo\n * math\n */\n\ntemplate &lt;class ubint_el_t&gt;\nclass mubintvec final : public lbcrypto::BigVectorInterface&lt;mubintvec&lt;ubint_el_t&gt;, ubint_el_t&gt;,\n                        public lbcrypto::Serializable {\npublic:\n    mubintvec() = default;\n\n    static mubintvec Single(const ubint_el_t&amp; val, const ubint_el_t&amp; modulus) {\n        mubintvec vec(1, modulus);\n        vec.m_data[0] = val;\n        return vec;\n    }\n\n    /**\n   * Basic constructor for specifying the length of the vector.\n   *\n   * @param length initial size in terms of the number of entries.\n   */\n    explicit mubintvec(usint length) noexcept : m_data(length) {}\n\n    /**\n   * Basic constructor for specifying the length and modulus of the vector.\n   *\n   * @param length initial size in terms of the number of entries.\n   * @param modulus usint associated with entries in the vector.\n   */\n    // TODO: what practical purpose with usint modulus??\n    //    explicit mubintvec(usint length, const usint&amp; modulus) noexcept\n    //        : m_modulus(modulus), m_modulus_state(State::INITIALIZED), m_data(length) {}\n\n    /**\n   * Basic constructor for specifying the length of the vector with modulus\n   *\n   * @param length initial size in terms of the number of entries.\n   * @param modulus ubint associated with entries in the vector.\n   */\n    mubintvec(usint length, const ubint_el_t&amp; modulus) noexcept\n        : m_modulus{modulus}, m_modulus_state{State::INITIALIZED}, m_data(length) {}\n\n    mubintvec(usint length, const ubint_el_t&amp; modulus, const ubint_el_t&amp; val) noexcept\n        : m_modulus{modulus}, m_modulus_state{State::INITIALIZED}, m_data(length, val) {}\n\n    /**\n   * Basic constructor for specifying the length and modulus of the vector.\n   *\n   * @param length initial size in terms of the number of entries.\n   * @param modulus string associated with entries in the vector.\n   */\n    explicit mubintvec(usint length, const std::string&amp; modulus)\n        : m_modulus(modulus), m_modulus_state{State::INITIALIZED}, m_data(length) {}\n\n    /**\n   * Copy constructor for copying a vector\n   *\n   * @param rhs is the mubintvec to be copied.\n   */\n    mubintvec(const mubintvec&amp; rhs) noexcept\n        : m_modulus{rhs.m_modulus}, m_modulus_state{rhs.m_modulus_state}, m_data(rhs.m_data) {}\n\n    /**\n   * Move constructor for moving a vector\n   *\n   * @param &amp;&amp;rhs is the mubintvec to be moved.\n   */\n    mubintvec(mubintvec&amp;&amp; rhs) noexcept\n        : m_modulus{std::move(rhs.m_modulus)}, m_modulus_state{rhs.m_modulus_state}, m_data(std::move(rhs.m_data)) {}\n\n    /**\n   * Basic constructor for specifying the length of the vector with\n   * modulus with initializer lists\n   *\n   * @param length initial size in terms of the number of entries.\n   * @param modulus ubint associated with entries in the vector.\n   * @param rhs initialier list of strings\n   */\n    explicit mubintvec(usint length, const ubint_el_t&amp; modulus, std::initializer_list&lt;std::string&gt; rhs) noexcept;\n\n    /**\n   * Basic constructor for specifying the length of the vector with\n   * modulus with initializer lists\n   *\n   * @param length initial size in terms of the number of entries.\n   * @param modulus ubint associated with entries in the vector.\n   * @param rhs initialier list of usints\n   */\n    explicit mubintvec(usint length, const ubint_el_t&amp; modulus, std::initializer_list&lt;uint64_t&gt; rhs) noexcept;\n\n    // constructor specifying the mubintvec as a vector of strings and modulus\n    explicit mubintvec(const std::vector&lt;std::string&gt;&amp; s, const ubint_el_t&amp; modulus) noexcept;\n\n    // constructor specifying the mubintvec as a vector of strings and modulus\n    explicit mubintvec(const std::vector&lt;std::string&gt;&amp; s, const std::string&amp; modulus) noexcept;\n\n    /**\n   * Assignment operator\n   *\n   * @param &amp;rhs is the mubintvec to be assigned from.\n   * @return assigned mubintvec ref.\n   */\n    mubintvec&amp; operator=(const mubintvec&amp; rhs) noexcept;\n\n    /**\n   * move assignment contructor\n   *\n   * @param &amp;rhs is the mubintvec to move\n   * @return the return value.\n   */\n    mubintvec&amp; operator=(mubintvec&amp;&amp; rhs) noexcept {\n        m_modulus       = std::move(rhs.m_modulus);\n        m_modulus_state = rhs.m_modulus_state;\n        m_data          = std::move(rhs.m_data);\n        return *this;\n    }\n\n    /**\n   * Initializer list for mubintvec.\n   *\n   * @param &amp;&amp;rhs is the list of strings to be assigned to the mubintvec.\n   * @return mubintvec object\n   * note if  modulus is set then mod(input) is stored\n   * note modulus remains unchanged.\n   */\n    mubintvec&amp; operator=(std::initializer_list&lt;std::string&gt; rhs) noexcept;\n\n    /**\n   * Initializer list for mubintvec.\n   *\n   * @param &amp;&amp;rhs is the list of usints to be assigned to the mubintvec.\n   * @return mubintvec object\n   * note if  modulus is set then mod(input) is stored\n   * note modulus remains unchanged.\n   */\n    mubintvec&amp; operator=(std::initializer_list&lt;uint64_t&gt; rhs) noexcept;\n\n    /**\n   * @param &amp;&amp;rhs is the usint value to assign to the zeroth entry\n   * @return resulting mubintvec\n   * note that modulus remains untouched.\n   */\n    mubintvec&amp; operator=(uint64_t val) {\n        m_data.at(0) = ubint_el_t(val);\n        for (size_t i = 1; i &lt; m_data.size(); ++i)\n            m_data[i] = ubint_el_t();\n        return *this;\n    }\n\n    /**\n   * @param &amp;&amp;rhs is the ubint value to assign to the zeroth entry\n   * @return resulting mubintvec\n   */\n    mubintvec&amp; operator=(const ubint_el_t&amp; val) {\n        m_data.at(0) = val;\n        for (size_t i = 1; i &lt; m_data.size(); ++i)\n            m_data[i] = ubint_el_t();\n        return *this;\n    }\n\n    size_t GetLength() const {\n        return m_data.size();\n    }\n\n    /**\n   * Sets/gets a value at an index.\n   * This method is slower than operator[] as it checks if index out of range\n   *\n   * @param index is the index to set a value at.\n   */\n    ubint_el_t&amp; at(size_t i) {\n        if (!mubintvec::IndexCheck(i))\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;index out of range&quot;);\n        return m_data[i];\n    }\n\n    const ubint_el_t&amp; at(size_t i) const {\n        if (!mubintvec::IndexCheck(i))\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;index out of range&quot;);\n        return m_data[i];\n    }\n\n    ubint_el_t&amp; operator[](size_t i) {\n        return m_data[i];\n    }\n\n    const ubint_el_t&amp; operator[](size_t i) const {\n        return m_data[i];\n    }\n\n    /**\n   * checks the vector modulus state.\n   * always returns true\n   */\n    bool isModulusSet() const {\n        return m_modulus_state == State::INITIALIZED;\n    }\n\n    /**\n   * Sets the vector modulus.\n   *\n   * @param value is the value to set.\n   */\n    //    void SetModulus(const usint&amp; value) noexcept {\n    //        m_modulus       = ubint_el_t(value);\n    //        m_modulus_state = State::INITIALIZED;\n    //    }\n\n    /**\n   * Sets the vector modulus.\n   *\n   * @param value is the value to set.\n   */\n    void SetModulus(const ubint_el_t&amp; value) noexcept {\n        m_modulus       = value;\n        m_modulus_state = State::INITIALIZED;\n    }\n\n    void SetModulus(ubint_el_t&amp;&amp; value) noexcept {\n        m_modulus       = std::move(value);\n        m_modulus_state = State::INITIALIZED;\n    }\n\n    /**\n   * Sets the vector modulus.\n   *\n   * @param value is the value to set.\n   */\n    void SetModulus(const std::string&amp; value) {\n        m_modulus       = ubint_el_t(value);\n        m_modulus_state = State::INITIALIZED;\n    }\n\n    /**\n   * Sets the vector modulus to the same as another mubintvec\n   *\n   * @param value is the vector whose modulus to use.\n   */\n    void SetModulus(const mubintvec&amp; value) {\n        m_modulus       = value.GetModulus();\n        m_modulus_state = State::INITIALIZED;\n    }\n\n    /**\n   * Sets the vector modulus and changes the values to match the new modulus.\n   *\n   * @param value is the value to set.\n   */\n    void SwitchModulus(const ubint_el_t&amp; value);\n\n    /**\n   * Gets the vector modulus.\n   *\n   * @return the vector modulus.\n   */\n    const ubint_el_t&amp; GetModulus() const {\n        if (m_modulus_state != State::INITIALIZED)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::not_available_error, &quot;GetModulus() on uninitialized mubintvec&quot;);\n        return m_modulus;\n    }\n\n    /**\n   * Vector modulus operator.\n   * Side effect it resets the vector modulus to modulus\n   *\n   * @param &amp;modulus is the modulus to perform on the current vector entries.\n   * @return is the result of the modulus operation on current vector.\n   */\n    mubintvec Mod(const ubint_el_t&amp; modulus) const;\n\n    /**\n   * Vector modulus operator. In-place variant.\n   * Side effect it resets the vector modulus to modulus\n   *\n   * @param &amp;modulus is the modulus to perform on the current vector entries.\n   * @return is the result of the modulus operation on current vector.\n   */\n    mubintvec&amp; ModEq(const ubint_el_t&amp; modulus);\n\n    /**\n   * Scalar-to-vector modulus addition operation.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus addition operation.\n   */\n    mubintvec ModAdd(const ubint_el_t&amp; b) const;\n\n    /**\n   * Scalar-to-vector modulus addition operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus addition operation.\n   */\n    mubintvec&amp; ModAddEq(const ubint_el_t&amp; b);\n\n    /**\n   * Scalar modulus addition at a particular index.\n   *\n   * @param i is the index of the entry to add.\n   * @param &amp;b is the scalar to add.\n   * @return is the result of the modulus addition operation.\n   */\n    mubintvec ModAddAtIndex(size_t i, const ubint_el_t&amp; b) const;\n\n    /**\n   * Scalar modulus addition at a particular index. In-place variant.\n   *\n   * @param i is the index of the entry to add.\n   * @param &amp;b is the scalar to add.\n   * @return is the result of the modulus addition operation.\n   */\n    mubintvec&amp; ModAddAtIndexEq(size_t i, const ubint_el_t&amp; b);\n\n    /**\n   * Vector component wise modulus addition.\n   *\n   * @param &amp;b is the vector to perform operation with.\n   * @return is the result of the component wise modulus addition operation.\n   */\n    mubintvec ModAdd(const mubintvec&amp; b) const;\n\n    /**\n   * Vector component wise modulus addition. In-place variant.\n   *\n   * @param &amp;b is the vector to perform operation with.\n   * @return is the result of the component wise modulus addition operation.\n   */\n    mubintvec&amp; ModAddEq(const mubintvec&amp; b);\n    mubintvec&amp; ModAddNoCheckEq(const mubintvec&amp; b);\n\n    /**\n   * Scalar-from-vector modulus subtraction operation.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    mubintvec ModSub(const ubint_el_t&amp; b) const;\n\n    /**\n   * Scalar-from-vector modulus subtraction operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    mubintvec&amp; ModSubEq(const ubint_el_t&amp; b);\n\n    /**\n   * Vector component wise modulus subtraction.\n   *\n   * @param &amp;b is the vector to perform operation with.\n   * @return is the result of the component wise modulus subtraction operation.\n   */\n    mubintvec ModSub(const mubintvec&amp; b) const;\n\n    /**\n   * Vector component wise modulus subtraction. In-place variant.\n   *\n   * @param &amp;b is the vector to perform operation with.\n   * @return is the result of the component wise modulus subtraction operation.\n   */\n    mubintvec&amp; ModSubEq(const mubintvec&amp; b);\n\n    /**\n   * Scalar-to-vector modulus multiplication operation.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    mubintvec ModMul(const ubint_el_t&amp; b) const;\n\n    /**\n   * Scalar-to-vector modulus multiplication operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    mubintvec&amp; ModMulEq(const ubint_el_t&amp; b);\n\n    /**\n   * Vector component wise modulus multiplication.\n   *\n   * @param &amp;b is the vector to perform operation with.\n   * @return is the result of the component wise modulus multiplication\n   * operation.\n   */\n    mubintvec ModMul(const mubintvec&amp; b) const;\n\n    /**\n   * Vector component wise modulus multiplication. In-place variant.\n   *\n   * @param &amp;b is the vector to perform operation with.\n   * @return is the result of the component wise modulus multiplication\n   * operation.\n   */\n    mubintvec&amp; ModMulEq(const mubintvec&amp; b);\n    mubintvec&amp; ModMulNoCheckEq(const mubintvec&amp; b);\n\n    /**\n   * Scalar modulus exponentiation operation.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus exponentiation operation.\n   */\n    mubintvec ModExp(const ubint_el_t&amp; b) const;\n\n    /**\n   * Scalar modulus exponentiation operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus exponentiation operation.\n   */\n    mubintvec&amp; ModExpEq(const ubint_el_t&amp; b);\n\n    /**\n   * Modulus inverse operation.\n   *\n   * @return is the result of the component wise modulus inverse operation.\n   */\n    mubintvec ModInverse() const;\n\n    /**\n   * Modulus inverse operation. In-place variant.\n   *\n   * @return is the result of the component wise modulus inverse operation.\n   */\n    mubintvec&amp; ModInverseEq();\n\n    /**\n   * Modulus 2 operation, also a least significant bit.\n   *\n   * @return is the result of the component wise modulus 2 operation, also a\n   * least significant bit.\n   */\n    mubintvec ModByTwo() const;\n\n    /**\n   * Modulus 2 operation, also a least significant bit. In-place variant.\n   *\n   * @return is the result of the component wise modulus 2 operation, also a\n   * least significant bit.\n   */\n    mubintvec&amp; ModByTwoEq();\n\n    /**\n   * Multiply and Rounding operation. Returns [x*p/q] where [] is the rounding\n   * operation.\n   *\n   * @param &amp;p is the numerator to be multiplied.\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of multiply and round operation.\n   */\n    mubintvec MultiplyAndRound(const ubint_el_t&amp; p, const ubint_el_t&amp; q) const;\n\n    /**\n   * Multiply and Rounding operation. Returns [x*p/q] where [] is the rounding\n   * operation. In-place variant.\n   *\n   * @param &amp;p is the numerator to be multiplied.\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of multiply and round operation.\n   */\n    mubintvec&amp; MultiplyAndRoundEq(const ubint_el_t&amp; p, const ubint_el_t&amp; q);\n\n    /**\n   * Divide and Rounding operation. Returns [x/q] where [] is the rounding\n   * operation.\n   *\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of divide and round operation.\n   */\n    mubintvec DivideAndRound(const ubint_el_t&amp; q) const;\n\n    /**\n   * Divide and Rounding operation. Returns [x/q] where [] is the rounding\n   * operation. In-place variant.\n   *\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of divide and round operation.\n   */\n    mubintvec&amp; DivideAndRoundEq(const ubint_el_t&amp; q);\n\n    // OTHER FUNCTIONS\n\n    /**\n   * Digit vector at a specific index for all entries for a given number base.\n   * Warning: only power-of-2 bases are currently supported.\n   * Example: for vector (83, 1, 45), index 2 and base 4 we have:\n   *\n   *                           index:0,1,2,3\n   * |83|                           |3,0,1,1|                 |1|\n   * |1 | --base 4 decomposition--&gt; |1,0,0,0| --at index 2--&gt; |0|\n   * |45|                           |1,3,2,0|                 |2|\n   *\n   * The return vector is (1,0,2)\n   *\n   * @param index is the index to return the digit from in all entries.\n   * @param base is the base to use for the operation.\n   * @return is the digit at a specific index for all entries for a given number\n   * base\n   */\n    mubintvec GetDigitAtIndexForBase(usint index, usint base) const;\n\n    // STRINGS &amp; STREAMS\n\n    /**\n   * ostream output &lt;&lt; operator.\n   *\n   * @param os is the std ostream object.\n   * @param ptr_obj is mubintvec to be printed.\n   * @return is the ostream object.\n   */\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const mubintvec&amp; ptr_obj) {\n        #if 0  // old way\n    os &lt;&lt; std::endl;\n    for (usint i = 0; i &lt; ptr_obj.m_data.size(); i++) {\n      os &lt;&lt; ptr_obj.m_data[i] &lt;&lt; std::endl;\n    }\n    os &lt;&lt; &quot;modulus: &quot; &lt;&lt; ptr_obj.m_modulus;\n    os &lt;&lt; std::endl;\n        #else\n        auto len = ptr_obj.m_data.size();\n        os &lt;&lt; &quot;[&quot;;\n        for (usint i = 0; i &lt; len; i++) {\n            os &lt;&lt; ptr_obj.m_data[i];\n            os &lt;&lt; ((i == (len - 1)) ? &quot;]&quot; : &quot; &quot;);\n        }\n        os &lt;&lt; &quot; modulus: &quot; &lt;&lt; ptr_obj.m_modulus;\n        #endif\n        return os;\n    }\n\n    // SERIALIZATION\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::make_nvp(&quot;d&quot;, m_data));\n        ar(::cereal::make_nvp(&quot;m&quot;, m_modulus));\n        ar(::cereal::make_nvp(&quot;ms&quot;, m_modulus_state));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                           &quot; is from a later version of the library&quot;);\n        }\n        ar(::cereal::make_nvp(&quot;d&quot;, m_data));\n        ar(::cereal::make_nvp(&quot;m&quot;, m_modulus));\n        ar(::cereal::make_nvp(&quot;ms&quot;, m_modulus_state));\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;ExpVector&quot;;\n    }\n\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\nprivate:\n    enum State { GARBAGE, INITIALIZED };\n\n    ubint_el_t m_modulus{};\n\n    // enum to store the state of the\n    State m_modulus_state{State::GARBAGE};\n\n    std::vector&lt;ubint_el_t&gt; m_data{};\n\n    bool IndexCheck(size_t length) const {\n        return length &lt; m_data.size();\n    }\n};\n\n}  // namespace bigintdyn\n\n    #endif  // LBCRYPTO_MATH_HAL_BIGINTDYN_MUBINTVECDYN_H\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/vector.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/vector.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/vector.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  This file contains the interfaces for the math vector data types\n */\n\n#ifndef LBCRYPTO_MATH_VECTOR_H\n#define LBCRYPTO_MATH_VECTOR_H\n\n#include &quot;utils/inttypes.h&quot;\n\n#include &lt;string&gt;\n\nnamespace lbcrypto {\n\ntemplate &lt;typename T, typename I&gt;\nclass BigVectorInterface {\npublic:\n    typedef I Integer;\n\n    // CONSTRUCTORS\n\n    // Constructors should be implemented in the derived classes\n    // The derived classes should implement constructors from initializer lists of\n    // integers and strings\n\n    // ASSIGNMENT OPERATORS\n\n    /**\n   * Copy assignment operator.\n   *\n   * @param &amp;vec is the vector to be assigned from.\n   * @return assigned vector ref.\n   */\n    T&amp; operator=(const T&amp; vec);\n\n    /**\n   * Move assignment operator.\n   *\n   * @param &amp;vec is the vector to be assigned from.\n   * @return assigned vector ref.\n   */\n    T&amp; operator=(T&amp;&amp; vec);\n\n    /**\n   * Assignment operator from initializer list of strings.\n   *\n   * @param &amp;&amp;strvec is the list of strings.\n   * @return assigned vector ref.\n   */\n    T&amp; operator=(std::initializer_list&lt;std::string&gt; strvec);\n\n    /**\n   * Assignment operator from initializer list of unsigned integers.\n   *\n   * @param &amp;&amp;vec is the list of integers.\n   * @return assigned vector ref.\n   */\n    T&amp; operator=(std::initializer_list&lt;uint64_t&gt; vec);\n\n    /**\n   * Assignment operator to assign value val to first entry, 0 for the rest of\n   * entries.\n   *\n   * @param val is the unsigned integer the first entry to be assigned from.\n   * @return assigned vector ref.\n   */\n    T&amp; operator=(uint64_t val);\n\n    // EQUALS OPERATORS\n\n    /**\n   * Equals to operator.\n   *\n   * @param &amp;b is vector to be compared.\n   * @return true if equal and false otherwise.\n   */\n    friend inline bool operator==(const T&amp; a, const T&amp; b) {\n        if ((a.GetLength() != b.GetLength()) || (a.GetModulus() != b.GetModulus())) {\n            return false;\n        }\n        for (usint i = 0; i &lt; a.GetLength(); ++i) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n   * Not equal to operator.\n   *\n   * @param b is vector to be compared.\n   * @return true if not equal and false otherwise.\n   */\n    friend inline bool operator!=(const T&amp; a, const T&amp; b) {\n        return !(a == b);\n    }\n\n    // ACCESSORS\n\n    // The derived class must implement at and operator[]\n    I&amp; at(size_t idx);\n    const I&amp; at(size_t idx) const;\n    I&amp; operator[](size_t idx);\n    const I&amp; operator[](size_t idx) const;\n\n    /**\n   * Sets the vector modulus.\n   *\n   * @param value is the value to set.\n   * @param value is the modulus value to set.\n   */\n    void SetModulus(const I&amp; value);\n\n    /**\n   * Sets the vector modulus and changes the values to match the new modulus.\n   *\n   * @param value is the value to set.\n   */\n    void SwitchModulus(const I&amp; value);\n\n    /**\n   * Gets the vector modulus.\n   *\n   * @return the vector modulus.\n   */\n    const I&amp; GetModulus() const;\n\n    /**\n   * Gets the vector length.\n   *\n   * @return vector length.\n   */\n    size_t GetLength() const;\n\n    // MODULUS ARITHMETIC OPERATIONS\n\n    /**\n   * Vector modulus operator.\n   *\n   * @param &amp;modulus is the modulus to perform on the current vector entries.\n   * @return is the result of the modulus operation on current vector.\n   */\n    T Mod(const I&amp; modulus) const;\n\n    /**\n   * Vector modulus operator. In-place variant.\n   *\n   * @param &amp;modulus is the modulus to perform on the current vector entries.\n   * @return is the result of the modulus operation on current vector.\n   */\n    T&amp; ModEq(const I&amp; modulus);\n\n    /// inline operators for the modulus operations.\n    friend T operator%(const T&amp; a, const I&amp; b) {\n        return a.Mod(b);\n    }\n    friend T&amp; operator%=(T&amp; a, const I&amp; b) {\n        return a.ModEq(b);\n    }\n\n    /**\n   * Scalar-to-vector modulus addition operation.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus addition operation.\n   */\n    T ModAdd(const I&amp; b) const;\n\n    /**\n   * Scalar-to-vector modulus addition operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus addition operation.\n   */\n    T&amp; ModAddEq(const I&amp; b);\n\n    /// inline operators for the scara-to-vector modulus addition operations.\n    friend T operator+(const T&amp; a, const I&amp; b) {\n        return a.ModAdd(b);\n    }\n    friend T&amp; operator+=(T&amp; a, const I&amp; b) {\n        return a.ModAddEq(b);\n    }\n\n    /**\n   * Scalar modulus addition at a particular index.\n   *\n   * @param i is the index of the entry to add.\n   * @param &amp;b is the scalar to add.\n   * @return is the result of the modulus addition operation.\n   */\n    T ModAddAtIndex(usint i, const I&amp; b) const;\n\n    /**\n   * Scalar modulus addition at a particular index. In-place variant.\n   *\n   * @param i is the index of the entry to add.\n   * @param &amp;b is the scalar to add.\n   * @return is the result of the modulus addition operation.\n   */\n    T&amp; ModAddAtIndexEq(usint i, const I&amp; b);\n\n    /**\n   * Vector component wise modulus addition.\n   *\n   * @param &amp;b is the vector to perform operation with.\n   * @return is the result of the component wise modulus addition operation.\n   */\n    T ModAdd(const T&amp; b) const;\n\n    /**\n   * Vector component wise modulus addition. In-place variant.\n   *\n   * @param &amp;b is the vector to perform operation with.\n   * @return is the result of the component wise modulus addition operation.\n   */\n    T&amp; ModAddEq(const T&amp; b);\n    T&amp; ModAddNoCheckEq(const T&amp; b);\n\n    /// inline operators for the vector component wise modulus addition\n    /// operations.\n    friend T operator+(const T&amp; a, const T&amp; b) {\n        return a.ModAdd(b);\n    }\n    friend T&amp; operator+=(T&amp; a, const T&amp; b) {\n        return a.ModAddEq(b);\n    }\n\n    /**\n   * Scalar-from-vector modulus subtraction operation.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    T ModSub(const I&amp; b) const;\n\n    /**\n   * Scalar-from-vector modulus subtraction operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    T&amp; ModSubEq(const I&amp; b);\n\n    /// inline operators for the scalar-from-vector modulus subtraction\n    /// operations.\n    friend T operator-(const T&amp; a, const I&amp; b) {\n        return a.ModSub(b);\n    }\n    friend T&amp; operator-=(T&amp; a, const I&amp; b) {\n        return a.ModSubEq(b);\n    }\n\n    /**\n   * Vector component wise modulus subtraction.\n   *\n   * @param &amp;b is the vector to perform operation with.\n   * @return is the result of the component wise modulus subtraction operation.\n   */\n    T ModSub(const T&amp; b) const;\n\n    /**\n   * Vector component wise modulus subtraction. In-place variant.\n   *\n   * @param &amp;b is the vector to perform operation with.\n   * @return is the result of the component wise modulus subtraction operation.\n   */\n    T&amp; ModSubEq(const T&amp; b);\n\n    /// inline operators for the vector component wise modulus subtraction\n    /// operations.\n    inline friend T operator-(const T&amp; a, const T&amp; b) {\n        return a.ModSub(b);\n    }\n    inline friend const T&amp; operator-=(T&amp; a, const T&amp; b) {\n        return a.ModSubEq(b);\n    }\n\n    /// inline operator for the unary minus\n    inline friend T operator-(const T&amp; a) {\n        return a.ModMul(a.GetModulus() - I(1));\n    }\n\n    /**\n   * Scalar-to-vector modulus multiplication operation.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    T ModMul(const I&amp; b) const;\n\n    /**\n   * Scalar-to-vector modulus multiplication operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    T&amp; ModMulEq(const I&amp; b);\n\n    /// inline operators for the scalar-to-vector modulus multiplication\n    /// operations.\n    friend T operator*(const T&amp; a, const I&amp; b) {\n        return a.ModMul(b);\n    }\n    friend T&amp; operator*=(T&amp; a, const I&amp; b) {\n        return a.ModMulEq(b);\n    }\n\n    /**\n   * Vector component wise modulus multiplication.\n   *\n   * @param &amp;b is the vector to perform operation with.\n   * @return is the result of the component wise modulus multiplication\n   * operation.\n   */\n    T ModMul(const T&amp; b) const;\n\n    /**\n   * Vector component wise modulus multiplication. In-place variant.\n   *\n   * @param &amp;b is the vector to perform operation with.\n   * @return is the result of the component wise modulus multiplication\n   * operation.\n   */\n    T&amp; ModMulEq(const T&amp; b);\n    T&amp; ModMulNoCheckEq(const T&amp; b);\n\n    /// inline operators for the vector component wise modulus multiplication\n    /// operations.\n    friend T operator*(const T&amp; a, const T&amp; b) {\n        return a.ModMul(b);\n    }\n    friend T&amp; operator*=(T&amp; a, const T&amp; b) {\n        return a.ModMulEq(b);\n    }\n\n    /**\n   * Scalar modulus exponentiation operation.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus exponentiation operation.\n   */\n    T ModExp(const I&amp; b) const;\n\n    /**\n   * Scalar modulus exponentiation operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to perform operation with.\n   * @return is the result of the modulus exponentiation operation.\n   */\n    T&amp; ModExpEq(const I&amp; b);\n\n    /**\n   * Modulus inverse operation.\n   *\n   * @return is the result of the component wise modulus inverse operation.\n   */\n    T ModInverse() const;\n\n    /**\n   * Modulus inverse operation. In-place variant.\n   *\n   * @return is the result of the component wise modulus inverse operation.\n   */\n    T&amp; ModInverseEq();\n\n    /**\n   * Modulus 2 operation, also a least significant bit.\n   *\n   * @return is the result of the component wise modulus 2 operation, also a\n   * least significant bit.\n   */\n    T ModByTwo() const;\n\n    /**\n   * Modulus 2 operation, also a least significant bit. In-place variant.\n   *\n   * @return is the result of the component wise modulus 2 operation, also a\n   * least significant bit.\n   */\n    T&amp; ModByTwoEq();\n\n    /**\n   * Multiply and Rounding operation. Returns [x*p/q] where [] is the rounding\n   * operation.\n   *\n   * @param &amp;p is the numerator to be multiplied.\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of multiply and round operation.\n   */\n    T MultiplyAndRound(const I&amp; p, const I&amp; q) const;\n\n    /**\n   * Multiply and Rounding operation. Returns [x*p/q] where [] is the rounding\n   * operation. In-place variant.\n   *\n   * @param &amp;p is the numerator to be multiplied.\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of multiply and round operation.\n   */\n    T&amp; MultiplyAndRoundEq(const I&amp; p, const I&amp; q);\n\n    /**\n   * Divide and Rounding operation. Returns [x/q] where [] is the rounding\n   * operation.\n   *\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of divide and round operation.\n   */\n    T DivideAndRound(const I&amp; q) const;\n\n    /**\n   * Divide and Rounding operation. Returns [x/q] where [] is the rounding\n   * operation. In-place variant.\n   *\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of divide and round operation.\n   */\n    T&amp; DivideAndRoundEq(const I&amp; q);\n\n    // OTHER FUNCTIONS\n\n    /**\n   * Digit vector at a specific index for all entries for a given number base.\n   * Example: for vector (83, 1, 45), index 2 and base 4 we have:\n   *\n   *                           index:0,1,2,3\n   * |83|                           |3,0,1,1|                 |1|\n   * |1 | --base 4 decomposition--&gt; |1,0,0,0| --at index 2--&gt; |0|\n   * |45|                           |1,3,2,0|                 |2|\n   *\n   * The return vector is (1,0,2)\n   *\n   * @param index is the index to return the digit from in all entries.\n   * @param base is the base to use for the operation.\n   * @return is the digit at a specific index for all entries for a given number\n   * base\n   */\n    T GetDigitAtIndexForBase(usint index, usint base) const;\n\nprotected:\n    ~BigVectorInterface() = default;\n\n    // STRINGS &amp; STREAMS\n\n    // SERIALIZATION\n};\n\n}  // namespace lbcrypto\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/utils/openfhebase64.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/openfhebase64.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/openfhebase64.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  OpenFHE native base 64 utlities\n */\n\n#ifndef SRC_CORE_LIB_UTILS_OPENFHEBASE64_H_\n#define SRC_CORE_LIB_UTILS_OPENFHEBASE64_H_\n\n#include &lt;utils/exception.h&gt;\n\n#include &lt;cctype&gt;\n#include &lt;cstdint&gt;\n\nnamespace lbcrypto {\n\nextern const char to_base64_char[];\n\ninline unsigned char value_to_base64(int c) {\n    return to_base64_char[c];\n}\n\ninline unsigned char base64_to_value(unsigned char b64) {\n    if (isupper(b64))\n        return b64 - &#x27;A&#x27;;\n    if (islower(b64))\n        return b64 - &#x27;a&#x27; + 26;\n    if (isdigit(b64))\n        return b64 - &#x27;0&#x27; + 52;\n    if (b64 == &#x27;+&#x27;)\n        return 62;\n    return 63;\n}\n\ninline unsigned char get_6bits_atoffset(uint64_t m_value, uint32_t index) {\n    static unsigned char smallmask[] = {0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f};\n    if (index == 0)\n        &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Zero index in GetBitAtIndex&quot;);\n    if (index &lt;= 6)\n        return m_value &amp; smallmask[index];\n    return (m_value &gt;&gt; (index - 6)) &amp; 0x3f;\n}\n\n} /* namespace lbcrypto */\n\n#endif /* SRC_CORE_LIB_UTILS_OPENFHEBASE64_H_ */\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n This file contains the main class for native integers. It implements the same methods as other mathematical backends.\n*/\n\n#ifndef LBCRYPTO_MATH_HAL_INTNAT_UBINTNAT_H\n#define LBCRYPTO_MATH_HAL_INTNAT_UBINTNAT_H\n\n#include &quot;math/hal/basicint.h&quot;\n#include &quot;math/hal/bigintbackend.h&quot;\n#include &quot;math/hal/integer.h&quot;\n#include &quot;math/nbtheory.h&quot;\n\n#include &quot;utils/debug.h&quot;\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/inttypes.h&quot;\n#include &quot;utils/openfhebase64.h&quot;\n#include &quot;utils/serializable.h&quot;\n\n#include &lt;cstdint&gt;\n// #include &lt;cstdlib&gt;\n// #include &lt;fstream&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;limits&gt;\n// #include &lt;memory&gt;\n// #include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n// #include &lt;typeinfo&gt;\n#include &lt;vector&gt;\n#include &lt;utility&gt;\n\n// the default behavior of the native integer layer is\n// to assume that the user does not need bounds/range checks\n// in the native integer code\n// if you want them, change this #define to true\n// we use a #define to resolve which to use at compile time\n// sadly, making the choice according to some setting that\n// is checked at runtime has awful performance; using this\n// #define in a simple expression causes the compiler to\n// optimize away the test\n#define NATIVEINT_DO_CHECKS false\n#define NATIVEINT_BARRET_MOD\n\n// TODO: remove these?\nusing U32BITS = uint32_t;\nusing U64BITS = uint64_t;\n#if defined(HAVE_INT128)\nusing U128BITS = uint128_t;\n#endif\n\nnamespace intnat {\n\n// Forward declare class and give it an alias for the expected type\ntemplate &lt;typename IntType&gt;\nclass NativeIntegerT;\nusing NativeInteger = NativeIntegerT&lt;BasicInteger&gt;;\n\ntemplate &lt;typename IntType&gt;\nclass NativeVectorT;\n\n// constexpr double LOG2_10 = 3.32192809;  //!&lt; @brief A pre-computed  constant of Log base 2 of 10.\n// constexpr usint BARRETT_LEVELS = 8;  //!&lt; @brief The number of levels (precomputed\n//!&lt; values) used in the Barrett reductions.\n\n/**\n * @brief Struct to determine other datatyps based on utype.\n * @tparam utype primitive integer data type.\n */\ntemplate &lt;typename utype&gt;\nstruct DataTypes {\n    using SignedType       = void;\n    using DoubleType       = void;\n    using SignedDoubleType = void;\n};\ntemplate &lt;&gt;\nstruct DataTypes&lt;uint32_t&gt; {\n    using SignedType       = int32_t;\n    using DoubleType       = uint64_t;\n    using SignedDoubleType = int64_t;\n};\ntemplate &lt;&gt;\nstruct DataTypes&lt;uint64_t&gt; {\n    using SignedType = int64_t;\n#if defined(HAVE_INT128)\n    using DoubleType       = uint128_t;\n    using SignedDoubleType = int128_t;\n#else\n    using DoubleType       = uint64_t;\n    using SignedDoubleType = int64_t;\n#endif\n};\n#if defined(HAVE_INT128)\ntemplate &lt;&gt;\nstruct DataTypes&lt;uint128_t&gt; {\n    using SignedType       = int128_t;\n    using DoubleType       = uint128_t;\n    using SignedDoubleType = int128_t;\n};\n#endif\n\n/**\n * @brief Main class for big integers represented as an array of native\n * (primitive) unsigned integers\n * @tparam NativeInt native unsigned integer type\n */\ntemplate &lt;typename NativeInt&gt;\nclass NativeIntegerT final : public lbcrypto::BigIntegerInterface&lt;NativeIntegerT&lt;NativeInt&gt;&gt; {\nprivate:\n    NativeInt m_value{0};\n\n    // variable to store the maximum value of the integral data type.\n    static constexpr NativeInt m_uintMax{std::numeric_limits&lt;NativeInt&gt;::max()};\n    // variable to store the bit width of the integral data type.\n    //    static constexpr usint m_uintBitLength{sizeof(NativeInt) * 8};\n    static constexpr usint m_uintBitLength{std::numeric_limits&lt;NativeInt&gt;::digits};\n\n    friend class NativeVectorT&lt;NativeIntegerT&lt;NativeInt&gt;&gt;;\n\npublic:\n    using Integer         = NativeInt;\n    using SignedNativeInt = typename DataTypes&lt;NativeInt&gt;::SignedType;\n    using DNativeInt      = typename DataTypes&lt;NativeInt&gt;::DoubleType;\n    using SDNativeInt     = typename DataTypes&lt;NativeInt&gt;::SignedDoubleType;\n\n    // data structure to represent a double-word integer as two single-word integers\n    struct typeD {\n        NativeInt hi{0};\n        NativeInt lo{0};\n        inline std::string ConvertToString() const {\n            return std::string(&quot;hi [&quot; + toString(hi) + &quot;], lo [&quot; + toString(lo) + &quot;]&quot;);\n        }\n    };\n\n    explicit operator NativeInt() const {\n        return m_value;\n    }\n    explicit operator bool() const {\n        return m_value != 0;\n    }\n\n    constexpr NativeIntegerT() = default;\n    constexpr NativeIntegerT(const NativeIntegerT&amp; val) noexcept : m_value{val.m_value} {}\n    constexpr NativeIntegerT(NativeIntegerT&amp;&amp; val) noexcept : m_value{std::move(val.m_value)} {}\n\n    NativeIntegerT(const std::string&amp; val) {\n        this-&gt;NativeIntegerT::SetValue(val);\n    }\n\n    explicit NativeIntegerT(const char* strval) {\n        this-&gt;NativeIntegerT::SetValue(std::string(strval));\n    }\n    // explicit NativeIntegerT(const char strval) : m_value{NativeInt(strval - &#x27;0&#x27;)} {}\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, bool&gt; = true&gt;\n    constexpr NativeIntegerT(T val) noexcept : m_value(val) {}\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_same_v&lt;T, M2Integer&gt; || std::is_same_v&lt;T, M4Integer&gt; ||\n                                               std::is_same_v&lt;T, M6Integer&gt;,\n                                           bool&gt; = true&gt;\n    constexpr NativeIntegerT(T val) noexcept : m_value{val.template ConvertToInt&lt;NativeInt&gt;()} {}\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;, bool&gt; = true&gt;\n    NativeIntegerT(T val) = delete;\n\n    constexpr NativeIntegerT&amp; operator=(const NativeIntegerT&amp; val) noexcept {\n        m_value = val.m_value;\n        return *this;\n    }\n\n    constexpr NativeIntegerT&amp; operator=(NativeIntegerT&amp;&amp; val) noexcept {\n        m_value = std::move(val.m_value);\n        return *this;\n    }\n\n    NativeIntegerT&amp; operator=(const std::string&amp; val) {\n        this-&gt;NativeIntegerT::SetValue(val);\n        return *this;\n    }\n\n    NativeIntegerT&amp; operator=(const char* strval) {\n        this-&gt;NativeIntegerT::SetValue(std::string(strval));\n        return *this;\n    }\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, bool&gt; = true&gt;\n    constexpr NativeIntegerT&amp; operator=(T val) noexcept {\n        m_value = val;\n        return *this;\n    }\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_same_v&lt;T, M2Integer&gt; || std::is_same_v&lt;T, M4Integer&gt; ||\n                                               std::is_same_v&lt;T, M6Integer&gt;,\n                                           bool&gt; = true&gt;\n    constexpr NativeIntegerT&amp; operator=(T val) noexcept {\n        m_value = val.template ConvertToInt&lt;NativeInt&gt;();\n        return *this;\n    }\n\n    template &lt;typename T, std::enable_if_t&lt;std::is_floating_point_v&lt;T&gt;, bool&gt; = true&gt;\n    NativeIntegerT&amp; operator=(T val) = delete;\n\n    /**\n   * Basic set method for setting the value of a native integer\n   *\n   * @param &amp;strval is the string representation of the native integer to be\n   * copied.\n   */\n    void SetValue(const std::string&amp; str) {\n        NativeInt acc{0}, tst{0};\n        for (auto c : str) {\n            if ((c - &#x27;0&#x27;) &gt; 9)\n                &quot;hey&quot;; OPENFHE_THROW(lbcrypto::type_error, &quot;String contains a non-digit&quot;);\n            if ((acc = (10 * acc) + static_cast&lt;NativeInt&gt;(c - &#x27;0&#x27;)) &lt; tst)\n                &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, str + &quot; is too large to fit in this native integer object&quot;);\n            tst = acc;\n        }\n        m_value = acc;\n    }\n\n    /**\n   * Basic set method for setting the value of a native integer\n   *\n   * @param &amp;val is the big binary integer representation of the native\n   * integer to be assigned.\n   */\n    void SetValue(const NativeIntegerT&amp; val) {\n        m_value = val.m_value;\n    }\n\n    /**\n   *  Set this int to 1.\n   */\n    void SetIdentity() {\n        m_value = static_cast&lt;NativeInt&gt;(1);\n    }\n\n    /**\n   * Addition operation.\n   *\n   * @param &amp;b is the value to add.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT Add(const NativeIntegerT&amp; b) const {\n        return NATIVEINT_DO_CHECKS ? AddCheck(b) : AddFast(b);\n    }\n\n    /**\n   * AddCheck is the addition operation with bounds checking.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT AddCheck(const NativeIntegerT&amp; b) const {\n        auto r{m_value + b.m_value};\n        if (r &lt; m_value || r &lt; b.m_value)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT AddCheck: Overflow&quot;);\n        return {r};\n    }\n\n    /**\n   * AddFast is the addition operation without bounds checking.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT AddFast(const NativeIntegerT&amp; b) const {\n        return {b.m_value + m_value};\n    }\n\n    /**\n   * Addition operation. In-place variant.\n   *\n   * @param &amp;b is the value to add.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT&amp; AddEq(const NativeIntegerT&amp; b) {\n        return NATIVEINT_DO_CHECKS ? AddEqCheck(b) : AddEqFast(b);\n    }\n\n    /**\n   * AddEqCheck is the addition in place operation with bounds checking.\n   * In-place variant.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT&amp; AddEqCheck(const NativeIntegerT&amp; b) {\n        auto oldv{m_value};\n        if ((m_value += b.m_value) &lt; oldv)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT AddEqCheck: Overflow&quot;);\n        return *this;\n    }\n\n    /**\n   * AddEqFast is the addition in place operation without bounds checking.\n   * In-place variant.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT&amp; AddEqFast(const NativeIntegerT&amp; b) {\n        return *this = b.m_value + m_value;\n    }\n\n    /**\n   * Subtraction operation.\n   *\n   * @param &amp;b is the value to subtract.\n   * @return is the result of the subtraction operation.\n   */\n    NativeIntegerT Sub(const NativeIntegerT&amp; b) const {\n        return NATIVEINT_DO_CHECKS ? SubCheck(b) : SubFast(b);\n    }\n\n    /**\n   * SubCheck is the subtraction operation with bounds checking.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT SubCheck(const NativeIntegerT&amp; b) const {\n        return {m_value &lt;= b.m_value ? 0 : m_value - b.m_value};\n    }\n\n    /**\n   * SubFast is the subtraction operation without bounds checking.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    // no saturated subtraction? functionality differs from BigInteger Backends\n    NativeIntegerT SubFast(const NativeIntegerT&amp; b) const {\n        return {m_value - b.m_value};\n    }\n\n    /**\n   * Subtraction operation. In-place variant.\n   *\n   * @param &amp;b is the value to subtract.\n   * @return is the result of the subtraction operation.\n   */\n    NativeIntegerT&amp; SubEq(const NativeIntegerT&amp; b) {\n        return NATIVEINT_DO_CHECKS ? SubEqCheck(b) : SubEqFast(b);\n    }\n\n    /**\n   * SubEqCheck is the subtraction in place operation with bounds checking.\n   * In-place variant.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT&amp; SubEqCheck(const NativeIntegerT&amp; b) {\n        if (m_value &lt; b.m_value)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT SubEqCheck: neg value&quot;);\n        return *this = m_value - b.m_value;\n    }\n\n    /**\n   * SubEqFast is the subtraction in place operation without bounds checking.\n   * In-place variant.\n   *\n   * @param b is the value to add to this.\n   * @return result of the addition operation.\n   */\n    NativeIntegerT&amp; SubEqFast(const NativeIntegerT&amp; b) {\n        return *this = m_value - b.m_value;\n    }\n\n    // overloaded binary operators based on integer arithmetic and comparison\n    // functions.\n    NativeIntegerT operator-() const {\n        return NativeIntegerT().Sub(*this);\n    }\n\n    /**\n   * Multiplication operation.\n   *\n   * @param &amp;b is the value to multiply with.\n   * @return is the result of the multiplication operation.\n   */\n    NativeIntegerT Mul(const NativeIntegerT&amp; b) const {\n        return NATIVEINT_DO_CHECKS ? MulCheck(b) : MulFast(b);\n    }\n\n    /**\n   * MulCheck is the multiplication operation with bounds checking.\n   *\n   * @param b is the value to multiply with\n   * @return result of the multiplication operation\n   */\n    NativeIntegerT MulCheck(const NativeIntegerT&amp; b) const {\n        auto p{b.m_value * m_value};\n        if (p &lt; m_value || p &lt; b.m_value)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT MulCheck: Overflow&quot;);\n        return {p};\n    }\n\n    /**\n   * MulFast is the multiplication operation without bounds checking.\n   *\n   * @param b is the value to multiply with.\n   * @return result of the multiplication operation.\n   */\n    NativeIntegerT MulFast(const NativeIntegerT&amp; b) const {\n        return {b.m_value * m_value};\n    }\n\n    /**\n   * Multiplication operation. In-place variant.\n   *\n   * @param &amp;b is the value to multiply with.\n   * @return is the result of the multiplication operation.\n   */\n    NativeIntegerT&amp; MulEq(const NativeIntegerT&amp; b) {\n        return NATIVEINT_DO_CHECKS ? MulEqCheck(b) : MulEqFast(b);\n    }\n\n    /**\n   * MulEqCheck is the multiplication in place operation with bounds checking.\n   * In-place variant.\n   *\n   * @param b is the value to multiply with\n   * @return result of the multiplication operation\n   */\n    NativeIntegerT&amp; MulEqCheck(const NativeIntegerT&amp; b) {\n        auto oldv{m_value};\n        if ((m_value *= b.m_value) &lt; oldv)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT MulEqCheck: Overflow&quot;);\n        return *this;\n    }\n\n    /**\n   * MulEqFast is the multiplication in place operation without bounds\n   * checking. In-place variant.\n   *\n   * @param b is the value to multiply with\n   * @return result of the multiplication operation\n   */\n    NativeIntegerT&amp; MulEqFast(const NativeIntegerT&amp; b) {\n        return *this = b.m_value * m_value;\n    }\n\n    /**\n   * Division operation.\n   *\n   * @param &amp;b is the value to divide by.\n   * @return is the result of the division operation.\n   */\n    NativeIntegerT DividedBy(const NativeIntegerT&amp; b) const {\n        if (b.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT DividedBy: zero&quot;);\n        return {m_value / b.m_value};\n    }\n\n    /**\n   * Division operation. In-place variant.\n   *\n   * @param &amp;b is the value to divide by.\n   * @return is the result of the division operation.\n   */\n    NativeIntegerT&amp; DividedByEq(const NativeIntegerT&amp; b) {\n        if (b.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT DividedByEq: zero&quot;);\n        return *this = m_value / b.m_value;\n    }\n\n    /**\n   * Exponentiation operation. Returns x^p.\n   *\n   * @param p the exponent.\n   * @return is the result of the exponentiation operation.\n   */\n    NativeIntegerT Exp(usint p) const {\n        NativeInt r{1};\n        for (auto x = m_value; p &gt; 0; p &gt;&gt;= 1, x *= x)\n            r *= (p &amp; 0x1) ? x : 1;\n        return {r};\n    }\n\n    /**\n   * Exponentiation operation. Returns x^p. In-place variant.\n   *\n   * @param p the exponent.\n   * @return is the result of the exponentiation operation.\n   */\n    NativeIntegerT&amp; ExpEq(usint p) {\n        auto x{m_value};\n        m_value = 1;\n        for (; p &gt; 0; p &gt;&gt;= 1, x *= x)\n            m_value *= (p &amp; 0x1) ? x : 1;\n        return *this;\n    }\n\n    /**\n   * Multiply and Rounding operation. Returns [x*p/q] where [] is the rounding\n   * operation.\n   *\n   * @param &amp;p is the numerator to be multiplied.\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of multiply and round operation.\n   */\n    NativeIntegerT MultiplyAndRound(const NativeIntegerT&amp; p, const NativeIntegerT&amp; q) const {\n        if (q.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT MultiplyAndRound: Divide by zero&quot;);\n        return static_cast&lt;NativeInt&gt;(p.ConvertToDouble() * (this-&gt;ConvertToDouble() / q.ConvertToDouble()) + 0.5);\n    }\n\n    /**\n   * Multiply and Rounding operation. Returns [x*p/q] where [] is the rounding\n   * operation. In-place variant.\n   *\n   * @param &amp;p is the numerator to be multiplied.\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of multiply and round operation.\n   */\n    NativeIntegerT&amp; MultiplyAndRoundEq(const NativeIntegerT&amp; p, const NativeIntegerT&amp; q) {\n        if (q.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT MultiplyAndRoundEq: Divide by zero&quot;);\n        return *this =\n                   static_cast&lt;NativeInt&gt;(p.ConvertToDouble() * (this-&gt;ConvertToDouble() / q.ConvertToDouble()) + 0.5);\n    }\n\n    /**\n   * Computes the quotient of x*p/q, where x,p,q are all NativeInt numbers, x\n   * is the current value; uses DNativeInt arithmetic\n   *\n   * @param p is the multiplicand\n   * @param q is the divisor\n   * @return the quotient\n   */\n    //    template &lt;typename T = NativeInt&gt;\n    //    NativeIntegerT MultiplyAndDivideQuotient(const NativeIntegerT&amp; p, const NativeIntegerT&amp; q) const {\n    //        DNativeInt xD{m_value};\n    //        DNativeInt pD{p.m_value};\n    //        DNativeInt qD{q.m_value};\n    //        return static_cast&lt;NativeIntegerT&gt;(xD * pD / qD);\n    //    }\n\n    /**\n   * Computes the remainder of x*p/q, where x,p,q are all NativeInt numbers, x\n   * is the current value; uses DNativeInt arithmetic. In-place variant.\n   *\n   * @param p is the multiplicand\n   * @param q is the divisor\n   * @return the remainder\n   */\n    //    template &lt;typename T = NativeInt&gt;\n    //    NativeIntegerT MultiplyAndDivideRemainder(const NativeIntegerT&amp; p, const NativeIntegerT&amp; q) const {\n    //        DNativeInt xD{m_value};\n    //        DNativeInt pD{p.m_value};\n    //        DNativeInt qD{q.m_value};\n    //        return static_cast&lt;NativeIntegerT&gt;(xD * pD % qD);\n    //    }\n\n    /**\n   * Divide and Rounding operation. Returns [x/q] where [] is the rounding\n   * operation.\n   *\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of divide and round operation.\n   */\n    NativeIntegerT DivideAndRound(const NativeIntegerT&amp; q) const {\n        if (q.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT DivideAndRound: zero&quot;);\n        auto ans{m_value / q.m_value};\n        auto rem{m_value % q.m_value};\n        auto halfQ{q.m_value &gt;&gt; 1};\n        if (rem &gt; halfQ)\n            return {ans + 1};\n        return {ans};\n    }\n\n    /**\n   * Divide and Rounding operation. Returns [x/q] where [] is the rounding\n   * operation. In-place variant.\n   *\n   * @param &amp;q is the denominator to be divided.\n   * @return is the result of divide and round operation.\n   */\n    NativeIntegerT&amp; DivideAndRoundEq(const NativeIntegerT&amp; q) {\n        if (q.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT DivideAndRoundEq: zero&quot;);\n        auto ans{m_value / q.m_value};\n        auto rem{m_value % q.m_value};\n        auto halfQ{q.m_value &gt;&gt; 1};\n        if (rem &gt; halfQ)\n            return *this = ans + 1;\n        return *this = ans;\n    }\n\n    /**\n   * Naive modulus operation.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @return is the result of the modulus operation.\n   */\n    NativeIntegerT Mod(const NativeIntegerT&amp; modulus) const {\n        return {m_value % modulus.m_value};\n    }\n\n    /**\n   * Naive modulus operation. In-place variant.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @return is the result of the modulus operation.\n   */\n    NativeIntegerT&amp; ModEq(const NativeIntegerT&amp; modulus) {\n        return *this = m_value % modulus.m_value;\n    }\n\n    /**\n   * Precomputes a parameter mu for Barrett modular reduction.\n   *\n   * @return the precomputed parameter mu.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ComputeMu(typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        if (m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT ComputeMu: Divide by zero&quot;);\n        auto&amp;&amp; tmp{DNativeInt{1} &lt;&lt; (2 * lbcrypto::GetMSB(m_value) + 3)};\n        return {tmp / DNativeInt(m_value)};\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ComputeMu(typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        if (m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeIntegerT ComputeMu: Divide by zero&quot;);\n        auto&amp;&amp; tmp{bigintbackend::BigInteger{1} &lt;&lt; (2 * lbcrypto::GetMSB(m_value) + 3)};\n        return {(tmp / bigintbackend::BigInteger(m_value)).template ConvertToInt&lt;NativeInt&gt;()};\n    }\n\n    /**\n   * Barrett modulus operation.\n   * Implements generalized Barrett modular reduction algorithm. Uses one\n   * precomputed value of mu.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus operation.\n   */\n    // TODO: pass modulus.GetMSB() with mu for faster vector ops?\n    NativeIntegerT Mod(const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu) const {\n        typeD tmp;\n        NativeIntegerT ans{*this};\n        ModMu(tmp, ans, modulus.m_value, mu.m_value, modulus.GetMSB() - 2);\n        return ans;\n    }\n\n    /**\n   * Barrett modulus operation. In-place variant.\n   * Implements generalized Barrett modular reduction algorithm. Uses one\n   * precomputed value of mu.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus operation.\n   */\n    NativeIntegerT&amp; ModEq(const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu) {\n        typeD tmp;\n        ModMu(tmp, *this, modulus.m_value, mu.m_value, modulus.GetMSB() - 2);\n        return *this;\n    }\n\n    /**\n   * Modulus addition operation.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeIntegerT ModAdd(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) const {\n        auto av{m_value};\n        auto bv{b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (av &gt;= mv)\n            av %= mv;\n        if (bv &gt;= mv)\n            bv %= mv;\n        av += bv;\n        if (av &gt;= mv)\n            av -= mv;\n        return {av};\n    }\n\n    /**\n   * Modulus addition operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeIntegerT&amp; ModAddEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) {\n        auto bv{b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (m_value &gt;= mv)\n            m_value = m_value % mv;\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        m_value += bv;\n        if (m_value &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /**\n   * Modulus addition where operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeIntegerT ModAddFast(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) const {\n        auto r{m_value + b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (r &gt;= mv)\n            r -= mv;\n        return {r};\n    }\n    /**\n   * Modulus addition where operands are &lt; modulus. In-place variant.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeIntegerT&amp; ModAddFastEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) {\n        auto&amp; mv{modulus.m_value};\n        m_value += b.m_value;\n        if (m_value &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /**\n   * Barrett modulus addition operation.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus addition operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModAdd(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                          typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        auto&amp; mv{modulus.m_value};\n#ifdef NATIVEINT_BARRET_MOD\n        auto av{*this};\n        auto bv{b};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        av.m_value += bv.m_value;\n        if (av.m_value &gt;= mv)\n            av.m_value -= mv;\n        return av;\n#else\n        auto bv{b.m_value};\n        auto av{m_value};\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &gt;= mv)\n            av = av % mv;\n        av = av + bv;\n        if (av &gt;= mv)\n            return {av - mv};\n        return {av};\n#endif\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModAdd(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                          typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        auto av{*this};\n        auto bv{b};\n        auto&amp; mv{modulus.m_value};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        av.m_value += bv.m_value;\n        if (av.m_value &gt;= mv)\n            av.m_value -= mv;\n        return av;\n    }\n\n    /**\n   * Barrett modulus addition operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to add.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus addition operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModAddEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                             typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        auto&amp; mv{modulus.m_value};\n#ifdef NATIVEINT_BARRET_MOD\n        auto av{*this};\n        auto bv{b};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        m_value = av.m_value + bv.m_value;\n        if (m_value &gt;= mv)\n            m_value -= mv;\n        return *this;\n#else\n        auto bv{b.m_value};\n        auto av{m_value};\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &gt;= mv)\n            av = av % mv;\n        av = av + bv;\n        if (av &gt;= mv)\n            return *this = av - mv;\n        return *this = av;\n#endif\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModAddEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                             typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        auto av{*this};\n        auto bv{b};\n        auto&amp; mv{modulus.m_value};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        m_value = av.m_value + bv.m_value;\n        if (m_value &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /**\n   * Modulus subtraction operation.\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    NativeIntegerT ModSub(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) const {\n        auto av{m_value};\n        auto bv{b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (av &gt;= mv)\n            av %= mv;\n        if (bv &gt;= mv)\n            bv %= mv;\n        if (av &lt; bv)\n            return {av + mv - bv};\n        return {av - bv};\n    }\n\n    /**\n   * Modulus subtraction operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    NativeIntegerT&amp; ModSubEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) {\n        auto av{m_value};\n        auto bv{b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (av &gt;= mv)\n            av = av % mv;\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &lt; bv)\n            return *this = av + mv - bv;\n        return *this = av - bv;\n    }\n\n    /**\n   * Modulus subtraction where operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    NativeIntegerT ModSubFast(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) const {\n        if (m_value &lt; b.m_value)\n            return {m_value + modulus.m_value - b.m_value};\n        return {m_value - b.m_value};\n    }\n\n    /**\n   * Modulus subtraction where operands are &lt; modulus. In-place variant.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus subtraction operation.\n   */\n    NativeIntegerT&amp; ModSubFastEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus) {\n        if (m_value &lt; b.m_value)\n            return *this = m_value + modulus.m_value - b.m_value;\n        return *this = m_value - b.m_value;\n    }\n\n    /**\n   * Barrett modulus subtraction operation.\n   *\n   * @param &amp;b is the scalar to subtract.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus subtraction operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModSub(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                          typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        auto&amp; mv{modulus.m_value};\n#ifdef NATIVEINT_BARRET_MOD\n        auto av{*this};\n        auto bv{b};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        if (av.m_value &lt; bv.m_value)\n            return {av.m_value + mv - bv.m_value};\n        return {av.m_value - bv.m_value};\n#else\n        auto av{m_value};\n        auto bv{b.m_value};\n        if (av &gt;= mv)\n            av = av % mv;\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &lt; bv)\n            return {av + mv - bv};\n        return {av - bv};\n#endif\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModSub(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                          typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        auto av{*this};\n        auto bv{b};\n        auto&amp; mv{modulus.m_value};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        if (av.m_value &lt; bv.m_value)\n            return {av.m_value + mv - bv.m_value};\n        return {av.m_value - bv.m_value};\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModSubEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                             typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        auto&amp; mv{modulus.m_value};\n#ifdef NATIVEINT_BARRET_MOD\n        auto av{*this};\n        auto bv{b};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        if (av.m_value &lt; bv.m_value)\n            return *this = av.m_value + mv - bv.m_value;\n        return *this = av.m_value - bv.m_value;\n#else\n        auto bv{b.m_value};\n        auto av{m_value};\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &gt;= mv)\n            av = av % mv;\n        if (av &lt; bv)\n            return *this = av + mv - bv;\n        return *this = av - bv;\n#endif\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModSubEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                             typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        auto av{*this};\n        auto bv{b};\n        auto&amp; mv{modulus.m_value};\n        if (av.m_value &gt;= mv)\n            av.ModEq(modulus, mu);\n        if (bv.m_value &gt;= mv)\n            bv.ModEq(modulus, mu);\n        if (av.m_value &lt; bv.m_value)\n            return *this = av.m_value + mv - bv.m_value;\n        return *this = av.m_value - bv.m_value;\n    }\n\n    /**\n   * Modulus multiplication operation.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMul(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                          typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        auto av{m_value};\n        auto bv{b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (av &gt;= mv)\n            av = av % mv;\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        DNativeInt rv{static_cast&lt;DNativeInt&gt;(av) * bv};\n        DNativeInt dmv{mv};\n        if (rv &gt;= dmv)\n            rv %= dmv;\n        return {rv};\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMul(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                          typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        typeD tmp;\n        auto av{*this};\n        auto&amp; mv{modulus.m_value};\n        auto mu{modulus.ComputeMu().m_value};\n        int64_t n{modulus.GetMSB() - 2};\n        if (av.m_value &gt;= mv)\n            ModMu(tmp, av, mv, mu, n);\n        auto bv{b};\n        if (bv.m_value &gt;= mv)\n            ModMu(tmp, bv, mv, mu, n);\n        MultD(av.m_value, bv.m_value, tmp);\n        typeD r{tmp};\n        MultD(RShiftD(tmp, n), mu, tmp);\n        MultD(RShiftD(tmp, n + 7), mv, tmp);\n        SubtractD(r, tmp);\n        if (r.lo &gt;= mv)\n            r.lo -= mv;\n        return {r.lo};\n    }\n\n    /**\n   * Modulus multiplication operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModMulEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                             typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        auto av{m_value};\n        auto bv{b.m_value};\n        auto&amp; mv{modulus.m_value};\n        if (av &gt;= mv)\n            av = av % mv;\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        DNativeInt rv{static_cast&lt;DNativeInt&gt;(av) * bv};\n        DNativeInt dmv{mv};\n        if (rv &gt;= dmv)\n            rv %= dmv;\n        return *this = static_cast&lt;NativeInt&gt;(rv);\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModMulEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                             typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        auto av{*this};\n        auto&amp; mv{modulus.m_value};\n        typeD tmp;\n        auto mu{modulus.ComputeMu().m_value};\n        int64_t n{modulus.GetMSB() - 2};\n        if (av.m_value &gt;= mv)\n            ModMu(tmp, av, mv, mu, n);\n        auto bv{b};\n        if (bv.m_value &gt;= mv)\n            ModMu(tmp, bv, mv, mu, n);\n        MultD(av.m_value, bv.m_value, tmp);\n        typeD r = tmp;\n        MultD(RShiftD(tmp, n), mu, tmp);\n        MultD(RShiftD(tmp, n + 7), mv, tmp);\n        SubtractD(r, tmp);\n        m_value = r.lo;\n        if (r.lo &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /**\n   * Barrett modulus multiplication.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMul(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                          typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n#ifdef NATIVEINT_BARRET_MOD\n        auto av{*this};\n        auto&amp; mv{modulus.m_value};\n        typeD tmp;\n        int64_t n{modulus.GetMSB() - 2};\n        if (av.m_value &gt;= mv)\n            ModMu(tmp, av, mv, mu.m_value, n);\n        auto bv{b};\n        if (bv.m_value &gt;= mv)\n            ModMu(tmp, bv, mv, mu.m_value, n);\n        MultD(av.m_value, bv.m_value, tmp);\n        auto rv = GetD(tmp);\n        MultD(RShiftD(tmp, n), mu.m_value, tmp);\n        rv -= DNativeInt(mv) * (GetD(tmp) &gt;&gt; n + 7);\n        NativeIntegerT r(rv);\n        if (r.m_value &gt;= mv)\n            r.m_value -= mv;\n        return r;\n#else\n        auto&amp; mv{modulus.m_value};\n        auto bv{b.m_value};\n        auto av{m_value};\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &gt;= mv)\n            av = av % mv;\n        DNativeInt rv{static_cast&lt;DNativeInt&gt;(av) * bv};\n        DNativeInt dmv{mv};\n        if (rv &gt;= dmv)\n            return {rv % dmv};\n        return {rv};\n#endif\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMul(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                          typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        auto av{*this};\n        auto&amp; mv{modulus.m_value};\n        typeD tmp;\n        int64_t n{modulus.GetMSB() - 2};\n        if (av.m_value &gt;= mv)\n            ModMu(tmp, av, mv, mu.m_value, n);\n        auto bv{b};\n        if (bv.m_value &gt;= mv)\n            ModMu(tmp, bv, mv, mu.m_value, n);\n        MultD(av.m_value, bv.m_value, tmp);\n        typeD r = tmp;\n        MultD(RShiftD(tmp, n), mu.m_value, tmp);\n        MultD(RShiftD(tmp, n + 7), mv, tmp);\n        SubtractD(r, tmp);\n        if (r.lo &gt;= mv)\n            r.lo -= mv;\n        return {r.lo};\n    }\n\n    /**\n   * Barrett modulus multiplication. In-place variant.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModMulEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                             typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n#ifdef NATIVEINT_BARRET_MOD\n        auto av{*this};\n        auto bv{b};\n        auto&amp; mv{modulus.m_value};\n        typeD tmp;\n        auto&amp; muv{mu.m_value};\n        int64_t n{modulus.GetMSB() - 2};\n        if (av.m_value &gt;= mv)\n            ModMu(tmp, av, mv, muv, n);\n        if (bv.m_value &gt;= mv)\n            ModMu(tmp, bv, mv, muv, n);\n        MultD(av.m_value, bv.m_value, tmp);\n        auto rv = GetD(tmp);\n        MultD(RShiftD(tmp, n), muv, tmp);\n        rv -= DNativeInt(mv) * (GetD(tmp) &gt;&gt; n + 7);\n        m_value = static_cast&lt;NativeInt&gt;(rv);\n        if (m_value &gt;= mv)\n            m_value -= mv;\n        return *this;\n#else\n        auto&amp; mv{modulus.m_value};\n        auto bv{b.m_value};\n        auto av{m_value};\n        if (bv &gt;= mv)\n            bv = bv % mv;\n        if (av &gt;= mv)\n            av = av % mv;\n        DNativeInt rv{static_cast&lt;DNativeInt&gt;(av) * bv};\n        DNativeInt dmv{mv};\n        if (rv &gt;= dmv)\n            return *this = static_cast&lt;NativeInt&gt;(rv % dmv);\n        return *this = static_cast&lt;NativeInt&gt;(rv);\n#endif\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModMulEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                             typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        int64_t n{modulus.GetMSB() - 2};\n        auto av{*this};\n        auto bv{b};\n        auto&amp; mv{modulus.m_value};\n        typeD tmp;\n        if (av.m_value &gt;= mv)\n            ModMu(tmp, av, mv, mu.m_value, n);\n        if (bv.m_value &gt;= mv)\n            ModMu(tmp, bv, mv, mu.m_value, n);\n        MultD(av.m_value, bv.m_value, tmp);\n        typeD r = tmp;\n        MultD(RShiftD(tmp, n), mu.m_value, tmp);\n        MultD(RShiftD(tmp, n + 7), mv, tmp);\n        SubtractD(r, tmp);\n        m_value = r.lo;\n        if (r.lo &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /**\n   * Modulus multiplication that assumes the operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMulFast(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                              typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        DNativeInt rv{static_cast&lt;DNativeInt&gt;(m_value) * b.m_value};\n        DNativeInt dmv{modulus.m_value};\n        if (rv &gt;= dmv)\n            rv %= dmv;\n        return {rv};\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMulFast(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                              typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        int64_t n = modulus.GetMSB() - 2;\n        auto&amp; mv{modulus.m_value};\n        typeD prod;\n        MultD(m_value, b.m_value, prod);\n        typeD r = prod;\n        MultD(RShiftD(prod, n), modulus.ComputeMu().m_value, prod);\n        MultD(RShiftD(prod, n + 7), mv, prod);\n        SubtractD(r, prod);\n        if (r.lo &gt;= mv)\n            r.lo -= mv;\n        return {r.lo};\n    }\n\n    /**\n   * Modulus multiplication that assumes the operands are &lt; modulus. In-place\n   * variant.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus multiplication operation.\n   */\n    // TODO: find what in Matrix&lt;DCRTPoly&gt; is calling ModMulFastEq incorrectly\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMulFastEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                                typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        DNativeInt rv{static_cast&lt;DNativeInt&gt;(m_value) * b.m_value};\n        DNativeInt dmv{modulus.m_value};\n        if (rv &gt;= dmv)\n            rv %= dmv;\n        return *this = static_cast&lt;NativeInt&gt;(rv);\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMulFastEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                                typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        int64_t n = modulus.GetMSB() - 2;\n        auto&amp; mv{modulus.m_value};\n        typeD prod;\n        MultD(m_value, b.m_value, prod);\n        typeD r = prod;\n        MultD(RShiftD(prod, n), modulus.ComputeMu().m_value, prod);\n        MultD(RShiftD(prod, n + 7), mv, prod);\n        SubtractD(r, prod);\n        m_value = r.lo;\n        if (r.lo &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /**\n   * Barrett modulus multiplication that assumes the operands are &lt; modulus.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus multiplication operation.\n   */\n    /* Source: http://homes.esat.kuleuven.be/~fvercaut/papers/bar_mont.pdf\n    @article{knezevicspeeding,\n    title={Speeding Up Barrett and Montgomery Modular Multiplications},\n    author={Knezevic, Miroslav and Vercauteren, Frederik and Verbauwhede,\n    Ingrid}\n    }\n    We use the Generalized Barrett modular reduction algorithm described in\n    Algorithm 2 of the Source. The algorithm was originally proposed in J.-F.\n    Dhem. Modified version of the Barrett algorithm. Technical report, 1994\n    and described in more detail in the PhD thesis of the author published at\n    http://users.belgacom.net/dhem/these/these_public.pdf (Section 2.2.4).\n    We take \\alpha equal to n + 3. So in our case, \\mu = 2^(n + \\alpha) =\n    2^(2*n + 3). Generally speaking, the value of \\alpha should be \\ge \\gamma\n    + 1, where \\gamma + n is the number of digits in the dividend. We use the\n    upper bound of dividend assuming that none of the dividends will be larger\n    than 2^(2*n + 3). The value of \\mu is computed by NativeVector::ComputeMu.\n    */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMulFast(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                              typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        int64_t n = modulus.GetMSB() - 2;\n        auto&amp; mv{modulus.m_value};\n        typeD tmp;\n        MultD(m_value, b.m_value, tmp);\n        auto rv = GetD(tmp);\n        MultD(RShiftD(tmp, n), mu.m_value, tmp);\n        rv -= DNativeInt(mv) * (GetD(tmp) &gt;&gt; n + 7);\n        NativeIntegerT r(rv);\n        if (r.m_value &gt;= mv)\n            r.m_value -= mv;\n        return r;\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModMulFast(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                              typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) const {\n        int64_t n = modulus.GetMSB() - 2;\n        auto&amp; mv{modulus.m_value};\n        typeD prod;\n        MultD(m_value, b.m_value, prod);\n        typeD r = prod;\n        MultD(RShiftD(prod, n), mu.m_value, prod);\n        MultD(RShiftD(prod, n + 7), mv, prod);\n        SubtractD(r, prod);\n        if (r.lo &gt;= mv)\n            r.lo -= mv;\n        return {r.lo};\n    }\n\n    /**\n   * Barrett modulus multiplication that assumes the operands are &lt; modulus.\n   * In-place variant.\n   *\n   * @param &amp;b is the scalar to multiply.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @param &amp;mu is the Barrett value.\n   * @return is the result of the modulus multiplication operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModMulFastEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                                 typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        typeD tmp;\n        MultD(m_value, b.m_value, tmp);\n        auto rv{GetD(tmp)};\n        int64_t n{modulus.GetMSB() - 2};\n        MultD(RShiftD(tmp, n), mu.m_value, tmp);\n        auto&amp; mv{modulus.m_value};\n        rv -= DNativeInt(mv) * (GetD(tmp) &gt;&gt; n + 7);\n        m_value = NativeInt(rv);\n        if (m_value &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT&amp; ModMulFastEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus, const NativeIntegerT&amp; mu,\n                                 typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        int64_t n{modulus.GetMSB() - 2};\n        typeD prod;\n        MultD(m_value, b.m_value, prod);\n        typeD r{prod};\n        auto&amp; mv{modulus.m_value};\n        MultD(RShiftD(prod, n), mu.m_value, prod);\n        MultD(RShiftD(prod, n + 7), mv, prod);\n        SubtractD(r, prod);\n        m_value = r.lo;\n        if (r.lo &gt;= mv)\n            m_value -= mv;\n        return *this;\n    }\n\n    /*  The next three subroutines implement the modular multiplication\n    algorithm for the case when the multiplicand is used multiple times (known\n    in advance), as in NTT. The algorithm is described in\n    https://arxiv.org/pdf/1205.2926.pdf (Dave Harvey, FASTER ARITHMETIC FOR\n    NUMBER-THEORETIC TRANSFORMS). The algorithm is described in lines 5-7 of\n    Algorithm 2. The algorithm was originally proposed and implemented in NTL\n    (https://www.shoup.net/ntl/) by Victor Shoup.\n    */\n\n    /**\n   * Precomputation for a multiplicand.\n   *\n   * @param modulus is the modulus to perform operations with.\n   * @return the precomputed factor.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT PrepModMulConst(\n        const NativeIntegerT&amp; modulus,\n        typename std::enable_if&lt;!std::is_same&lt;T, DNativeInt&gt;::value, bool&gt;::type = true) const {\n        if (modulus.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Divide by zero&quot;);\n        auto&amp;&amp; w{DNativeInt(m_value) &lt;&lt; NativeIntegerT::MaxBits()};\n        return {w / DNativeInt(modulus.m_value)};\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT PrepModMulConst(\n        const NativeIntegerT&amp; modulus,\n        typename std::enable_if&lt;std::is_same&lt;T, DNativeInt&gt;::value, bool&gt;::type = true) const {\n        if (modulus.m_value == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Divide by zero&quot;);\n        auto&amp;&amp; w{bigintbackend::BigInteger(m_value) &lt;&lt; NativeIntegerT::MaxBits()};\n        return {(w / bigintbackend::BigInteger(modulus.m_value)).template ConvertToInt&lt;NativeInt&gt;()};\n    }\n\n    /**\n   * Modular multiplication using a precomputation for the multiplicand.\n   *\n   * @param &amp;b is the NativeIntegerT to multiply.\n   * @param modulus is the modulus to perform operations with.\n   * @param &amp;bInv precomputation for b.\n   * @return is the result of the modulus multiplication operation.\n   */\n    NativeIntegerT ModMulFastConst(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                                   const NativeIntegerT&amp; bInv) const {\n        NativeInt q = MultDHi(m_value, bInv.m_value) + 1;\n        auto yprime = static_cast&lt;SignedNativeInt&gt;(m_value * b.m_value - q * modulus.m_value);\n        return {yprime &gt;= 0 ? yprime : yprime + modulus.m_value};\n    }\n\n    /**\n   * Modular multiplication using a precomputation for the multiplicand.\n   * In-place variant.\n   *\n   * @param &amp;b is the NativeIntegerT to multiply.\n   * @param modulus is the modulus to perform operations with.\n   * @param &amp;bInv precomputation for b.\n   * @return is the result of the modulus multiplication operation.\n   */\n    NativeIntegerT&amp; ModMulFastConstEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; modulus,\n                                      const NativeIntegerT&amp; bInv) {\n        NativeInt q = MultDHi(m_value, bInv.m_value) + 1;\n        auto yprime = static_cast&lt;SignedNativeInt&gt;(m_value * b.m_value - q * modulus.m_value);\n        m_value     = static_cast&lt;NativeInt&gt;(yprime &gt;= 0 ? yprime : yprime + modulus.m_value);\n        return *this;\n    }\n\n    /**\n   * Modulus exponentiation operation.\n   *\n   * @param &amp;b is the scalar to exponentiate at all locations.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus exponentiation operation.\n   */\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModExp(const NativeIntegerT&amp; b, const NativeIntegerT&amp; mod,\n                          typename std::enable_if&lt;!std::is_same&lt;T, DNativeInt&gt;::value, bool&gt;::type = true) const {\n        DNativeInt t{m_value};\n        DNativeInt p{b.m_value};\n        DNativeInt m{mod.m_value};\n        DNativeInt r{1};\n        if (p &amp; 0x1) {\n            r = r * t;\n            if (r &gt;= m)\n                r = r % m;\n        }\n        while (p &gt;&gt;= 1) {\n            t = t * t;\n            if (t &gt;= m)\n                t = t % m;\n            if (p &amp; 0x1) {\n                r = r * t;\n                if (r &gt;= m)\n                    r = r % m;\n            }\n        }\n        return {r};\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    NativeIntegerT ModExp(const NativeIntegerT&amp; b, const NativeIntegerT&amp; mod,\n                          typename std::enable_if&lt;std::is_same&lt;T, DNativeInt&gt;::value, bool&gt;::type = true) const {\n        NativeIntegerT t{m_value % mod.m_value};\n        NativeIntegerT p{b.m_value};\n        NativeIntegerT mu{mod.ComputeMu()};\n        NativeIntegerT r{1};\n        if (p.m_value &amp; 0x1)\n            r.ModMulFastEq(t, mod, mu);\n        while (p.m_value &gt;&gt;= 1) {\n            t.ModMulFastEq(t, mod, mu);\n            if (p.m_value &amp; 0x1)\n                r.ModMulFastEq(t, mod, mu);\n        }\n        return {r};\n    }\n\n    /**\n   * Modulus exponentiation operation. In-place variant.\n   *\n   * @param &amp;b is the scalar to exponentiate at all locations.\n   * @param &amp;modulus is the modulus to perform operations with.\n   * @return is the result of the modulus exponentiation operation.\n   */\n    NativeIntegerT&amp; ModExpEq(const NativeIntegerT&amp; b, const NativeIntegerT&amp; mod) {\n        return *this = this-&gt;NativeIntegerT::ModExp(b, mod);\n    }\n\n    /**\n   * Modulus inverse operation.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @return is the result of the modulus inverse operation.\n   */\n    NativeIntegerT ModInverse(const NativeIntegerT&amp; mod) const {\n        SignedNativeInt modulus(mod.m_value);\n        SignedNativeInt a(m_value % mod.m_value);\n        if (a == 0) {\n            std::string msg = NativeIntegerT::toString(m_value) + &quot; does not have a ModInverse using &quot; +\n                              NativeIntegerT::toString(mod.m_value);\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, msg);\n        }\n        if (modulus == 1)\n            return NativeIntegerT();\n\n        SignedNativeInt y{0};\n        SignedNativeInt x{1};\n        while (a &gt; 1) {\n            auto t  = modulus;\n            auto q  = a / t;\n            modulus = a % t;\n            a       = t;\n            t       = y;\n            y       = x - q * y;\n            x       = t;\n        }\n        if (x &lt; 0)\n            x += mod.m_value;\n        return {x};\n    }\n\n    /**\n   * Modulus inverse operation. In-place variant.\n   *\n   * @param &amp;modulus is the modulus to perform.\n   * @return is the result of the modulus inverse operation.\n   */\n    NativeIntegerT&amp; ModInverseEq(const NativeIntegerT&amp; mod) {\n        return *this = this-&gt;NativeIntegerT::ModInverse(mod);\n    }\n\n    /**\n   * Left shift operation.\n   *\n   * @param shift # of bits.\n   * @return result of the shift operation.\n   */\n    NativeIntegerT LShift(usshort shift) const {\n        return {m_value &lt;&lt; shift};\n    }\n\n    /**\n   * Left shift operation. In-place variant.\n   *\n   * @param shift # of bits.\n   * @return result of the shift operation.\n   */\n    NativeIntegerT&amp; LShiftEq(usshort shift) {\n        return *this = m_value &lt;&lt; shift;\n    }\n\n    /**\n   * Right shift operation.\n   *\n   * @param shift # of bits.\n   * @return result of the shift operation.\n   */\n    NativeIntegerT RShift(usshort shift) const {\n        return {m_value &gt;&gt; shift};\n    }\n\n    /**\n   * Right shift operation. In-place variant.\n   *\n   * @param shift # of bits.\n   * @return result of the shift operation.\n   */\n    NativeIntegerT&amp; RShiftEq(usshort shift) {\n        return *this = m_value &gt;&gt; shift;\n    }\n\n    /**\n   * Compares the current NativeIntegerT to NativeIntegerT a.\n   *\n   * @param a is the NativeIntegerT to be compared with.\n   * @return  -1 for strictly less than, 0 for equal to and 1 for strictly\n   * greater than conditons.\n   */\n    int Compare(const NativeIntegerT&amp; a) const {\n        return (m_value &lt; a.m_value) ? -1 : (m_value &gt; a.m_value) ? 1 : 0;\n    }\n\n    /**\n   * Converts the value to an int.\n   *\n   * @return the int representation of the value as usint.\n   */\n    template &lt;typename T = NativeInt, std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, bool&gt; = true&gt;\n    constexpr T ConvertToInt() const noexcept {\n        // static_assert(sizeof(T) &gt;= sizeof(m_value), &quot;ConvertToInt(): Narrowing Conversion&quot;);\n        return static_cast&lt;T&gt;(m_value);\n    }\n\n    /**\n   * Converts the value to an double.\n   *\n   * @return double representation of the value.\n   */\n    constexpr double ConvertToDouble() const noexcept {\n        return static_cast&lt;double&gt;(m_value);\n    }\n\n    /**\n   * Convert a string representation of a binary number to a NativeIntegerT.\n   *\n   * @param bitString the binary num in string.\n   * @return the binary number represented as a big binary int.\n   */\n    static NativeIntegerT FromBinaryString(const std::string&amp; bitString) {\n        if (bitString.length() &gt; NativeIntegerT::MaxBits())\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Bit string is too long to fit in an intnat&quot;);\n        NativeInt v{0};\n        for (size_t i = 0; i &lt; bitString.length(); ++i) {\n            auto n = bitString[i] - &#x27;0&#x27;;\n            if (n &lt; 0 || n &gt; 1)\n                &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Bit string must contain only 0 or 1&quot;);\n            v = (v &lt;&lt; 1) | static_cast&lt;NativeInt&gt;(n);\n        }\n        return {v};\n    }\n\n    /**\n   * Returns the MSB location of the value.\n   *\n   * @return the index of the most significant bit.\n   */\n    usint GetMSB() const {\n        return lbcrypto::GetMSB(m_value);\n    }\n\n    /**\n   * Get the number of digits using a specific base - support for arbitrary\n   * base may be needed.\n   *\n   * @param base is the base with which to determine length in.\n   * @return the length of the representation in a specific base.\n   */\n\n    // TODO: only base 2?\n    usint GetLengthForBase(usint base) const {\n        return NativeIntegerT::GetMSB();\n    }\n\n    /**\n   * Get a specific digit at &quot;digit&quot; index; big integer is seen as an array of\n   * digits, where a 0 &lt;= digit &lt; base Warning: only power-of-2 bases are\n   * currently supported. Example: for number 83, index 2 and base 4 we have:\n   *\n   *                         index:0,1,2,3\n   * 83 --base 4 decomposition--&gt; (3,0,1,1) --at index 2--&gt; 1\n   *\n   * The return number is 1.\n   *\n   * @param index is the &quot;digit&quot; index of the requested digit\n   * @param base is the base with which to determine length in.\n   * @return is the requested digit\n   */\n\n    // TODO: * i to &lt;&lt; i\n    usint GetDigitAtIndexForBase(usint index, usint base) const {\n        usint DigitLen = ceil(log2(base));\n        usint digit    = 0;\n        usint newIndex = 1 + (index - 1) * DigitLen;\n        for (usint i = 1; i &lt; base; i &lt;&lt;= 1) {\n            digit += GetBitAtIndex(newIndex++) * i;\n        }\n        return digit;\n    }\n\n    /**\n   * Gets the bit at the specified index.\n   *\n   * @param index is the index of the bit to get.\n   * @return resulting bit.\n   */\n    uschar GetBitAtIndex(usint index) const {\n        if (index == 0)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;Zero index in GetBitAtIndex&quot;);\n        return static_cast&lt;uschar&gt;((m_value &gt;&gt; (index - 1)) &amp; 0x1);\n    }\n\n    /**\n   * A zero allocator that is called by the Matrix class.\n   * It is used to initialize a Matrix of NativeIntegerT objects.\n   */\n    static constexpr NativeIntegerT Allocator() noexcept {\n        return NativeIntegerT();\n    }\n\n    // STRINGS &amp; STREAMS\n\n    /**\n   * Stores the based 10 equivalent/Decimal value of the NativeIntegerT in a\n   * string object and returns it.\n   *\n   * @return value of this NativeIntegerT in base 10 represented as a string.\n   */\n    std::string ToString() const {\n        return toString(m_value);\n    }\n\n    static const std::string IntegerTypeName() {\n        return &quot;UBNATINT&quot;;\n    }\n\n    /**\n   * Console output operation.\n   *\n   * @param os is the std ostream object.\n   * @param ptr_obj is NativeIntegerT to be printed.\n   * @return is the ostream object.\n   */\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const NativeIntegerT&amp; ptr_obj) {\n        os &lt;&lt; ptr_obj.ToString();\n        return os;\n    }\n\n    template &lt;class Archive, typename T = void&gt;\n    typename std::enable_if_t&lt;std::is_same_v&lt;NativeInt, U64BITS&gt; || std::is_same_v&lt;NativeInt, U32BITS&gt;, T&gt; load(\n        Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                           &quot; is from a later version of the library&quot;);\n        }\n        ar(::cereal::make_nvp(&quot;v&quot;, m_value));\n    }\n\n#if defined(HAVE_INT128)\n    template &lt;class Archive&gt;\n    typename std::enable_if_t&lt;std::is_same_v&lt;NativeInt, U128BITS&gt; &amp;&amp; !cereal::traits::is_text_archive&lt;Archive&gt;::value,\n                              void&gt;\n    load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                           &quot; is from a later version of the library&quot;);\n        }\n        // get an array with 2 unint64_t values for m_value\n        uint64_t vec[2];\n        ar(::cereal::binary_data(vec, sizeof(vec)));  // 2*8 - size in bytes\n        m_value = vec[1];                             // most significant word\n        m_value &lt;&lt;= 64;\n        m_value += vec[0];  // least significant word\n    }\n\n    template &lt;class Archive&gt;\n    typename std::enable_if_t&lt;std::is_same_v&lt;NativeInt, U128BITS&gt; &amp;&amp; cereal::traits::is_text_archive&lt;Archive&gt;::value,\n                              void&gt;\n    load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                           &quot; is from a later version of the library&quot;);\n        }\n        // get an array with 2 unint64_t values for m_value\n        uint64_t vec[2];\n        ar(::cereal::make_nvp(&quot;i&quot;, vec));\n        m_value = vec[1];  // most significant word\n        m_value &lt;&lt;= 64;\n        m_value += vec[0];  // least significant word\n    }\n#endif\n\n    template &lt;class Archive, typename T = void&gt;\n    typename std::enable_if_t&lt;std::is_same_v&lt;NativeInt, U64BITS&gt; || std::is_same&lt;NativeInt, U32BITS&gt;::value, T&gt; save(\n        Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::make_nvp(&quot;v&quot;, m_value));\n    }\n\n#if defined(HAVE_INT128)\n    template &lt;class Archive&gt;\n    typename std::enable_if_t&lt;std::is_same_v&lt;NativeInt, U128BITS&gt; &amp;&amp; !cereal::traits::is_text_archive&lt;Archive&gt;::value,\n                              void&gt;\n    save(Archive&amp; ar, std::uint32_t const version) const {\n        // save 2 unint64_t values instead of uint128_t\n        constexpr U128BITS mask = (static_cast&lt;U128BITS&gt;(1) &lt;&lt; 64) - 1;\n        uint64_t vec[2];\n        vec[0] = m_value &amp; mask;  // least significant word\n        vec[1] = m_value &gt;&gt; 64;   // most significant word\n        ar(::cereal::binary_data(vec, sizeof(vec)));\n    }\n\n    template &lt;class Archive&gt;\n    typename std::enable_if_t&lt;std::is_same_v&lt;NativeInt, U128BITS&gt; &amp;&amp; cereal::traits::is_text_archive&lt;Archive&gt;::value,\n                              void&gt;\n    save(Archive&amp; ar, std::uint32_t const version) const {\n        // save 2 unint64_t values instead of uint128_t\n        constexpr U128BITS mask = (static_cast&lt;U128BITS&gt;(1) &lt;&lt; 64) - 1;\n        uint64_t vec[2];\n        vec[0] = m_value &amp; mask;  // least significant word\n        vec[1] = m_value &gt;&gt; 64;   // most significant word\n        ar(::cereal::make_nvp(&quot;i&quot;, vec));\n    }\n#endif\n\n    std::string SerializedObjectName() const {\n        return &quot;NATInteger&quot;;\n    }\n\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\n    static constexpr usint MaxBits() noexcept {\n        return m_uintBitLength;\n    }\n\n    static constexpr bool IsNativeInt() noexcept {\n        return true;\n    }\n\nprivate:\n    // Computes res -= a;\n    static void SubtractD(typeD&amp; res, const typeD&amp; a) {\n        if (res.lo &lt; a.lo) {\n            res.lo += m_uintMax + 1 - a.lo;\n            res.hi--;\n        }\n        else {\n            res.lo -= a.lo;\n        }\n        res.hi -= a.hi;\n    }\n\n    /**\n   * Right shifts a typeD integer by a specific number of bits\n   * and stores the result as a single-word integer.\n   *\n   * @param &amp;x double-word input\n   * @param shift the number of bits to shift by\n   * @return the result of right-shifting\n   */\n    static NativeInt RShiftD(const typeD&amp; x, int64_t shift) {\n        return (x.lo &gt;&gt; shift) | (x.hi &lt;&lt; (NativeIntegerT::MaxBits() - shift));\n    }\n\n    /**\n   * Multiplies two single-word integers and stores the result in a\n   * typeD data structure.\n   *\n   * @param a multiplier\n   * @param b multiplicand\n   * @param &amp;x result of multiplication\n   */\n    static void MultD(U32BITS a, U32BITS b, typeD&amp; res) {\n        U64BITS c{static_cast&lt;U64BITS&gt;(a) * b};\n        res.hi = static_cast&lt;U32BITS&gt;(c &gt;&gt; 32);\n        res.lo = static_cast&lt;U32BITS&gt;(c);\n    }\n\n    static void MultD(U64BITS a, U64BITS b, typeD&amp; res) {\n#if defined(__x86_64__)\n    #if defined(HAVE_INT128)\n        U128BITS c{static_cast&lt;U128BITS&gt;(a) * b};\n        res.hi = static_cast&lt;U64BITS&gt;(c &gt;&gt; 64);\n        res.lo = static_cast&lt;U64BITS&gt;(c);\n    #else\n        // clang-format off\n    __asm__(&quot;mulq %[b]&quot;\n            : [ lo ] &quot;=a&quot;(res.lo), [ hi ] &quot;=d&quot;(res.hi)\n            : [ a ] &quot;%[lo]&quot;(a), [ b ] &quot;rm&quot;(b)\n            : &quot;cc&quot;);\n                // clang-format on\n    #endif\n#elif defined(__aarch64__)\n        typeD x;\n        x.hi = 0;\n        x.lo = a;\n        U64BITS y(b);\n        res.lo = x.lo * y;\n        asm(&quot;umulh %0, %1, %2\\n\\t&quot; : &quot;=r&quot;(res.hi) : &quot;r&quot;(x.lo), &quot;r&quot;(y));\n        res.hi += x.hi * y;\n#elif defined(__arm__)  // 32 bit processor\n        uint64_t wres(0), wa(a), wb(b);\n        wres   = wa * wb;\n        res.hi = wres &gt;&gt; 32;\n        res.lo = (uint32_t)wres &amp; 0xFFFFFFFF;\n#elif __riscv\n        U128BITS wres(0), wa(a), wb(b);\n        wres   = wa * wb;\n        res.hi = (uint64_t)(wres &gt;&gt; 64);\n        res.lo = (uint64_t)wres;\n#elif defined(__EMSCRIPTEN__)  // web assembly\n        U64BITS a1 = a &gt;&gt; 32;\n        U64BITS a2 = (uint32_t)a;\n        U64BITS b1 = b &gt;&gt; 32;\n        U64BITS b2 = (uint32_t)b;\n\n        // use schoolbook multiplication\n        res.hi            = a1 * b1;\n        res.lo            = a2 * b2;\n        U64BITS lowBefore = res.lo;\n\n        U64BITS p1   = a2 * b1;\n        U64BITS p2   = a1 * b2;\n        U64BITS temp = p1 + p2;\n        res.hi += temp &gt;&gt; 32;\n        res.lo += U64BITS((uint32_t)temp) &lt;&lt; 32;\n\n        // adds the carry to the high word\n        if (lowBefore &gt; res.lo)\n            res.hi++;\n\n        // if there is an overflow in temp, add 2^32\n        if ((temp &lt; p1) || (temp &lt; p2))\n            res.hi += (U64BITS)1 &lt;&lt; 32;\n#else\n    #error Architecture not supported for MultD()\n#endif\n    }\n\n#if defined(HAVE_INT128)\n    static void MultD(U128BITS a, U128BITS b, typeD&amp; res) {\n        static constexpr U128BITS masklo = (static_cast&lt;U128BITS&gt;(1) &lt;&lt; 64) - 1;\n        static constexpr U128BITS onehi  = static_cast&lt;U128BITS&gt;(1) &lt;&lt; 64;\n\n        U128BITS a1{a &gt;&gt; 64};\n        U128BITS a2{a &amp; masklo};\n        U128BITS b1{b &gt;&gt; 64};\n        U128BITS b2{b &amp; masklo};\n        U128BITS a1b2{a1 * b2};\n        U128BITS a2b1{a2 * b1};\n        U128BITS tmp{a1b2 + a2b1};\n        U128BITS lo{a2 * b2};\n\n        res = {a1 * b1, lo};\n        res.lo += tmp &lt;&lt; 64;\n        if (lo &gt; res.lo)\n            ++res.hi;\n        if ((tmp &lt; a1b2) || (tmp &lt; a2b1))\n            res.hi += onehi;\n        res.hi += tmp &gt;&gt; 64;\n    }\n#endif\n\n    /**\n   * Multiplies two single-word integers and stores the high word of the\n   * result\n   *\n   * @param a multiplier\n   * @param b multiplicand\n   * @return the high word of the result\n   */\n    static NativeInt MultDHi(NativeInt a, NativeInt b) {\n        typeD x;\n        MultD(a, b, x);\n        return x.hi;\n    }\n\n    /**\n   * Converts a double-word integer from typeD representation\n   * to DNativeInt.\n   *\n   * @param &amp;x double-word input\n   * @return the result as DNativeInt\n   */\n    static DNativeInt GetD(const typeD&amp; x) {\n        return (DNativeInt(x.hi) &lt;&lt; NativeIntegerT::MaxBits()) | x.lo;\n    }\n\n    static std::string toString(uint32_t value) noexcept {\n        return std::to_string(value);\n    }\n\n    static std::string toString(uint64_t value) noexcept {\n        return std::to_string(value);\n    }\n\n#if defined(HAVE_INT128)\n    // TODO\n    static std::string toString(uint128_t value) noexcept {\n        constexpr size_t maxChars = 15;\n        constexpr uint128_t divisor{0x38d7ea4c68000};  // 10**15\n        std::string tmp(46, &#x27;0&#x27;);\n        auto msd_it = tmp.end() - 1;\n        auto it     = tmp.end();\n        for (auto i = 3; i != 0; --i, it -= maxChars) {\n            auto part = static_cast&lt;uint64_t&gt;(value % divisor);\n            value /= divisor;\n            if (part) {\n                auto s{std::to_string(part)};\n                msd_it = it - s.size();\n                tmp.replace(it - s.size(), it, s.begin(), s.end());\n            }\n        }\n        return std::string(msd_it, tmp.end());\n    }\n#endif\n\n    template &lt;typename T = NativeInt&gt;\n    static void ModMu(typeD&amp; prod, NativeIntegerT&amp; a, const T&amp; mv, const T&amp; mu, int64_t n,\n                      typename std::enable_if_t&lt;!std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        prod = {0, a.m_value};\n        MultD(RShiftD(prod, n), mu, prod);\n        a.m_value -= static_cast&lt;NativeInt&gt;((GetD(prod) &gt;&gt; n + 7) * mv);\n        if (a.m_value &gt;= mv)\n            a.m_value -= mv;\n    }\n\n    template &lt;typename T = NativeInt&gt;\n    static void ModMu(typeD&amp; prod, NativeIntegerT&amp; a, const T&amp; mv, const T&amp; mu, int64_t n,\n                      typename std::enable_if_t&lt;std::is_same_v&lt;T, DNativeInt&gt;, bool&gt; = true) {\n        prod = {0, a.m_value};\n        MultD(RShiftD(prod, n), mu, prod);\n        MultD(RShiftD(prod, n + 7), mv, prod);\n        a.m_value -= prod.lo;\n        if (a.m_value &gt;= mv)\n            a.m_value -= mv;\n    }\n};\n\n// helper template to stream vector contents provided T has an stream operator&lt;&lt;\ntemplate &lt;typename T&gt;\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;T&gt;&amp; v) {\n    os &lt;&lt; &quot;[&quot;;\n    //    for (const auto&amp; i : v)\n    for (auto&amp;&amp; i : v)\n        os &lt;&lt; &quot; &quot; &lt;&lt; i;\n    os &lt;&lt; &quot; ]&quot;;\n    return os;\n}\n// to stream internal representation\ntemplate std::ostream&amp; operator&lt;&lt; &lt;uint64_t&gt;(std::ostream&amp; os, const std::vector&lt;uint64_t&gt;&amp; v);\n\n}  // namespace intnat\n\n#endif  // LBCRYPTO_MATH_HAL_INTNAT_UBINTNAT_H\n"}, "/home/zero0000/static-analyze-openfhe/src/binfhe/include/rgsw-cryptoparameters.h": {"id": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/rgsw-cryptoparameters.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/rgsw-cryptoparameters.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef _RGSW_CRYPTOPARAMETERS_H_\n#define _RGSW_CRYPTOPARAMETERS_H_\n\n#include &quot;lattice/lat-hal.h&quot;\n#include &quot;math/discretegaussiangenerator.h&quot;\n#include &quot;math/nbtheory.h&quot;\n#include &quot;utils/serializable.h&quot;\n#include &quot;utils/utilities.h&quot;\n\n#include &quot;binfhe-constants.h&quot;\n\n#include &quot;lwe-ciphertext.h&quot;\n#include &quot;lwe-keyswitchkey.h&quot;\n#include &quot;lwe-cryptoparameters.h&quot;\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n\nnamespace lbcrypto {\n\n/**\n * @brief Class that stores all parameters for the RingGSW scheme used in\n * bootstrapping\n */\nclass RingGSWCryptoParams : public Serializable {\npublic:\n    RingGSWCryptoParams() = default;\n\n    /**\n   * Main constructor for RingGSWCryptoParams\n   *\n   * @param N ring dimension for RingGSW/RLWE used in bootstrapping\n   * @param Q modulus for RingGSW/RLWE used in bootstrapping\n   * @param q ciphertext modulus for additive LWE\n   * @param baseG the gadget base used in the bootstrapping\n   * @param baseR the base for the refreshing key\n   * @param method bootstrapping method (DM or CGGI or LMKCDEY)\n   * @param std standar deviation\n   * @param keyDist secret key distribution\n   * @param signEval flag if sign evaluation is needed\n   * @param numAutoKeys number of automorphism keys in LMKCDEY bootstrapping\n   */\n    explicit RingGSWCryptoParams(uint32_t N, NativeInteger Q, NativeInteger q, uint32_t baseG, uint32_t baseR,\n                                 BINFHE_METHOD method, double std, SecretKeyDist keyDist = UNIFORM_TERNARY,\n                                 bool signEval = false, uint32_t numAutoKeys = 10)\n        : m_Q(Q),\n          m_q(q),\n          m_N(N),\n          m_baseG(baseG),\n          m_baseR(baseR),\n          m_polyParams{std::make_shared&lt;ILNativeParams&gt;(2 * N, Q)},\n          m_method(method),\n          m_keyDist(keyDist),\n          m_numAutoKeys(numAutoKeys) {\n        if (!IsPowerOfTwo(baseG))\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Gadget base should be a power of two.&quot;);\n        if ((method == LMKCDEY) &amp; (numAutoKeys == 0))\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;numAutoKeys should be greater than 0.&quot;);\n        auto logQ{log(m_Q.ConvertToDouble())};\n        m_digitsG = static_cast&lt;uint32_t&gt;(std::ceil(logQ / log(static_cast&lt;double&gt;(m_baseG))));\n        m_dgg.SetStd(std);\n        PreCompute(signEval);\n    }\n\n    /**\n   * Performs precomputations based on the supplied parameters\n   */\n    void PreCompute(bool signEval = false);\n\n    uint32_t GetN() const {\n        return m_N;\n    }\n\n    const NativeInteger&amp; GetQ() const {\n        return m_Q;\n    }\n\n    const NativeInteger&amp; Getq() const {\n        return m_q;\n    }\n\n    uint32_t GetBaseG() const {\n        return m_baseG;\n    }\n\n    uint32_t GetDigitsG() const {\n        return m_digitsG;\n    }\n\n    uint32_t GetBaseR() const {\n        return m_baseR;\n    }\n\n    uint32_t GetNumAutoKeys() const {\n        return m_numAutoKeys;\n    }\n\n    const std::vector&lt;NativeInteger&gt;&amp; GetDigitsR() const {\n        return m_digitsR;\n    }\n\n    const std::shared_ptr&lt;ILNativeParams&gt; GetPolyParams() const {\n        return m_polyParams;\n    }\n\n    const std::vector&lt;NativeInteger&gt;&amp; GetGPower() const {\n        return m_Gpower;\n    }\n\n    const std::vector&lt;int32_t&gt;&amp; GetLogGen() const {\n        return m_logGen;\n    }\n\n    const std::map&lt;uint32_t, std::vector&lt;NativeInteger&gt;&gt;&amp; GetGPowerMap() const {\n        return m_Gpower_map;\n    }\n\n    const DiscreteGaussianGeneratorImpl&lt;NativeVector&gt;&amp; GetDgg() const {\n        return m_dgg;\n    }\n\n    const std::vector&lt;NativeInteger&gt;&amp; GetGateConst() const {\n        return m_gateConst;\n    }\n\n    const NativePoly&amp; GetMonomial(uint32_t i) const {\n        return m_monomials[i];\n    }\n\n    BINFHE_METHOD GetMethod() const {\n        return m_method;\n    }\n\n    SecretKeyDist GetKeyDist() const {\n        return m_keyDist;\n    }\n\n    bool operator==(const RingGSWCryptoParams&amp; other) const {\n        return m_N == other.m_N &amp;&amp; m_Q == other.m_Q &amp;&amp; m_baseR == other.m_baseR &amp;&amp; m_baseG == other.m_baseG;\n    }\n\n    bool operator!=(const RingGSWCryptoParams&amp; other) const {\n        return !(*this == other);\n    }\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::make_nvp(&quot;bN&quot;, m_N));\n        ar(::cereal::make_nvp(&quot;bQ&quot;, m_Q));\n        ar(::cereal::make_nvp(&quot;bq&quot;, m_q));\n        ar(::cereal::make_nvp(&quot;bR&quot;, m_baseR));\n        ar(::cereal::make_nvp(&quot;bG&quot;, m_baseG));\n        ar(::cereal::make_nvp(&quot;bmethod&quot;, m_method));\n        ar(::cereal::make_nvp(&quot;bs&quot;, m_dgg.GetStd()));\n        ar(::cereal::make_nvp(&quot;bdigitsG&quot;, m_digitsG));\n        ar(::cereal::make_nvp(&quot;bparams&quot;, m_polyParams));\n        ar(::cereal::make_nvp(&quot;numAutoKeys&quot;, m_numAutoKeys));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                 &quot; is from a later version of the library&quot;);\n        }\n        ar(::cereal::make_nvp(&quot;bN&quot;, m_N));\n        ar(::cereal::make_nvp(&quot;bQ&quot;, m_Q));\n        ar(::cereal::make_nvp(&quot;bq&quot;, m_q));\n        ar(::cereal::make_nvp(&quot;bR&quot;, m_baseR));\n        ar(::cereal::make_nvp(&quot;bG&quot;, m_baseG));\n        ar(::cereal::make_nvp(&quot;bmethod&quot;, m_method));\n        double sigma = 0;\n        ar(::cereal::make_nvp(&quot;bs&quot;, sigma));\n        m_dgg.SetStd(sigma);\n        ar(::cereal::make_nvp(&quot;bdigitsG&quot;, m_digitsG));\n        ar(::cereal::make_nvp(&quot;bparams&quot;, m_polyParams));\n        ar(::cereal::make_nvp(&quot;numAutoKeys&quot;, m_numAutoKeys));\n\n        PreCompute();\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;RingGSWCryptoParams&quot;;\n    }\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\n    void Change_BaseG(uint32_t BaseG) {\n        if (m_baseG != BaseG) {\n            m_baseG  = BaseG;\n            m_Gpower = m_Gpower_map[m_baseG];\n            m_digitsG =\n                static_cast&lt;uint32_t&gt;(std::ceil(log(m_Q.ConvertToDouble()) / log(static_cast&lt;double&gt;(m_baseG))));\n        }\n    }\n\nprivate:\n    // modulus for the RingGSW/RingLWE scheme\n    NativeInteger m_Q{};\n\n    // modulus for the RingLWE scheme\n    NativeInteger m_q{};\n\n    // ring dimension for RingGSW/RingLWE scheme\n    uint32_t m_N{};\n\n    // gadget base used in bootstrapping\n    uint32_t m_baseG{};\n\n    // base used for the refreshing key (used only for DM bootstrapping)\n    uint32_t m_baseR{};\n\n    // number of digits in decomposing integers mod Q\n    uint32_t m_digitsG{};\n\n    // powers of m_baseR (used only for DM bootstrapping)\n    std::vector&lt;NativeInteger&gt; m_digitsR;\n\n    // A vector of powers of baseG\n    std::vector&lt;NativeInteger&gt; m_Gpower;\n\n    // A vector of log by generator g (=5) (only for LMKCDEY)\n    // Not exactly log, but a mapping similar to logarithm for efficiency\n    // m_logGen[5^i (mod M)] = i (i &gt; 0)\n    // m_logGen[-5^i (mod M)] = -i ()\n    // m_logGen[1] = 0\n    // m_logGen[-1 (mod M)] = M (special case for efficiency)\n    std::vector&lt;int32_t&gt; m_logGen;\n\n    // Error distribution generator\n    DiscreteGaussianGeneratorImpl&lt;NativeVector&gt; m_dgg;\n\n    // A map of vectors of powers of baseG for sign evaluation\n    std::map&lt;uint32_t, std::vector&lt;NativeInteger&gt;&gt; m_Gpower_map;\n\n    // Parameters for polynomials in RingGSW/RingLWE\n    std::shared_ptr&lt;ILNativeParams&gt; m_polyParams;\n\n    // Constants used in evaluating binary gates\n    std::vector&lt;NativeInteger&gt; m_gateConst;\n\n    // Precomputed polynomials in Format::EVALUATION representation for X^m - 1\n    // (used only for CGGI bootstrapping)\n    std::vector&lt;NativePoly&gt; m_monomials;\n\n    // Bootstrapping method (DM or CGGI or LMKCDEY)\n    BINFHE_METHOD m_method{BINFHE_METHOD::INVALID_METHOD};\n\n    // Secret key distribution: GAUSSIAN, UNIFORM_TERNARY, etc.\n    SecretKeyDist m_keyDist{SecretKeyDist::UNIFORM_TERNARY};\n\n    // number of automorphism keys (used only for LMKCDEY bootstrapping)\n    uint32_t m_numAutoKeys{};\n};\n\n}  // namespace lbcrypto\n\n#endif  // _RGSW_CRYPTOPARAMETERS_H_\n"}, "/usr/include/c++/11/bits/shared_ptr.h": {"id": "/usr/include/c++/11/bits/shared_ptr.h", "filePath": "/usr/include/c++/11/bits/shared_ptr.h", "content": "// shared_ptr and weak_ptr implementation -*- C++ -*-\n\n// Copyright (C) 2007-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n// GCC Note: Based on files from version 1.32.0 of the Boost library.\n\n//  shared_count.hpp\n//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n\n//  shared_ptr.hpp\n//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  weak_ptr.hpp\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  enable_shared_from_this.hpp\n//  Copyright (C) 2002 Peter Dimov\n\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n\n/** @file\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _SHARED_PTR_H\n#define _SHARED_PTR_H 1\n\n#include &lt;iosfwd&gt;           \t  // std::basic_ostream\n#include &lt;bits/shared_ptr_base.h&gt;\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   * @addtogroup pointer_abstractions\n   * @{\n   */\n\n  // 20.7.2.2.11 shared_ptr I/O\n\n  /// Write the stored pointer to an ostream.\n  /// @relates shared_ptr\n  template&lt;typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp&gt;\n    inline std::basic_ostream&lt;_Ch, _Tr&gt;&amp;\n    operator&lt;&lt;(std::basic_ostream&lt;_Ch, _Tr&gt;&amp; __os,\n\t       const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __p)\n    {\n      __os &lt;&lt; __p.get();\n      return __os;\n    }\n\n  template&lt;typename _Del, typename _Tp, _Lock_policy _Lp&gt;\n    inline _Del*\n    get_deleter(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __p) noexcept\n    {\n#if __cpp_rtti\n      return static_cast&lt;_Del*&gt;(__p._M_get_deleter(typeid(_Del)));\n#else\n      return 0;\n#endif\n    }\n\n  /// 20.7.2.2.10 shared_ptr get_deleter\n\n  /// If `__p` has a deleter of type `_Del`, return a pointer to it.\n  /// @relates shared_ptr\n  template&lt;typename _Del, typename _Tp&gt;\n    inline _Del*\n    get_deleter(const shared_ptr&lt;_Tp&gt;&amp; __p) noexcept\n    {\n#if __cpp_rtti\n      return static_cast&lt;_Del*&gt;(__p._M_get_deleter(typeid(_Del)));\n#else\n      return 0;\n#endif\n    }\n\n  /**\n   *  @brief  A smart pointer with reference-counted copy semantics.\n   *\n   * A `shared_ptr` object is either empty or _owns_ a pointer passed\n   * to the constructor. Copies of a `shared_ptr` share ownership of\n   * the same pointer. When the last `shared_ptr` that owns the pointer\n   * is destroyed or reset, the owned pointer is freed (either by `delete`\n   * or by invoking a custom deleter that was passed to the constructor).\n   *\n   * A `shared_ptr` also stores another pointer, which is usually\n   * (but not always) the same pointer as it owns. The stored pointer\n   * can be retrieved by calling the `get()` member function.\n   *\n   * The equality and relational operators for `shared_ptr` only compare\n   * the stored pointer returned by `get()`, not the owned pointer.\n   * To test whether two `shared_ptr` objects share ownership of the same\n   * pointer see `std::shared_ptr::owner_before` and `std::owner_less`.\n  */\n  template&lt;typename _Tp&gt;\n    class shared_ptr : public __shared_ptr&lt;_Tp&gt;\n    {\n      template&lt;typename... _Args&gt;\n\tusing _Constructible = typename enable_if&lt;\n\t  is_constructible&lt;__shared_ptr&lt;_Tp&gt;, _Args...&gt;::value\n\t&gt;::type;\n\n      template&lt;typename _Arg&gt;\n\tusing _Assignable = typename enable_if&lt;\n\t  is_assignable&lt;__shared_ptr&lt;_Tp&gt;&amp;, _Arg&gt;::value, shared_ptr&amp;\n\t&gt;::type;\n\n    public:\n\n      /// The type pointed to by the stored pointer, remove_extent_t&lt;_Tp&gt;\n      using element_type = typename __shared_ptr&lt;_Tp&gt;::element_type;\n\n#if __cplusplus &gt;= 201703L\n# define __cpp_lib_shared_ptr_weak_type 201606\n      /// The corresponding weak_ptr type for this shared_ptr\n      using weak_type = weak_ptr&lt;_Tp&gt;;\n#endif\n      /**\n       *  @brief  Construct an empty %shared_ptr.\n       *  @post   use_count()==0 &amp;&amp; get()==0\n       */\n      constexpr shared_ptr() noexcept : __shared_ptr&lt;_Tp&gt;() { }\n\n      shared_ptr(const shared_ptr&amp;) noexcept = default; ///&lt; Copy constructor\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns the pointer @a __p.\n       *  @param  __p  A pointer that is convertible to element_type*.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @c delete @a __p is called.\n       */\n      template&lt;typename _Yp, typename = _Constructible&lt;_Yp*&gt;&gt;\n\texplicit\n\tshared_ptr(_Yp* __p) : __shared_ptr&lt;_Tp&gt;(__p) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns the pointer @a __p\n       *          and the deleter @a __d.\n       *  @param  __p  A pointer.\n       *  @param  __d  A deleter.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw\n       *\n       *  __shared_ptr will release __p by calling __d(__p)\n       */\n      template&lt;typename _Yp, typename _Deleter,\n\t       typename = _Constructible&lt;_Yp*, _Deleter&gt;&gt;\n\tshared_ptr(_Yp* __p, _Deleter __d)\n        : __shared_ptr&lt;_Tp&gt;(__p, std::move(__d)) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns a null pointer\n       *          and the deleter @a __d.\n       *  @param  __p  A null pointer constant.\n       *  @param  __d  A deleter.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw\n       *\n       *  The last owner will call __d(__p)\n       */\n      template&lt;typename _Deleter&gt;\n\tshared_ptr(nullptr_t __p, _Deleter __d)\n        : __shared_ptr&lt;_Tp&gt;(__p, std::move(__d)) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns the pointer @a __p\n       *          and the deleter @a __d.\n       *  @param  __p  A pointer.\n       *  @param  __d  A deleter.\n       *  @param  __a  An allocator.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw _Alloc&#x27;s copy constructor and destructor must not\n       *  throw.\n       *\n       *  __shared_ptr will release __p by calling __d(__p)\n       */\n      template&lt;typename _Yp, typename _Deleter, typename _Alloc,\n\t       typename = _Constructible&lt;_Yp*, _Deleter, _Alloc&gt;&gt;\n\tshared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)\n\t: __shared_ptr&lt;_Tp&gt;(__p, std::move(__d), std::move(__a)) { }\n\n      /**\n       *  @brief  Construct a %shared_ptr that owns a null pointer\n       *          and the deleter @a __d.\n       *  @param  __p  A null pointer constant.\n       *  @param  __d  A deleter.\n       *  @param  __a  An allocator.\n       *  @post   use_count() == 1 &amp;&amp; get() == __p\n       *  @throw  std::bad_alloc, in which case @a __d(__p) is called.\n       *\n       *  Requirements: _Deleter&#x27;s copy constructor and destructor must\n       *  not throw _Alloc&#x27;s copy constructor and destructor must not\n       *  throw.\n       *\n       *  The last owner will call __d(__p)\n       */\n      template&lt;typename _Deleter, typename _Alloc&gt;\n\tshared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)\n\t: __shared_ptr&lt;_Tp&gt;(__p, std::move(__d), std::move(__a)) { }\n\n      // Aliasing constructor\n\n      /**\n       *  @brief  Constructs a `shared_ptr` instance that stores `__p`\n       *          and shares ownership with `__r`.\n       *  @param  __r  A `shared_ptr`.\n       *  @param  __p  A pointer that will remain valid while `*__r` is valid.\n       *  @post   `get() == __p &amp;&amp; use_count() == __r.use_count()`\n       *\n       *  This can be used to construct a `shared_ptr` to a sub-object\n       *  of an object managed by an existing `shared_ptr`. The complete\n       *  object will remain valid while any `shared_ptr` owns it, even\n       *  if they don&#x27;t store a pointer to the complete object.\n       *\n       * @code\n       * shared_ptr&lt;pair&lt;int,int&gt;&gt; pii(new pair&lt;int,int&gt;());\n       * shared_ptr&lt;int&gt; pi(pii, &amp;pii-&gt;first);\n       * assert(pii.use_count() == 2);\n       * @endcode\n       */\n      template&lt;typename _Yp&gt;\n\tshared_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r, element_type* __p) noexcept\n\t: __shared_ptr&lt;_Tp&gt;(__r, __p) { }\n\n#if __cplusplus &gt; 201703L\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2996. Missing rvalue overloads for shared_ptr operations\n      /**\n       *  @brief  Constructs a `shared_ptr` instance that stores `__p`\n       *          and shares ownership with `__r`.\n       *  @param  __r  A `shared_ptr`.\n       *  @param  __p  A pointer that will remain valid while `*__r` is valid.\n       *  @post   `get() == __p &amp;&amp; !__r.use_count() &amp;&amp; !__r.get()`\n       *\n       *  This can be used to construct a `shared_ptr` to a sub-object\n       *  of an object managed by an existing `shared_ptr`. The complete\n       *  object will remain valid while any `shared_ptr` owns it, even\n       *  if they don&#x27;t store a pointer to the complete object.\n       *\n       * @code\n       * shared_ptr&lt;pair&lt;int,int&gt;&gt; pii(new pair&lt;int,int&gt;());\n       * shared_ptr&lt;int&gt; pi1(pii, &amp;pii-&gt;first);\n       * assert(pii.use_count() == 2);\n       * shared_ptr&lt;int&gt; pi2(std::move(pii), &amp;pii-&gt;second);\n       * assert(pii.use_count() == 0);\n       * @endcode\n       */\n      template&lt;typename _Yp&gt;\n\tshared_ptr(shared_ptr&lt;_Yp&gt;&amp;&amp; __r, element_type* __p) noexcept\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r), __p) { }\n#endif\n      /**\n       *  @brief  If @a __r is empty, constructs an empty %shared_ptr;\n       *          otherwise construct a %shared_ptr that shares ownership\n       *          with @a __r.\n       *  @param  __r  A %shared_ptr.\n       *  @post   get() == __r.get() &amp;&amp; use_count() == __r.use_count()\n       */\n      template&lt;typename _Yp,\n\t       typename = _Constructible&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\tshared_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n        : __shared_ptr&lt;_Tp&gt;(__r) { }\n\n      /**\n       *  @brief  Move-constructs a %shared_ptr instance from @a __r.\n       *  @param  __r  A %shared_ptr rvalue.\n       *  @post   *this contains the old value of @a __r, @a __r is empty.\n       */\n      shared_ptr(shared_ptr&amp;&amp; __r) noexcept\n      : __shared_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n      /**\n       *  @brief  Move-constructs a %shared_ptr instance from @a __r.\n       *  @param  __r  A %shared_ptr rvalue.\n       *  @post   *this contains the old value of @a __r, @a __r is empty.\n       */\n      template&lt;typename _Yp, typename = _Constructible&lt;shared_ptr&lt;_Yp&gt;&gt;&gt;\n\tshared_ptr(shared_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n      /**\n       *  @brief  Constructs a %shared_ptr that shares ownership with @a __r\n       *          and stores a copy of the pointer stored in @a __r.\n       *  @param  __r  A weak_ptr.\n       *  @post   use_count() == __r.use_count()\n       *  @throw  bad_weak_ptr when __r.expired(),\n       *          in which case the constructor has no effect.\n       */\n      template&lt;typename _Yp, typename = _Constructible&lt;const weak_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\texplicit shared_ptr(const weak_ptr&lt;_Yp&gt;&amp; __r)\n\t: __shared_ptr&lt;_Tp&gt;(__r) { }\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      template&lt;typename _Yp, typename = _Constructible&lt;auto_ptr&lt;_Yp&gt;&gt;&gt;\n\tshared_ptr(auto_ptr&lt;_Yp&gt;&amp;&amp; __r);\n#pragma GCC diagnostic pop\n#endif\n\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2399. shared_ptr&#x27;s constructor from unique_ptr should be constrained\n      template&lt;typename _Yp, typename _Del,\n\t       typename = _Constructible&lt;unique_ptr&lt;_Yp, _Del&gt;&gt;&gt;\n\tshared_ptr(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n#if __cplusplus &lt;= 201402L &amp;&amp; _GLIBCXX_USE_DEPRECATED\n      // This non-standard constructor exists to support conversions that\n      // were possible in C++11 and C++14 but are ill-formed in C++17.\n      // If an exception is thrown this constructor has no effect.\n      template&lt;typename _Yp, typename _Del,\n\t\t_Constructible&lt;unique_ptr&lt;_Yp, _Del&gt;, __sp_array_delete&gt;* = 0&gt;\n\tshared_ptr(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t: __shared_ptr&lt;_Tp&gt;(std::move(__r), __sp_array_delete()) { }\n#endif\n\n      /**\n       *  @brief  Construct an empty %shared_ptr.\n       *  @post   use_count() == 0 &amp;&amp; get() == nullptr\n       */\n      constexpr shared_ptr(nullptr_t) noexcept : shared_ptr() { }\n\n      shared_ptr&amp; operator=(const shared_ptr&amp;) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;\n\toperator=(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(__r);\n\t  return *this;\n\t}\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;auto_ptr&lt;_Yp&gt;&gt;\n\toperator=(auto_ptr&lt;_Yp&gt;&amp;&amp; __r)\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n#pragma GCC diagnostic pop\n#endif\n\n      shared_ptr&amp;\n      operator=(shared_ptr&amp;&amp; __r) noexcept\n      {\n\tthis-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\treturn *this;\n      }\n\n      template&lt;class _Yp&gt;\n\t_Assignable&lt;shared_ptr&lt;_Yp&gt;&gt;\n\toperator=(shared_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp, typename _Del&gt;\n\t_Assignable&lt;unique_ptr&lt;_Yp, _Del&gt;&gt;\n\toperator=(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t{\n\t  this-&gt;__shared_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n\n    private:\n      // This constructor is non-standard, it is used by allocate_shared.\n      template&lt;typename _Alloc, typename... _Args&gt;\n\tshared_ptr(_Sp_alloc_shared_tag&lt;_Alloc&gt; __tag, _Args&amp;&amp;... __args)\n\t: __shared_ptr&lt;_Tp&gt;(__tag, std::forward&lt;_Args&gt;(__args)...)\n\t{ }\n\n      template&lt;typename _Yp, typename _Alloc, typename... _Args&gt;\n\tfriend shared_ptr&lt;_Yp&gt;\n\tallocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args);\n\n      // This constructor is non-standard, it is used by weak_ptr::lock().\n      shared_ptr(const weak_ptr&lt;_Tp&gt;&amp; __r, std::nothrow_t) noexcept\n      : __shared_ptr&lt;_Tp&gt;(__r, std::nothrow) { }\n\n      friend class weak_ptr&lt;_Tp&gt;;\n    };\n\n#if __cpp_deduction_guides &gt;= 201606\n  template&lt;typename _Tp&gt;\n    shared_ptr(weak_ptr&lt;_Tp&gt;) -&gt;  shared_ptr&lt;_Tp&gt;;\n  template&lt;typename _Tp, typename _Del&gt;\n    shared_ptr(unique_ptr&lt;_Tp, _Del&gt;) -&gt;  shared_ptr&lt;_Tp&gt;;\n#endif\n\n  // 20.7.2.2.7 shared_ptr comparisons\n\n  /// @relates shared_ptr @{\n\n  /// Equality operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator==(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return __a.get() == __b.get(); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator==(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return !__a; }\n\n#ifdef __cpp_lib_three_way_comparison\n  template&lt;typename _Tp, typename _Up&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a,\n\t\tconst shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return compare_three_way()(__a.get(), __b.get()); }\n\n  template&lt;typename _Tp&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using pointer = typename shared_ptr&lt;_Tp&gt;::element_type*;\n      return compare_three_way()(__a.get(), static_cast&lt;pointer&gt;(nullptr));\n    }\n#else\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator==(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return !__a; }\n\n  /// Inequality operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator!=(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return __a.get() != __b.get(); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator!=(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return (bool)__a; }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator!=(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return (bool)__a; }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    {\n      using _Tp_elt = typename shared_ptr&lt;_Tp&gt;::element_type;\n      using _Up_elt = typename shared_ptr&lt;_Up&gt;::element_type;\n      using _Vp = typename common_type&lt;_Tp_elt*, _Up_elt*&gt;::type;\n      return less&lt;_Vp&gt;()(__a.get(), __b.get());\n    }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using _Tp_elt = typename shared_ptr&lt;_Tp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(__a.get(), nullptr);\n    }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    {\n      using _Tp_elt = typename shared_ptr&lt;_Tp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(nullptr, __a.get());\n    }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return !(__b &lt; __a); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(nullptr &lt; __a); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&lt;=(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return !(__a &lt; nullptr); }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return (__b &lt; __a); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return nullptr &lt; __a; }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return __a &lt; nullptr; }\n\n  /// Relational operator for shared_ptr objects, compares the stored pointers\n  template&lt;typename _Tp, typename _Up&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, const shared_ptr&lt;_Up&gt;&amp; __b) noexcept\n    { return !(__a &lt; __b); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;=(const shared_ptr&lt;_Tp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(__a &lt; nullptr); }\n\n  /// shared_ptr comparison with nullptr\n  template&lt;typename _Tp&gt;\n    _GLIBCXX_NODISCARD inline bool\n    operator&gt;=(nullptr_t, const shared_ptr&lt;_Tp&gt;&amp; __a) noexcept\n    { return !(nullptr &lt; __a); }\n#endif\n\n  // 20.7.2.2.8 shared_ptr specialized algorithms.\n\n  /// Swap overload for shared_ptr\n  template&lt;typename _Tp&gt;\n    inline void\n    swap(shared_ptr&lt;_Tp&gt;&amp; __a, shared_ptr&lt;_Tp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n  // 20.7.2.2.9 shared_ptr casts.\n\n  /// Convert type of `shared_ptr`, via `static_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    static_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(__r, static_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr`, via `const_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    const_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(__r, const_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr`, via `dynamic_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    dynamic_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      if (auto* __p = dynamic_cast&lt;typename _Sp::element_type*&gt;(__r.get()))\n\treturn _Sp(__r, __p);\n      return _Sp();\n    }\n\n#if __cplusplus &gt;= 201703L\n  /// Convert type of `shared_ptr`, via `reinterpret_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    reinterpret_pointer_cast(const shared_ptr&lt;_Up&gt;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(__r, reinterpret_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n#if __cplusplus &gt; 201703L\n  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n  // 2996. Missing rvalue overloads for shared_ptr operations\n\n  /// Convert type of `shared_ptr` rvalue, via `static_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    static_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(std::move(__r),\n\t\t static_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr` rvalue, via `const_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    const_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(std::move(__r),\n\t\t const_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  /// Convert type of `shared_ptr` rvalue, via `dynamic_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    dynamic_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      if (auto* __p = dynamic_cast&lt;typename _Sp::element_type*&gt;(__r.get()))\n\treturn _Sp(std::move(__r), __p);\n      return _Sp();\n    }\n\n  /// Convert type of `shared_ptr` rvalue, via `reinterpret_cast`\n  template&lt;typename _Tp, typename _Up&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    reinterpret_pointer_cast(shared_ptr&lt;_Up&gt;&amp;&amp; __r) noexcept\n    {\n      using _Sp = shared_ptr&lt;_Tp&gt;;\n      return _Sp(std::move(__r),\n\t\t reinterpret_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n#endif // C++20\n#endif // C++17\n\n  /// @}\n\n  /**\n   * @brief  A non-owning observer for a pointer owned by a shared_ptr\n   *\n   * A weak_ptr provides a safe alternative to a raw pointer when you want\n   * a non-owning reference to an object that is managed by a shared_ptr.\n   *\n   * Unlike a raw pointer, a weak_ptr can be converted to a new shared_ptr\n   * that shares ownership with every other shared_ptr that already owns\n   * the pointer. In other words you can upgrade from a non-owning &quot;weak&quot;\n   * reference to an owning shared_ptr, without having access to any of\n   * the existing shared_ptr objects.\n   *\n   * Also unlike a raw pointer, a weak_ptr does not become &quot;dangling&quot; after\n   * the object it points to has been destroyed. Instead, a weak_ptr\n   * becomes _expired_ and can no longer be converted to a shared_ptr that\n   * owns the freed pointer, so you cannot accidentally access the pointed-to\n   * object after it has been destroyed.\n   */\n  template&lt;typename _Tp&gt;\n    class weak_ptr : public __weak_ptr&lt;_Tp&gt;\n    {\n      template&lt;typename _Arg&gt;\n\tusing _Constructible = typename enable_if&lt;\n\t  is_constructible&lt;__weak_ptr&lt;_Tp&gt;, _Arg&gt;::value\n\t&gt;::type;\n\n      template&lt;typename _Arg&gt;\n\tusing _Assignable = typename enable_if&lt;\n\t  is_assignable&lt;__weak_ptr&lt;_Tp&gt;&amp;, _Arg&gt;::value, weak_ptr&amp;\n\t&gt;::type;\n\n    public:\n      constexpr weak_ptr() noexcept = default;\n\n      template&lt;typename _Yp,\n\t       typename = _Constructible&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\tweak_ptr(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t: __weak_ptr&lt;_Tp&gt;(__r) { }\n\n      weak_ptr(const weak_ptr&amp;) noexcept = default;\n\n      template&lt;typename _Yp, typename = _Constructible&lt;const weak_ptr&lt;_Yp&gt;&amp;&gt;&gt;\n\tweak_ptr(const weak_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t: __weak_ptr&lt;_Tp&gt;(__r) { }\n\n      weak_ptr(weak_ptr&amp;&amp;) noexcept = default;\n\n      template&lt;typename _Yp, typename = _Constructible&lt;weak_ptr&lt;_Yp&gt;&gt;&gt;\n\tweak_ptr(weak_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t: __weak_ptr&lt;_Tp&gt;(std::move(__r)) { }\n\n      weak_ptr&amp;\n      operator=(const weak_ptr&amp; __r) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;const weak_ptr&lt;_Yp&gt;&amp;&gt;\n\toperator=(const weak_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t{\n\t  this-&gt;__weak_ptr&lt;_Tp&gt;::operator=(__r);\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;const shared_ptr&lt;_Yp&gt;&amp;&gt;\n\toperator=(const shared_ptr&lt;_Yp&gt;&amp; __r) noexcept\n\t{\n\t  this-&gt;__weak_ptr&lt;_Tp&gt;::operator=(__r);\n\t  return *this;\n\t}\n\n      weak_ptr&amp;\n      operator=(weak_ptr&amp;&amp; __r) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;weak_ptr&lt;_Yp&gt;&gt;\n\toperator=(weak_ptr&lt;_Yp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  this-&gt;__weak_ptr&lt;_Tp&gt;::operator=(std::move(__r));\n\t  return *this;\n\t}\n\n      shared_ptr&lt;_Tp&gt;\n      lock() const noexcept\n      { return shared_ptr&lt;_Tp&gt;(*this, std::nothrow); }\n    };\n\n#if __cpp_deduction_guides &gt;= 201606\n  template&lt;typename _Tp&gt;\n    weak_ptr(shared_ptr&lt;_Tp&gt;) -&gt;  weak_ptr&lt;_Tp&gt;;\n#endif\n\n  // 20.7.2.3.6 weak_ptr specialized algorithms.\n  /// Swap overload for weak_ptr\n  /// @relates weak_ptr\n  template&lt;typename _Tp&gt;\n    inline void\n    swap(weak_ptr&lt;_Tp&gt;&amp; __a, weak_ptr&lt;_Tp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n\n  /// Primary template owner_less\n  template&lt;typename _Tp = void&gt;\n    struct owner_less;\n\n  /// Void specialization of owner_less compares either shared_ptr or weak_ptr\n  template&lt;&gt;\n    struct owner_less&lt;void&gt; : _Sp_owner_less&lt;void, void&gt;\n    { };\n\n  /// Partial specialization of owner_less for shared_ptr.\n  template&lt;typename _Tp&gt;\n    struct owner_less&lt;shared_ptr&lt;_Tp&gt;&gt;\n    : public _Sp_owner_less&lt;shared_ptr&lt;_Tp&gt;, weak_ptr&lt;_Tp&gt;&gt;\n    { };\n\n  /// Partial specialization of owner_less for weak_ptr.\n  template&lt;typename _Tp&gt;\n    struct owner_less&lt;weak_ptr&lt;_Tp&gt;&gt;\n    : public _Sp_owner_less&lt;weak_ptr&lt;_Tp&gt;, shared_ptr&lt;_Tp&gt;&gt;\n    { };\n\n  /**\n   *  @brief Base class allowing use of member function shared_from_this.\n   */\n  template&lt;typename _Tp&gt;\n    class enable_shared_from_this\n    {\n    protected:\n      constexpr enable_shared_from_this() noexcept { }\n\n      enable_shared_from_this(const enable_shared_from_this&amp;) noexcept { }\n\n      enable_shared_from_this&amp;\n      operator=(const enable_shared_from_this&amp;) noexcept\n      { return *this; }\n\n      ~enable_shared_from_this() { }\n\n    public:\n      shared_ptr&lt;_Tp&gt;\n      shared_from_this()\n      { return shared_ptr&lt;_Tp&gt;(this-&gt;_M_weak_this); }\n\n      shared_ptr&lt;const _Tp&gt;\n      shared_from_this() const\n      { return shared_ptr&lt;const _Tp&gt;(this-&gt;_M_weak_this); }\n\n#if __cplusplus &gt; 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n#define __cpp_lib_enable_shared_from_this 201603\n      weak_ptr&lt;_Tp&gt;\n      weak_from_this() noexcept\n      { return this-&gt;_M_weak_this; }\n\n      weak_ptr&lt;const _Tp&gt;\n      weak_from_this() const noexcept\n      { return this-&gt;_M_weak_this; }\n#endif\n\n    private:\n      template&lt;typename _Tp1&gt;\n\tvoid\n\t_M_weak_assign(_Tp1* __p, const __shared_count&lt;&gt;&amp; __n) const noexcept\n\t{ _M_weak_this._M_assign(__p, __n); }\n\n      // Found by ADL when this is an associated class.\n      friend const enable_shared_from_this*\n      __enable_shared_from_this_base(const __shared_count&lt;&gt;&amp;,\n\t\t\t\t     const enable_shared_from_this* __p)\n      { return __p; }\n\n      template&lt;typename, _Lock_policy&gt;\n\tfriend class __shared_ptr;\n\n      mutable weak_ptr&lt;_Tp&gt;  _M_weak_this;\n    };\n\n  /// @relates shared_ptr @{\n\n  /**\n   *  @brief  Create an object that is owned by a shared_ptr.\n   *  @param  __a     An allocator.\n   *  @param  __args  Arguments for the @a _Tp object&#x27;s constructor.\n   *  @return A shared_ptr that owns the newly created object.\n   *  @throw  An exception thrown from @a _Alloc::allocate or from the\n   *          constructor of @a _Tp.\n   *\n   *  A copy of @a __a will be used to allocate memory for the shared_ptr\n   *  and the new object.\n   */\n  template&lt;typename _Tp, typename _Alloc, typename... _Args&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args)\n    {\n      static_assert(!is_array&lt;_Tp&gt;::value, &quot;make_shared&lt;T[]&gt; not supported&quot;);\n\n      return shared_ptr&lt;_Tp&gt;(_Sp_alloc_shared_tag&lt;_Alloc&gt;{__a},\n\t\t\t     std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  /**\n   *  @brief  Create an object that is owned by a shared_ptr.\n   *  @param  __args  Arguments for the @a _Tp object&#x27;s constructor.\n   *  @return A shared_ptr that owns the newly created object.\n   *  @throw  std::bad_alloc, or an exception thrown from the\n   *          constructor of @a _Tp.\n   */\n  template&lt;typename _Tp, typename... _Args&gt;\n    inline shared_ptr&lt;_Tp&gt;\n    make_shared(_Args&amp;&amp;... __args)\n    {\n      typedef typename std::remove_cv&lt;_Tp&gt;::type _Tp_nc;\n      return std::allocate_shared&lt;_Tp&gt;(std::allocator&lt;_Tp_nc&gt;(),\n\t\t\t\t       std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  /// std::hash specialization for shared_ptr.\n  template&lt;typename _Tp&gt;\n    struct hash&lt;shared_ptr&lt;_Tp&gt;&gt;\n    : public __hash_base&lt;size_t, shared_ptr&lt;_Tp&gt;&gt;\n    {\n      size_t\n      operator()(const shared_ptr&lt;_Tp&gt;&amp; __s) const noexcept\n      {\n\treturn std::hash&lt;typename shared_ptr&lt;_Tp&gt;::element_type*&gt;()(__s.get());\n      }\n    };\n\n  /// @} relates shared_ptr\n  /// @} group pointer_abstractions\n\n#if __cplusplus &gt;= 201703L\n  namespace __detail::__variant\n  {\n    template&lt;typename&gt; struct _Never_valueless_alt; // see &lt;variant&gt;\n\n    // Provide the strong exception-safety guarantee when emplacing a\n    // shared_ptr into a variant.\n    template&lt;typename _Tp&gt;\n      struct _Never_valueless_alt&lt;std::shared_ptr&lt;_Tp&gt;&gt;\n      : std::true_type\n      { };\n\n    // Provide the strong exception-safety guarantee when emplacing a\n    // weak_ptr into a variant.\n    template&lt;typename _Tp&gt;\n      struct _Never_valueless_alt&lt;std::weak_ptr&lt;_Tp&gt;&gt;\n      : std::true_type\n      { };\n  }  // namespace __detail::__variant\n#endif // C++17\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif // _SHARED_PTR_H\n"}, "/usr/include/c++/11/bits/shared_ptr_base.h": {"id": "/usr/include/c++/11/bits/shared_ptr_base.h", "filePath": "/usr/include/c++/11/bits/shared_ptr_base.h", "content": "// shared_ptr and weak_ptr implementation details -*- C++ -*-\n\n// Copyright (C) 2007-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n// GCC Note: Based on files from version 1.32.0 of the Boost library.\n\n//  shared_count.hpp\n//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n\n//  shared_ptr.hpp\n//  Copyright (C) 1998, 1999 Greg Colvin and Beman Dawes.\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  weak_ptr.hpp\n//  Copyright (C) 2001, 2002, 2003 Peter Dimov\n\n//  enable_shared_from_this.hpp\n//  Copyright (C) 2002 Peter Dimov\n\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n\n/** @file bits/shared_ptr_base.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _SHARED_PTR_BASE_H\n#define _SHARED_PTR_BASE_H 1\n\n#include &lt;typeinfo&gt;\n#include &lt;bits/allocated_ptr.h&gt;\n#include &lt;bits/allocator.h&gt;\n#include &lt;bits/exception_defines.h&gt;\n#include &lt;bits/functional_hash.h&gt;\n#include &lt;bits/refwrap.h&gt;\n#include &lt;bits/stl_function.h&gt;  // std::less\n#include &lt;bits/unique_ptr.h&gt;\n#include &lt;ext/aligned_buffer.h&gt;\n#include &lt;ext/atomicity.h&gt;\n#include &lt;ext/concurrence.h&gt;\n#if __cplusplus &gt; 201703L\n# include &lt;compare&gt;\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n  template&lt;typename&gt; class auto_ptr;\n#pragma GCC diagnostic pop\n#endif\n\n /**\n   *  @brief  Exception possibly thrown by @c shared_ptr.\n   *  @ingroup exceptions\n   */\n  class bad_weak_ptr : public std::exception\n  {\n  public:\n    virtual char const* what() const noexcept;\n\n    virtual ~bad_weak_ptr() noexcept;\n  };\n\n  // Substitute for bad_weak_ptr object in the case of -fno-exceptions.\n  inline void\n  __throw_bad_weak_ptr()\n  { _GLIBCXX_THROW_OR_ABORT(bad_weak_ptr()); }\n\n  using __gnu_cxx::_Lock_policy;\n  using __gnu_cxx::__default_lock_policy;\n  using __gnu_cxx::_S_single;\n  using __gnu_cxx::_S_mutex;\n  using __gnu_cxx::_S_atomic;\n\n  // Empty helper class except when the template argument is _S_mutex.\n  template&lt;_Lock_policy _Lp&gt;\n    class _Mutex_base\n    {\n    protected:\n      // The atomic policy uses fully-fenced builtins, single doesn&#x27;t care.\n      enum { _S_need_barriers = 0 };\n    };\n\n  template&lt;&gt;\n    class _Mutex_base&lt;_S_mutex&gt;\n    : public __gnu_cxx::__mutex\n    {\n    protected:\n      // This policy is used when atomic builtins are not available.\n      // The replacement atomic operations might not have the necessary\n      // memory barriers.\n      enum { _S_need_barriers = 1 };\n    };\n\n  template&lt;_Lock_policy _Lp = __default_lock_policy&gt;\n    class _Sp_counted_base\n    : public _Mutex_base&lt;_Lp&gt;\n    {\n    public:\n      _Sp_counted_base() noexcept\n      : _M_use_count(1), _M_weak_count(1) { }\n\n      virtual\n      ~_Sp_counted_base() noexcept\n      { }\n\n      // Called when _M_use_count drops to zero, to release the resources\n      // managed by *this.\n      virtual void\n      _M_dispose() noexcept = 0;\n\n      // Called when _M_weak_count drops to zero.\n      virtual void\n      _M_destroy() noexcept\n      { delete this; }\n\n      virtual void*\n      _M_get_deleter(const std::type_info&amp;) noexcept = 0;\n\n      void\n      _M_add_ref_copy()\n      { __gnu_cxx::__atomic_add_dispatch(&amp;_M_use_count, 1); }\n\n      void\n      _M_add_ref_lock()\n      {\n\tif (!_M_add_ref_lock_nothrow())\n\t  __throw_bad_weak_ptr();\n      }\n\n      bool\n      _M_add_ref_lock_nothrow() noexcept;\n\n      void\n      _M_release() noexcept\n      {\n        // Be race-detector-friendly.  For more info see bits/c++config.\n        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_use_count);\n\tif (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, -1) == 1)\n\t  {\n            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_use_count);\n\t    _M_dispose();\n\t    // There must be a memory barrier between dispose() and destroy()\n\t    // to ensure that the effects of dispose() are observed in the\n\t    // thread that runs destroy().\n\t    // See http://gcc.gnu.org/ml/libstdc++/2005-11/msg00136.html\n\t    if (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)\n\t      {\n\t\t__atomic_thread_fence (__ATOMIC_ACQ_REL);\n\t      }\n\n            // Be race-detector-friendly.  For more info see bits/c++config.\n            _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);\n\t    if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count,\n\t\t\t\t\t\t       -1) == 1)\n              {\n                _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);\n\t        _M_destroy();\n              }\n\t  }\n      }\n\n      void\n      _M_weak_add_ref() noexcept\n      { __gnu_cxx::__atomic_add_dispatch(&amp;_M_weak_count, 1); }\n\n      void\n      _M_weak_release() noexcept\n      {\n        // Be race-detector-friendly. For more info see bits/c++config.\n        _GLIBCXX_SYNCHRONIZATION_HAPPENS_BEFORE(&amp;_M_weak_count);\n\tif (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_weak_count, -1) == 1)\n\t  {\n            _GLIBCXX_SYNCHRONIZATION_HAPPENS_AFTER(&amp;_M_weak_count);\n\t    if (_Mutex_base&lt;_Lp&gt;::_S_need_barriers)\n\t      {\n\t        // See _M_release(),\n\t        // destroy() must observe results of dispose()\n\t\t__atomic_thread_fence (__ATOMIC_ACQ_REL);\n\t      }\n\t    _M_destroy();\n\t  }\n      }\n\n      long\n      _M_get_use_count() const noexcept\n      {\n        // No memory barrier is used here so there is no synchronization\n        // with other threads.\n        return __atomic_load_n(&amp;_M_use_count, __ATOMIC_RELAXED);\n      }\n\n    private:\n      _Sp_counted_base(_Sp_counted_base const&amp;) = delete;\n      _Sp_counted_base&amp; operator=(_Sp_counted_base const&amp;) = delete;\n\n      _Atomic_word  _M_use_count;     // #shared\n      _Atomic_word  _M_weak_count;    // #weak + (#shared != 0)\n    };\n\n  template&lt;&gt;\n    inline bool\n    _Sp_counted_base&lt;_S_single&gt;::\n    _M_add_ref_lock_nothrow() noexcept\n    {\n      if (_M_use_count == 0)\n\treturn false;\n      ++_M_use_count;\n      return true;\n    }\n\n  template&lt;&gt;\n    inline bool\n    _Sp_counted_base&lt;_S_mutex&gt;::\n    _M_add_ref_lock_nothrow() noexcept\n    {\n      __gnu_cxx::__scoped_lock sentry(*this);\n      if (__gnu_cxx::__exchange_and_add_dispatch(&amp;_M_use_count, 1) == 0)\n\t{\n\t  _M_use_count = 0;\n\t  return false;\n\t}\n      return true;\n    }\n\n  template&lt;&gt;\n    inline bool\n    _Sp_counted_base&lt;_S_atomic&gt;::\n    _M_add_ref_lock_nothrow() noexcept\n    {\n      // Perform lock-free add-if-not-zero operation.\n      _Atomic_word __count = _M_get_use_count();\n      do\n\t{\n\t  if (__count == 0)\n\t    return false;\n\t  // Replace the current counter value with the old value + 1, as\n\t  // long as it&#x27;s not changed meanwhile.\n\t}\n      while (!__atomic_compare_exchange_n(&amp;_M_use_count, &amp;__count, __count + 1,\n\t\t\t\t\t  true, __ATOMIC_ACQ_REL,\n\t\t\t\t\t  __ATOMIC_RELAXED));\n      return true;\n    }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_add_ref_copy()\n    { ++_M_use_count; }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_release() noexcept\n    {\n      if (--_M_use_count == 0)\n        {\n          _M_dispose();\n          if (--_M_weak_count == 0)\n            _M_destroy();\n        }\n    }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_weak_add_ref() noexcept\n    { ++_M_weak_count; }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_base&lt;_S_single&gt;::_M_weak_release() noexcept\n    {\n      if (--_M_weak_count == 0)\n        _M_destroy();\n    }\n\n  template&lt;&gt;\n    inline long\n    _Sp_counted_base&lt;_S_single&gt;::_M_get_use_count() const noexcept\n    { return _M_use_count; }\n\n\n  // Forward declarations.\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy&gt;\n    class __shared_ptr;\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy&gt;\n    class __weak_ptr;\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy&gt;\n    class __enable_shared_from_this;\n\n  template&lt;typename _Tp&gt;\n    class shared_ptr;\n\n  template&lt;typename _Tp&gt;\n    class weak_ptr;\n\n  template&lt;typename _Tp&gt;\n    struct owner_less;\n\n  template&lt;typename _Tp&gt;\n    class enable_shared_from_this;\n\n  template&lt;_Lock_policy _Lp = __default_lock_policy&gt;\n    class __weak_count;\n\n  template&lt;_Lock_policy _Lp = __default_lock_policy&gt;\n    class __shared_count;\n\n\n  // Counted ptr with no deleter or allocator support\n  template&lt;typename _Ptr, _Lock_policy _Lp&gt;\n    class _Sp_counted_ptr final : public _Sp_counted_base&lt;_Lp&gt;\n    {\n    public:\n      explicit\n      _Sp_counted_ptr(_Ptr __p) noexcept\n      : _M_ptr(__p) { }\n\n      virtual void\n      _M_dispose() noexcept\n      { delete _M_ptr; }\n\n      virtual void\n      _M_destroy() noexcept\n      { delete this; }\n\n      virtual void*\n      _M_get_deleter(const std::type_info&amp;) noexcept\n      { return nullptr; }\n\n      _Sp_counted_ptr(const _Sp_counted_ptr&amp;) = delete;\n      _Sp_counted_ptr&amp; operator=(const _Sp_counted_ptr&amp;) = delete;\n\n    private:\n      _Ptr             _M_ptr;\n    };\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_ptr&lt;nullptr_t, _S_single&gt;::_M_dispose() noexcept { }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_ptr&lt;nullptr_t, _S_mutex&gt;::_M_dispose() noexcept { }\n\n  template&lt;&gt;\n    inline void\n    _Sp_counted_ptr&lt;nullptr_t, _S_atomic&gt;::_M_dispose() noexcept { }\n\n  template&lt;int _Nm, typename _Tp,\n\t   bool __use_ebo = !__is_final(_Tp) &amp;&amp; __is_empty(_Tp)&gt;\n    struct _Sp_ebo_helper;\n\n  /// Specialization using EBO.\n  template&lt;int _Nm, typename _Tp&gt;\n    struct _Sp_ebo_helper&lt;_Nm, _Tp, true&gt; : private _Tp\n    {\n      explicit _Sp_ebo_helper(const _Tp&amp; __tp) : _Tp(__tp) { }\n      explicit _Sp_ebo_helper(_Tp&amp;&amp; __tp) : _Tp(std::move(__tp)) { }\n\n      static _Tp&amp;\n      _S_get(_Sp_ebo_helper&amp; __eboh) { return static_cast&lt;_Tp&amp;&gt;(__eboh); }\n    };\n\n  /// Specialization not using EBO.\n  template&lt;int _Nm, typename _Tp&gt;\n    struct _Sp_ebo_helper&lt;_Nm, _Tp, false&gt;\n    {\n      explicit _Sp_ebo_helper(const _Tp&amp; __tp) : _M_tp(__tp) { }\n      explicit _Sp_ebo_helper(_Tp&amp;&amp; __tp) : _M_tp(std::move(__tp)) { }\n\n      static _Tp&amp;\n      _S_get(_Sp_ebo_helper&amp; __eboh)\n      { return __eboh._M_tp; }\n\n    private:\n      _Tp _M_tp;\n    };\n\n  // Support for custom deleter and/or allocator\n  template&lt;typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp&gt;\n    class _Sp_counted_deleter final : public _Sp_counted_base&lt;_Lp&gt;\n    {\n      class _Impl : _Sp_ebo_helper&lt;0, _Deleter&gt;, _Sp_ebo_helper&lt;1, _Alloc&gt;\n      {\n\ttypedef _Sp_ebo_helper&lt;0, _Deleter&gt;\t_Del_base;\n\ttypedef _Sp_ebo_helper&lt;1, _Alloc&gt;\t_Alloc_base;\n\n      public:\n\t_Impl(_Ptr __p, _Deleter __d, const _Alloc&amp; __a) noexcept\n\t: _Del_base(std::move(__d)), _Alloc_base(__a), _M_ptr(__p)\n\t{ }\n\n\t_Deleter&amp; _M_del() noexcept { return _Del_base::_S_get(*this); }\n\t_Alloc&amp; _M_alloc() noexcept { return _Alloc_base::_S_get(*this); }\n\n\t_Ptr _M_ptr;\n      };\n\n    public:\n      using __allocator_type = __alloc_rebind&lt;_Alloc, _Sp_counted_deleter&gt;;\n\n      // __d(__p) must not throw.\n      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept\n      : _M_impl(__p, std::move(__d), _Alloc()) { }\n\n      // __d(__p) must not throw.\n      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc&amp; __a) noexcept\n      : _M_impl(__p, std::move(__d), __a) { }\n\n      ~_Sp_counted_deleter() noexcept { }\n\n      virtual void\n      _M_dispose() noexcept\n      { _M_impl._M_del()(_M_impl._M_ptr); }\n\n      virtual void\n      _M_destroy() noexcept\n      {\n\t__allocator_type __a(_M_impl._M_alloc());\n\t__allocated_ptr&lt;__allocator_type&gt; __guard_ptr{ __a, this };\n\tthis-&gt;~_Sp_counted_deleter();\n      }\n\n      virtual void*\n      _M_get_deleter(const type_info&amp; __ti [[__gnu__::__unused__]]) noexcept\n      {\n#if __cpp_rtti\n\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t// 2400. shared_ptr&#x27;s get_deleter() should use addressof()\n        return __ti == typeid(_Deleter)\n\t  ? std::__addressof(_M_impl._M_del())\n\t  : nullptr;\n#else\n        return nullptr;\n#endif\n      }\n\n    private:\n      _Impl _M_impl;\n    };\n\n  // helpers for make_shared / allocate_shared\n\n  struct _Sp_make_shared_tag\n  {\n  private:\n    template&lt;typename _Tp, typename _Alloc, _Lock_policy _Lp&gt;\n      friend class _Sp_counted_ptr_inplace;\n\n    static const type_info&amp;\n    _S_ti() noexcept _GLIBCXX_VISIBILITY(default)\n    {\n      alignas(type_info) static constexpr char __tag[sizeof(type_info)] = { };\n      return reinterpret_cast&lt;const type_info&amp;&gt;(__tag);\n    }\n\n    static bool _S_eq(const type_info&amp;) noexcept;\n  };\n\n  template&lt;typename _Alloc&gt;\n    struct _Sp_alloc_shared_tag\n    {\n      const _Alloc&amp; _M_a;\n    };\n\n  template&lt;typename _Tp, typename _Alloc, _Lock_policy _Lp&gt;\n    class _Sp_counted_ptr_inplace final : public _Sp_counted_base&lt;_Lp&gt;\n    {\n      class _Impl : _Sp_ebo_helper&lt;0, _Alloc&gt;\n      {\n\ttypedef _Sp_ebo_helper&lt;0, _Alloc&gt;\t_A_base;\n\n      public:\n\texplicit _Impl(_Alloc __a) noexcept : _A_base(__a) { }\n\n\t_Alloc&amp; _M_alloc() noexcept { return _A_base::_S_get(*this); }\n\n\t__gnu_cxx::__aligned_buffer&lt;_Tp&gt; _M_storage;\n      };\n\n    public:\n      using __allocator_type = __alloc_rebind&lt;_Alloc, _Sp_counted_ptr_inplace&gt;;\n\n      // Alloc parameter is not a reference so doesn&#x27;t alias anything in __args\n      template&lt;typename... _Args&gt;\n\t_Sp_counted_ptr_inplace(_Alloc __a, _Args&amp;&amp;... __args)\n\t: _M_impl(__a)\n\t{\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 2070.  allocate_shared should use allocator_traits&lt;A&gt;::construct\n\t  allocator_traits&lt;_Alloc&gt;::construct(__a, _M_ptr(),\n\t      std::forward&lt;_Args&gt;(__args)...); // might throw\n\t}\n\n      ~_Sp_counted_ptr_inplace() noexcept { }\n\n      virtual void\n      _M_dispose() noexcept\n      {\n\tallocator_traits&lt;_Alloc&gt;::destroy(_M_impl._M_alloc(), _M_ptr());\n      }\n\n      // Override because the allocator needs to know the dynamic type\n      virtual void\n      _M_destroy() noexcept\n      {\n\t__allocator_type __a(_M_impl._M_alloc());\n\t__allocated_ptr&lt;__allocator_type&gt; __guard_ptr{ __a, this };\n\tthis-&gt;~_Sp_counted_ptr_inplace();\n      }\n\n    private:\n      friend class __shared_count&lt;_Lp&gt;; // To be able to call _M_ptr().\n\n      // No longer used, but code compiled against old libstdc++ headers\n      // might still call it from __shared_ptr ctor to get the pointer out.\n      virtual void*\n      _M_get_deleter(const std::type_info&amp; __ti) noexcept override\n      {\n\tauto __ptr = const_cast&lt;typename remove_cv&lt;_Tp&gt;::type*&gt;(_M_ptr());\n\t// Check for the fake type_info first, so we don&#x27;t try to access it\n\t// as a real type_info object. Otherwise, check if it&#x27;s the real\n\t// type_info for this class. With RTTI enabled we can check directly,\n\t// or call a library function to do it.\n\tif (&amp;__ti == &amp;_Sp_make_shared_tag::_S_ti()\n\t    ||\n#if __cpp_rtti\n\t    __ti == typeid(_Sp_make_shared_tag)\n#else\n\t    _Sp_make_shared_tag::_S_eq(__ti)\n#endif\n\t   )\n\t  return __ptr;\n\treturn nullptr;\n      }\n\n      _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }\n\n      _Impl _M_impl;\n    };\n\n  // The default deleter for shared_ptr&lt;T[]&gt; and shared_ptr&lt;T[N]&gt;.\n  struct __sp_array_delete\n  {\n    template&lt;typename _Yp&gt;\n      void operator()(_Yp* __p) const { delete[] __p; }\n  };\n\n  template&lt;_Lock_policy _Lp&gt;\n    class __shared_count\n    {\n      template&lt;typename _Tp&gt;\n\tstruct __not_alloc_shared_tag { using type = void; };\n\n      template&lt;typename _Tp&gt;\n\tstruct __not_alloc_shared_tag&lt;_Sp_alloc_shared_tag&lt;_Tp&gt;&gt; { };\n\n    public:\n      constexpr __shared_count() noexcept : _M_pi(0)\n      { }\n\n      template&lt;typename _Ptr&gt;\n        explicit\n\t__shared_count(_Ptr __p) : _M_pi(0)\n\t{\n\t  __try\n\t    {\n\t      _M_pi = new _Sp_counted_ptr&lt;_Ptr, _Lp&gt;(__p);\n\t    }\n\t  __catch(...)\n\t    {\n\t      delete __p;\n\t      __throw_exception_again;\n\t    }\n\t}\n\n      template&lt;typename _Ptr&gt;\n\t__shared_count(_Ptr __p, /* is_array = */ false_type)\n\t: __shared_count(__p)\n\t{ }\n\n      template&lt;typename _Ptr&gt;\n\t__shared_count(_Ptr __p, /* is_array = */ true_type)\n\t: __shared_count(__p, __sp_array_delete{}, allocator&lt;void&gt;())\n\t{ }\n\n      template&lt;typename _Ptr, typename _Deleter,\n\t       typename = typename __not_alloc_shared_tag&lt;_Deleter&gt;::type&gt;\n\t__shared_count(_Ptr __p, _Deleter __d)\n\t: __shared_count(__p, std::move(__d), allocator&lt;void&gt;())\n\t{ }\n\n      template&lt;typename _Ptr, typename _Deleter, typename _Alloc,\n\t       typename = typename __not_alloc_shared_tag&lt;_Deleter&gt;::type&gt;\n\t__shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)\n\t{\n\t  typedef _Sp_counted_deleter&lt;_Ptr, _Deleter, _Alloc, _Lp&gt; _Sp_cd_type;\n\t  __try\n\t    {\n\t      typename _Sp_cd_type::__allocator_type __a2(__a);\n\t      auto __guard = std::__allocate_guarded(__a2);\n\t      _Sp_cd_type* __mem = __guard.get();\n\t      ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));\n\t      _M_pi = __mem;\n\t      __guard = nullptr;\n\t    }\n\t  __catch(...)\n\t    {\n\t      __d(__p); // Call _Deleter on __p.\n\t      __throw_exception_again;\n\t    }\n\t}\n\n      template&lt;typename _Tp, typename _Alloc, typename... _Args&gt;\n\t__shared_count(_Tp*&amp; __p, _Sp_alloc_shared_tag&lt;_Alloc&gt; __a,\n\t\t       _Args&amp;&amp;... __args)\n\t{\n\t  typedef _Sp_counted_ptr_inplace&lt;_Tp, _Alloc, _Lp&gt; _Sp_cp_type;\n\t  typename _Sp_cp_type::__allocator_type __a2(__a._M_a);\n\t  auto __guard = std::__allocate_guarded(__a2);\n\t  _Sp_cp_type* __mem = __guard.get();\n\t  auto __pi = ::new (__mem)\n\t    _Sp_cp_type(__a._M_a, std::forward&lt;_Args&gt;(__args)...);\n\t  __guard = nullptr;\n\t  _M_pi = __pi;\n\t  __p = __pi-&gt;_M_ptr();\n\t}\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      // Special case for auto_ptr&lt;_Tp&gt; to provide the strong guarantee.\n      template&lt;typename _Tp&gt;\n        explicit\n\t__shared_count(std::auto_ptr&lt;_Tp&gt;&amp;&amp; __r);\n#pragma GCC diagnostic pop\n#endif\n\n      // Special case for unique_ptr&lt;_Tp,_Del&gt; to provide the strong guarantee.\n      template&lt;typename _Tp, typename _Del&gt;\n        explicit\n\t__shared_count(std::unique_ptr&lt;_Tp, _Del&gt;&amp;&amp; __r) : _M_pi(0)\n\t{\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 2415. Inconsistency between unique_ptr and shared_ptr\n\t  if (__r.get() == nullptr)\n\t    return;\n\n\t  using _Ptr = typename unique_ptr&lt;_Tp, _Del&gt;::pointer;\n\t  using _Del2 = typename conditional&lt;is_reference&lt;_Del&gt;::value,\n\t      reference_wrapper&lt;typename remove_reference&lt;_Del&gt;::type&gt;,\n\t      _Del&gt;::type;\n\t  using _Sp_cd_type\n\t    = _Sp_counted_deleter&lt;_Ptr, _Del2, allocator&lt;void&gt;, _Lp&gt;;\n\t  using _Alloc = allocator&lt;_Sp_cd_type&gt;;\n\t  using _Alloc_traits = allocator_traits&lt;_Alloc&gt;;\n\t  _Alloc __a;\n\t  _Sp_cd_type* __mem = _Alloc_traits::allocate(__a, 1);\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 3548. shared_ptr construction from unique_ptr should move\n\t  // (not copy) the deleter\n\t  _Alloc_traits::construct(__a, __mem, __r.release(),\n\t\t\t\t   std::forward&lt;_Del&gt;(__r.get_deleter()));\n\t  _M_pi = __mem;\n\t}\n\n      // Throw bad_weak_ptr when __r._M_get_use_count() == 0.\n      explicit __shared_count(const __weak_count&lt;_Lp&gt;&amp; __r);\n\n      // Does not throw if __r._M_get_use_count() == 0, caller must check.\n      explicit\n      __shared_count(const __weak_count&lt;_Lp&gt;&amp; __r, std::nothrow_t) noexcept;\n\n      ~__shared_count() noexcept\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_release();\n      }\n\n      __shared_count(const __shared_count&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_add_ref_copy();\n      }\n\n      __shared_count&amp;\n      operator=(const __shared_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\tif (__tmp != _M_pi)\n\t  {\n\t    if (__tmp != nullptr)\n\t      __tmp-&gt;_M_add_ref_copy();\n\t    if (_M_pi != nullptr)\n\t      _M_pi-&gt;_M_release();\n\t    _M_pi = __tmp;\n\t  }\n\treturn *this;\n      }\n\n      void\n      _M_swap(__shared_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\t__r._M_pi = _M_pi;\n\t_M_pi = __tmp;\n      }\n\n      long\n      _M_get_use_count() const noexcept\n      { return _M_pi ? _M_pi-&gt;_M_get_use_count() : 0; }\n\n      bool\n      _M_unique() const noexcept\n      { return this-&gt;_M_get_use_count() == 1; }\n\n      void*\n      _M_get_deleter(const std::type_info&amp; __ti) const noexcept\n      { return _M_pi ? _M_pi-&gt;_M_get_deleter(__ti) : nullptr; }\n\n      bool\n      _M_less(const __shared_count&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      bool\n      _M_less(const __weak_count&lt;_Lp&gt;&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      // Friend function injected into enclosing namespace and found by ADL\n      friend inline bool\n      operator==(const __shared_count&amp; __a, const __shared_count&amp; __b) noexcept\n      { return __a._M_pi == __b._M_pi; }\n\n    private:\n      friend class __weak_count&lt;_Lp&gt;;\n\n      _Sp_counted_base&lt;_Lp&gt;*  _M_pi;\n    };\n\n\n  template&lt;_Lock_policy _Lp&gt;\n    class __weak_count\n    {\n    public:\n      constexpr __weak_count() noexcept : _M_pi(nullptr)\n      { }\n\n      __weak_count(const __shared_count&lt;_Lp&gt;&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_add_ref();\n      }\n\n      __weak_count(const __weak_count&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_add_ref();\n      }\n\n      __weak_count(__weak_count&amp;&amp; __r) noexcept\n      : _M_pi(__r._M_pi)\n      { __r._M_pi = nullptr; }\n\n      ~__weak_count() noexcept\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n      }\n\n      __weak_count&amp;\n      operator=(const __shared_count&lt;_Lp&gt;&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\tif (__tmp != nullptr)\n\t  __tmp-&gt;_M_weak_add_ref();\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n\t_M_pi = __tmp;\n\treturn *this;\n      }\n\n      __weak_count&amp;\n      operator=(const __weak_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\tif (__tmp != nullptr)\n\t  __tmp-&gt;_M_weak_add_ref();\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n\t_M_pi = __tmp;\n\treturn *this;\n      }\n\n      __weak_count&amp;\n      operator=(__weak_count&amp;&amp; __r) noexcept\n      {\n\tif (_M_pi != nullptr)\n\t  _M_pi-&gt;_M_weak_release();\n\t_M_pi = __r._M_pi;\n        __r._M_pi = nullptr;\n\treturn *this;\n      }\n\n      void\n      _M_swap(__weak_count&amp; __r) noexcept\n      {\n\t_Sp_counted_base&lt;_Lp&gt;* __tmp = __r._M_pi;\n\t__r._M_pi = _M_pi;\n\t_M_pi = __tmp;\n      }\n\n      long\n      _M_get_use_count() const noexcept\n      { return _M_pi != nullptr ? _M_pi-&gt;_M_get_use_count() : 0; }\n\n      bool\n      _M_less(const __weak_count&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      bool\n      _M_less(const __shared_count&lt;_Lp&gt;&amp; __rhs) const noexcept\n      { return std::less&lt;_Sp_counted_base&lt;_Lp&gt;*&gt;()(this-&gt;_M_pi, __rhs._M_pi); }\n\n      // Friend function injected into enclosing namespace and found by ADL\n      friend inline bool\n      operator==(const __weak_count&amp; __a, const __weak_count&amp; __b) noexcept\n      { return __a._M_pi == __b._M_pi; }\n\n    private:\n      friend class __shared_count&lt;_Lp&gt;;\n\n      _Sp_counted_base&lt;_Lp&gt;*  _M_pi;\n    };\n\n  // Now that __weak_count is defined we can define this constructor:\n  template&lt;_Lock_policy _Lp&gt;\n    inline\n    __shared_count&lt;_Lp&gt;::__shared_count(const __weak_count&lt;_Lp&gt;&amp; __r)\n    : _M_pi(__r._M_pi)\n    {\n      if (_M_pi == nullptr || !_M_pi-&gt;_M_add_ref_lock_nothrow())\n\t__throw_bad_weak_ptr();\n    }\n\n  // Now that __weak_count is defined we can define this constructor:\n  template&lt;_Lock_policy _Lp&gt;\n    inline\n    __shared_count&lt;_Lp&gt;::\n    __shared_count(const __weak_count&lt;_Lp&gt;&amp; __r, std::nothrow_t) noexcept\n    : _M_pi(__r._M_pi)\n    {\n      if (_M_pi &amp;&amp; !_M_pi-&gt;_M_add_ref_lock_nothrow())\n\t_M_pi = nullptr;\n    }\n\n#define __cpp_lib_shared_ptr_arrays 201611L\n\n  // Helper traits for shared_ptr of array:\n\n  // A pointer type Y* is said to be compatible with a pointer type T* when\n  // either Y* is convertible to T* or Y is U[N] and T is U cv [].\n  template&lt;typename _Yp_ptr, typename _Tp_ptr&gt;\n    struct __sp_compatible_with\n    : false_type\n    { };\n\n  template&lt;typename _Yp, typename _Tp&gt;\n    struct __sp_compatible_with&lt;_Yp*, _Tp*&gt;\n    : is_convertible&lt;_Yp*, _Tp*&gt;::type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], _Up(*)[]&gt;\n    : true_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], const _Up(*)[]&gt;\n    : true_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], volatile _Up(*)[]&gt;\n    : true_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm&gt;\n    struct __sp_compatible_with&lt;_Up(*)[_Nm], const volatile _Up(*)[]&gt;\n    : true_type\n    { };\n\n  // Test conversion from Y(*)[N] to U(*)[N] without forming invalid type Y[N].\n  template&lt;typename _Up, size_t _Nm, typename _Yp, typename = void&gt;\n    struct __sp_is_constructible_arrN\n    : false_type\n    { };\n\n  template&lt;typename _Up, size_t _Nm, typename _Yp&gt;\n    struct __sp_is_constructible_arrN&lt;_Up, _Nm, _Yp, __void_t&lt;_Yp[_Nm]&gt;&gt;\n    : is_convertible&lt;_Yp(*)[_Nm], _Up(*)[_Nm]&gt;::type\n    { };\n\n  // Test conversion from Y(*)[] to U(*)[] without forming invalid type Y[].\n  template&lt;typename _Up, typename _Yp, typename = void&gt;\n    struct __sp_is_constructible_arr\n    : false_type\n    { };\n\n  template&lt;typename _Up, typename _Yp&gt;\n    struct __sp_is_constructible_arr&lt;_Up, _Yp, __void_t&lt;_Yp[]&gt;&gt;\n    : is_convertible&lt;_Yp(*)[], _Up(*)[]&gt;::type\n    { };\n\n  // Trait to check if shared_ptr&lt;T&gt; can be constructed from Y*.\n  template&lt;typename _Tp, typename _Yp&gt;\n    struct __sp_is_constructible;\n\n  // When T is U[N], Y(*)[N] shall be convertible to T*;\n  template&lt;typename _Up, size_t _Nm, typename _Yp&gt;\n    struct __sp_is_constructible&lt;_Up[_Nm], _Yp&gt;\n    : __sp_is_constructible_arrN&lt;_Up, _Nm, _Yp&gt;::type\n    { };\n\n  // when T is U[], Y(*)[] shall be convertible to T*;\n  template&lt;typename _Up, typename _Yp&gt;\n    struct __sp_is_constructible&lt;_Up[], _Yp&gt;\n    : __sp_is_constructible_arr&lt;_Up, _Yp&gt;::type\n    { };\n\n  // otherwise, Y* shall be convertible to T*.\n  template&lt;typename _Tp, typename _Yp&gt;\n    struct __sp_is_constructible\n    : is_convertible&lt;_Yp*, _Tp*&gt;::type\n    { };\n\n\n  // Define operator* and operator-&gt; for shared_ptr&lt;T&gt;.\n  template&lt;typename _Tp, _Lock_policy _Lp,\n\t   bool = is_array&lt;_Tp&gt;::value, bool = is_void&lt;_Tp&gt;::value&gt;\n    class __shared_ptr_access\n    {\n    public:\n      using element_type = _Tp;\n\n      element_type&amp;\n      operator*() const noexcept\n      {\n\t__glibcxx_assert(_M_get() != nullptr);\n\treturn *_M_get();\n      }\n\n      element_type*\n      operator-&gt;() const noexcept\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_get() != nullptr);\n\treturn _M_get();\n      }\n\n    private:\n      element_type*\n      _M_get() const noexcept\n      { return static_cast&lt;const __shared_ptr&lt;_Tp, _Lp&gt;*&gt;(this)-&gt;get(); }\n    };\n\n  // Define operator-&gt; for shared_ptr&lt;cv void&gt;.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __shared_ptr_access&lt;_Tp, _Lp, false, true&gt;\n    {\n    public:\n      using element_type = _Tp;\n\n      element_type*\n      operator-&gt;() const noexcept\n      {\n\tauto __ptr = static_cast&lt;const __shared_ptr&lt;_Tp, _Lp&gt;*&gt;(this)-&gt;get();\n\t_GLIBCXX_DEBUG_PEDASSERT(__ptr != nullptr);\n\treturn __ptr;\n      }\n    };\n\n  // Define operator[] for shared_ptr&lt;T[]&gt; and shared_ptr&lt;T[N]&gt;.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __shared_ptr_access&lt;_Tp, _Lp, true, false&gt;\n    {\n    public:\n      using element_type = typename remove_extent&lt;_Tp&gt;::type;\n\n#if __cplusplus &lt;= 201402L\n      [[__deprecated__(&quot;shared_ptr&lt;T[]&gt;::operator* is absent from C++17&quot;)]]\n      element_type&amp;\n      operator*() const noexcept\n      {\n\t__glibcxx_assert(_M_get() != nullptr);\n\treturn *_M_get();\n      }\n\n      [[__deprecated__(&quot;shared_ptr&lt;T[]&gt;::operator-&gt; is absent from C++17&quot;)]]\n      element_type*\n      operator-&gt;() const noexcept\n      {\n\t_GLIBCXX_DEBUG_PEDASSERT(_M_get() != nullptr);\n\treturn _M_get();\n      }\n#endif\n\n      element_type&amp;\n      operator[](ptrdiff_t __i) const\n      {\n\t__glibcxx_assert(_M_get() != nullptr);\n\t__glibcxx_assert(!extent&lt;_Tp&gt;::value || __i &lt; extent&lt;_Tp&gt;::value);\n\treturn _M_get()[__i];\n      }\n\n    private:\n      element_type*\n      _M_get() const noexcept\n      { return static_cast&lt;const __shared_ptr&lt;_Tp, _Lp&gt;*&gt;(this)-&gt;get(); }\n    };\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __shared_ptr\n    : public __shared_ptr_access&lt;_Tp, _Lp&gt;\n    {\n    public:\n      using element_type = typename remove_extent&lt;_Tp&gt;::type;\n\n    private:\n      // Constraint for taking ownership of a pointer of type _Yp*:\n      template&lt;typename _Yp&gt;\n\tusing _SafeConv\n\t  = typename enable_if&lt;__sp_is_constructible&lt;_Tp, _Yp&gt;::value&gt;::type;\n\n      // Constraint for construction from shared_ptr and weak_ptr:\n      template&lt;typename _Yp, typename _Res = void&gt;\n\tusing _Compatible = typename\n\t  enable_if&lt;__sp_compatible_with&lt;_Yp*, _Tp*&gt;::value, _Res&gt;::type;\n\n      // Constraint for assignment from shared_ptr and weak_ptr:\n      template&lt;typename _Yp&gt;\n\tusing _Assignable = _Compatible&lt;_Yp, __shared_ptr&amp;&gt;;\n\n      // Constraint for construction from unique_ptr:\n      template&lt;typename _Yp, typename _Del, typename _Res = void,\n\t       typename _Ptr = typename unique_ptr&lt;_Yp, _Del&gt;::pointer&gt;\n\tusing _UniqCompatible = __enable_if_t&lt;__and_&lt;\n\t  __sp_compatible_with&lt;_Yp*, _Tp*&gt;,\n\t  is_convertible&lt;_Ptr, element_type*&gt;,\n\t  is_move_constructible&lt;_Del&gt;\n\t  &gt;::value, _Res&gt;;\n\n      // Constraint for assignment from unique_ptr:\n      template&lt;typename _Yp, typename _Del&gt;\n\tusing _UniqAssignable = _UniqCompatible&lt;_Yp, _Del, __shared_ptr&amp;&gt;;\n\n    public:\n\n#if __cplusplus &gt; 201402L\n      using weak_type = __weak_ptr&lt;_Tp, _Lp&gt;;\n#endif\n\n      constexpr __shared_ptr() noexcept\n      : _M_ptr(0), _M_refcount()\n      { }\n\n      template&lt;typename _Yp, typename = _SafeConv&lt;_Yp&gt;&gt;\n\texplicit\n\t__shared_ptr(_Yp* __p)\n\t: _M_ptr(__p), _M_refcount(__p, typename is_array&lt;_Tp&gt;::type())\n\t{\n\t  static_assert( !is_void&lt;_Yp&gt;::value, &quot;incomplete type&quot; );\n\t  static_assert( sizeof(_Yp) &gt; 0, &quot;incomplete type&quot; );\n\t  _M_enable_shared_from_this_with(__p);\n\t}\n\n      template&lt;typename _Yp, typename _Deleter, typename = _SafeConv&lt;_Yp&gt;&gt;\n\t__shared_ptr(_Yp* __p, _Deleter __d)\n\t: _M_ptr(__p), _M_refcount(__p, std::move(__d))\n\t{\n\t  static_assert(__is_invocable&lt;_Deleter&amp;, _Yp*&amp;&gt;::value,\n\t      &quot;deleter expression d(p) is well-formed&quot;);\n\t  _M_enable_shared_from_this_with(__p);\n\t}\n\n      template&lt;typename _Yp, typename _Deleter, typename _Alloc,\n\t       typename = _SafeConv&lt;_Yp&gt;&gt;\n\t__shared_ptr(_Yp* __p, _Deleter __d, _Alloc __a)\n\t: _M_ptr(__p), _M_refcount(__p, std::move(__d), std::move(__a))\n\t{\n\t  static_assert(__is_invocable&lt;_Deleter&amp;, _Yp*&amp;&gt;::value,\n\t      &quot;deleter expression d(p) is well-formed&quot;);\n\t  _M_enable_shared_from_this_with(__p);\n\t}\n\n      template&lt;typename _Deleter&gt;\n\t__shared_ptr(nullptr_t __p, _Deleter __d)\n\t: _M_ptr(0), _M_refcount(__p, std::move(__d))\n\t{ }\n\n      template&lt;typename _Deleter, typename _Alloc&gt;\n        __shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)\n\t: _M_ptr(0), _M_refcount(__p, std::move(__d), std::move(__a))\n\t{ }\n\n      // Aliasing constructor\n      template&lt;typename _Yp&gt;\n\t__shared_ptr(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r,\n\t\t     element_type* __p) noexcept\n\t: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws\n\t{ }\n\n      // Aliasing constructor\n      template&lt;typename _Yp&gt;\n\t__shared_ptr(__shared_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r,\n\t\t     element_type* __p) noexcept\n\t: _M_ptr(__p), _M_refcount()\n\t{\n\t  _M_refcount._M_swap(__r._M_refcount);\n\t  __r._M_ptr = nullptr;\n\t}\n\n      __shared_ptr(const __shared_ptr&amp;) noexcept = default;\n      __shared_ptr&amp; operator=(const __shared_ptr&amp;) noexcept = default;\n      ~__shared_ptr() = default;\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__shared_ptr(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)\n\t{ }\n\n      __shared_ptr(__shared_ptr&amp;&amp; __r) noexcept\n      : _M_ptr(__r._M_ptr), _M_refcount()\n      {\n\t_M_refcount._M_swap(__r._M_refcount);\n\t__r._M_ptr = nullptr;\n      }\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__shared_ptr(__shared_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t: _M_ptr(__r._M_ptr), _M_refcount()\n\t{\n\t  _M_refcount._M_swap(__r._M_refcount);\n\t  __r._M_ptr = nullptr;\n\t}\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\texplicit __shared_ptr(const __weak_ptr&lt;_Yp, _Lp&gt;&amp; __r)\n\t: _M_refcount(__r._M_refcount) // may throw\n\t{\n\t  // It is now safe to copy __r._M_ptr, as\n\t  // _M_refcount(__r._M_refcount) did not throw.\n\t  _M_ptr = __r._M_ptr;\n\t}\n\n      // If an exception is thrown this constructor has no effect.\n      template&lt;typename _Yp, typename _Del,\n\t       typename = _UniqCompatible&lt;_Yp, _Del&gt;&gt;\n\t__shared_ptr(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t: _M_ptr(__r.get()), _M_refcount()\n\t{\n\t  auto __raw = __to_address(__r.get());\n\t  _M_refcount = __shared_count&lt;_Lp&gt;(std::move(__r));\n\t  _M_enable_shared_from_this_with(__raw);\n\t}\n\n#if __cplusplus &lt;= 201402L &amp;&amp; _GLIBCXX_USE_DEPRECATED\n    protected:\n      // If an exception is thrown this constructor has no effect.\n      template&lt;typename _Tp1, typename _Del,\n\t       typename enable_if&lt;__and_&lt;\n\t\t __not_&lt;is_array&lt;_Tp&gt;&gt;, is_array&lt;_Tp1&gt;,\n\t         is_convertible&lt;typename unique_ptr&lt;_Tp1, _Del&gt;::pointer, _Tp*&gt;\n\t       &gt;::value, bool&gt;::type = true&gt;\n\t__shared_ptr(unique_ptr&lt;_Tp1, _Del&gt;&amp;&amp; __r, __sp_array_delete)\n\t: _M_ptr(__r.get()), _M_refcount()\n\t{\n\t  auto __raw = __to_address(__r.get());\n\t  _M_refcount = __shared_count&lt;_Lp&gt;(std::move(__r));\n\t  _M_enable_shared_from_this_with(__raw);\n\t}\n    public:\n#endif\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      // Postcondition: use_count() == 1 and __r.get() == 0\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__shared_ptr(auto_ptr&lt;_Yp&gt;&amp;&amp; __r);\n#pragma GCC diagnostic pop\n#endif\n\n      constexpr __shared_ptr(nullptr_t) noexcept : __shared_ptr() { }\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r._M_ptr;\n\t  _M_refcount = __r._M_refcount; // __shared_count::op= doesn&#x27;t throw\n\t  return *this;\n\t}\n\n#if _GLIBCXX_USE_DEPRECATED\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(auto_ptr&lt;_Yp&gt;&amp;&amp; __r)\n\t{\n\t  __shared_ptr(std::move(__r)).swap(*this);\n\t  return *this;\n\t}\n#pragma GCC diagnostic pop\n#endif\n\n      __shared_ptr&amp;\n      operator=(__shared_ptr&amp;&amp; __r) noexcept\n      {\n\t__shared_ptr(std::move(__r)).swap(*this);\n\treturn *this;\n      }\n\n      template&lt;class _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(__shared_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  __shared_ptr(std::move(__r)).swap(*this);\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp, typename _Del&gt;\n\t_UniqAssignable&lt;_Yp, _Del&gt;\n\toperator=(unique_ptr&lt;_Yp, _Del&gt;&amp;&amp; __r)\n\t{\n\t  __shared_ptr(std::move(__r)).swap(*this);\n\t  return *this;\n\t}\n\n      void\n      reset() noexcept\n      { __shared_ptr().swap(*this); }\n\n      template&lt;typename _Yp&gt;\n\t_SafeConv&lt;_Yp&gt;\n\treset(_Yp* __p) // _Yp must be complete.\n\t{\n\t  // Catch self-reset errors.\n\t  __glibcxx_assert(__p == nullptr || __p != _M_ptr);\n\t  __shared_ptr(__p).swap(*this);\n\t}\n\n      template&lt;typename _Yp, typename _Deleter&gt;\n\t_SafeConv&lt;_Yp&gt;\n\treset(_Yp* __p, _Deleter __d)\n\t{ __shared_ptr(__p, std::move(__d)).swap(*this); }\n\n      template&lt;typename _Yp, typename _Deleter, typename _Alloc&gt;\n\t_SafeConv&lt;_Yp&gt;\n\treset(_Yp* __p, _Deleter __d, _Alloc __a)\n        { __shared_ptr(__p, std::move(__d), std::move(__a)).swap(*this); }\n\n      /// Return the stored pointer.\n      element_type*\n      get() const noexcept\n      { return _M_ptr; }\n\n      /// Return true if the stored pointer is not null.\n      explicit operator bool() const noexcept\n      { return _M_ptr != nullptr; }\n\n      /// Return true if use_count() == 1.\n      bool\n      unique() const noexcept\n      { return _M_refcount._M_unique(); }\n\n      /// If *this owns a pointer, return the number of owners, otherwise zero.\n      long\n      use_count() const noexcept\n      { return _M_refcount._M_get_use_count(); }\n\n      /// Exchange both the owned pointer and the stored pointer.\n      void\n      swap(__shared_ptr&lt;_Tp, _Lp&gt;&amp; __other) noexcept\n      {\n\tstd::swap(_M_ptr, __other._M_ptr);\n\t_M_refcount._M_swap(__other._M_refcount);\n      }\n\n      /** @brief Define an ordering based on ownership.\n       *\n       * This function defines a strict weak ordering between two shared_ptr\n       * or weak_ptr objects, such that one object is less than the other\n       * unless they share ownership of the same pointer, or are both empty.\n       * @{\n      */\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(__shared_ptr&lt;_Tp1, _Lp&gt; const&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(__weak_ptr&lt;_Tp1, _Lp&gt; const&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n      /// @}\n\n    protected:\n      // This constructor is non-standard, it is used by allocate_shared.\n      template&lt;typename _Alloc, typename... _Args&gt;\n\t__shared_ptr(_Sp_alloc_shared_tag&lt;_Alloc&gt; __tag, _Args&amp;&amp;... __args)\n\t: _M_ptr(), _M_refcount(_M_ptr, __tag, std::forward&lt;_Args&gt;(__args)...)\n\t{ _M_enable_shared_from_this_with(_M_ptr); }\n\n      template&lt;typename _Tp1, _Lock_policy _Lp1, typename _Alloc,\n\t       typename... _Args&gt;\n\tfriend __shared_ptr&lt;_Tp1, _Lp1&gt;\n\t__allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args);\n\n      // This constructor is used by __weak_ptr::lock() and\n      // shared_ptr::shared_ptr(const weak_ptr&amp;, std::nothrow_t).\n      __shared_ptr(const __weak_ptr&lt;_Tp, _Lp&gt;&amp; __r, std::nothrow_t) noexcept\n      : _M_refcount(__r._M_refcount, std::nothrow)\n      {\n\t_M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;\n      }\n\n      friend class __weak_ptr&lt;_Tp, _Lp&gt;;\n\n    private:\n\n      template&lt;typename _Yp&gt;\n\tusing __esft_base_t = decltype(__enable_shared_from_this_base(\n\t      std::declval&lt;const __shared_count&lt;_Lp&gt;&amp;&gt;(),\n\t      std::declval&lt;_Yp*&gt;()));\n\n      // Detect an accessible and unambiguous enable_shared_from_this base.\n      template&lt;typename _Yp, typename = void&gt;\n\tstruct __has_esft_base\n\t: false_type { };\n\n      template&lt;typename _Yp&gt;\n\tstruct __has_esft_base&lt;_Yp, __void_t&lt;__esft_base_t&lt;_Yp&gt;&gt;&gt;\n\t: __not_&lt;is_array&lt;_Tp&gt;&gt; { }; // No enable shared_from_this for arrays\n\n      template&lt;typename _Yp, typename _Yp2 = typename remove_cv&lt;_Yp&gt;::type&gt;\n\ttypename enable_if&lt;__has_esft_base&lt;_Yp2&gt;::value&gt;::type\n\t_M_enable_shared_from_this_with(_Yp* __p) noexcept\n\t{\n\t  if (auto __base = __enable_shared_from_this_base(_M_refcount, __p))\n\t    __base-&gt;_M_weak_assign(const_cast&lt;_Yp2*&gt;(__p), _M_refcount);\n\t}\n\n      template&lt;typename _Yp, typename _Yp2 = typename remove_cv&lt;_Yp&gt;::type&gt;\n\ttypename enable_if&lt;!__has_esft_base&lt;_Yp2&gt;::value&gt;::type\n\t_M_enable_shared_from_this_with(_Yp*) noexcept\n\t{ }\n\n      void*\n      _M_get_deleter(const std::type_info&amp; __ti) const noexcept\n      { return _M_refcount._M_get_deleter(__ti); }\n\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __shared_ptr;\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __weak_ptr;\n\n      template&lt;typename _Del, typename _Tp1, _Lock_policy _Lp1&gt;\n\tfriend _Del* get_deleter(const __shared_ptr&lt;_Tp1, _Lp1&gt;&amp;) noexcept;\n\n      template&lt;typename _Del, typename _Tp1&gt;\n\tfriend _Del* get_deleter(const shared_ptr&lt;_Tp1&gt;&amp;) noexcept;\n\n      element_type*\t   _M_ptr;         // Contained pointer.\n      __shared_count&lt;_Lp&gt;  _M_refcount;    // Reference counter.\n    };\n\n\n  // 20.7.2.2.7 shared_ptr comparisons\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator==(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return __a.get() == __b.get(); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator==(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return !__a; }\n\n#ifdef __cpp_lib_three_way_comparison\n  template&lt;typename _Tp, typename _Up, _Lock_policy _Lp&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a,\n\t\tconst __shared_ptr&lt;_Up, _Lp&gt;&amp; __b) noexcept\n    { return compare_three_way()(__a.get(), __b.get()); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline strong_ordering\n    operator&lt;=&gt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using pointer = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type*;\n      return compare_three_way()(__a.get(), static_cast&lt;pointer&gt;(nullptr));\n    }\n#else\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator==(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return !__a; }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator!=(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return __a.get() != __b.get(); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator!=(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return (bool)__a; }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator!=(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return (bool)__a; }\n\n  template&lt;typename _Tp, typename _Up, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a,\n\t      const __shared_ptr&lt;_Up, _Lp&gt;&amp; __b) noexcept\n    {\n      using _Tp_elt = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type;\n      using _Up_elt = typename __shared_ptr&lt;_Up, _Lp&gt;::element_type;\n      using _Vp = typename common_type&lt;_Tp_elt*, _Up_elt*&gt;::type;\n      return less&lt;_Vp&gt;()(__a.get(), __b.get());\n    }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    {\n      using _Tp_elt = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(__a.get(), nullptr);\n    }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    {\n      using _Tp_elt = typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type;\n      return less&lt;_Tp_elt*&gt;()(nullptr, __a.get());\n    }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;=(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return !(__b &lt; __a); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;=(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(nullptr &lt; __a); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&lt;=(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return !(__a &lt; nullptr); }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t      const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return (__b &lt; __a); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return nullptr &lt; __a; }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return __a &lt; nullptr; }\n\n  template&lt;typename _Tp1, typename _Tp2, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;=(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __a,\n\t       const __shared_ptr&lt;_Tp2, _Lp&gt;&amp; __b) noexcept\n    { return !(__a &lt; __b); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;=(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, nullptr_t) noexcept\n    { return !(__a &lt; nullptr); }\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline bool\n    operator&gt;=(nullptr_t, const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __a) noexcept\n    { return !(nullptr &lt; __a); }\n#endif // three-way comparison\n\n  // 20.7.2.2.8 shared_ptr specialized algorithms.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline void\n    swap(__shared_ptr&lt;_Tp, _Lp&gt;&amp; __a, __shared_ptr&lt;_Tp, _Lp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n  // 20.7.2.2.9 shared_ptr casts\n\n  // The seemingly equivalent code:\n  // shared_ptr&lt;_Tp, _Lp&gt;(static_cast&lt;_Tp*&gt;(__r.get()))\n  // will eventually result in undefined behaviour, attempting to\n  // delete the same object twice.\n  /// static_pointer_cast\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    static_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      return _Sp(__r, static_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  // The seemingly equivalent code:\n  // shared_ptr&lt;_Tp, _Lp&gt;(const_cast&lt;_Tp*&gt;(__r.get()))\n  // will eventually result in undefined behaviour, attempting to\n  // delete the same object twice.\n  /// const_pointer_cast\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    const_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      return _Sp(__r, const_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n\n  // The seemingly equivalent code:\n  // shared_ptr&lt;_Tp, _Lp&gt;(dynamic_cast&lt;_Tp*&gt;(__r.get()))\n  // will eventually result in undefined behaviour, attempting to\n  // delete the same object twice.\n  /// dynamic_pointer_cast\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    dynamic_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      if (auto* __p = dynamic_cast&lt;typename _Sp::element_type*&gt;(__r.get()))\n\treturn _Sp(__r, __p);\n      return _Sp();\n    }\n\n#if __cplusplus &gt; 201402L\n  template&lt;typename _Tp, typename _Tp1, _Lock_policy _Lp&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    reinterpret_pointer_cast(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __r) noexcept\n    {\n      using _Sp = __shared_ptr&lt;_Tp, _Lp&gt;;\n      return _Sp(__r, reinterpret_cast&lt;typename _Sp::element_type*&gt;(__r.get()));\n    }\n#endif\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __weak_ptr\n    {\n      template&lt;typename _Yp, typename _Res = void&gt;\n\tusing _Compatible = typename\n\t  enable_if&lt;__sp_compatible_with&lt;_Yp*, _Tp*&gt;::value, _Res&gt;::type;\n\n      // Constraint for assignment from shared_ptr and weak_ptr:\n      template&lt;typename _Yp&gt;\n\tusing _Assignable = _Compatible&lt;_Yp, __weak_ptr&amp;&gt;;\n\n    public:\n      using element_type = typename remove_extent&lt;_Tp&gt;::type;\n\n      constexpr __weak_ptr() noexcept\n      : _M_ptr(nullptr), _M_refcount()\n      { }\n\n      __weak_ptr(const __weak_ptr&amp;) noexcept = default;\n\n      ~__weak_ptr() = default;\n\n      // The &quot;obvious&quot; converting constructor implementation:\n      //\n      //  template&lt;typename _Tp1&gt;\n      //    __weak_ptr(const __weak_ptr&lt;_Tp1, _Lp&gt;&amp; __r)\n      //    : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount) // never throws\n      //    { }\n      //\n      // has a serious problem.\n      //\n      //  __r._M_ptr may already have been invalidated. The _M_ptr(__r._M_ptr)\n      //  conversion may require access to *__r._M_ptr (virtual inheritance).\n      //\n      // It is not possible to avoid spurious access violations since\n      // in multithreaded programs __r._M_ptr may be invalidated at any point.\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__weak_ptr(const __weak_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t: _M_refcount(__r._M_refcount)\n        { _M_ptr = __r.lock().get(); }\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__weak_ptr(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)\n\t{ }\n\n      __weak_ptr(__weak_ptr&amp;&amp; __r) noexcept\n      : _M_ptr(__r._M_ptr), _M_refcount(std::move(__r._M_refcount))\n      { __r._M_ptr = nullptr; }\n\n      template&lt;typename _Yp, typename = _Compatible&lt;_Yp&gt;&gt;\n\t__weak_ptr(__weak_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t: _M_ptr(__r.lock().get()), _M_refcount(std::move(__r._M_refcount))\n        { __r._M_ptr = nullptr; }\n\n      __weak_ptr&amp;\n      operator=(const __weak_ptr&amp; __r) noexcept = default;\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(const __weak_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r.lock().get();\n\t  _M_refcount = __r._M_refcount;\n\t  return *this;\n\t}\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(const __shared_ptr&lt;_Yp, _Lp&gt;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r._M_ptr;\n\t  _M_refcount = __r._M_refcount;\n\t  return *this;\n\t}\n\n      __weak_ptr&amp;\n      operator=(__weak_ptr&amp;&amp; __r) noexcept\n      {\n\t_M_ptr = __r._M_ptr;\n\t_M_refcount = std::move(__r._M_refcount);\n\t__r._M_ptr = nullptr;\n\treturn *this;\n      }\n\n      template&lt;typename _Yp&gt;\n\t_Assignable&lt;_Yp&gt;\n\toperator=(__weak_ptr&lt;_Yp, _Lp&gt;&amp;&amp; __r) noexcept\n\t{\n\t  _M_ptr = __r.lock().get();\n\t  _M_refcount = std::move(__r._M_refcount);\n\t  __r._M_ptr = nullptr;\n\t  return *this;\n\t}\n\n      __shared_ptr&lt;_Tp, _Lp&gt;\n      lock() const noexcept\n      { return __shared_ptr&lt;element_type, _Lp&gt;(*this, std::nothrow); }\n\n      long\n      use_count() const noexcept\n      { return _M_refcount._M_get_use_count(); }\n\n      bool\n      expired() const noexcept\n      { return _M_refcount._M_get_use_count() == 0; }\n\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(const __shared_ptr&lt;_Tp1, _Lp&gt;&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n\n      template&lt;typename _Tp1&gt;\n\tbool\n\towner_before(const __weak_ptr&lt;_Tp1, _Lp&gt;&amp; __rhs) const noexcept\n\t{ return _M_refcount._M_less(__rhs._M_refcount); }\n\n      void\n      reset() noexcept\n      { __weak_ptr().swap(*this); }\n\n      void\n      swap(__weak_ptr&amp; __s) noexcept\n      {\n\tstd::swap(_M_ptr, __s._M_ptr);\n\t_M_refcount._M_swap(__s._M_refcount);\n      }\n\n    private:\n      // Used by __enable_shared_from_this.\n      void\n      _M_assign(_Tp* __ptr, const __shared_count&lt;_Lp&gt;&amp; __refcount) noexcept\n      {\n\tif (use_count() == 0)\n\t  {\n\t    _M_ptr = __ptr;\n\t    _M_refcount = __refcount;\n\t  }\n      }\n\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __shared_ptr;\n      template&lt;typename _Tp1, _Lock_policy _Lp1&gt; friend class __weak_ptr;\n      friend class __enable_shared_from_this&lt;_Tp, _Lp&gt;;\n      friend class enable_shared_from_this&lt;_Tp&gt;;\n\n      element_type*\t _M_ptr;         // Contained pointer.\n      __weak_count&lt;_Lp&gt;  _M_refcount;    // Reference counter.\n    };\n\n  // 20.7.2.3.6 weak_ptr specialized algorithms.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    inline void\n    swap(__weak_ptr&lt;_Tp, _Lp&gt;&amp; __a, __weak_ptr&lt;_Tp, _Lp&gt;&amp; __b) noexcept\n    { __a.swap(__b); }\n\n  template&lt;typename _Tp, typename _Tp1&gt;\n    struct _Sp_owner_less : public binary_function&lt;_Tp, _Tp, bool&gt;\n    {\n      bool\n      operator()(const _Tp&amp; __lhs, const _Tp&amp; __rhs) const noexcept\n      { return __lhs.owner_before(__rhs); }\n\n      bool\n      operator()(const _Tp&amp; __lhs, const _Tp1&amp; __rhs) const noexcept\n      { return __lhs.owner_before(__rhs); }\n\n      bool\n      operator()(const _Tp1&amp; __lhs, const _Tp&amp; __rhs) const noexcept\n      { return __lhs.owner_before(__rhs); }\n    };\n\n  template&lt;&gt;\n    struct _Sp_owner_less&lt;void, void&gt;\n    {\n      template&lt;typename _Tp, typename _Up&gt;\n\tauto\n\toperator()(const _Tp&amp; __lhs, const _Up&amp; __rhs) const noexcept\n\t-&gt; decltype(__lhs.owner_before(__rhs))\n\t{ return __lhs.owner_before(__rhs); }\n\n      using is_transparent = void;\n    };\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    struct owner_less&lt;__shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    : public _Sp_owner_less&lt;__shared_ptr&lt;_Tp, _Lp&gt;, __weak_ptr&lt;_Tp, _Lp&gt;&gt;\n    { };\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    struct owner_less&lt;__weak_ptr&lt;_Tp, _Lp&gt;&gt;\n    : public _Sp_owner_less&lt;__weak_ptr&lt;_Tp, _Lp&gt;, __shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    { };\n\n\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __enable_shared_from_this\n    {\n    protected:\n      constexpr __enable_shared_from_this() noexcept { }\n\n      __enable_shared_from_this(const __enable_shared_from_this&amp;) noexcept { }\n\n      __enable_shared_from_this&amp;\n      operator=(const __enable_shared_from_this&amp;) noexcept\n      { return *this; }\n\n      ~__enable_shared_from_this() { }\n\n    public:\n      __shared_ptr&lt;_Tp, _Lp&gt;\n      shared_from_this()\n      { return __shared_ptr&lt;_Tp, _Lp&gt;(this-&gt;_M_weak_this); }\n\n      __shared_ptr&lt;const _Tp, _Lp&gt;\n      shared_from_this() const\n      { return __shared_ptr&lt;const _Tp, _Lp&gt;(this-&gt;_M_weak_this); }\n\n#if __cplusplus &gt; 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11\n      __weak_ptr&lt;_Tp, _Lp&gt;\n      weak_from_this() noexcept\n      { return this-&gt;_M_weak_this; }\n\n      __weak_ptr&lt;const _Tp, _Lp&gt;\n      weak_from_this() const noexcept\n      { return this-&gt;_M_weak_this; }\n#endif\n\n    private:\n      template&lt;typename _Tp1&gt;\n\tvoid\n\t_M_weak_assign(_Tp1* __p, const __shared_count&lt;_Lp&gt;&amp; __n) const noexcept\n\t{ _M_weak_this._M_assign(__p, __n); }\n\n      friend const __enable_shared_from_this*\n      __enable_shared_from_this_base(const __shared_count&lt;_Lp&gt;&amp;,\n\t\t\t\t     const __enable_shared_from_this* __p)\n      { return __p; }\n\n      template&lt;typename, _Lock_policy&gt;\n\tfriend class __shared_ptr;\n\n      mutable __weak_ptr&lt;_Tp, _Lp&gt;  _M_weak_this;\n    };\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy,\n\t   typename _Alloc, typename... _Args&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    __allocate_shared(const _Alloc&amp; __a, _Args&amp;&amp;... __args)\n    {\n      static_assert(!is_array&lt;_Tp&gt;::value, &quot;make_shared&lt;T[]&gt; not supported&quot;);\n\n      return __shared_ptr&lt;_Tp, _Lp&gt;(_Sp_alloc_shared_tag&lt;_Alloc&gt;{__a},\n\t\t\t\t    std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  template&lt;typename _Tp, _Lock_policy _Lp = __default_lock_policy,\n\t   typename... _Args&gt;\n    inline __shared_ptr&lt;_Tp, _Lp&gt;\n    __make_shared(_Args&amp;&amp;... __args)\n    {\n      typedef typename std::remove_const&lt;_Tp&gt;::type _Tp_nc;\n      return std::__allocate_shared&lt;_Tp, _Lp&gt;(std::allocator&lt;_Tp_nc&gt;(),\n\t\t\t\t\t      std::forward&lt;_Args&gt;(__args)...);\n    }\n\n  /// std::hash specialization for __shared_ptr.\n  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    struct hash&lt;__shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    : public __hash_base&lt;size_t, __shared_ptr&lt;_Tp, _Lp&gt;&gt;\n    {\n      size_t\n      operator()(const __shared_ptr&lt;_Tp, _Lp&gt;&amp; __s) const noexcept\n      {\n\treturn hash&lt;typename __shared_ptr&lt;_Tp, _Lp&gt;::element_type*&gt;()(\n\t    __s.get());\n      }\n    };\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif // _SHARED_PTR_BASE_H\n"}, "/usr/include/c++/11/bits/alloc_traits.h": {"id": "/usr/include/c++/11/bits/alloc_traits.h", "filePath": "/usr/include/c++/11/bits/alloc_traits.h", "content": "// Allocator traits -*- C++ -*-\n\n// Copyright (C) 2011-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n/** @file bits/alloc_traits.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{memory}\n */\n\n#ifndef _ALLOC_TRAITS_H\n#define _ALLOC_TRAITS_H 1\n\n#include &lt;bits/stl_construct.h&gt;\n#include &lt;bits/memoryfwd.h&gt;\n#if __cplusplus &gt;= 201103L\n# include &lt;bits/allocator.h&gt;\n# include &lt;bits/ptr_traits.h&gt;\n# include &lt;ext/numeric_traits.h&gt;\n#endif\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#if __cplusplus &gt;= 201103L\n#define __cpp_lib_allocator_traits_is_always_equal 201411\n\n  /// @cond undocumented\n  struct __allocator_traits_base\n  {\n    template&lt;typename _Tp, typename _Up, typename = void&gt;\n      struct __rebind : __replace_first_arg&lt;_Tp, _Up&gt; { };\n\n    template&lt;typename _Tp, typename _Up&gt;\n      struct __rebind&lt;_Tp, _Up,\n\t\t      __void_t&lt;typename _Tp::template rebind&lt;_Up&gt;::other&gt;&gt;\n      { using type = typename _Tp::template rebind&lt;_Up&gt;::other; };\n\n  protected:\n    template&lt;typename _Tp&gt;\n      using __pointer = typename _Tp::pointer;\n    template&lt;typename _Tp&gt;\n      using __c_pointer = typename _Tp::const_pointer;\n    template&lt;typename _Tp&gt;\n      using __v_pointer = typename _Tp::void_pointer;\n    template&lt;typename _Tp&gt;\n      using __cv_pointer = typename _Tp::const_void_pointer;\n    template&lt;typename _Tp&gt;\n      using __pocca = typename _Tp::propagate_on_container_copy_assignment;\n    template&lt;typename _Tp&gt;\n      using __pocma = typename _Tp::propagate_on_container_move_assignment;\n    template&lt;typename _Tp&gt;\n      using __pocs = typename _Tp::propagate_on_container_swap;\n    template&lt;typename _Tp&gt;\n      using __equal = typename _Tp::is_always_equal;\n  };\n\n  template&lt;typename _Alloc, typename _Up&gt;\n    using __alloc_rebind\n      = typename __allocator_traits_base::template __rebind&lt;_Alloc, _Up&gt;::type;\n  /// @endcond\n\n  /**\n   * @brief  Uniform interface to all allocator types.\n   * @headerfile memory\n   * @ingroup allocators\n   * @since C++11\n  */\n  template&lt;typename _Alloc&gt;\n    struct allocator_traits : __allocator_traits_base\n    {\n      /// The allocator type\n      typedef _Alloc allocator_type;\n      /// The allocated type\n      typedef typename _Alloc::value_type value_type;\n\n      /**\n       * @brief   The allocator&#x27;s pointer type.\n       *\n       * @c Alloc::pointer if that type exists, otherwise @c value_type*\n      */\n      using pointer = __detected_or_t&lt;value_type*, __pointer, _Alloc&gt;;\n\n    private:\n      // Select _Func&lt;_Alloc&gt; or pointer_traits&lt;pointer&gt;::rebind&lt;_Tp&gt;\n      template&lt;template&lt;typename&gt; class _Func, typename _Tp, typename = void&gt;\n\tstruct _Ptr\n\t{\n\t  using type = typename pointer_traits&lt;pointer&gt;::template rebind&lt;_Tp&gt;;\n\t};\n\n      template&lt;template&lt;typename&gt; class _Func, typename _Tp&gt;\n\tstruct _Ptr&lt;_Func, _Tp, __void_t&lt;_Func&lt;_Alloc&gt;&gt;&gt;\n\t{\n\t  using type = _Func&lt;_Alloc&gt;;\n\t};\n\n      // Select _A2::difference_type or pointer_traits&lt;_Ptr&gt;::difference_type\n      template&lt;typename _A2, typename _PtrT, typename = void&gt;\n\tstruct _Diff\n\t{ using type = typename pointer_traits&lt;_PtrT&gt;::difference_type; };\n\n      template&lt;typename _A2, typename _PtrT&gt;\n\tstruct _Diff&lt;_A2, _PtrT, __void_t&lt;typename _A2::difference_type&gt;&gt;\n\t{ using type = typename _A2::difference_type; };\n\n      // Select _A2::size_type or make_unsigned&lt;_DiffT&gt;::type\n      template&lt;typename _A2, typename _DiffT, typename = void&gt;\n\tstruct _Size : make_unsigned&lt;_DiffT&gt; { };\n\n      template&lt;typename _A2, typename _DiffT&gt;\n\tstruct _Size&lt;_A2, _DiffT, __void_t&lt;typename _A2::size_type&gt;&gt;\n\t{ using type = typename _A2::size_type; };\n\n    public:\n      /**\n       * @brief   The allocator&#x27;s const pointer type.\n       *\n       * @c Alloc::const_pointer if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::rebind&lt;const value_type&gt; &lt;/tt&gt;\n      */\n      using const_pointer = typename _Ptr&lt;__c_pointer, const value_type&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s void pointer type.\n       *\n       * @c Alloc::void_pointer if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::rebind&lt;void&gt; &lt;/tt&gt;\n      */\n      using void_pointer = typename _Ptr&lt;__v_pointer, void&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s const void pointer type.\n       *\n       * @c Alloc::const_void_pointer if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::rebind&lt;const void&gt; &lt;/tt&gt;\n      */\n      using const_void_pointer = typename _Ptr&lt;__cv_pointer, const void&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s difference type\n       *\n       * @c Alloc::difference_type if that type exists, otherwise\n       * &lt;tt&gt; pointer_traits&lt;pointer&gt;::difference_type &lt;/tt&gt;\n      */\n      using difference_type = typename _Diff&lt;_Alloc, pointer&gt;::type;\n\n      /**\n       * @brief   The allocator&#x27;s size type\n       *\n       * @c Alloc::size_type if that type exists, otherwise\n       * &lt;tt&gt; make_unsigned&lt;difference_type&gt;::type &lt;/tt&gt;\n      */\n      using size_type = typename _Size&lt;_Alloc, difference_type&gt;::type;\n\n      /**\n       * @brief   How the allocator is propagated on copy assignment\n       *\n       * @c Alloc::propagate_on_container_copy_assignment if that type exists,\n       * otherwise @c false_type\n      */\n      using propagate_on_container_copy_assignment\n\t= __detected_or_t&lt;false_type, __pocca, _Alloc&gt;;\n\n      /**\n       * @brief   How the allocator is propagated on move assignment\n       *\n       * @c Alloc::propagate_on_container_move_assignment if that type exists,\n       * otherwise @c false_type\n      */\n      using propagate_on_container_move_assignment\n\t= __detected_or_t&lt;false_type, __pocma, _Alloc&gt;;\n\n      /**\n       * @brief   How the allocator is propagated on swap\n       *\n       * @c Alloc::propagate_on_container_swap if that type exists,\n       * otherwise @c false_type\n      */\n      using propagate_on_container_swap\n\t= __detected_or_t&lt;false_type, __pocs, _Alloc&gt;;\n\n      /**\n       * @brief   Whether all instances of the allocator type compare equal.\n       *\n       * @c Alloc::is_always_equal if that type exists,\n       * otherwise @c is_empty&lt;Alloc&gt;::type\n      */\n      using is_always_equal\n\t= __detected_or_t&lt;typename is_empty&lt;_Alloc&gt;::type, __equal, _Alloc&gt;;\n\n      template&lt;typename _Tp&gt;\n\tusing rebind_alloc = __alloc_rebind&lt;_Alloc, _Tp&gt;;\n      template&lt;typename _Tp&gt;\n\tusing rebind_traits = allocator_traits&lt;rebind_alloc&lt;_Tp&gt;&gt;;\n\n    private:\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr auto\n\t_S_allocate(_Alloc2&amp; __a, size_type __n, const_void_pointer __hint, int)\n\t-&gt; decltype(__a.allocate(__n, __hint))\n\t{ return __a.allocate(__n, __hint); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr pointer\n\t_S_allocate(_Alloc2&amp; __a, size_type __n, const_void_pointer, ...)\n\t{ return __a.allocate(__n); }\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstruct __construct_helper\n\t{\n\t  template&lt;typename _Alloc2,\n\t    typename = decltype(std::declval&lt;_Alloc2*&gt;()-&gt;construct(\n\t\t  std::declval&lt;_Tp*&gt;(), std::declval&lt;_Args&gt;()...))&gt;\n\t    static true_type __test(int);\n\n\t  template&lt;typename&gt;\n\t    static false_type __test(...);\n\n\t  using type = decltype(__test&lt;_Alloc&gt;(0));\n\t};\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tusing __has_construct\n\t  = typename __construct_helper&lt;_Tp, _Args...&gt;::type;\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstatic _GLIBCXX14_CONSTEXPR _Require&lt;__has_construct&lt;_Tp, _Args...&gt;&gt;\n\t_S_construct(_Alloc&amp; __a, _Tp* __p, _Args&amp;&amp;... __args)\n\tnoexcept(noexcept(__a.construct(__p, std::forward&lt;_Args&gt;(__args)...)))\n\t{ __a.construct(__p, std::forward&lt;_Args&gt;(__args)...); }\n\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstatic _GLIBCXX14_CONSTEXPR\n\t_Require&lt;__and_&lt;__not_&lt;__has_construct&lt;_Tp, _Args...&gt;&gt;,\n\t\t\t       is_constructible&lt;_Tp, _Args...&gt;&gt;&gt;\n\t_S_construct(_Alloc&amp;, _Tp* __p, _Args&amp;&amp;... __args)\n\tnoexcept(std::is_nothrow_constructible&lt;_Tp, _Args...&gt;::value)\n\t{\n#if __cplusplus &lt;= 201703L\n\t  ::new((void*)__p) _Tp(std::forward&lt;_Args&gt;(__args)...);\n#else\n\t  std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...);\n#endif\n\t}\n\n      template&lt;typename _Alloc2, typename _Tp&gt;\n\tstatic _GLIBCXX14_CONSTEXPR auto\n\t_S_destroy(_Alloc2&amp; __a, _Tp* __p, int)\n\tnoexcept(noexcept(__a.destroy(__p)))\n\t-&gt; decltype(__a.destroy(__p))\n\t{ __a.destroy(__p); }\n\n      template&lt;typename _Alloc2, typename _Tp&gt;\n\tstatic _GLIBCXX14_CONSTEXPR void\n\t_S_destroy(_Alloc2&amp;, _Tp* __p, ...)\n\tnoexcept(std::is_nothrow_destructible&lt;_Tp&gt;::value)\n\t{ std::_Destroy(__p); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr auto\n\t_S_max_size(_Alloc2&amp; __a, int)\n\t-&gt; decltype(__a.max_size())\n\t{ return __a.max_size(); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr size_type\n\t_S_max_size(_Alloc2&amp;, ...)\n\t{\n\t  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t  // 2466. allocator_traits::max_size() default behavior is incorrect\n\t  return __gnu_cxx::__numeric_traits&lt;size_type&gt;::__max\n\t    / sizeof(value_type);\n\t}\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr auto\n\t_S_select(_Alloc2&amp; __a, int)\n\t-&gt; decltype(__a.select_on_container_copy_construction())\n\t{ return __a.select_on_container_copy_construction(); }\n\n      template&lt;typename _Alloc2&gt;\n\tstatic constexpr _Alloc2\n\t_S_select(_Alloc2&amp; __a, ...)\n\t{ return __a; }\n\n    public:\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *\n       *  Calls @c a.allocate(n)\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(_Alloc&amp; __a, size_type __n)\n      { return __a.allocate(__n); }\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *  @param  __hint Aid to locality.\n       *  @return Memory of suitable size and alignment for @a n objects\n       *          of type @c value_type\n       *\n       *  Returns &lt;tt&gt; a.allocate(n, hint) &lt;/tt&gt; if that expression is\n       *  well-formed, otherwise returns @c a.allocate(n)\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(_Alloc&amp; __a, size_type __n, const_void_pointer __hint)\n      { return _S_allocate(__a, __n, __hint, 0); }\n\n      /**\n       *  @brief  Deallocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the memory to deallocate.\n       *  @param  __n  The number of objects space was allocated for.\n       *\n       *  Calls &lt;tt&gt; a.deallocate(p, n) &lt;/tt&gt;\n      */\n      static _GLIBCXX20_CONSTEXPR void\n      deallocate(_Alloc&amp; __a, pointer __p, size_type __n)\n      { __a.deallocate(__p, __n); }\n\n      /**\n       *  @brief  Construct an object of type `_Tp`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to memory of suitable size and alignment for Tp\n       *  @param  __args Constructor arguments.\n       *\n       *  Calls &lt;tt&gt; __a.construct(__p, std::forward&lt;Args&gt;(__args)...) &lt;/tt&gt;\n       *  if that expression is well-formed, otherwise uses placement-new\n       *  to construct an object of type @a _Tp at location @a __p from the\n       *  arguments @a __args...\n      */\n      template&lt;typename _Tp, typename... _Args&gt;\n\tstatic _GLIBCXX20_CONSTEXPR auto\n\tconstruct(_Alloc&amp; __a, _Tp* __p, _Args&amp;&amp;... __args)\n\tnoexcept(noexcept(_S_construct(__a, __p,\n\t\t\t\t       std::forward&lt;_Args&gt;(__args)...)))\n\t-&gt; decltype(_S_construct(__a, __p, std::forward&lt;_Args&gt;(__args)...))\n\t{ _S_construct(__a, __p, std::forward&lt;_Args&gt;(__args)...); }\n\n      /**\n       *  @brief  Destroy an object of type @a _Tp\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the object to destroy\n       *\n       *  Calls @c __a.destroy(__p) if that expression is well-formed,\n       *  otherwise calls @c __p-&gt;~_Tp()\n      */\n      template&lt;typename _Tp&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tdestroy(_Alloc&amp; __a, _Tp* __p)\n\tnoexcept(noexcept(_S_destroy(__a, __p, 0)))\n\t{ _S_destroy(__a, __p, 0); }\n\n      /**\n       *  @brief  The maximum supported allocation size\n       *  @param  __a  An allocator.\n       *  @return @c __a.max_size() or @c numeric_limits&lt;size_type&gt;::max()\n       *\n       *  Returns @c __a.max_size() if that expression is well-formed,\n       *  otherwise returns @c numeric_limits&lt;size_type&gt;::max()\n      */\n      static _GLIBCXX20_CONSTEXPR size_type\n      max_size(const _Alloc&amp; __a) noexcept\n      { return _S_max_size(__a, 0); }\n\n      /**\n       *  @brief  Obtain an allocator to use when copying a container.\n       *  @param  __rhs  An allocator.\n       *  @return @c __rhs.select_on_container_copy_construction() or @a __rhs\n       *\n       *  Returns @c __rhs.select_on_container_copy_construction() if that\n       *  expression is well-formed, otherwise returns @a __rhs\n      */\n      static _GLIBCXX20_CONSTEXPR _Alloc\n      select_on_container_copy_construction(const _Alloc&amp; __rhs)\n      { return _S_select(__rhs, 0); }\n    };\n\n#if __cplusplus &gt; 201703L\n# define __cpp_lib_constexpr_dynamic_alloc 201907L\n#endif\n\n  /// Partial specialization for std::allocator.\n  template&lt;typename _Tp&gt;\n    struct allocator_traits&lt;allocator&lt;_Tp&gt;&gt;\n    {\n      /// The allocator type\n      using allocator_type = allocator&lt;_Tp&gt;;\n\n      /// The allocated type\n      using value_type = _Tp;\n\n      /// The allocator&#x27;s pointer type.\n      using pointer = _Tp*;\n\n      /// The allocator&#x27;s const pointer type.\n      using const_pointer = const _Tp*;\n\n      /// The allocator&#x27;s void pointer type.\n      using void_pointer = void*;\n\n      /// The allocator&#x27;s const void pointer type.\n      using const_void_pointer = const void*;\n\n      /// The allocator&#x27;s difference type\n      using difference_type = std::ptrdiff_t;\n\n      /// The allocator&#x27;s size type\n      using size_type = std::size_t;\n\n      /// How the allocator is propagated on copy assignment\n      using propagate_on_container_copy_assignment = false_type;\n\n      /// How the allocator is propagated on move assignment\n      using propagate_on_container_move_assignment = true_type;\n\n      /// How the allocator is propagated on swap\n      using propagate_on_container_swap = false_type;\n\n      /// Whether all instances of the allocator type compare equal.\n      using is_always_equal = true_type;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_alloc = allocator&lt;_Up&gt;;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_traits = allocator_traits&lt;allocator&lt;_Up&gt;&gt;;\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *\n       *  Calls @c a.allocate(n)\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(allocator_type&amp; __a, size_type __n)\n      { return __a.allocate(__n); }\n\n      /**\n       *  @brief  Allocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __n  The number of objects to allocate space for.\n       *  @param  __hint Aid to locality.\n       *  @return Memory of suitable size and alignment for @a n objects\n       *          of type @c value_type\n       *\n       *  Returns &lt;tt&gt; a.allocate(n, hint) &lt;/tt&gt;\n      */\n      _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer\n      allocate(allocator_type&amp; __a, size_type __n, const_void_pointer __hint)\n      {\n#if __cplusplus &lt;= 201703L\n\treturn __a.allocate(__n, __hint);\n#else\n\treturn __a.allocate(__n);\n#endif\n      }\n\n      /**\n       *  @brief  Deallocate memory.\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the memory to deallocate.\n       *  @param  __n  The number of objects space was allocated for.\n       *\n       *  Calls &lt;tt&gt; a.deallocate(p, n) &lt;/tt&gt;\n      */\n      static _GLIBCXX20_CONSTEXPR void\n      deallocate(allocator_type&amp; __a, pointer __p, size_type __n)\n      { __a.deallocate(__p, __n); }\n\n      /**\n       *  @brief  Construct an object of type `_Up`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to memory of suitable size and alignment for\n       *\t       an object of type `_Up`.\n       *  @param  __args Constructor arguments.\n       *\n       *  Calls `__a.construct(__p, std::forward&lt;_Args&gt;(__args)...)`\n       *  in C++11, C++14 and C++17. Changed in C++20 to call\n       *  `std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...)` instead.\n      */\n      template&lt;typename _Up, typename... _Args&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tconstruct(allocator_type&amp; __a __attribute__((__unused__)), _Up* __p,\n\t\t  _Args&amp;&amp;... __args)\n\tnoexcept(std::is_nothrow_constructible&lt;_Up, _Args...&gt;::value)\n\t{\n#if __cplusplus &lt;= 201703L\n\t  __a.construct(__p, std::forward&lt;_Args&gt;(__args)...);\n#else\n\t  std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...);\n#endif\n\t}\n\n      /**\n       *  @brief  Destroy an object of type @a _Up\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the object to destroy\n       *\n       *  Calls @c __a.destroy(__p).\n      */\n      template&lt;typename _Up&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tdestroy(allocator_type&amp; __a __attribute__((__unused__)), _Up* __p)\n\tnoexcept(is_nothrow_destructible&lt;_Up&gt;::value)\n\t{\n#if __cplusplus &lt;= 201703L\n\t  __a.destroy(__p);\n#else\n\t  std::destroy_at(__p);\n#endif\n\t}\n\n      /**\n       *  @brief  The maximum supported allocation size\n       *  @param  __a  An allocator.\n       *  @return @c __a.max_size()\n      */\n      static _GLIBCXX20_CONSTEXPR size_type\n      max_size(const allocator_type&amp; __a __attribute__((__unused__))) noexcept\n      {\n#if __cplusplus &lt;= 201703L\n\treturn __a.max_size();\n#else\n\treturn size_t(-1) / sizeof(value_type);\n#endif\n      }\n\n      /**\n       *  @brief  Obtain an allocator to use when copying a container.\n       *  @param  __rhs  An allocator.\n       *  @return @c __rhs\n      */\n      static _GLIBCXX20_CONSTEXPR allocator_type\n      select_on_container_copy_construction(const allocator_type&amp; __rhs)\n      { return __rhs; }\n    };\n\n  /// Explicit specialization for std::allocator&lt;void&gt;.\n  template&lt;&gt;\n    struct allocator_traits&lt;allocator&lt;void&gt;&gt;\n    {\n      /// The allocator type\n      using allocator_type = allocator&lt;void&gt;;\n\n      /// The allocated type\n      using value_type = void;\n\n      /// The allocator&#x27;s pointer type.\n      using pointer = void*;\n\n      /// The allocator&#x27;s const pointer type.\n      using const_pointer = const void*;\n\n      /// The allocator&#x27;s void pointer type.\n      using void_pointer = void*;\n\n      /// The allocator&#x27;s const void pointer type.\n      using const_void_pointer = const void*;\n\n      /// The allocator&#x27;s difference type\n      using difference_type = std::ptrdiff_t;\n\n      /// The allocator&#x27;s size type\n      using size_type = std::size_t;\n\n      /// How the allocator is propagated on copy assignment\n      using propagate_on_container_copy_assignment = false_type;\n\n      /// How the allocator is propagated on move assignment\n      using propagate_on_container_move_assignment = true_type;\n\n      /// How the allocator is propagated on swap\n      using propagate_on_container_swap = false_type;\n\n      /// Whether all instances of the allocator type compare equal.\n      using is_always_equal = true_type;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_alloc = allocator&lt;_Up&gt;;\n\n      template&lt;typename _Up&gt;\n\tusing rebind_traits = allocator_traits&lt;allocator&lt;_Up&gt;&gt;;\n\n      /// allocate is ill-formed for allocator&lt;void&gt;\n      static void*\n      allocate(allocator_type&amp;, size_type, const void* = nullptr) = delete;\n\n      /// deallocate is ill-formed for allocator&lt;void&gt;\n      static void\n      deallocate(allocator_type&amp;, void*, size_type) = delete;\n\n      /**\n       *  @brief  Construct an object of type `_Up`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to memory of suitable size and alignment for\n       *\t       an object of type `_Up`.\n       *  @param  __args Constructor arguments.\n       *\n       *  Calls `__a.construct(__p, std::forward&lt;_Args&gt;(__args)...)`\n       *  in C++11, C++14 and C++17. Changed in C++20 to call\n       *  `std::construct_at(__p, std::forward&lt;_Args&gt;(__args)...)` instead.\n      */\n      template&lt;typename _Up, typename... _Args&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tconstruct(allocator_type&amp;, _Up* __p, _Args&amp;&amp;... __args)\n\tnoexcept(std::is_nothrow_constructible&lt;_Up, _Args...&gt;::value)\n\t{ std::_Construct(__p, std::forward&lt;_Args&gt;(__args)...); }\n\n      /**\n       *  @brief  Destroy an object of type `_Up`\n       *  @param  __a  An allocator.\n       *  @param  __p  Pointer to the object to destroy\n       *\n       *  Invokes the destructor for `*__p`.\n      */\n      template&lt;typename _Up&gt;\n\tstatic _GLIBCXX20_CONSTEXPR void\n\tdestroy(allocator_type&amp;, _Up* __p)\n\tnoexcept(is_nothrow_destructible&lt;_Up&gt;::value)\n\t{ std::_Destroy(__p); }\n\n      /// max_size is ill-formed for allocator&lt;void&gt;\n      static size_type\n      max_size(const allocator_type&amp;) = delete;\n\n      /**\n       *  @brief  Obtain an allocator to use when copying a container.\n       *  @param  __rhs  An allocator.\n       *  @return `__rhs`\n      */\n      static _GLIBCXX20_CONSTEXPR allocator_type\n      select_on_container_copy_construction(const allocator_type&amp; __rhs)\n      { return __rhs; }\n    };\n\n#if __cplusplus &lt; 201703L\n  template&lt;typename _Alloc&gt;\n    inline void\n    __do_alloc_on_copy(_Alloc&amp; __one, const _Alloc&amp; __two, true_type)\n    { __one = __two; }\n\n  template&lt;typename _Alloc&gt;\n    inline void\n    __do_alloc_on_copy(_Alloc&amp;, const _Alloc&amp;, false_type)\n    { }\n#endif\n\n  template&lt;typename _Alloc&gt;\n    _GLIBCXX14_CONSTEXPR inline void\n    __alloc_on_copy(_Alloc&amp; __one, const _Alloc&amp; __two)\n    {\n      typedef allocator_traits&lt;_Alloc&gt; __traits;\n      typedef typename __traits::propagate_on_container_copy_assignment __pocca;\n#if __cplusplus &gt;= 201703L\n      if constexpr (__pocca::value)\n\t__one = __two;\n#else\n      __do_alloc_on_copy(__one, __two, __pocca());\n#endif\n    }\n\n  template&lt;typename _Alloc&gt;\n    constexpr _Alloc\n    __alloc_on_copy(const _Alloc&amp; __a)\n    {\n      typedef allocator_traits&lt;_Alloc&gt; __traits;\n      return __traits::select_on_container_copy_construction(__a);\n    }\n\n#if __cplusplus &lt; 201703L\n  template&lt;typename _Alloc&gt;\n    inline void __do_alloc_on_move(_Alloc&amp; __one, _Alloc&amp; __two, true_type)\n    { __one = std::move(__two); }\n\n  template&lt;typename _Alloc&gt;\n    inline void __do_alloc_on_move(_Alloc&amp;, _Alloc&amp;, false_type)\n    { }\n#endif\n\n  template&lt;typename _Alloc&gt;\n    _GLIBCXX14_CONSTEXPR inline void\n    __alloc_on_move(_Alloc&amp; __one, _Alloc&amp; __two)\n    {\n      typedef allocator_traits&lt;_Alloc&gt; __traits;\n      typedef typename __traits::propagate_on_container_move_assignment __pocma;\n#if __cplusplus &gt;= 201703L\n      if constexpr (__pocma::value)\n\t__one = std::move(__two);\n#else\n      __do_alloc_on_move(__one, __two, __pocma());\n#endif\n    }\n\n#if __cplusplus &lt; 201703L\n  template&lt;typename _Alloc&gt;\n    inline void __do_alloc_on_swap(_Alloc&amp; __one, _Alloc&amp; __two, true_type)\n    {\n      using std::swap;\n      swap(__one, __two);\n    }\n\n  template&lt;typename _Alloc&gt;\n    inline void __do_alloc_on_swap(_Alloc&amp;, _Alloc&amp;, false_type)\n    { }\n#endif\n\n  template&lt;typename _Alloc&gt;\n    _GLIBCXX14_CONSTEXPR inline void\n    __alloc_on_swap(_Alloc&amp; __one, _Alloc&amp; __two)\n    {\n      typedef allocator_traits&lt;_Alloc&gt; __traits;\n      typedef typename __traits::propagate_on_container_swap __pocs;\n#if __cplusplus &gt;= 201703L\n      if constexpr (__pocs::value)\n\t{\n\t  using std::swap;\n\t  swap(__one, __two);\n\t}\n#else\n      __do_alloc_on_swap(__one, __two, __pocs());\n#endif\n    }\n\n  template&lt;typename _Alloc, typename _Tp,\n\t   typename _ValueT = __remove_cvref_t&lt;typename _Alloc::value_type&gt;,\n\t   typename = void&gt;\n    struct __is_alloc_insertable_impl\n    : false_type\n    { };\n\n  template&lt;typename _Alloc, typename _Tp, typename _ValueT&gt;\n    struct __is_alloc_insertable_impl&lt;_Alloc, _Tp, _ValueT,\n      __void_t&lt;decltype(allocator_traits&lt;_Alloc&gt;::construct(\n\t\t   std::declval&lt;_Alloc&amp;&gt;(), std::declval&lt;_ValueT*&gt;(),\n\t\t   std::declval&lt;_Tp&gt;()))&gt;&gt;\n    : true_type\n    { };\n\n  // true if _Alloc::value_type is CopyInsertable into containers using _Alloc\n  // (might be wrong if _Alloc::construct exists but is not constrained,\n  // i.e. actually trying to use it would still be invalid. Use with caution.)\n  template&lt;typename _Alloc&gt;\n    struct __is_copy_insertable\n    : __is_alloc_insertable_impl&lt;_Alloc,\n\t\t\t\t typename _Alloc::value_type const&amp;&gt;::type\n    { };\n\n  // std::allocator&lt;_Tp&gt; just requires CopyConstructible\n  template&lt;typename _Tp&gt;\n    struct __is_copy_insertable&lt;allocator&lt;_Tp&gt;&gt;\n    : is_copy_constructible&lt;_Tp&gt;\n    { };\n\n  // true if _Alloc::value_type is MoveInsertable into containers using _Alloc\n  // (might be wrong if _Alloc::construct exists but is not constrained,\n  // i.e. actually trying to use it would still be invalid. Use with caution.)\n  template&lt;typename _Alloc&gt;\n    struct __is_move_insertable\n    : __is_alloc_insertable_impl&lt;_Alloc, typename _Alloc::value_type&gt;::type\n    { };\n\n  // std::allocator&lt;_Tp&gt; just requires MoveConstructible\n  template&lt;typename _Tp&gt;\n    struct __is_move_insertable&lt;allocator&lt;_Tp&gt;&gt;\n    : is_move_constructible&lt;_Tp&gt;\n    { };\n\n  // Trait to detect Allocator-like types.\n  template&lt;typename _Alloc, typename = void&gt;\n    struct __is_allocator : false_type { };\n\n  template&lt;typename _Alloc&gt;\n    struct __is_allocator&lt;_Alloc,\n      __void_t&lt;typename _Alloc::value_type,\n\t       decltype(std::declval&lt;_Alloc&amp;&gt;().allocate(size_t{}))&gt;&gt;\n    : true_type { };\n\n  template&lt;typename _Alloc&gt;\n    using _RequireAllocator\n      = typename enable_if&lt;__is_allocator&lt;_Alloc&gt;::value, _Alloc&gt;::type;\n\n  template&lt;typename _Alloc&gt;\n    using _RequireNotAllocator\n      = typename enable_if&lt;!__is_allocator&lt;_Alloc&gt;::value, _Alloc&gt;::type;\n\n#if __cpp_concepts &gt;= 201907L\n  template&lt;typename _Alloc&gt;\n    concept __allocator_like = requires (_Alloc&amp; __a) {\n      typename _Alloc::value_type;\n      __a.deallocate(__a.allocate(1u), 1u);\n    };\n#endif\n#endif // C++11\n\n  /**\n   * Destroy a range of objects using the supplied allocator.  For\n   * non-default allocators we do not optimize away invocation of\n   * destroy() even if _Tp has a trivial destructor.\n   */\n\n  template&lt;typename _ForwardIterator, typename _Allocator&gt;\n    void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n\t     _Allocator&amp; __alloc)\n    {\n      for (; __first != __last; ++__first)\n#if __cplusplus &lt; 201103L\n\t__alloc.destroy(std::__addressof(*__first));\n#else\n\tallocator_traits&lt;_Allocator&gt;::destroy(__alloc,\n\t\t\t\t\t      std::__addressof(*__first));\n#endif\n    }\n\n  template&lt;typename _ForwardIterator, typename _Tp&gt;\n    inline void\n    _Destroy(_ForwardIterator __first, _ForwardIterator __last,\n\t     allocator&lt;_Tp&gt;&amp;)\n    {\n      _Destroy(__first, __last);\n    }\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n#endif // _ALLOC_TRAITS_H\n"}, "/usr/include/c++/11/ext/new_allocator.h": {"id": "/usr/include/c++/11/ext/new_allocator.h", "filePath": "/usr/include/c++/11/ext/new_allocator.h", "content": "// Allocator that wraps operator new -*- C++ -*-\n\n// Copyright (C) 2001-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n/** @file ext/new_allocator.h\n *  This file is a GNU extension to the Standard C++ Library.\n */\n\n#ifndef _NEW_ALLOCATOR_H\n#define _NEW_ALLOCATOR_H 1\n\n#include &lt;bits/c++config.h&gt;\n#include &lt;new&gt;\n#include &lt;bits/functexcept.h&gt;\n#include &lt;bits/move.h&gt;\n#if __cplusplus &gt;= 201103L\n#include &lt;type_traits&gt;\n#endif\n\nnamespace __gnu_cxx _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n  /**\n   *  @brief  An allocator that uses global new, as per C++03 [20.4.1].\n   *  @ingroup allocators\n   *\n   *  This is precisely the allocator defined in the C++ Standard.\n   *    - all allocation calls operator new\n   *    - all deallocation calls operator delete\n   *\n   *  @tparam  _Tp  Type of allocated object.\n   */\n  template&lt;typename _Tp&gt;\n    class new_allocator\n    {\n    public:\n      typedef _Tp        value_type;\n      typedef std::size_t     size_type;\n      typedef std::ptrdiff_t  difference_type;\n#if __cplusplus &lt;= 201703L\n      typedef _Tp*       pointer;\n      typedef const _Tp* const_pointer;\n      typedef _Tp&amp;       reference;\n      typedef const _Tp&amp; const_reference;\n\n      template&lt;typename _Tp1&gt;\n\tstruct rebind\n\t{ typedef new_allocator&lt;_Tp1&gt; other; };\n#endif\n\n#if __cplusplus &gt;= 201103L\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 2103. propagate_on_container_move_assignment\n      typedef std::true_type propagate_on_container_move_assignment;\n#endif\n\n      _GLIBCXX20_CONSTEXPR\n      new_allocator() _GLIBCXX_USE_NOEXCEPT { }\n\n      _GLIBCXX20_CONSTEXPR\n      new_allocator(const new_allocator&amp;) _GLIBCXX_USE_NOEXCEPT { }\n\n      template&lt;typename _Tp1&gt;\n\t_GLIBCXX20_CONSTEXPR\n\tnew_allocator(const new_allocator&lt;_Tp1&gt;&amp;) _GLIBCXX_USE_NOEXCEPT { }\n\n#if __cplusplus &lt;= 201703L\n      ~new_allocator() _GLIBCXX_USE_NOEXCEPT { }\n\n      pointer\n      address(reference __x) const _GLIBCXX_NOEXCEPT\n      { return std::__addressof(__x); }\n\n      const_pointer\n      address(const_reference __x) const _GLIBCXX_NOEXCEPT\n      { return std::__addressof(__x); }\n#endif\n\n      // NB: __n is permitted to be 0.  The C++ standard says nothing\n      // about what the return value is when __n == 0.\n      _GLIBCXX_NODISCARD _Tp*\n      allocate(size_type __n, const void* = static_cast&lt;const void*&gt;(0))\n      {\n#if __cplusplus &gt;= 201103L\n\t // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t // 3308. std::allocator&lt;void&gt;().allocate(n)\n\t static_assert(sizeof(_Tp) != 0, &quot;cannot allocate incomplete types&quot;);\n#endif\n\n\tif (__builtin_expect(__n &gt; this-&gt;_M_max_size(), false))\n\t  {\n\t    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n\t    // 3190. allocator::allocate sometimes returns too little storage\n\t    if (__n &gt; (std::size_t(-1) / sizeof(_Tp)))\n\t      std::__throw_bad_array_new_length();\n\t    std::__throw_bad_alloc();\n\t  }\n\n#if __cpp_aligned_new\n\tif (alignof(_Tp) &gt; __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n\t  {\n\t    std::align_val_t __al = std::align_val_t(alignof(_Tp));\n\t    return static_cast&lt;_Tp*&gt;(::operator new(__n * sizeof(_Tp), __al));\n\t  }\n#endif\n\treturn static_cast&lt;_Tp*&gt;(::operator new(__n * sizeof(_Tp)));\n      }\n\n      // __p is not permitted to be a null pointer.\n      void\n      deallocate(_Tp* __p, size_type __t __attribute__ ((__unused__)))\n      {\n#if __cpp_aligned_new\n\tif (alignof(_Tp) &gt; __STDCPP_DEFAULT_NEW_ALIGNMENT__)\n\t  {\n\t    ::operator delete(__p,\n# if __cpp_sized_deallocation\n\t\t\t      __t * sizeof(_Tp),\n# endif\n\t\t\t      std::align_val_t(alignof(_Tp)));\n\t    return;\n\t  }\n#endif\n\t::operator delete(__p\n#if __cpp_sized_deallocation\n\t\t\t  , __t * sizeof(_Tp)\n#endif\n\t\t\t );\n      }\n\n#if __cplusplus &lt;= 201703L\n      size_type\n      max_size() const _GLIBCXX_USE_NOEXCEPT\n      { return _M_max_size(); }\n\n#if __cplusplus &gt;= 201103L\n      template&lt;typename _Up, typename... _Args&gt;\n\tvoid\n\tconstruct(_Up* __p, _Args&amp;&amp;... __args)\n\tnoexcept(std::is_nothrow_constructible&lt;_Up, _Args...&gt;::value)\n\t{ ::new((void *)__p) _Up(std::forward&lt;_Args&gt;(__args)...); }\n\n      template&lt;typename _Up&gt;\n\tvoid\n\tdestroy(_Up* __p)\n\tnoexcept(std::is_nothrow_destructible&lt;_Up&gt;::value)\n\t{ __p-&gt;~_Up(); }\n#else\n      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n      // 402. wrong new expression in [some_] allocator::construct\n      void\n      construct(pointer __p, const _Tp&amp; __val)\n      { ::new((void *)__p) _Tp(__val); }\n\n      void\n      destroy(pointer __p) { __p-&gt;~_Tp(); }\n#endif\n#endif // ! C++20\n\n      template&lt;typename _Up&gt;\n\tfriend _GLIBCXX20_CONSTEXPR bool\n\toperator==(const new_allocator&amp;, const new_allocator&lt;_Up&gt;&amp;)\n\t_GLIBCXX_NOTHROW\n\t{ return true; }\n\n#if __cpp_impl_three_way_comparison &lt; 201907L\n      template&lt;typename _Up&gt;\n\tfriend _GLIBCXX20_CONSTEXPR bool\n\toperator!=(const new_allocator&amp;, const new_allocator&lt;_Up&gt;&amp;)\n\t_GLIBCXX_NOTHROW\n\t{ return false; }\n#endif\n\n    private:\n      _GLIBCXX_CONSTEXPR size_type\n      _M_max_size() const _GLIBCXX_USE_NOEXCEPT\n      {\n#if __PTRDIFF_MAX__ &lt; __SIZE_MAX__\n\treturn std::size_t(__PTRDIFF_MAX__) / sizeof(_Tp);\n#else\n\treturn std::size_t(-1) / sizeof(_Tp);\n#endif\n      }\n    };\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ilparams.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ilparams.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ilparams.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Wraps parameters for integer lattice operations. Inherits from ElemParams\n */\n\n#ifndef LBCRYPTO_INC_LATTICE_ILPARAMS_H\n#define LBCRYPTO_INC_LATTICE_ILPARAMS_H\n\n#include &quot;lattice/elemparams.h&quot;\n\n#include &quot;math/math-hal.h&quot;\n#include &quot;math/nbtheory.h&quot;\n\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/inttypes.h&quot;\n\n#include &lt;string&gt;\n#include &lt;utility&gt;\n\nnamespace lbcrypto {\n\n/**\n * @class ILParamsImpl\n * @file ilparams.h\n * @brief Wrapper class to hold the parameters for integer lattice operations\n * and their inheritors.\n */\ntemplate &lt;typename IntType&gt;\nclass ILParamsImpl final : public ElemParams&lt;IntType&gt; {\npublic:\n    using Integer = IntType;\n\n    /**\n   * Constructor that initializes nothing.\n   * All of the private members will be initialized to zero.\n   */\n    constexpr ILParamsImpl() : ElemParams&lt;IntType&gt;() {}\n\n    /**\n   * @brief Constructor for the case of partially pre-computed parameters.\n   *\n   * @param &amp;order the order of the ciphertext.\n   * @param &amp;modulus the ciphertext modulus.\n   * @param &amp;rootOfUnity the root of unity used in the ciphertext.\n   * @param bigModulus the big ciphertext modulus.\n   * @param bigRootOfUnity the big ciphertext modulus used for bit packing\n   * operations.\n   * @return\n   */\n    ILParamsImpl(usint order, const IntType&amp; modulus, const IntType&amp; rootOfUnity,\n                 const IntType&amp; bigModulus = IntType(0), const IntType&amp; bigRootOfUnity = IntType(0))\n        : ElemParams&lt;IntType&gt;(order, modulus, rootOfUnity, bigModulus, bigRootOfUnity) {}\n\n    /**\n   * @brief Constructor for the case of partially pre-computed parameters.\n   *\n   * @param &amp;order the order of the ciphertext.\n   * @param &amp;modulus the ciphertext modulus.\n   */\n    ILParamsImpl(usint order, const IntType&amp; modulus)\n        : ElemParams&lt;IntType&gt;(order, modulus, RootOfUnity&lt;IntType&gt;(order, modulus)) {}\n\n    /**\n   * @brief Copy constructor.\n   *\n   * @param &amp;rhs the input set of parameters which is copied.\n   */\n    ILParamsImpl(const ILParamsImpl&amp; rhs) : ElemParams&lt;IntType&gt;(rhs) {}\n\n    /**\n   * @brief Assignment Operator.\n   *\n   * @param &amp;rhs the params to be copied.\n   * @return this object\n   */\n    ILParamsImpl&amp; operator=(const ILParamsImpl&amp; rhs) {\n        ElemParams&lt;IntType&gt;::operator=(rhs);\n        return *this;\n    }\n\n    /**\n   * @brief Move constructor.\n   *\n   * @param &amp;rhs the input set of parameters which is copied.\n   */\n    ILParamsImpl(ILParamsImpl&amp;&amp; rhs) noexcept : ElemParams&lt;IntType&gt;(std::move(rhs)) {}\n\n    ILParamsImpl&amp; operator=(ILParamsImpl&amp;&amp; rhs) noexcept {\n        ElemParams&lt;IntType&gt;::operator=(std::move(rhs));\n        return *this;\n    }\n\n    /**\n   * @brief Standard Destructor method.\n   */\n    ~ILParamsImpl() override = default;\n\n    /**\n   * @brief Equality operator compares ElemParams (which will be dynamic casted)\n   *\n   * @param &amp;rhs is the specified Poly to be compared with this Poly.\n   * @return True if this Poly represents the same values as the specified\n   * DCRTPoly, False otherwise\n   */\n    bool operator==(const ElemParams&lt;IntType&gt;&amp; rhs) const override {\n        if (dynamic_cast&lt;const ILParamsImpl&lt;IntType&gt;*&gt;(&amp;rhs) == nullptr)\n            return false;\n        return ElemParams&lt;IntType&gt;::operator==(rhs);\n    }\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::base_class&lt;ElemParams&lt;IntType&gt;&gt;(this));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                 &quot; is from a later version of the library&quot;);\n        }\n        ar(::cereal::base_class&lt;ElemParams&lt;IntType&gt;&gt;(this));\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;ILParms&quot;;\n    }\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\nprivate:\n    std::ostream&amp; doprint(std::ostream&amp; out) const override {\n        out &lt;&lt; &quot;ILParams &quot;;\n        ElemParams&lt;IntType&gt;::doprint(out);\n        out &lt;&lt; std::endl;\n        return out;\n    }\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  This code provides number theory utilities\n */\n\n#ifndef LBCRYPTO_INC_MATH_NBTHEORY_IMPL_H\n#define LBCRYPTO_INC_MATH_NBTHEORY_IMPL_H\n\n#define _USE_MATH_DEFINES\n\n#include &quot;math/distributiongenerator.h&quot;\n#include &quot;math/nbtheory.h&quot;\n\n#include &quot;utils/debug.h&quot;\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/inttypes.h&quot;\n\n#include &lt;cmath&gt;\n#include &lt;limits&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n#include &lt;vector&gt;\n\nnamespace lbcrypto {\n\n/*\n Generates a random number between 0 and n.\n Input: BigInteger n.\n Output: Randomly generated BigInteger  between 0 and n.\n */\ntemplate &lt;typename IntType&gt;\nstatic IntType RNG(const IntType&amp; modulus) {\n    static constexpr uint32_t chunk_min{0};\n    static constexpr uint32_t chunk_max{std::numeric_limits&lt;uint32_t&gt;::max()};\n    static constexpr uint32_t chunk_width{std::numeric_limits&lt;uint32_t&gt;::digits};\n    static std::uniform_int_distribution&lt;uint32_t&gt; distribution(chunk_min, chunk_max);\n\n    uint32_t chunksPerValue{(modulus.GetMSB() - 1) / chunk_width};\n    uint32_t shiftChunk{chunksPerValue * chunk_width};\n    std::uniform_int_distribution&lt;uint32_t&gt;::param_type bound(chunk_min, (modulus &gt;&gt; shiftChunk).ConvertToInt());\n\n    while (true) {\n        IntType result{};\n        for (uint32_t i{0}, shift{0}; i &lt; chunksPerValue; ++i, shift += chunk_width)\n            result += IntType{distribution(PseudoRandomNumberGenerator::GetPRNG())} &lt;&lt; shift;\n        result += IntType{distribution(PseudoRandomNumberGenerator::GetPRNG(), bound)} &lt;&lt; shiftChunk;\n        if (result &lt; modulus)\n            return result;\n    }\n}\n/*\n A witness function used for the Miller-Rabin Primality test.\n Inputs: a is a randomly generated witness between 2 and p-1,\n p is the number to be tested for primality,\n s and d satisfy p-1 = ((2^s) * d), d is odd.\n Output: true if p is composite,\n false if p is likely prime\n */\ntemplate &lt;typename IntType&gt;\nstatic bool WitnessFunction(const IntType&amp; a, const IntType&amp; d, usint s, const IntType&amp; p) {\n    IntType mod  = a.ModExp(d, p);\n    bool prevMod = false;\n    for (usint i = 0; i &lt; s; ++i) {\n        prevMod = (mod != IntType(1) &amp;&amp; mod != p - IntType(1));\n        mod.ModMulFastEq(mod, p);\n        if (mod == IntType(1) &amp;&amp; prevMod)\n            return true;\n    }\n    return (mod != IntType(1));\n}\n\n/*\n A helper function to RootOfUnity function. This finds a generator for a given\n prime q. Input: BigInteger q which is a prime. Output: A generator of prime q\n */\ntemplate &lt;typename IntType&gt;\nstatic IntType FindGenerator(const IntType&amp; q) {\n    IntType qm1(q - IntType(1));\n    IntType qm2(q - IntType(2));\n    std::set&lt;IntType&gt; primeFactors;\n    PrimeFactorize&lt;IntType&gt;(qm1, primeFactors);\n    usint cnt;\n    IntType gen;\n    do {\n        cnt = 0;\n        gen = RNG(qm2) + IntType(1);\n        for (auto it = primeFactors.begin(); it != primeFactors.end(); ++it, ++cnt) {\n            if (gen.ModExp(qm1 / (*it), q) == IntType(1))\n                break;\n        }\n    } while (cnt != primeFactors.size());\n    return gen;\n}\n\n/*\n A helper function for arbitrary cyclotomics. This finds a generator for any\n composite q (cyclic group). Input: BigInteger q (cyclic group). Output: A\n generator of q\n */\ntemplate &lt;typename IntType&gt;\nIntType FindGeneratorCyclic(const IntType&amp; q) {\n    IntType phi_q(GetTotient(q.ConvertToInt()));\n    IntType phi_q_m1(GetTotient(q.ConvertToInt()));\n    std::set&lt;IntType&gt; primeFactors;\n    PrimeFactorize&lt;IntType&gt;(phi_q, primeFactors);\n    usint cnt;\n    IntType gen;\n    do {\n        cnt = 0;\n        gen = RNG(phi_q_m1) + IntType(1);  // gen is random in [1, phi(q)]\n\n        // Generator must lie in the group!\n        if (GreatestCommonDivisor&lt;IntType&gt;(gen, q) != IntType(1))\n            continue;\n\n        // Order of a generator cannot divide any co-factor\n        for (auto it = primeFactors.begin(); it != primeFactors.end(); ++it, ++cnt) {\n            if (gen.ModExp(phi_q / (*it), q) == IntType(1))\n                break;\n        }\n    } while (cnt != primeFactors.size());\n    return gen;\n}\n\n/*\n A helper function for arbitrary cyclotomics. Checks if g is a generator of q\n (supports any cyclic group, not just prime-modulus groups) Input: Candidate\n generator g and modulus q Output: returns true if g is a generator for q\n */\ntemplate &lt;typename IntType&gt;\nbool IsGenerator(const IntType&amp; g, const IntType&amp; q) {\n    IntType qm1(GetTotient(q.ConvertToInt()));\n    std::set&lt;IntType&gt; primeFactors;\n    PrimeFactorize&lt;IntType&gt;(qm1, primeFactors);\n    usint cnt = 0;\n    for (auto it = primeFactors.begin(); it != primeFactors.end(); ++it, ++cnt) {\n        if (g.ModExp(qm1 / (*it), q) == IntType(1))\n            break;\n    }\n    return cnt == primeFactors.size();\n}\n\n/*\n finds roots of unity for given input.  Assumes the the input is a power of two.\n Mostly likely does not give correct results otherwise. input:  m as number\n which is cyclotomic(in format of int), modulo which is used to find generator\n (in format of BigInteger)\n\n output:  root of unity (in format of BigInteger)\n */\ntemplate &lt;typename IntType&gt;\nIntType RootOfUnity(usint m, const IntType&amp; modulo) {\n    IntType M(m);\n    if ((modulo - IntType(1)).Mod(M) != IntType(0)) {\n        std::string errMsg =\n            &quot;Please provide a primeModulus(q) and a cyclotomic number(m) &quot;\n            &quot;satisfying the condition: (q-1)/m is an integer. The values of &quot;\n            &quot;primeModulus = &quot; +\n            modulo.ToString() + &quot; and m = &quot; + std::to_string(m) + &quot; do not satisfy this condition&quot;;\n        &quot;hey&quot;; OPENFHE_THROW(math_error, errMsg);\n    }\n\n    IntType gen    = FindGenerator(modulo);\n    IntType result = gen.ModExp((modulo - IntType(1)).DividedBy(M), modulo);\n    if (result == IntType(1))\n        result = RootOfUnity(m, modulo);\n\n    /*\n   * At this point, result contains a primitive root of unity. However,\n   * we want to return the minimum root of unity, to avoid different\n   * crypto contexts having different roots of unity for the same\n   * cyclotomic order and moduli. Therefore, we are going to cycle over\n   * all primitive roots of unity and select the smallest one (minRU).\n   *\n   * To cycle over all primitive roots of unity, we raise the root of\n   * unity in result to all the powers that are co-prime to the\n   * cyclotomic order. In power-of-two cyclotomics, this will be the\n   * set of all odd powers, but here we use a more general routine\n   * to support arbitrary cyclotomics.\n   *\n   */\n\n    IntType mu(modulo.ComputeMu());\n    IntType x(1);\n    x.ModMulEq(result, modulo, mu);\n\n    std::vector&lt;IntType&gt; coprimes = GetTotientList&lt;IntType&gt;(m);\n    IntType minRU(x);\n    IntType curPowIdx(1);\n    for (size_t i = 0; i &lt; coprimes.size(); ++i) {\n        auto nextPowIdx = coprimes[i];\n        IntType diffPow(nextPowIdx - curPowIdx);\n        for (IntType j(0); j &lt; diffPow; j += IntType(1))\n            x.ModMulEq(result, modulo, mu);\n        if (x &lt; minRU &amp;&amp; x != IntType(1))\n            minRU = x;\n        curPowIdx = nextPowIdx;\n    }\n    return minRU;\n}\n\ntemplate &lt;typename IntType&gt;\nstd::vector&lt;IntType&gt; RootsOfUnity(usint m, const std::vector&lt;IntType&gt; moduli) {\n    std::vector&lt;IntType&gt; rootsOfUnity(moduli.size());\n    for (size_t i = 0; i &lt; moduli.size(); ++i)\n        rootsOfUnity[i] = RootOfUnity(m, moduli[i]);\n    return rootsOfUnity;\n}\n\ntemplate &lt;typename IntType&gt;\nIntType GreatestCommonDivisor(const IntType&amp; a, const IntType&amp; b) {\n    static const IntType ZERO(0);\n    auto m_a(a);\n    auto m_b(b);\n    while (m_b != ZERO) {\n        auto tmp(m_b);\n        m_b = m_a % m_b;\n        m_a = tmp;\n    }\n    return m_a;\n}\n\n/*\n The Miller-Rabin Primality Test\n Input: p the number to be tested for primality.\n Output: true if p is prime,\n false if p is not prime\n */\ntemplate &lt;typename IntType&gt;\nbool MillerRabinPrimalityTest(const IntType&amp; p, const usint niter) {\n    //    constexpr IntType ZERO(0);\n    //    constexpr IntType TWO(2);\n    //    constexpr IntType THREE(3);\n    //    constexpr IntType FIVE(5);\n    static const IntType ZERO(0);\n    static const IntType TWO(2);\n    static const IntType THREE(3);\n    static const IntType FIVE(5);\n\n    if (p == TWO || p == THREE || p == FIVE)\n        return true;\n    if (p &lt; TWO || (p.Mod(TWO) == ZERO))\n        return false;\n\n    IntType d(p - IntType(1));\n    usint s(0);\n    while (d.Mod(TWO) == ZERO) {\n        // d.DividedByEq(TWO);\n        d.RShiftEq(1);\n        ++s;\n    }\n    for (usint i = 0; i &lt; niter; ++i) {\n        if (WitnessFunction(RNG(p - THREE).ModAdd(TWO, p), d, s, p))\n            return false;\n    }\n    return true;\n}\n\n/*\n The Pollard Rho factorization of a number n.\n Input: n the number to be factorized.\n Output: a factor of n.\n */\ntemplate &lt;typename IntType&gt;\nconst IntType PollardRhoFactorization(const IntType&amp; n) {\n    if (n.Mod(IntType(2)) == IntType(0))\n        return IntType(2);\n    IntType divisor(1);\n    IntType c(RNG(n));\n    IntType x(RNG(n));\n    IntType xx(x);\n    IntType mu(n.ComputeMu());\n    do {\n        x       = x.ModMul(x, n, mu).ModAdd(c, n, mu);\n        xx      = xx.ModMul(xx, n, mu).ModAdd(c, n, mu);\n        xx      = xx.ModMul(xx, n, mu).ModAdd(c, n, mu);\n        divisor = GreatestCommonDivisor((x &gt; xx) ? x - xx : xx - x, n);\n    } while (divisor == IntType(1));\n    return divisor;\n}\n\n/*\n Recursively factorizes and find the distinct primefactors of a number\n Input: n is the number to be prime factorized,\n primeFactors is a set of prime factors of n.\n */\ntemplate &lt;typename IntType&gt;\nvoid PrimeFactorize(IntType n, std::set&lt;IntType&gt;&amp; primeFactors) {\n    if (n == IntType(0) || n == IntType(1))\n        return;\n    if (MillerRabinPrimalityTest(n)) {\n        primeFactors.insert(n);\n        return;\n    }\n\n    IntType divisor(PollardRhoFactorization(n));\n    PrimeFactorize(divisor, primeFactors);\n    PrimeFactorize(n / divisor, primeFactors);\n}\n\n// issue-881: make sure we don&#x27;t overflow an IntType\ntemplate &lt;typename IntType&gt;\nIntType FirstPrime(uint64_t nBits, uint64_t m) {\n    if constexpr (std::is_same_v&lt;IntType, NativeInteger&gt;) {\n        if (nBits &gt; MAX_MODULUS_SIZE)\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Requested bit length &quot; + std::to_string(nBits) +\n                                          &quot; exceeds maximum allowed length &quot; + std::to_string(MAX_MODULUS_SIZE));\n    }\n    try {\n        IntType mi(m);\n        IntType qNew(IntType(1) &lt;&lt; nBits);\n        IntType r(qNew.Mod(mi));\n        IntType qNew2(qNew + IntType(1));\n        if (r &gt; IntType(0))\n            qNew2 += (mi - r);\n        if (qNew2 &lt; qNew)\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;FirstPrime parameters overflow this integer implementation&quot;);\n        while (!MillerRabinPrimalityTest((qNew = qNew2))) {\n            qNew2 = qNew + mi;\n            if (qNew2 &lt; qNew)\n                &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;FirstPrime overflow growing candidate&quot;);\n        }\n        return qNew;\n    }\n    catch (...) {\n        &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;FirstPrime math exception&quot;);\n    }\n}\n\ntemplate &lt;typename IntType&gt;\nIntType NextPrime(const IntType&amp; q, uint64_t m) {\n    IntType M(m), qNew(q + M);\n    while (!MillerRabinPrimalityTest(qNew)) {\n        if ((qNew += M) &lt; q)\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;NextPrime overflow growing candidate&quot;);\n    }\n    return qNew;\n}\n\ntemplate &lt;typename IntType&gt;\nIntType PreviousPrime(const IntType&amp; q, uint64_t m) {\n    IntType M(m), qNew(q - M);\n    while (!MillerRabinPrimalityTest(qNew)) {\n        if ((qNew -= M) &gt; q)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Moduli size is not sufficient! Must be increased.&quot;);\n    }\n    return qNew;\n}\n\ntemplate &lt;typename IntType&gt;\nIntType NextPowerOfTwo(IntType n) {\n    usint result = ceil(log2(n));\n    return result;\n}\n\n/*Naive Loop to find coprimes to n*/\ntemplate &lt;typename IntType&gt;\nstd::vector&lt;IntType&gt; GetTotientList(const IntType&amp; n) {\n    std::vector&lt;IntType&gt; result;\n    static const IntType one(1);\n    for (IntType i = one; i &lt; n; i = i + one) {\n        if (GreatestCommonDivisor(i, n) == one)\n            result.push_back(i);\n    }\n    return result;\n}\n\n/* Calculate the remainder from polynomial division */\ntemplate &lt;typename IntVector&gt;\nIntVector PolyMod(const IntVector&amp; dividend, const IntVector&amp; divisor, const typename IntVector::Integer&amp; modulus) {\n    auto mu(modulus.ComputeMu());\n    usint divisorLength(divisor.GetLength());\n    usint dividendLength(dividend.GetLength());\n    usint runs(dividendLength - divisorLength + 1);\n    IntVector runningDividend(dividend);\n    for (usint i = 0; i &lt; runs; ++i) {\n        // get the highest degree coeff\n        auto divConst(runningDividend[dividendLength - 1]);\n        usint divisorPtr(divisorLength - 1);\n        for (usint j = 0; j &lt; dividendLength - i - 1; j++) {\n            auto&amp; rdtmp1 = runningDividend[dividendLength - 1 - j];\n            rdtmp1       = runningDividend[dividendLength - 2 - j];\n            if (divisorPtr &gt; j)\n                rdtmp1.ModSubEq(divisor[divisorPtr - 1 - j] * divConst, modulus, mu);\n        }\n    }\n\n    IntVector result(divisorLength - 1, modulus);\n    for (usint i = 0, j = runs; i &lt; divisorLength - 1; ++i, ++j)\n        result[i] = runningDividend[j];\n    return result;\n}\n\ntemplate &lt;typename IntVector&gt;\nIntVector PolynomialMultiplication(const IntVector&amp; a, const IntVector&amp; b) {\n    usint degreeA(a.GetLength());\n    usint degreeB(b.GetLength());\n    usint degreeResultant(degreeA + degreeB - 1);\n    const auto&amp; modulus = a.GetModulus();\n    IntVector result(degreeResultant, modulus);\n    for (usint i = 0; i &lt; degreeA; i++) {\n        for (usint j = 0; j &lt; degreeB; j++) {\n            result[i + j].ModAddEq(a[i] * b[j], modulus);\n        }\n    }\n    return result;\n}\n\ntemplate &lt;typename IntVector&gt;\nIntVector GetCyclotomicPolynomial(usint m, const typename IntVector::Integer&amp; modulus) {\n    auto intCP = GetCyclotomicPolynomialRecursive(m);\n    IntVector result(intCP.size(), modulus);\n    for (usint i = 0; i &lt; intCP.size(); i++) {\n        auto val = intCP[i];\n        if (val &gt; -1) {\n            result[i] = typename IntVector::Integer(val);\n        }\n        else {\n            result[i] = modulus - typename IntVector::Integer(-val);\n        }\n    }\n    return result;\n}\n\ntemplate &lt;typename IntVector&gt;\ntypename IntVector::Integer SyntheticRemainder(const IntVector&amp; dividend, const typename IntVector::Integer&amp; a,\n                                               const typename IntVector::Integer&amp; modulus) {\n    auto mu  = modulus.ComputeMu();\n    auto val = dividend[dividend.GetLength() - 1];\n    for (int i = dividend.GetLength() - 2; i &gt;= 0; --i)\n        val = (dividend[i] + a * val).Mod(modulus, mu);\n    return val;\n}\n\ntemplate &lt;typename IntVector&gt;\nIntVector SyntheticPolyRemainder(const IntVector&amp; dividend, const IntVector&amp; aList,\n                                 const typename IntVector::Integer&amp; modulus) {\n    IntVector result(aList.GetLength(), modulus);\n    for (usint i = 0; i &lt; aList.GetLength(); ++i)\n        result[i] = SyntheticRemainder(dividend, aList[i], modulus);\n    return result;\n}\n\ntemplate &lt;typename IntVector&gt;\nIntVector PolynomialPower(const IntVector&amp; input, usint power) {\n    usint finalDegree = (input.GetLength() - 1) * power;\n    IntVector finalPoly(finalDegree + 1, input.GetModulus());\n    for (usint i = 0; i &lt; input.GetLength(); ++i)\n        finalPoly[i * power] = input[i];\n    return finalPoly;\n}\n\ntemplate &lt;typename IntVector&gt;\nIntVector SyntheticPolynomialDivision(const IntVector&amp; dividend, const typename IntVector::Integer&amp; a,\n                                      const typename IntVector::Integer&amp; modulus) {\n    auto mu(modulus.ComputeMu());\n    usint n(dividend.GetLength() - 1);\n    IntVector result(n, modulus);\n    result[n - 1] = dividend[n];\n    auto val(dividend[n]);\n    for (int i = n - 1; i &gt; 0; i--) {\n        val           = (val * a + dividend[i]).Mod(modulus, mu);\n        result[i - 1] = val;\n    }\n    return result;\n}\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/mubintvecnat.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/mubintvecnat.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/mubintvecnat.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n * This file contains the vector manipulation functionality for native integers\n */\n\n#ifndef LBCRYPTO_INC_MATH_HAL_INTNAT_MUBINTVECNAT_H\n#define LBCRYPTO_INC_MATH_HAL_INTNAT_MUBINTVECNAT_H\n\n#include &quot;math/hal/basicint.h&quot;\n#include &quot;math/hal/intnat/ubintnat.h&quot;\n#include &quot;math/hal/vector.h&quot;\n\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/inttypes.h&quot;\n#include &quot;utils/serializable.h&quot;\n\n#include &lt;algorithm&gt;\n#include &lt;initializer_list&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\n// the following should be set to 1 in order to have native vector use block\n// allocations then determine if you want dynamic or static allocations by\n// settingdefining STAIC_POOLS on line 24 of\n// xallocator.cpp\n#define BLOCK_VECTOR_ALLOCATION 0  // set to 1 to use block allocations\n\n/**\n * @namespace intnat\n * The namespace of intnat\n */\nnamespace intnat {\n\n// Forward declare class and give it an alias for the expected type\ntemplate &lt;typename IntType&gt;\nclass NativeVectorT;\nusing NativeVector = NativeVectorT&lt;NativeInteger&gt;;\n\n/**\n * @brief The class for representing vectors of native integers.\n */\n\n#if 0  // allocator that reports bytes used.\ntemplate &lt;class Tp&gt;\nstruct NAlloc {\n    typedef Tp value_type;\n    NAlloc() = default;\n    template &lt;class T&gt; NAlloc(const NAlloc&lt;T&gt;&amp;) {}\n    Tp* allocate(std::size_t n) {\n        n *= sizeof(Tp);\n        return static_cast&lt;Tp*&gt;(::operator new(n));\n    }\n    void deallocate(Tp* p, std::size_t n) {\n        std::cout &lt;&lt; &quot;deallocating &quot; &lt;&lt; n*sizeof*p &lt;&lt; &quot; bytes\\n&quot;;\n        ::operator delete(p);\n    }\n};\ntemplate &lt;class T, class U&gt;\nbool operator==(const NAlloc&lt;T&gt;&amp;, const NAlloc&lt;U&gt;&amp;) { return true; }\ntemplate &lt;class T, class U&gt;\nbool operator!=(const NAlloc&lt;T&gt;&amp;, const NAlloc&lt;U&gt;&amp;) { return false; }\n#endif\n\n#if 0  // allocator that reports bytes used.\ntemplate &lt;class Tp&gt;\nstruct NAlloc {\n    typedef Tp value_type;\n    NAlloc() = default;\n    template &lt;class T&gt; NAlloc(const NAlloc&lt;T&gt;&amp;) {}\n    Tp* allocate(std::size_t n) {\n        n *= sizeof(Tp);\n        std::cout &lt;&lt; &quot;allocating   &quot; &lt;&lt; n &lt;&lt; &quot; bytes\\n&quot;;\n        return static_cast&lt;Tp*&gt;(::operator new(n));\n    }\n    void deallocate(Tp* p, std::size_t n) {\n        std::cout &lt;&lt; &quot;deallocating &quot; &lt;&lt; n*sizeof*p &lt;&lt; &quot; bytes\\n&quot;;\n        ::operator delete(p);\n    }\n};\ntemplate &lt;class T, class U&gt;\nbool operator==(const NAlloc&lt;T&gt;&amp;, const NAlloc&lt;U&gt;&amp;) { return true; }\ntemplate &lt;class T, class U&gt;\nbool operator!=(const NAlloc&lt;T&gt;&amp;, const NAlloc&lt;U&gt;&amp;) { return false; }\n#endif\n\ntemplate &lt;class IntegerType&gt;\nclass NativeVectorT final : public lbcrypto::BigVectorInterface&lt;NativeVectorT&lt;IntegerType&gt;, IntegerType&gt;,\n                            public lbcrypto::Serializable {\nprivate:\n    // m_modulus stores the internal modulus of the vector.\n    IntegerType m_modulus{0};\n\n#if BLOCK_VECTOR_ALLOCATION != 1\n    std::vector&lt;IntegerType&gt; m_data{};\n#else\n    xvector&lt;IntegerType&gt; m_data;\n#endif\n\n    // function to check if the index is a valid index.\n    bool IndexCheck(size_t length) const {\n        return length &lt; m_data.size();\n    }\n\npublic:\n    using BasicInt = typename IntegerType::Integer;\n\n    constexpr NativeVectorT() = default;\n\n    static constexpr NativeVectorT Single(const IntegerType&amp; val, const IntegerType&amp; modulus) noexcept {\n        return NativeVectorT(1, modulus, val);\n    }\n\n    /**\n   * Basic constructor for specifying the length of the vector.\n   *\n   * @param length is the length of the native vector, in terms of the number of\n   * entries.\n   */\n    explicit constexpr NativeVectorT(usint length) noexcept : m_data(length) {}\n\n    /**\n   * Basic constructor for specifying the length of the vector and the modulus.\n   *\n   * @param length is the length of the native vector, in terms of the number of\n   * entries.\n   * @param modulus is the modulus of the ring.\n   */\n    constexpr NativeVectorT(usint length, const IntegerType&amp; modulus) noexcept : m_modulus{modulus}, m_data(length) {\n        // TODO: better performance if this check is done at poly level\n        //        if (modulus.GetMSB() &gt; MAX_MODULUS_SIZE)\n        //            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::not_available_error, std::to_string(modulus.GetMSB()) +\n        //                              &quot; bits larger than max modulus bits &quot; + std::to_string(MAX_MODULUS_SIZE));\n    }\n\n    constexpr NativeVectorT(usint length, const IntegerType&amp; modulus, const IntegerType&amp; val) noexcept\n        : m_modulus{modulus}, m_data(length, val.Mod(modulus)) {\n        // TODO: better performance if this check is done at poly level\n        //        if (modulus.GetMSB() &gt; MAX_MODULUS_SIZE)\n        //            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::not_available_error, std::to_string(modulus.GetMSB()) +\n        //                              &quot; bits larger than max modulus bits &quot; + std::to_string(MAX_MODULUS_SIZE));\n    }\n\n    /**\n   * Basic constructor for copying a vector\n   *\n   * @param bigVector is the native vector to be copied.\n   */\n    constexpr NativeVectorT(const NativeVectorT&amp; v) noexcept : m_modulus{v.m_modulus}, m_data{v.m_data} {}\n\n    /**\n   * Basic move constructor for moving a vector\n   *\n   * @param &amp;&amp;bigVector is the native vector to be moved.\n   */\n    constexpr NativeVectorT(NativeVectorT&amp;&amp; v) noexcept\n        : m_modulus{std::move(v.m_modulus)}, m_data{std::move(v.m_data)} {}\n\n    /**\n   * Basic constructor for specifying the length of the vector\n   * the modulus and an initializer list.\n   *\n   * @param length is the length of the native vector, in terms of the number of\n   * entries.\n   * @param modulus is the modulus of the ring.\n   * @param rhs is an initializer list of strings\n   */\n\n    NativeVectorT(usint length, const IntegerType&amp; modulus, std::initializer_list&lt;std::string&gt; rhs) noexcept;\n\n    /**\n   * Basic constructor for specifying the length of the vector\n   * the modulus and an initializer list.\n   *\n   * @param length is the length of the native vector, in terms of the number of\n   * entries.\n   * @param modulus is the modulus of the ring.\n   * @param rhs is an initializer list of usint\n   */\n    NativeVectorT(usint length, const IntegerType&amp; modulus, std::initializer_list&lt;uint64_t&gt; rhs) noexcept;\n\n    /**\n   * Assignment operator to assign value from rhs\n   *\n   * @param &amp;rhs is the native vector to be assigned from.\n   * @return Assigned NativeVectorT.\n   */\n    NativeVectorT&amp; operator=(const NativeVectorT&amp; rhs) noexcept {\n        m_modulus = rhs.m_modulus;\n        if (m_data.size() &gt;= rhs.m_data.size()) {\n            std::copy(rhs.m_data.begin(), rhs.m_data.end(), m_data.begin());\n            if (m_data.size() &gt; rhs.m_data.size())\n                m_data.resize(rhs.m_data.size());\n            return *this;\n        }\n        m_data = rhs.m_data;\n        return *this;\n    }\n\n    /**\n   * Move assignment operator\n   *\n   * @param &amp;&amp;rhs is the native vector to be moved.\n   * @return moved NativeVectorT object\n   */\n    NativeVectorT&amp; operator=(NativeVectorT&amp;&amp; rhs) noexcept {\n        m_modulus = std::move(rhs.m_modulus);\n        m_data    = std::move(rhs.m_data);\n        return *this;\n    }\n\n    /**\n   * Initializer list for NativeVectorT.\n   *\n   * @param &amp;&amp;rhs is the list of strings containing integers to be assigned to\n   * the BBV.\n   * @return NativeVectorT object\n   */\n    NativeVectorT&amp; operator=(std::initializer_list&lt;std::string&gt; rhs) noexcept;\n\n    /**\n   * Initializer list for NativeVectorT.\n   *\n   * @param &amp;&amp;rhs is the list of integers to be assigned to the BBV.\n   * @return NativeVectorT object\n   */\n    NativeVectorT&amp; operator=(std::initializer_list&lt;uint64_t&gt; rhs) noexcept;\n\n    /**\n   * Assignment operator to assign value val to first entry, 0 for the rest of\n   * entries.\n   *\n   * @param val is the value to be assigned at the first entry.\n   * @return Assigned NativeVectorT.\n   */\n    constexpr NativeVectorT&amp; operator=(uint64_t val) {\n        std::fill(m_data.begin(), m_data.end(), 0);\n        m_data.at(0) = val;\n        return *this;\n    }\n\n    /**\n   * Sets/gets a value at an index.\n   * This method is slower than operator[] as it checks if index out of range\n   *\n   * @param index is the index to set a value at.\n   */\n    IntegerType&amp; at(size_t i) {\n        if (!NativeVectorT::IndexCheck(i))\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeVectorT index out of range&quot;);\n        return m_data[i];\n    }\n\n    const IntegerType&amp; at(size_t i) const {\n        if (!NativeVectorT::IndexCheck(i))\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::math_error, &quot;NativeVectorT index out of range&quot;);\n        return m_data[i];\n    }\n\n    /**\n   * operators to get a value at an index.\n   * @param idx is the index to get a value at.\n   * @return is the value at the index. return nullptr if invalid index.\n   */\n    IntegerType&amp; operator[](size_t idx) {\n        return m_data[idx];\n    }\n\n    const IntegerType&amp; operator[](size_t idx) const {\n        return m_data[idx];\n    }\n\n    /**\n   * Sets the vector modulus.\n   *\n   * @param value is the value to set.\n   * @param value is the modulus value to set.\n   */\n    void SetModulus(const IntegerType&amp; value) {\n        if (value.GetMSB() &gt; MAX_MODULUS_SIZE)\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::not_available_error,\n                          &quot;NativeVectorT supports only modulus size &lt;=  &quot; + std::to_string(MAX_MODULUS_SIZE) + &quot; bits&quot;);\n        m_modulus.m_value = value.m_value;\n    }\n\n    /**\n   * Sets the vector modulus and changes the values to match the new modulus.\n   *\n   * @param value is the value to set.\n   */\n    void SwitchModulus(const IntegerType&amp; value);\n\n    /**\n   * Gets the vector modulus.\n   *\n   * @return the vector modulus.\n   */\n    const IntegerType&amp; GetModulus() const {\n        return m_modulus;\n    }\n\n    /**\n   * Gets the vector length.\n   *\n   * @return vector length.\n   */\n    size_t GetLength() const {\n        return m_data.size();\n    }\n\n    // MODULAR ARITHMETIC OPERATIONS\n\n    /**\n   * Vector Modulus operator.\n   *\n   * @param modulus is the modulus to perform on the current vector entries.\n   * @return is the result after the modulus operation on current vector.\n   */\n    NativeVectorT Mod(const IntegerType&amp; modulus) const;\n\n    /**\n   * Vector Modulus operator. In-place variant.\n   *\n   * @param modulus is the modulus to perform on the current vector entries.\n   * @return is the result after the modulus operation on current vector.\n   */\n    NativeVectorT&amp; ModEq(const IntegerType&amp; modulus);\n\n    /**\n   * Scalar modulus addition.\n   *\n   * After addition modulus operation is performed with the current vector\n   * modulus.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeVectorT ModAdd(const IntegerType&amp; b) const;\n\n    /**\n   * Scalar modulus addition. In-place variant.\n   *\n   * After addition modulus operation is performed with the current vector\n   * modulus.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeVectorT&amp; ModAddEq(const IntegerType&amp; b);\n\n    /**\n   * Scalar modulus addition at a particular index.\n   *\n   * @param i is the index of the entry to add.\n   * @param &amp;b is the scalar to add.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeVectorT ModAddAtIndex(size_t i, const IntegerType&amp; b) const;\n\n    /**\n   * Scalar modulus addition at a particular index. In-place variant.\n   *\n   * @param i is the index of the entry to add.\n   * @param &amp;b is the scalar to add.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeVectorT&amp; ModAddAtIndexEq(size_t i, const IntegerType&amp; b);\n\n    /**\n   * vector modulus addition.\n   *\n   * @param &amp;b is the vector to add at all locations.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeVectorT ModAdd(const NativeVectorT&amp; b) const;\n\n    /**\n   * vector modulus addition. In-place variant.\n   *\n   * @param &amp;b is the vector to add at all locations.\n   * @return is the result of the modulus addition operation.\n   */\n    NativeVectorT&amp; ModAddEq(const NativeVectorT&amp; b);\n    NativeVectorT&amp; ModAddNoCheckEq(const NativeVectorT&amp; b) {\n        size_t size{m_data.size()};\n        auto mv{m_modulus};\n        for (size_t i = 0; i &lt; size; ++i)\n            m_data[i].ModAddFastEq(b[i], mv);\n        return *this;\n    }\n\n    /**\n   * Scalar modulus subtraction.\n   * After substraction modulus operation is performed with the current vector\n   * modulus.\n   * @param &amp;b is the scalar to subtract from all locations.\n   * @return is the result of the modulus substraction operation.\n   */\n    NativeVectorT ModSub(const IntegerType&amp; b) const;\n\n    /**\n   * Scalar modulus subtraction. In-place variant.\n   * After substraction modulus operation is performed with the current vector\n   * modulus.\n   * @param &amp;b is the scalar to subtract from all locations.\n   * @return is the result of the modulus substraction operation.\n   */\n    NativeVectorT&amp; ModSubEq(const IntegerType&amp; b);\n\n    /**\n   * Vector Modulus subtraction.\n   *\n   * @param &amp;b is the vector to subtract.\n   * @return is the result of the modulus subtraction operation.\n   */\n    NativeVectorT ModSub(const NativeVectorT&amp; b) const;\n\n    /**\n   * Vector Modulus subtraction. In-place variant.\n   *\n   * @param &amp;b is the vector to subtract.\n   * @return is the result of the modulus subtraction operation.\n   */\n    NativeVectorT&amp; ModSubEq(const NativeVectorT&amp; b);\n\n    /**\n   * Scalar modular multiplication.\n   * See the comments in the cpp files for details of the implementation.\n   *\n   * @param &amp;b is the scalar to multiply at all locations.\n   * @return is the result of the modulus multiplication operation.\n   */\n    NativeVectorT ModMul(const IntegerType&amp; b) const;\n\n    /**\n   * Scalar modular multiplication. In-place variant.\n   * See the comments in the cpp files for details of the implementation.\n   *\n   * @param &amp;b is the scalar to multiply at all locations.\n   * @return is the result of the modulus multiplication operation.\n   */\n    NativeVectorT&amp; ModMulEq(const IntegerType&amp; b);\n\n    /**\n   * Vector modulus multiplication.\n   *\n   * @param &amp;b is the vector to multiply.\n   * @return is the result of the modulus multiplication operation.\n   */\n    NativeVectorT ModMul(const NativeVectorT&amp; b) const;\n\n    /**\n   * Vector modulus multiplication. In-place variant.\n   *\n   * @param &amp;b is the vector to multiply.\n   * @return is the result of the modulus multiplication operation.\n   */\n    NativeVectorT&amp; ModMulEq(const NativeVectorT&amp; b);\n    NativeVectorT&amp; ModMulNoCheckEq(const NativeVectorT&amp; b) {\n        size_t size{m_data.size()};\n        auto mv{m_modulus};\n#ifdef NATIVEINT_BARRET_MOD\n        auto mu{m_modulus.ComputeMu()};\n        for (size_t i = 0; i &lt; size; ++i)\n            m_data[i].ModMulFastEq(b[i], mv, mu);\n#else\n        for (size_t i = 0; i &lt; size; ++i)\n            m_data[i].ModMulFastEq(b[i], mv);\n#endif\n        return *this;\n    }\n\n    /**\n   * Vector multiplication without applying the modulus operation.\n   *\n   * @param &amp;b is the vector to multiply.\n   * @return is the result of the multiplication operation.\n   */\n    NativeVectorT MultWithOutMod(const NativeVectorT&amp; b) const;\n\n    /**\n   * Scalar modulus exponentiation.\n   *\n   * @param &amp;b is the scalar to exponentiate at all locations.\n   * @return a new vector which is the result of the modulus exponentiation\n   * operation.\n   */\n    NativeVectorT ModExp(const IntegerType&amp; b) const;\n\n    /**\n   * Scalar modulus exponentiation. In-place variant.\n   *\n   * @param &amp;b is the scalar to exponentiate at all locations.\n   * @return a new vector which is the result of the modulus exponentiation\n   * operation.\n   */\n    NativeVectorT&amp; ModExpEq(const IntegerType&amp; b);\n\n    /**\n   * Modulus inverse.\n   *\n   * @return a new vector which is the result of the modulus inverse operation.\n   */\n    NativeVectorT ModInverse() const {\n        size_t size{m_data.size()};\n        auto mv{m_modulus};\n        NativeVectorT ans(size, mv);\n        for (size_t i{0}; i &lt; size; ++i)\n            ans[i] = m_data[i].ModInverse(mv);\n        return ans;\n    }\n\n    /**\n   * Modulus inverse. In-place variant.\n   *\n   * @return a new vector which is the result of the modulus inverse operation.\n   */\n    NativeVectorT&amp; ModInverseEq() {\n        size_t size{m_data.size()};\n        auto mv{m_modulus};\n        for (size_t i{0}; i &lt; size; ++i)\n            m_data[i] = m_data[i].ModInverse(mv);\n        return *this;\n    }\n\n    /**\n   * Perform a modulus by 2 operation.  Returns the least significant bit.\n   *\n   * @return a new vector which is the return value of the modulus by 2, also\n   * the least significant bit.\n   */\n    NativeVectorT ModByTwo() const;\n\n    /**\n   * Perform a modulus by 2 operation.  Returns the least significant bit.\n   * In-place variant.\n   *\n   * @return a new vector which is the return value of the modulus by 2, also\n   * the least significant bit.\n   */\n    NativeVectorT&amp; ModByTwoEq();\n\n    /**\n   * Multiply and Rounding operation on a BigInteger x. Returns [x*p/q] where []\n   * is the rounding operation.\n   *\n   * @param p is the numerator to be multiplied.\n   * @param q is the denominator to be divided.\n   * @return the result of multiply and round.\n   */\n    NativeVectorT MultiplyAndRound(const IntegerType&amp; p, const IntegerType&amp; q) const;\n\n    /**\n   * Multiply and Rounding operation on a BigInteger x. Returns [x*p/q] where []\n   * is the rounding operation. In-place variant.\n   *\n   * @param p is the numerator to be multiplied.\n   * @param q is the denominator to be divided.\n   * @return the result of multiply and round.\n   */\n    NativeVectorT&amp; MultiplyAndRoundEq(const IntegerType&amp; p, const IntegerType&amp; q);\n\n    /**\n   * Divide and Rounding operation on a BigInteger x. Returns [x/q] where [] is\n   * the rounding operation.\n   *\n   * @param q is the denominator to be divided.\n   * @return the result of divide and round.\n   */\n    NativeVectorT DivideAndRound(const IntegerType&amp; q) const;\n\n    /**\n   * Divide and Rounding operation on a BigInteger x. Returns [x/q] where [] is\n   * the rounding operation. In-place variant.\n   *\n   * @param q is the denominator to be divided.\n   * @return the result of divide and round.\n   */\n    NativeVectorT&amp; DivideAndRoundEq(const IntegerType&amp; q);\n\n    // OTHER FUNCTIONS\n\n    /**\n   * Digit vector at a specific index for all entries for a given number base.\n   * Warning: only power-of-2 bases are currently supported.\n   * Example: for vector (83, 1, 45), index 2 and base 4 we have:\n   *\n   *                           index:0,1,2,3\n   * |83|                           |3,0,1,1|                 |1|\n   * |1 | --base 4 decomposition--&gt; |1,0,0,0| --at index 2--&gt; |0|\n   * |45|                           |1,3,2,0|                 |2|\n   *\n   * The return vector is (1,0,2)\n   *\n   * @param index is the index to return the digit from in all entries.\n   * @param base is the base to use for the operation.\n   * @return is the digit at a specific index for all entries for a given number\n   * base\n   */\n    NativeVectorT GetDigitAtIndexForBase(usint index, usint base) const;\n\n    // STRINGS &amp; STREAMS\n\n    /**\n   * ostream operator to output vector values to console\n   *\n   * @param os is the std ostream object.\n   * @param &amp;ptr_obj is the NativeVectorT object to be printed.\n   * @return std ostream object which captures the vector values.\n   */\n    template &lt;class IntegerType_c&gt;\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const NativeVectorT&lt;IntegerType_c&gt;&amp; ptr_obj) {\n        auto len = ptr_obj.m_data.size();\n        os &lt;&lt; &quot;[&quot;;\n        for (usint i = 0; i &lt; len; i++) {\n            os &lt;&lt; ptr_obj.m_data[i];\n            os &lt;&lt; ((i == (len - 1)) ? &quot;]&quot; : &quot; &quot;);\n        }\n        os &lt;&lt; &quot; modulus: &quot; &lt;&lt; ptr_obj.m_modulus;\n        return os;\n    }\n\n    template &lt;class Archive&gt;\n    typename std::enable_if&lt;!cereal::traits::is_text_archive&lt;Archive&gt;::value, void&gt;::type save(\n        Archive&amp; ar, std::uint32_t const version) const {\n        ::cereal::size_type size = m_data.size();\n        ar(size);\n        if (size &gt; 0) {\n            ar(::cereal::binary_data(m_data.data(), size * sizeof(IntegerType)));\n        }\n        ar(m_modulus);\n    }\n\n    template &lt;class Archive&gt;\n    typename std::enable_if&lt;cereal::traits::is_text_archive&lt;Archive&gt;::value, void&gt;::type save(\n        Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::make_nvp(&quot;v&quot;, m_data));\n        ar(::cereal::make_nvp(&quot;m&quot;, m_modulus));\n    }\n\n    template &lt;class Archive&gt;\n    typename std::enable_if&lt;!cereal::traits::is_text_archive&lt;Archive&gt;::value, void&gt;::type load(\n        Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                           &quot; is from a later version of the library&quot;);\n        }\n        ::cereal::size_type size;\n        ar(size);\n        m_data.resize(size);\n        if (size &gt; 0) {\n            auto* data = reinterpret_cast&lt;IntegerType*&gt;(malloc(size * sizeof(IntegerType)));\n            ar(::cereal::binary_data(data, size * sizeof(IntegerType)));\n            for (::cereal::size_type i = 0; i &lt; size; i++) {\n                m_data[i] = data[i];\n            }\n            free(data);\n        }\n        ar(m_modulus);\n    }\n\n    template &lt;class Archive&gt;\n    typename std::enable_if&lt;cereal::traits::is_text_archive&lt;Archive&gt;::value, void&gt;::type load(\n        Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(lbcrypto::deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                           &quot; is from a later version of the library&quot;);\n        }\n        ar(::cereal::make_nvp(&quot;v&quot;, m_data));\n        ar(::cereal::make_nvp(&quot;m&quot;, m_modulus));\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;NativeVectorT&quot;;\n    }\n\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n};\n\n}  // namespace intnat\n\nnamespace cereal {\n\n//! Serialization for vector of NativeInteger\n\ntemplate &lt;class Archive, class A&gt;\ninline void CEREAL_SAVE_FUNCTION_NAME(Archive&amp; ar, std::vector&lt;intnat::NativeIntegerT&lt;uint64_t&gt;, A&gt; const&amp; vec) {\n    ar(make_size_tag(static_cast&lt;cereal::size_type&gt;(vec.size())));  // number of elements\n    for (const auto&amp; v : vec) {\n        ar(v.ConvertToInt());\n    }\n}\n\n#if defined(HAVE_INT128)\ntemplate &lt;class Archive, class A&gt;\ninline void CEREAL_SAVE_FUNCTION_NAME(Archive&amp; ar, std::vector&lt;intnat::NativeIntegerT&lt;uint128_t&gt;, A&gt; const&amp; vec) {\n    ar(make_size_tag(static_cast&lt;cereal::size_type&gt;(vec.size())));  // number of elements\n    constexpr uint128_t mask = (static_cast&lt;uint128_t&gt;(1) &lt;&lt; 64) - 1;\n    for (const auto&amp; v : vec) {\n        uint64_t vec[2];\n        uint128_t v128 = v.ConvertToInt();\n        vec[0]         = v128 &amp; mask;  // least significant word\n        vec[1]         = v128 &gt;&gt; 64;   // most significant word\n        ar(vec);\n    }\n}\n#endif\n\n//! Deserialization for vector of NativeInteger\n\ntemplate &lt;class Archive, class A&gt;\ninline void CEREAL_LOAD_FUNCTION_NAME(Archive&amp; ar, std::vector&lt;intnat::NativeIntegerT&lt;uint64_t&gt;, A&gt;&amp; vec) {\n    cereal::size_type size;\n    ar(make_size_tag(size));\n    vec.resize(static_cast&lt;size_t&gt;(size));\n    for (auto&amp; v : vec) {\n        uint64_t b;\n        ar(b);\n        v = b;\n    }\n}\n\n#if defined(HAVE_INT128)\ntemplate &lt;class Archive, class A&gt;\ninline void CEREAL_LOAD_FUNCTION_NAME(Archive&amp; ar, std::vector&lt;intnat::NativeIntegerT&lt;uint128_t&gt;, A&gt;&amp; vec) {\n    cereal::size_type size;\n    ar(make_size_tag(size));\n    vec.resize(static_cast&lt;size_t&gt;(size));\n    for (auto&amp; v : vec) {\n        uint64_t vec[2];\n        ar(vec);\n        v = vec[1];  // most significant word\n        v &lt;&lt;= 64;\n        v += vec[0];  // least significant word\n    }\n}\n#endif\n}  // namespace cereal\n\n#endif  // LBCRYPTO_MATH_HAL_INTNAT_MUBINTVECNAT_H\n"}, "/home/zero0000/static-analyze-openfhe/src/binfhe/include/lwe-ciphertext.h": {"id": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/lwe-ciphertext.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/lwe-ciphertext.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef _LWE_CIPHERTEXT_H_\n#define _LWE_CIPHERTEXT_H_\n\n#include &quot;lwe-ciphertext-fwd.h&quot;\n#include &quot;math/math-hal.h&quot;\n#include &quot;utils/serializable.h&quot;\n\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\nnamespace lbcrypto {\n/**\n * @brief Class that stores a LWE scheme ciphertext; composed of a vector &quot;a&quot;\n * and integer &quot;b&quot;\n */\nclass LWECiphertextImpl : public Serializable {\npublic:\n    LWECiphertextImpl() = default;\n\n    LWECiphertextImpl(const NativeVector&amp; a, const NativeInteger&amp; b) : m_a(a), m_b(b) {}\n\n    LWECiphertextImpl(NativeVector&amp;&amp; a, NativeInteger b) noexcept : m_a(std::move(a)), m_b(b) {}\n\n    LWECiphertextImpl(const LWECiphertextImpl&amp; rhs) : m_a(rhs.m_a), m_b(rhs.m_b) {}\n\n    LWECiphertextImpl(LWECiphertextImpl&amp;&amp; rhs) noexcept : m_a(std::move(rhs.m_a)), m_b(std::move(rhs.m_b)) {}\n\n    LWECiphertextImpl&amp; operator=(const LWECiphertextImpl&amp; rhs) {\n        m_a = rhs.m_a;\n        m_b = rhs.m_b;\n        return *this;\n    }\n\n    LWECiphertextImpl&amp; operator=(LWECiphertextImpl&amp;&amp; rhs) noexcept {\n        m_a = std::move(rhs.m_a);\n        m_b = std::move(rhs.m_b);\n        return *this;\n    }\n\n    const NativeVector&amp; GetA() const {\n        return m_a;\n    }\n\n    NativeVector&amp; GetA() {\n        return m_a;\n    }\n\n    const NativeInteger&amp; GetA(std::size_t i) const {\n        return m_a[i];\n    }\n\n    NativeInteger&amp; GetA(std::size_t i) {\n        return m_a[i];\n    }\n\n    const NativeInteger&amp; GetB() const {\n        return m_b;\n    }\n\n    NativeInteger&amp; GetB() {\n        return m_b;\n    }\n\n    const NativeInteger&amp; GetModulus() const {\n        return m_a.GetModulus();\n    }\n\n    uint32_t GetLength() const {\n        return m_a.GetLength();\n    }\n\n    const NativeInteger&amp; GetptModulus() const {\n        return m_p;\n    }\n\n    void SetA(const NativeVector&amp; a) {\n        m_a = a;\n    }\n\n    void SetB(const NativeInteger&amp; b) {\n        m_b = b;\n    }\n\n    void SetModulus(const NativeInteger&amp; mod) {\n        m_a.ModEq(mod);\n        m_a.SetModulus(mod);\n        m_b.ModEq(mod);\n    }\n\n    void SetptModulus(const NativeInteger&amp; pmod) {\n        m_p = pmod;\n    }\n\n    bool operator==(const LWECiphertextImpl&amp; other) const {\n        return m_a == other.m_a &amp;&amp; m_b == other.m_b;\n    }\n\n    bool operator!=(const LWECiphertextImpl&amp; other) const {\n        return !(*this == other);\n    }\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::make_nvp(&quot;a&quot;, m_a));\n        ar(::cereal::make_nvp(&quot;b&quot;, m_b));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                 &quot; is from a later version of the library&quot;);\n        }\n\n        ar(::cereal::make_nvp(&quot;a&quot;, m_a));\n        ar(::cereal::make_nvp(&quot;b&quot;, m_b));\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;LWECiphertext&quot;;\n    }\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\nprivate:\n    NativeVector m_a{};\n    NativeInteger m_b{};\n    NativeInteger m_p = 4;  // pt modulus\n};\n\n}  // namespace lbcrypto\n\n#endif  // _LWE_CIPHERTEXT_H_\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "content": "// clang-format off\n//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  PRNG engine based on BLAKE2b\n */\n\n#ifndef _SRC_LIB_UTILS_BLAKE2ENGINE_H\n#define _SRC_LIB_UTILS_BLAKE2ENGINE_H\n\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;array&gt;\n#include &lt;limits&gt;\n\n#include &quot;blake2.h&quot;\n\n#include &quot;utils/exception.h&quot;\n\nnamespace lbcrypto {\n\n// the buffer stores 1024 samples of 32-bit integers\nconst uint32_t PRNG_BUFFER_SIZE = 1024;\n\n/**\n * @brief Defines the PRNG engine used by OpenFHE. It is based on BLAKE2. Use\n * this as a template for adding other PRNG engines to OpenFHE.\n */\nclass Blake2Engine {\n public:\n  // all C++11 distributions used in OpenFHE work by default with uint32_t\n  // a different data type can be specified if needed for a particular\n  // architecture\n  using result_type = uint32_t;\n\n  /**\n   * @brief Constructor using a small seed - used for generating a large seed\n   */\n  explicit Blake2Engine(result_type seed)\n      : m_counter(0), m_buffer({}), m_bufferIndex(0) {\n    m_seed[0] = seed;\n  }\n\n  /**\n   * @brief Main constructor taking a vector of 16 integers as a seed\n   */\n  explicit Blake2Engine(const std::array&lt;result_type, 16&gt;&amp; seed)\n      : m_counter(0), m_seed(seed), m_buffer({}), m_bufferIndex(0) {}\n\n  /**\n   * @brief Main constructor taking a vector of 16 integers as a seed and a\n   * counter\n   */\n  explicit Blake2Engine(const std::array&lt;result_type, 16&gt;&amp; seed,\n                        result_type counter)\n      : m_counter(counter), m_seed(seed), m_buffer({}), m_bufferIndex(0) {}\n\n  /**\n   * @brief minimum value used by C+11 distribution generators when no lower\n   * bound is explicitly specified by the user\n   */\n  static constexpr result_type min() {\n    return std::numeric_limits&lt;result_type&gt;::min();\n  }\n\n  /**\n   * @brief maximum value used by C+11 distribution generators when no upper\n   * bound is explicitly specified by the user\n   */\n  static constexpr result_type max() {\n    return std::numeric_limits&lt;result_type&gt;::max();\n  }\n\n  /**\n   * @brief main call to the PRNG\n   */\n  result_type operator()() {\n    result_type result;\n\n    if (m_bufferIndex == PRNG_BUFFER_SIZE) m_bufferIndex = 0;\n\n    // makes a call to the BLAKE2 generator only when the currently buffered\n    // values are all consumed precomputations are done only once for the\n    // current buffer\n    if (m_bufferIndex == 0) Generate();\n\n    result = m_buffer[m_bufferIndex];\n\n    m_bufferIndex++;\n\n    return result;\n  }\n\n  Blake2Engine(const Blake2Engine&amp; other) {\n    m_counter = other.m_counter;\n    m_seed = other.m_seed;\n    m_buffer = other.m_buffer;\n    m_bufferIndex = other.m_bufferIndex;\n  }\n\n  void operator=(const Blake2Engine&amp; other) {\n    m_counter = other.m_counter;\n    m_seed = other.m_seed;\n    m_buffer = other.m_buffer;\n    m_bufferIndex = other.m_bufferIndex;\n  }\n\n private:\n  /**\n   * @brief The main call to blake2xb function\n   */\n  void Generate() {\n    // m_counter is the input to the hash function\n    // m_buffer is the output\n    if (blake2xb(m_buffer.begin(), m_buffer.size() * sizeof(result_type),\n                 &amp;m_counter, sizeof(m_counter), m_seed.cbegin(),\n                 m_seed.size() * sizeof(result_type)) != 0) {\n      &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;PRNG: blake2xb failed&quot;);\n    }\n    m_counter++;\n    return;\n  }\n\n  // counter used as input to the BLAKE2 hash function\n  // gets incremented after each call\n  uint64_t m_counter = 0;\n\n  // the seed for the BLAKE2 hash function\n  std::array&lt;result_type, 16&gt; m_seed{};\n\n  // The vector that stores random samples generated using the hash function\n  std::array&lt;result_type, PRNG_BUFFER_SIZE&gt; m_buffer{};\n\n  // Index in m_buffer corresponding to the current PRNG sample\n  uint16_t m_bufferIndex = 0;\n};\n\n}  // namespace lbcrypto\n\n#endif\n// clang-format on\n"}, "/usr/include/c++/11/bits/uniform_int_dist.h": {"id": "/usr/include/c++/11/bits/uniform_int_dist.h", "filePath": "/usr/include/c++/11/bits/uniform_int_dist.h", "content": "// Class template uniform_int_distribution -*- C++ -*-\n\n// Copyright (C) 2009-2021 Free Software Foundation, Inc.\n//\n// This file is part of the GNU ISO C++ Library.  This library is free\n// software; you can redistribute it and/or modify it under the\n// terms of the GNU General Public License as published by the\n// Free Software Foundation; either version 3, or (at your option)\n// any later version.\n\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// Under Section 7 of GPL version 3, you are granted additional\n// permissions described in the GCC Runtime Library Exception, version\n// 3.1, as published by the Free Software Foundation.\n\n// You should have received a copy of the GNU General Public License and\n// a copy of the GCC Runtime Library Exception along with this program;\n// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n// &lt;http://www.gnu.org/licenses/&gt;.\n\n/**\n * @file bits/uniform_int_dist.h\n *  This is an internal header file, included by other library headers.\n *  Do not attempt to use it directly. @headername{random}\n */\n\n#ifndef _GLIBCXX_BITS_UNIFORM_INT_DIST_H\n#define _GLIBCXX_BITS_UNIFORM_INT_DIST_H\n\n#include &lt;type_traits&gt;\n#include &lt;ext/numeric_traits.h&gt;\n#if __cplusplus &gt; 201703L\n# include &lt;concepts&gt;\n#endif\n#include &lt;bits/concept_check.h&gt; // __glibcxx_function_requires\n\nnamespace std _GLIBCXX_VISIBILITY(default)\n{\n_GLIBCXX_BEGIN_NAMESPACE_VERSION\n\n#ifdef __cpp_lib_concepts\n  /// Requirements for a uniform random bit generator.\n  template&lt;typename _Gen&gt;\n    concept uniform_random_bit_generator\n      = invocable&lt;_Gen&amp;&gt; &amp;&amp; unsigned_integral&lt;invoke_result_t&lt;_Gen&amp;&gt;&gt;\n      &amp;&amp; requires\n      {\n\t{ _Gen::min() } -&gt; same_as&lt;invoke_result_t&lt;_Gen&amp;&gt;&gt;;\n\t{ _Gen::max() } -&gt; same_as&lt;invoke_result_t&lt;_Gen&amp;&gt;&gt;;\n\trequires bool_constant&lt;(_Gen::min() &lt; _Gen::max())&gt;::value;\n      };\n#endif\n\n  namespace __detail\n  {\n    // Determine whether number is a power of two.\n    // This is true for zero, which is OK because we want _Power_of_2(n+1)\n    // to be true if n==numeric_limits&lt;_Tp&gt;::max() and so n+1 wraps around.\n    template&lt;typename _Tp&gt;\n      constexpr bool\n      _Power_of_2(_Tp __x)\n      {\n\treturn ((__x - 1) &amp; __x) == 0;\n      }\n  }\n\n  /**\n   * @brief Uniform discrete distribution for random numbers.\n   * A discrete random distribution on the range @f$[min, max]@f$ with equal\n   * probability throughout the range.\n   */\n  template&lt;typename _IntType = int&gt;\n    class uniform_int_distribution\n    {\n      static_assert(std::is_integral&lt;_IntType&gt;::value,\n\t\t    &quot;template argument must be an integral type&quot;);\n\n    public:\n      /** The type of the range of the distribution. */\n      typedef _IntType result_type;\n      /** Parameter type. */\n      struct param_type\n      {\n\ttypedef uniform_int_distribution&lt;_IntType&gt; distribution_type;\n\n\tparam_type() : param_type(0) { }\n\n\texplicit\n\tparam_type(_IntType __a,\n\t\t   _IntType __b = __gnu_cxx::__int_traits&lt;_IntType&gt;::__max)\n\t: _M_a(__a), _M_b(__b)\n\t{\n\t  __glibcxx_assert(_M_a &lt;= _M_b);\n\t}\n\n\tresult_type\n\ta() const\n\t{ return _M_a; }\n\n\tresult_type\n\tb() const\n\t{ return _M_b; }\n\n\tfriend bool\n\toperator==(const param_type&amp; __p1, const param_type&amp; __p2)\n\t{ return __p1._M_a == __p2._M_a &amp;&amp; __p1._M_b == __p2._M_b; }\n\n\tfriend bool\n\toperator!=(const param_type&amp; __p1, const param_type&amp; __p2)\n\t{ return !(__p1 == __p2); }\n\n      private:\n\t_IntType _M_a;\n\t_IntType _M_b;\n      };\n\n    public:\n      /**\n       * @brief Constructs a uniform distribution object.\n       */\n      uniform_int_distribution() : uniform_int_distribution(0) { }\n\n      /**\n       * @brief Constructs a uniform distribution object.\n       */\n      explicit\n      uniform_int_distribution(_IntType __a,\n\t\t\t       _IntType __b\n\t\t\t\t = __gnu_cxx::__int_traits&lt;_IntType&gt;::__max)\n      : _M_param(__a, __b)\n      { }\n\n      explicit\n      uniform_int_distribution(const param_type&amp; __p)\n      : _M_param(__p)\n      { }\n\n      /**\n       * @brief Resets the distribution state.\n       *\n       * Does nothing for the uniform integer distribution.\n       */\n      void\n      reset() { }\n\n      result_type\n      a() const\n      { return _M_param.a(); }\n\n      result_type\n      b() const\n      { return _M_param.b(); }\n\n      /**\n       * @brief Returns the parameter set of the distribution.\n       */\n      param_type\n      param() const\n      { return _M_param; }\n\n      /**\n       * @brief Sets the parameter set of the distribution.\n       * @param __param The new parameter set of the distribution.\n       */\n      void\n      param(const param_type&amp; __param)\n      { _M_param = __param; }\n\n      /**\n       * @brief Returns the inclusive lower bound of the distribution range.\n       */\n      result_type\n      min() const\n      { return this-&gt;a(); }\n\n      /**\n       * @brief Returns the inclusive upper bound of the distribution range.\n       */\n      result_type\n      max() const\n      { return this-&gt;b(); }\n\n      /**\n       * @brief Generating functions.\n       */\n      template&lt;typename _UniformRandomBitGenerator&gt;\n\tresult_type\n\toperator()(_UniformRandomBitGenerator&amp; __urng)\n        { return this-&gt;operator()(__urng, _M_param); }\n\n      template&lt;typename _UniformRandomBitGenerator&gt;\n\tresult_type\n\toperator()(_UniformRandomBitGenerator&amp; __urng,\n\t\t   const param_type&amp; __p);\n\n      template&lt;typename _ForwardIterator,\n\t       typename _UniformRandomBitGenerator&gt;\n\tvoid\n\t__generate(_ForwardIterator __f, _ForwardIterator __t,\n\t\t   _UniformRandomBitGenerator&amp; __urng)\n\t{ this-&gt;__generate(__f, __t, __urng, _M_param); }\n\n      template&lt;typename _ForwardIterator,\n\t       typename _UniformRandomBitGenerator&gt;\n\tvoid\n\t__generate(_ForwardIterator __f, _ForwardIterator __t,\n\t\t   _UniformRandomBitGenerator&amp; __urng,\n\t\t   const param_type&amp; __p)\n\t{ this-&gt;__generate_impl(__f, __t, __urng, __p); }\n\n      template&lt;typename _UniformRandomBitGenerator&gt;\n\tvoid\n\t__generate(result_type* __f, result_type* __t,\n\t\t   _UniformRandomBitGenerator&amp; __urng,\n\t\t   const param_type&amp; __p)\n\t{ this-&gt;__generate_impl(__f, __t, __urng, __p); }\n\n      /**\n       * @brief Return true if two uniform integer distributions have\n       *        the same parameters.\n       */\n      friend bool\n      operator==(const uniform_int_distribution&amp; __d1,\n\t\t const uniform_int_distribution&amp; __d2)\n      { return __d1._M_param == __d2._M_param; }\n\n    private:\n      template&lt;typename _ForwardIterator,\n\t       typename _UniformRandomBitGenerator&gt;\n\tvoid\n\t__generate_impl(_ForwardIterator __f, _ForwardIterator __t,\n\t\t\t_UniformRandomBitGenerator&amp; __urng,\n\t\t\tconst param_type&amp; __p);\n\n      param_type _M_param;\n\n      // Lemire&#x27;s nearly divisionless algorithm.\n      // Returns an unbiased random number from __g downscaled to [0,__range)\n      // using an unsigned type _Wp twice as wide as unsigned type _Up.\n      template&lt;typename _Wp, typename _Urbg, typename _Up&gt;\n\tstatic _Up\n\t_S_nd(_Urbg&amp; __g, _Up __range)\n\t{\n\t  using _Up_traits = __gnu_cxx::__int_traits&lt;_Up&gt;;\n\t  using _Wp_traits = __gnu_cxx::__int_traits&lt;_Wp&gt;;\n\t  static_assert(!_Up_traits::__is_signed, &quot;U must be unsigned&quot;);\n\t  static_assert(!_Wp_traits::__is_signed, &quot;W must be unsigned&quot;);\n\t  static_assert(_Wp_traits::__digits == (2 * _Up_traits::__digits),\n\t\t\t&quot;W must be twice as wide as U&quot;);\n\n\t  // reference: Fast Random Integer Generation in an Interval\n\t  // ACM Transactions on Modeling and Computer Simulation 29 (1), 2019\n\t  // https://arxiv.org/abs/1805.10941\n\t  _Wp __product = _Wp(__g()) * _Wp(__range);\n\t  _Up __low = _Up(__product);\n\t  if (__low &lt; __range)\n\t    {\n\t      _Up __threshold = -__range % __range;\n\t      while (__low &lt; __threshold)\n\t\t{\n\t\t  __product = _Wp(__g()) * _Wp(__range);\n\t\t  __low = _Up(__product);\n\t\t}\n\t    }\n\t  return __product &gt;&gt; _Up_traits::__digits;\n\t}\n    };\n\n  template&lt;typename _IntType&gt;\n    template&lt;typename _UniformRandomBitGenerator&gt;\n      typename uniform_int_distribution&lt;_IntType&gt;::result_type\n      uniform_int_distribution&lt;_IntType&gt;::\n      operator()(_UniformRandomBitGenerator&amp; __urng,\n\t\t const param_type&amp; __param)\n      {\n\ttypedef typename _UniformRandomBitGenerator::result_type _Gresult_type;\n\ttypedef typename make_unsigned&lt;result_type&gt;::type __utype;\n\ttypedef typename common_type&lt;_Gresult_type, __utype&gt;::type __uctype;\n\n\tconstexpr __uctype __urngmin = _UniformRandomBitGenerator::min();\n\tconstexpr __uctype __urngmax = _UniformRandomBitGenerator::max();\n\tstatic_assert( __urngmin &lt; __urngmax,\n\t    &quot;Uniform random bit generator must define min() &lt; max()&quot;);\n\tconstexpr __uctype __urngrange = __urngmax - __urngmin;\n\n\tconst __uctype __urange\n\t  = __uctype(__param.b()) - __uctype(__param.a());\n\n\t__uctype __ret;\n\tif (__urngrange &gt; __urange)\n\t  {\n\t    // downscaling\n\n\t    const __uctype __uerange = __urange + 1; // __urange can be zero\n\n#if defined __UINT64_TYPE__ &amp;&amp; defined __UINT32_TYPE__\n#if __SIZEOF_INT128__\n\t    if _GLIBCXX17_CONSTEXPR (__urngrange == __UINT64_MAX__)\n\t      {\n\t\t// __urng produces values that use exactly 64-bits,\n\t\t// so use 128-bit integers to downscale to desired range.\n\t\t__UINT64_TYPE__ __u64erange = __uerange;\n\t\t__ret = _S_nd&lt;unsigned __int128&gt;(__urng, __u64erange);\n\t      }\n\t    else\n#endif\n\t    if _GLIBCXX17_CONSTEXPR (__urngrange == __UINT32_MAX__)\n\t      {\n\t\t// __urng produces values that use exactly 32-bits,\n\t\t// so use 64-bit integers to downscale to desired range.\n\t\t__UINT32_TYPE__ __u32erange = __uerange;\n\t\t__ret = _S_nd&lt;__UINT64_TYPE__&gt;(__urng, __u32erange);\n\t      }\n\t    else\n#endif\n\t      {\n\t\t// fallback case (2 divisions)\n\t\tconst __uctype __scaling = __urngrange / __uerange;\n\t\tconst __uctype __past = __uerange * __scaling;\n\t\tdo\n\t\t  __ret = __uctype(__urng()) - __urngmin;\n\t\twhile (__ret &gt;= __past);\n\t\t__ret /= __scaling;\n\t      }\n\t  }\n\telse if (__urngrange &lt; __urange)\n\t  {\n\t    // upscaling\n\t    /*\n\t      Note that every value in [0, urange]\n\t      can be written uniquely as\n\n\t      (urngrange + 1) * high + low\n\n\t      where\n\n\t      high in [0, urange / (urngrange + 1)]\n\n\t      and\n\n\t      low in [0, urngrange].\n\t    */\n\t    __uctype __tmp; // wraparound control\n\t    do\n\t      {\n\t\tconst __uctype __uerngrange = __urngrange + 1;\n\t\t__tmp = (__uerngrange * operator()\n\t\t\t (__urng, param_type(0, __urange / __uerngrange)));\n\t\t__ret = __tmp + (__uctype(__urng()) - __urngmin);\n\t      }\n\t    while (__ret &gt; __urange || __ret &lt; __tmp);\n\t  }\n\telse\n\t  __ret = __uctype(__urng()) - __urngmin;\n\n\treturn __ret + __param.a();\n      }\n\n\n  template&lt;typename _IntType&gt;\n    template&lt;typename _ForwardIterator,\n\t     typename _UniformRandomBitGenerator&gt;\n      void\n      uniform_int_distribution&lt;_IntType&gt;::\n      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,\n\t\t      _UniformRandomBitGenerator&amp; __urng,\n\t\t      const param_type&amp; __param)\n      {\n\t__glibcxx_function_requires(_ForwardIteratorConcept&lt;_ForwardIterator&gt;)\n\ttypedef typename _UniformRandomBitGenerator::result_type _Gresult_type;\n\ttypedef typename make_unsigned&lt;result_type&gt;::type __utype;\n\ttypedef typename common_type&lt;_Gresult_type, __utype&gt;::type __uctype;\n\n\tstatic_assert( __urng.min() &lt; __urng.max(),\n\t    &quot;Uniform random bit generator must define min() &lt; max()&quot;);\n\n\tconstexpr __uctype __urngmin = __urng.min();\n\tconstexpr __uctype __urngmax = __urng.max();\n\tconstexpr __uctype __urngrange = __urngmax - __urngmin;\n\tconst __uctype __urange\n\t  = __uctype(__param.b()) - __uctype(__param.a());\n\n\t__uctype __ret;\n\n\tif (__urngrange &gt; __urange)\n\t  {\n\t    if (__detail::_Power_of_2(__urngrange + 1)\n\t\t&amp;&amp; __detail::_Power_of_2(__urange + 1))\n\t      {\n\t\twhile (__f != __t)\n\t\t  {\n\t\t    __ret = __uctype(__urng()) - __urngmin;\n\t\t    *__f++ = (__ret &amp; __urange) + __param.a();\n\t\t  }\n\t      }\n\t    else\n\t      {\n\t\t// downscaling\n\t\tconst __uctype __uerange = __urange + 1; // __urange can be zero\n\t\tconst __uctype __scaling = __urngrange / __uerange;\n\t\tconst __uctype __past = __uerange * __scaling;\n\t\twhile (__f != __t)\n\t\t  {\n\t\t    do\n\t\t      __ret = __uctype(__urng()) - __urngmin;\n\t\t    while (__ret &gt;= __past);\n\t\t    *__f++ = __ret / __scaling + __param.a();\n\t\t  }\n\t      }\n\t  }\n\telse if (__urngrange &lt; __urange)\n\t  {\n\t    // upscaling\n\t    /*\n\t      Note that every value in [0, urange]\n\t      can be written uniquely as\n\n\t      (urngrange + 1) * high + low\n\n\t      where\n\n\t      high in [0, urange / (urngrange + 1)]\n\n\t      and\n\n\t      low in [0, urngrange].\n\t    */\n\t    __uctype __tmp; // wraparound control\n\t    while (__f != __t)\n\t      {\n\t\tdo\n\t\t  {\n\t\t    constexpr __uctype __uerngrange = __urngrange + 1;\n\t\t    __tmp = (__uerngrange * operator()\n\t\t\t     (__urng, param_type(0, __urange / __uerngrange)));\n\t\t    __ret = __tmp + (__uctype(__urng()) - __urngmin);\n\t\t  }\n\t\twhile (__ret &gt; __urange || __ret &lt; __tmp);\n\t\t*__f++ = __ret;\n\t      }\n\t  }\n\telse\n\t  while (__f != __t)\n\t    *__f++ = __uctype(__urng()) - __urngmin + __param.a();\n      }\n\n  // operator!= and operator&lt;&lt; and operator&gt;&gt; are defined in &lt;bits/random.h&gt;\n\n_GLIBCXX_END_NAMESPACE_VERSION\n} // namespace std\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Wraps parameters for integer lattice operations using double-CRT representation. Inherits from ElemParams\n */\n\n#ifndef LBCRYPTO_INC_LATTICE_ILDCRTPARAMS_H\n#define LBCRYPTO_INC_LATTICE_ILDCRTPARAMS_H\n\n#include &quot;lattice/elemparams.h&quot;\n#include &quot;lattice/ilparams.h&quot;\n\n#include &quot;math/math-hal.h&quot;\n#include &quot;math/nbtheory-impl.h&quot;\n\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/inttypes.h&quot;\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\nnamespace lbcrypto {\n\n/**\n * @brief Parameters for array of ideal lattices (used for Double-CRT).\n *\n * The double-CRT representation of polynomials is a common optimization for\n * lattice encryption operations. Basically, it allows large-modulus polynamials\n * to be represented as multiple smaller-modulus polynomials. The double-CRT\n * representations are discussed theoretically here:\n *   - Gentry C., Halevi S., Smart N.P. (2012) Homomorphic Evaluation of the AES\n * Circuit. In: Safavi-Naini R., Canetti R. (eds) Advances in Cryptology \u2013\n * CRYPTO 2012. Lecture Notes in Computer Science, vol 7417. Springer, Berlin,\n * Heidelberg\n */\ntemplate &lt;typename IntType&gt;\nclass ILDCRTParams final : public ElemParams&lt;IntType&gt; {\npublic:\n    static constexpr usint DEFAULT_NBITS = 20;\n\n    using Integer        = IntType;\n    using ILNativeParams = ILParamsImpl&lt;NativeInteger&gt;;\n\n    /**\n   * @brief Constructor with basic parameter set.\n   * q is selected as FirstPrime(bits, order)\n   * @param order the order of the ciphertext.\n   * @param depth is the size of the tower.\n   * @param bits is the number of bits of each tower&#x27;s moduli.\n   */\n    explicit ILDCRTParams(usint order = 0, usint depth = 1, usint bits = DEFAULT_NBITS)\n        : ElemParams&lt;IntType&gt;(order, 0), m_params(depth) {\n        if (order == 0)\n            return;\n        if (depth == 0)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Invalid depth for ILDCRTParams&quot;);\n        if (bits == 0 || bits &gt; 64)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Invalid bits for ILDCRTParams&quot;);\n        auto q{FirstPrime&lt;NativeInteger&gt;(bits, order)};\n        for (usint j = 0; j &lt; depth; ++j, q = NextPrime&lt;NativeInteger&gt;(q, order))\n            m_params[j] = std::make_shared&lt;ILNativeParams&gt;(order, q, RootOfUnity&lt;NativeInteger&gt;(order, q));\n        RecalculateModulus();\n    }\n\n    /**\n   * @brief Constructor with basic parameters\n   *\n   * @param cyclotomic_order the order of the ciphertext\n   * @param &amp;modulus is the modulus for the primary ciphertext.\n   * @param rootsOfUnity is unused\n   */\n\n    // root of unity unused?\n    ILDCRTParams(usint cyclotomic_order, const IntType&amp; modulus, const IntType&amp; rootOfUnity)\n        : ElemParams&lt;IntType&gt;(cyclotomic_order, modulus, 0, 0, 0), m_originalModulus(modulus) {\n        // NOTE params generation uses this constructor to make an empty params that\n        // it will later populate during the gen process. For that special case...\n        // we don&#x27;t populate, and we just return\n        if (cyclotomic_order == 0)\n            return;\n        std::vector&lt;NativeInteger&gt; moduli;\n        std::vector&lt;NativeInteger&gt; rootsOfUnity;\n        auto q{FirstPrime&lt;NativeInteger&gt;(DEFAULT_NBITS, cyclotomic_order)};\n        IntType compositeModulus(1);\n        while (true) {\n            moduli.push_back(q);\n            rootsOfUnity.push_back(RootOfUnity(cyclotomic_order, q));\n            m_params.push_back(std::make_shared&lt;ILNativeParams&gt;(cyclotomic_order, q, rootsOfUnity.back()));\n            compositeModulus = compositeModulus * IntType(q.ConvertToInt());\n            if (compositeModulus &gt;= modulus)\n                break;\n            q = NextPrime(q, cyclotomic_order);\n        }\n        RecalculateModulus();\n    }\n\n    /**\n   * @brief Constructor with some pre-computed parameters provided as input.\n   * @param cyclotomic_order the order of the ciphertext\n   * @param moduli the list of the smaller moduli of the component polynomials.\n   * @param rootsOfUnity the list of the smaller roots of unity of the component\n   * polynomials.\n   * @param moduliBig the list of the big moduli of the component polynomials\n   * (arbitrary cyclotomics).\n   * @param rootsOfUnityBig the list of the roots of unity of the component\n   * polynomials for big moduli (arbitrary cyclotomics).\n   * @return\n   */\n    ILDCRTParams(usint cyclotomic_order, const std::vector&lt;NativeInteger&gt;&amp; moduli,\n                 const std::vector&lt;NativeInteger&gt;&amp; rootsOfUnity, const std::vector&lt;NativeInteger&gt;&amp; moduliBig = {},\n                 const std::vector&lt;NativeInteger&gt;&amp; rootsOfUnityBig = {},\n                 const IntType&amp; inputOriginalModulus               = IntType(0))\n        : ElemParams&lt;IntType&gt;(cyclotomic_order, 0, 0, 0, 0),\n          m_originalModulus(inputOriginalModulus),\n          m_params(moduli.size()) {\n        if (moduli.size() != rootsOfUnity.size())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;sizes of moduli and roots of unity do not match&quot;);\n        size_t size{moduli.size()};\n        if (moduliBig.size() == size) {\n            for (size_t i = 0; i &lt; size; ++i)\n                m_params[i] = std::make_shared&lt;ILNativeParams&gt;(cyclotomic_order, moduli[i], rootsOfUnity[i],\n                                                               moduliBig[i], rootsOfUnityBig[i]);\n        }\n        else {\n            for (size_t i = 0; i &lt; size; ++i)\n                m_params[i] = std::make_shared&lt;ILNativeParams&gt;(cyclotomic_order, moduli[i], rootsOfUnity[i]);\n        }\n        RecalculateModulus();\n    }\n\n    /**\n   * @brief Constructor with only cylotomic order and chain of moduli.\n   * Multiplied values of the chain of moduli is automatically calculated. Root\n   * of unity of the modulus is also calculated.\n   *\n   * @param cyclotomic_order the order of the ciphertext\n   * @param &amp;moduli is the tower of moduli\n   */\n    ILDCRTParams(usint cyclotomic_order, const std::vector&lt;NativeInteger&gt;&amp; moduli,\n                 const IntType&amp; inputOriginalModulus = IntType(0))\n        : ElemParams&lt;IntType&gt;(cyclotomic_order, 0, 0, 0, 0),\n          m_originalModulus(inputOriginalModulus),\n          m_params(moduli.size()) {\n        for (size_t i = 0; i &lt; moduli.size(); i++)\n            m_params[i] = std::make_shared&lt;ILNativeParams&gt;(cyclotomic_order, moduli[i], 0, 0, 0);\n        RecalculateModulus();\n    }\n\n    /**\n   * @brief Constructor that takes in the cyclotomic order and the component\n   * parameters of the component moduli.\n   * @param cyclotomic_order the primary cyclotomic order.  This is not checked\n   * against the component moduli.\n   * @param params the componet parameters.\n   * @return\n   */\n    ILDCRTParams(usint cyclotomic_order, std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt;&amp; params,\n                 const IntType&amp; inputOriginalModulus = IntType(0))\n        : ElemParams&lt;IntType&gt;(cyclotomic_order, 0, 0, 0, 0), m_originalModulus(inputOriginalModulus), m_params(params) {\n        RecalculateModulus();\n    }\n\n    ILDCRTParams(const ILDCRTParams&amp; rhs)\n        : ElemParams&lt;IntType&gt;(rhs), m_originalModulus(rhs.m_originalModulus), m_params(rhs.m_params) {}\n\n    ILDCRTParams(ILDCRTParams&amp;&amp; rhs) noexcept\n        : ElemParams&lt;IntType&gt;(rhs),\n          m_originalModulus(std::move(rhs.m_originalModulus)),\n          m_params(std::move(rhs.m_params)) {}\n\n    /**\n   * Assignment Operator.\n   *\n   * @param &amp;rhs the copied ILDCRTParams.\n   * @return the resulting ILDCRTParams.\n   */\n    ILDCRTParams&amp; operator=(const ILDCRTParams&amp; rhs) {\n        ElemParams&lt;IntType&gt;::operator=(rhs);\n        m_originalModulus = rhs.m_originalModulus;\n        m_params          = rhs.m_params;\n        return *this;\n    }\n\n    ILDCRTParams&amp; operator=(ILDCRTParams&amp;&amp; rhs) noexcept {\n        ElemParams&lt;IntType&gt;::operator=(rhs);\n        m_originalModulus = std::move(rhs.m_originalModulus);\n        m_params          = std::move(rhs.m_params);\n        return *this;\n    }\n\n    // ACCESSORS\n    /**\n   * @brief Getter method for the component parameters.\n   * @return A vector of the component polynomial parameters.\n   */\n    const std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt;&amp; GetParams() const {\n        return m_params;\n    }\n\n    /**\n   * @brief Getter method that returns a subset of the component parameters.\n   *\n   * @param start The index of the first tower to include in the result.\n   * @param end The index of the last tower to include.\n   * @return A vector of the component polynomial parameters.\n   */\n    std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt; GetParamPartition(uint32_t start, uint32_t end) const {\n        if (end &lt; start || end &gt;= m_params.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Incorrect parameters for GetParamPartition - (start: &quot; + std::to_string(start) +\n                                          &quot;, end:&quot; + std::to_string(end) + &quot;)&quot;);\n        }\n\n        std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt; resParams;\n        for (uint32_t i = start; i &lt;= end; ++i)\n            resParams.push_back(m_params[i]);\n        return resParams;\n    }\n\n    /**\n   * @brief Simple getter method for the original modulus, not the ciphertex\n   * modulus.\n   * @return The original  modulus, not the big ciphertext modulus.\n   */\n    const IntType&amp; GetOriginalModulus() const {\n        return m_originalModulus;\n    }\n    /**\n   * @brief Simple setter method for the original modulus, not the ciphertex\n   * modulus.\n   * @return void\n   */\n    void SetOriginalModulus(const IntType&amp; inputOriginalModulus) {\n        m_originalModulus = inputOriginalModulus;\n    }\n    /**\n   * @brief Getter method for the component parameters of a specific index.\n   * @param i the index of the parameters to return.  Note this this call is\n   * unguarded if the index is out of bounds.\n   * @return the parameters at index i.\n   */\n    std::shared_ptr&lt;ILNativeParams&gt;&amp; operator[](usint i) {\n        return m_params[i];\n    }\n\n    /**\n   * @brief Removes the last parameter set and adjust the multiplied moduli.\n   *\n   */\n    void PopLastParam() {\n        ElemParams&lt;IntType&gt;::m_ciphertextModulus /= IntType(m_params.back()-&gt;GetModulus().ConvertToInt());\n        m_params.pop_back();\n    }\n\n    /**\n   * @brief Removes the first parameter set and adjust the multiplied moduli.\n   *\n   */\n    void PopFirstParam() {\n        ElemParams&lt;IntType&gt;::m_ciphertextModulus /= IntType(m_params[0]-&gt;GetModulus().ConvertToInt());\n        m_params.erase(m_params.begin());\n    }\n\n    /**\n   * Destructor.\n   */\n    ~ILDCRTParams() override = default;\n\n    /**\n   * @brief Equality operator checks if the ElemParams are the same.\n   *\n   * @param &amp;other ElemParams to compare against.\n   * @return the equality check results.\n   */\n    bool operator==(const ElemParams&lt;IntType&gt;&amp; other) const override {\n        const auto* dcrtParams = dynamic_cast&lt;const ILDCRTParams*&gt;(&amp;other);\n\n        if (dcrtParams == nullptr)\n            return false;\n\n        if (ElemParams&lt;IntType&gt;::operator==(other) == false)\n            return false;\n\n        if (m_params.size() != dcrtParams-&gt;m_params.size())\n            return false;\n\n        for (size_t i = 0; i &lt; m_params.size(); i++) {\n            if (*m_params[i] != *dcrtParams-&gt;m_params[i])\n                return false;\n        }\n\n        //    if (originalModulus != dcrtParams-&gt;originalModulus)\n        //      return false;\n\n        return true;\n    }\n\n    /**\n   * @brief Method to recalculate the composite modulus from the component\n   * moduli.\n   */\n    void RecalculateModulus() {\n        ElemParams&lt;IntType&gt;::m_ciphertextModulus = 1;\n        for (size_t i = 0; i &lt; m_params.size(); i++)\n            ElemParams&lt;IntType&gt;::m_ciphertextModulus =\n                ElemParams&lt;IntType&gt;::m_ciphertextModulus * IntType(m_params[i]-&gt;GetModulus().ConvertToInt());\n    }\n\n    /**\n   * @brief Method to recalculate the big composite modulus from the component\n   * moduli.\n   */\n    void RecalculateBigModulus() {\n        ElemParams&lt;IntType&gt;::m_bigCiphertextModulus = 1;\n        for (size_t i = 0; i &lt; m_params.size(); i++)\n            ElemParams&lt;IntType&gt;::m_bigCiphertextModulus =\n                ElemParams&lt;IntType&gt;::m_bigCiphertextModulus * IntType(m_params[i]-&gt;GetBigModulus().ConvertToInt());\n    }\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::base_class&lt;ElemParams&lt;IntType&gt;&gt;(this));\n        ar(::cereal::make_nvp(&quot;p&quot;, m_params));\n        ar(::cereal::make_nvp(&quot;m&quot;, m_originalModulus));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                 &quot; is from a later version of the library&quot;);\n        }\n        ar(::cereal::base_class&lt;ElemParams&lt;IntType&gt;&gt;(this));\n        ar(::cereal::make_nvp(&quot;p&quot;, m_params));\n        ar(::cereal::make_nvp(&quot;m&quot;, m_originalModulus));\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;DCRTParams&quot;;\n    }\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\nprivate:\n    std::ostream&amp; doprint(std::ostream&amp; out) const override {\n        out &lt;&lt; &quot;ILDCRTParams &quot;;\n        ElemParams&lt;IntType&gt;::doprint(out);\n        out &lt;&lt; std::endl &lt;&lt; &quot; Params:&quot; &lt;&lt; std::endl;\n        for (size_t i = 0; i &lt; m_params.size(); i++) {\n            out &lt;&lt; &quot;   &quot; &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; *m_params[i] &lt;&lt; std::endl;\n        }\n        out &lt;&lt; &quot;OriginalModulus &quot; &lt;&lt; m_originalModulus &lt;&lt; std::endl;\n        return out;\n    }\n\n    // original modulus when being constructed from a Poly or when\n    // ctor is passed that parameter\n    // note orignalModulus will be &lt;= composite modules\n    //   i.e. \\Prod_i=0^k-1 m_params[i]-&gt;GetModulus()\n    // note not using ElemParams::ciphertextModulus due to object stripping\n    IntType m_originalModulus{};\n\n    // array of smaller ILParams\n    std::vector&lt;std::shared_ptr&lt;ILNativeParams&gt;&gt; m_params;\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ilelement.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ilelement.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ilelement.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Represents and defines integer lattice element objects in OpenFHE\n */\n\n#ifndef LBCRYPTO_INC_LATTICE_ILELEMENT_H\n#define LBCRYPTO_INC_LATTICE_ILELEMENT_H\n\n// #include &quot;math/math-hal.h&quot;\n#include &quot;math/discretegaussiangenerator.h&quot;\n#include &quot;math/nbtheory.h&quot;\n\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/inttypes.h&quot;\n#include &quot;utils/serializable.h&quot;\n\n#include &lt;vector&gt;\n\nnamespace lbcrypto {\n\n/**\n * @brief Interface for ideal lattices\n *\n * Every lattice must implement these pure virtuals in order to properly\n * interoperate with OpenFHE PKE. Element is the return type for all of these\n * virtual functions. There is no constructor here in the base class; it\n * contains no data to construct.\n */\ntemplate &lt;typename Element, typename VecType&gt;\nclass ILElement : public Serializable {\n    using IntType = typename VecType::Integer;\n\npublic:\n    /**\n   * @brief Clone the object by making a copy of it and returning the copy\n   * @return new Element\n   */\n    virtual Element Clone() const = 0;\n\n    /**\n   * @brief Clone the object, but have it contain nothing\n   * @return new Element\n   */\n    virtual Element CloneEmpty() const = 0;\n\n    /**\n   * @brief Clones the element&#x27;s parameters, leaves vector initialized to 0\n   * @return new Element\n   */\n    virtual Element CloneParametersOnly() const = 0;\n\n    /**\n   * @brief Clones the element with parameters and with noise for the vector\n   * @param dgg\n   * @param format\n   * @return new Element\n   */\n    virtual Element CloneWithNoise(const DiscreteGaussianGeneratorImpl&lt;VecType&gt;&amp; dgg, Format format) const = 0;\n\n    /**\n   * @brief Standard destructor\n   */\n    virtual ~ILElement() = default;\n\n    // Assignment operators\n    /**\n   * @brief Assignment operator that copies elements.\n   * @param rhs\n   */\n    virtual const Element&amp; operator=(const Element&amp; rhs) = 0;\n    /**\n   * @brief Assignment operator that copies elements.\n   * @param rhs\n   */\n    virtual const Element&amp; operator=(Element&amp;&amp; rhs) = 0;\n    /**\n   * @brief Assignment operator that copies elements.\n   * @param rhs\n   */\n    virtual const Element&amp; operator=(std::initializer_list&lt;uint64_t&gt; rhs) = 0;\n\n    // GETTERS\n    /**\n   * @brief Get format of the element\n   *\n   * @return Format is either COEFFICIENT or EVALUATION\n   */\n    virtual Format GetFormat() const = 0;\n\n    /**\n   * @brief Get the length of the element.\n   *\n   * @return length\n   */\n    virtual usint GetLength() const = 0;\n\n    /**\n   * @brief Get modulus of the element\n   *\n   * @return the modulus.\n   */\n    virtual const IntType&amp; GetModulus() const = 0;\n\n    /**\n   * @brief Get the values for the element\n   *\n   * @return the vector.\n   */\n    virtual const VecType&amp; GetValues() const = 0;\n\n    /**\n   * @brief Get the cyclotomic order\n   *\n   * @return order\n   */\n    virtual usint GetCyclotomicOrder() const = 0;\n\n    /**\n   * @brief Gets the Value in the Element that is At Index and returns it.\n   * This is only implemented for some derived classes, so the default\n   * implementation throws an exception\n   *\n   * @param i is the index.\n   * @return will throw an error.\n   */\n    virtual IntType&amp; at(usint i) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;at not implemented&quot;);\n    }\n    virtual const IntType&amp; at(usint i) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;const at not implemented&quot;);\n    }\n    virtual IntType&amp; operator[](usint i) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;[] not implemented&quot;);\n    }\n    virtual const IntType&amp; operator[](usint i) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;const [] not implemented&quot;);\n    }\n\n    //  virtual NativePoly DecryptionCRTInterpolate(PlaintextModulus ptm) const\n    //= 0;\n\n    // OPERATORS\n    /**\n   * @brief Unary negation on a lattice\n   * @return -lattice\n   */\n    virtual Element operator-() const = 0;\n\n    /**\n   * @brief Scalar addition - add an element to the first index only.\n   * This operation is only allowed in COEFFICIENT format.\n   *\n   * @param &amp;element is the element to add entry-wise.\n   * @return is the return of the addition operation.\n   */\n    virtual Element Plus(const IntType&amp; element) const = 0;\n\n    /**\n   * @brief Scalar subtraction - subtract an element frp, all entries.\n   *\n   * @param &amp;element is the element to subtract entry-wise.\n   * @return is the return value of the minus operation.\n   */\n    virtual Element Minus(const IntType&amp; element) const = 0;\n\n    /**\n   * @brief Scalar multiplication - multiply all entries.\n   *\n   * @param &amp;element is the element to multiply entry-wise.\n   * @return is the return value of the times operation.\n   */\n    virtual Element Times(const IntType&amp; element) const = 0;\n\n    /**\n   * @brief Scalar multiplication - mulltiply by a signed integer\n   *\n   * @param &amp;element is the element to multiply entry-wise.\n   * @return is the return value of the times operation.\n   */\n    virtual Element Times(NativeInteger::SignedNativeInt element) const = 0;\n\n    /**\n   * @brief Performs an addition operation and returns the result.\n   *\n   * @param &amp;element is the element to add with.\n   * @return is the result of the addition.\n   */\n    virtual Element Plus(const Element&amp; element) const = 0;\n\n    /**\n   * @brief Performs a subtraction operation and returns the result.\n   *\n   * @param &amp;element is the element to subtract with.\n   * @return is the result of the subtraction.\n   */\n    virtual Element Minus(const Element&amp; element) const = 0;\n\n    /**\n   * @brief Performs a multiplication operation and returns the result.\n   *\n   * @param &amp;element is the element to multiply with.\n   * @return is the result of the multiplication.\n   */\n    virtual Element Times(const Element&amp; element) const = 0;\n\n    // overloaded op= operators\n    /**\n   * @brief Performs += operation with a BigInteger and returns the result.\n   *\n   * @param &amp;element is the element to add\n   * @return is the result of the addition.\n   */\n    virtual const Element&amp; operator+=(const IntType&amp; element) = 0;\n\n    /**\n   * @brief Performs -= operation with a BigInteger and returns the result.\n   *\n   * @param &amp;element is the element to subtract\n   * @return is the result of the addition.\n   */\n    virtual const Element&amp; operator-=(const IntType&amp; element) = 0;\n\n    /**\n   * @brief Performs *= operation with a BigInteger and returns the result.\n   *\n   * @param &amp;element is the element to multiply by\n   * @return is the result of the multiplication.\n   */\n    virtual const Element&amp; operator*=(const IntType&amp; element) = 0;\n\n    /**\n   * @brief Performs an addition operation and returns the result.\n   *\n   * @param &amp;element is the element to add\n   * @return is the result of the addition.\n   */\n    virtual const Element&amp; operator+=(const Element&amp; element) = 0;\n\n    /**\n   * @brief Performs an subtraction operation and returns the result.\n   *\n   * @param &amp;element is the element to subtract\n   * @return is the result of the addition.\n   */\n    virtual const Element&amp; operator-=(const Element&amp; element) = 0;\n\n    /**\n   * @brief Performs an multiplication operation and returns the result.\n   *\n   * @param &amp;element is the element to multiply by\n   * @return is the result of the multiplication.\n   */\n    virtual const Element&amp; operator*=(const Element&amp; element) = 0;\n\n    /**\n   * @brief Equality operator.  Compares values of element to be compared to.\n   * @param element the element to compare to.\n   */\n    virtual bool operator==(const Element&amp; element) const = 0;\n\n    /**\n   * @brief Inequality operator.  Compares values of element to be compared to.\n   * @param element the element to compare to.\n   */\n    inline bool operator!=(const Element&amp; element) const {\n        return !(*this == element);\n    }\n\n    /**\n   * @brief Adds one to every entry of the Element, in place\n   */\n    virtual void AddILElementOne() = 0;\n\n    /**\n   * @brief Performs an automorphism transform operation and returns the result.\n   *\n   * @param &amp;i is the element to perform the automorphism transform with.\n   * @return is the result of the automorphism transform.\n   */\n    virtual Element AutomorphismTransform(uint32_t i) const = 0;\n\n    /**\n   * @brief Performs an automorphism transform operation using precomputed bit\n   * reversal indices.\n   *\n   * @param &amp;i is the element to perform the automorphism transform with.\n   * @param &amp;vec a vector with precomputed indices\n   * @return is the result of the automorphism transform.\n   */\n    virtual Element AutomorphismTransform(uint32_t i, const std::vector&lt;uint32_t&gt;&amp; vec) const = 0;\n\n    /**\n   * @brief Transpose the ring element using the automorphism operation\n   *\n   * @return is the result of the transposition.\n   */\n    virtual Element Transpose() const = 0;\n\n    /**\n   * @brief Write the element as \\f$ \\sum\\limits{i=0}^{\\lfloor {\\log q/base}\n   * \\rfloor} {(base^i u_i)} \\f$ and return the vector of \\f$ \\left\\{u_0,\n   * u_1,...,u_{\\lfloor {\\log q/base} \\rfloor} \\right\\} \\in R_{{base}^{\\lceil\n   * {\\log q/base} \\rceil}} \\f$; This is used as a subroutine in the\n   * relinearization procedure.\n   *\n   * @param baseBits is the number of bits in the base, i.e., base = 2^baseBits\n   * @param evalModeAnswer - if true, convert the resultant polynomials to\n   * evaluation mode\n   * @result is the pointer where the base decomposition vector is stored\n   */\n    virtual std::vector&lt;Element&gt; BaseDecompose(usint baseBits, bool evalModeAnswer) const = 0;\n\n    /**\n   * @brief Scalar division followed by rounding operation - operation on all\n   * entries.\n   *\n   * @param &amp;q is the element to divide entry-wise.\n   * @return is the return value of the divide, followed by rounding operation.\n   */\n    virtual Element DivideAndRound(const IntType&amp; q) const = 0;\n\n    /**\n   * @brief Determines if inverse exists\n   *\n   * @return true if there exists a multiplicative inverse.\n   */\n    virtual bool InverseExists() const = 0;\n\n    /**\n   * @brief Returns the infinity norm, basically the largest value in the ring\n   * element.\n   *\n   * @return the largest value in the ring element.\n   */\n    virtual double Norm() const = 0;\n\n    /**\n   * @brief Returns true if the vector is empty/ m_values==nullptr\n   *\n   * @return true if the vector is empty and all values nullptr.  false\n   * otherwise.\n   */\n    virtual bool IsEmpty() const = 0;\n\n    /**\n   * @brief Make the element Sparse for SHE KeyGen operations.\n   * Sets every index not equal to zero mod the wFactor to zero.\n   *\n   * @param &amp;wFactor ratio between the original element&#x27;s ring dimension and the\n   * new ring dimension.\n   */\n    virtual void MakeSparse(uint32_t wFactor) = 0;\n\n    /**\n   * @brief Calculate Element mod 2\n   *\n   * @return result of performing a mod-2 operation on the element.\n   */\n    virtual Element ModByTwo() const = 0;\n\n    /**\n   * @brief Calculate and return the Multiplicative Inverse of the element\n   * @return the multiplicative inverse of the element, if it exists.\n   */\n    virtual Element MultiplicativeInverse() const = 0;\n\n    /**\n   * @brief Scalar multiplication followed by division and rounding operation -\n   * operation on all entries.\n   *\n   * @param &amp;p is the integer muliplicand.\n   * @param &amp;q is the integer divisor.\n   * @return is the return value of the multiply, divide and followed by\n   * rounding operation.\n   */\n    virtual Element MultiplyAndRound(const IntType&amp; p, const IntType&amp; q) const = 0;\n\n    /**\n   * @brief Calculate a vector of elements by raising the base element to\n   * successive powers\n   *\n   * @param baseBits\n   * @return\n   */\n    virtual std::vector&lt;Element&gt; PowersOfBase(usint baseBits) const = 0;\n\n    /**\n   * @brief Mod - perform a modulus operation.\n   * Does proper mapping of [-modulus/2, modulus/2) to [0, modulus).\n   *\n   * @param modulus is the modulus to use.\n   * @return is the return value of the modulus.\n   */\n    virtual Element Mod(const IntType&amp; modulus) const = 0;\n\n    /**\n   * @brief Switch modulus and adjust the values\n   *\n   * @param &amp;modulus is the modulus to be set.\n   * @param &amp;rootOfUnity is the corresponding root of unity for the modulus\n   * @param &amp;modulusArb is the modulus used for arbitrary cyclotomics CRT\n   * @param &amp;rootOfUnityArb is the corresponding root of unity for the modulus\n   * ASSUMPTION: This method assumes that the caller provides the correct\n   * rootOfUnity for the modulus.\n   */\n    virtual void SwitchModulus(const IntType&amp; modulus, const IntType&amp; rootOfUnity, const IntType&amp; modulusArb,\n                               const IntType&amp; rootOfUnityArb) = 0;\n\n    /**\n   * @brief onvert from Coefficient to CRT or vice versa; calls FFT and inverse FFT.\n   */\n    virtual void SwitchFormat() = 0;\n\n    /**\n   * @brief Sets the format/representation of the element.\n   * @param format the format/representation to set.\n   */\n    inline void SetFormat(const Format format) {\n        if (this-&gt;GetFormat() != format) {\n            this-&gt;SwitchFormat();\n        }\n    }\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/poly-interface.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/poly-interface.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/poly-interface.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Defines an interface that any DCRT Polynomial implmentation must implement in order to work in OpenFHE.\n */\n\n#ifndef LBCRYPTO_INC_LATTICE_HAL_POLYINTERFACE_H\n#define LBCRYPTO_INC_LATTICE_HAL_POLYINTERFACE_H\n\n#include &quot;lattice/ilelement.h&quot;\n#include &quot;lattice/ilparams.h&quot;\n\n#include &quot;math/math-hal.h&quot;\n#include &quot;math/distrgen.h&quot;\n#include &quot;math/nbtheory.h&quot;\n\n#include &quot;utils/inttypes.h&quot;\n#include &quot;utils/exception.h&quot;\n\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\nnamespace lbcrypto {\n\ntemplate &lt;typename DerivedType, typename VecType, template &lt;typename LVT&gt; typename ContainerType&gt;\nclass PolyInterface : public ILElement&lt;DerivedType, VecType&gt; {\npublic:\n    using Vector     = VecType;\n    using Integer    = typename VecType::Integer;\n    using Params     = ILParamsImpl&lt;Integer&gt;;\n    using PolyNative = ContainerType&lt;NativeVector&gt;;\n    using DggType    = DiscreteGaussianGeneratorImpl&lt;VecType&gt;;\n    using DugType    = DiscreteUniformGeneratorImpl&lt;VecType&gt;;\n    using TugType    = TernaryUniformGeneratorImpl&lt;VecType&gt;;\n    using BugType    = BinaryUniformGeneratorImpl&lt;VecType&gt;;\n\n    /**\n   * @brief Get the Derived object, this is apart of the CRTP software design pattern\n   * it allows the base class (this one) to implement methods that call the derived\n   * objects implementation.\n   *\n   * @ref Chapter 21.2 &quot;C++ Templates The Complete Guide&quot; by David Vandevoorde and Nicolai M. Josuttis\n   * http://www.informit.com/articles/article.asp?p=31473\n   *\n   * @return DerivedType&amp;\n   */\n    DerivedType&amp; GetDerived() {\n        return static_cast&lt;DerivedType&amp;&gt;(*this);\n    }\n\n    const DerivedType&amp; GetDerived() const {\n        return static_cast&lt;DerivedType const&amp;&gt;(*this);\n    }\n\n    /**\n   * @brief Create lambda that allocates a zeroed element for the case when it\n   * is called from a templated class\n   * @param params the params to use.\n   * @param format - EVALUATION or COEFFICIENT\n   */\n    inline static std::function&lt;DerivedType()&gt; Allocator(const std::shared_ptr&lt;Params&gt;&amp; params, Format format) {\n        return [=]() {\n            return DerivedType(params, format, true);\n        };\n    }\n\n    /**\n   * @brief Allocator for discrete uniform distribution.\n   *\n   * @param params Params instance that is is passed.\n   * @param resultFormat resultFormat for the polynomials generated.\n   * @param stddev standard deviation for the discrete gaussian generator.\n   * @return the resulting vector.\n   */\n    inline static std::function&lt;DerivedType()&gt; MakeDiscreteGaussianCoefficientAllocator(\n        const std::shared_ptr&lt;Params&gt;&amp; params, Format resultFormat, double stddev) {\n        return [=]() {\n            DggType dgg(stddev);\n            DerivedType ilvec(dgg, params, Format::COEFFICIENT);\n            ilvec.SetFormat(resultFormat);\n            return ilvec;\n        };\n    }\n\n    /**\n   * @brief Allocator for discrete uniform distribution.\n   *\n   * @param params Params instance that is is passed.\n   * @param format format for the polynomials generated.\n   * @return the resulting vector.\n   */\n    inline static std::function&lt;DerivedType()&gt; MakeDiscreteUniformAllocator(const std::shared_ptr&lt;Params&gt;&amp; params,\n                                                                            Format format) {\n        return [=]() {\n            DugType dug;\n            dug.SetModulus(params-&gt;GetModulus());\n            return DerivedType(dug, params, format);\n        };\n    }\n\n    DerivedType&amp; operator=(const DerivedType&amp; rhs) override = 0;\n    DerivedType&amp; operator=(DerivedType&amp;&amp; rhs) override      = 0;\n    DerivedType&amp; operator=(const std::vector&lt;int32_t&gt;&amp; rhs) {\n        return this-&gt;GetDerived().operator=(rhs);\n    }\n    DerivedType&amp; operator=(const std::vector&lt;int64_t&gt;&amp; rhs) {\n        return this-&gt;GetDerived().operator=(rhs);\n    }\n    DerivedType&amp; operator=(std::initializer_list&lt;uint64_t&gt; rhs) override = 0;\n    DerivedType&amp; operator=(std::initializer_list&lt;std::string&gt; rhs) {\n        return this-&gt;GetDerived().operator=(rhs);\n    }\n    DerivedType&amp; operator=(uint64_t rhs) {\n        return this-&gt;GetDerived().operator=(rhs);\n    }\n\n    /**\n   * @brief Get method of the format.\n   *\n   * @return the format, either COEFFICIENT or EVALUATION\n   */\n    Format GetFormat() const override {\n        return this-&gt;GetDerived().GetFormat();\n    }\n\n    /**\n   * @brief returns the parameters of the element.\n   * @return the element parameter set.\n   */\n    const std::shared_ptr&lt;Params&gt;&amp; GetParams() const {\n        return this-&gt;GetDerived().GetParams();\n    }\n\n    /**\n   * @brief returns the element&#x27;s ring dimension\n   * @return returns the ring dimension of the element.\n   */\n    usint GetRingDimension() const {\n        return this-&gt;GetDerived().GetParams()-&gt;GetRingDimension();\n    }\n\n    /**\n   * @brief returns the element&#x27;s root of unity.\n   * @return the element&#x27;s root of unity.\n   */\n    const Integer&amp; GetRootOfUnity() const {\n        return this-&gt;GetDerived().GetParams()-&gt;GetRootOfUnity();\n    }\n\n    /**\n   * @brief returns the element&#x27;s modulus\n   * @return returns the modulus of the element.\n   */\n    const Integer&amp; GetModulus() const final {\n        return this-&gt;GetDerived().GetParams()-&gt;GetModulus();\n    }\n\n    /**\n   * @brief returns the element&#x27;s cyclotomic order\n   * @return returns the cyclotomic order of the element.\n   */\n    usint GetCyclotomicOrder() const final {\n        return this-&gt;GetDerived().GetParams()-&gt;GetCyclotomicOrder();\n    }\n\n    /**\n   * @brief Get method for length of each component element.\n   * NOTE assumes all components are the same size. (Ring Dimension)\n   *\n   * @return length of the component element\n   */\n    usint GetLength() const final {\n        //        if (this-&gt;GetDerived().IsEmpty())\n        //            &quot;hey&quot;; OPENFHE_THROW(not_available_error, &quot;No values in PolyImpl&quot;);\n        return this-&gt;GetDerived().GetValues().GetLength();\n    }\n\n    /**\n   * @brief Get method that should not be used\n   *\n   * @return will throw an error.\n   *\n   * @warning Doesn&#x27;t make sense for DCRT\n   */\n    const VecType&amp; GetValues() const override = 0;\n\n    /**\n   * @brief Get interpolated value of elements at all tower index i.\n   * Note this operation is computationally intense. Does bound checking\n   * @return interpolated value at index i.\n   */\n    Integer&amp; at(usint i) override             = 0;\n    const Integer&amp; at(usint i) const override = 0;\n\n    /**\n   * @brief Get interpolated value of element at index i.\n   * Note this operation is computationally intense. No bound checking\n   * @return interpolated value at index i.\n   */\n    Integer&amp; operator[](usint i) override {\n        return this-&gt;GetDerived()[i];\n    }\n\n    const Integer&amp; operator[](usint i) const override {\n        return this-&gt;GetDerived()[i];\n    }\n\n    /**\n   * @brief Performs an addition operation and returns the result.\n   *\n   * @param &amp;element is the element to add with.\n   * @return is the result of the addition.\n   */\n    DerivedType Plus(const DerivedType&amp; rhs) const override {\n        return this-&gt;GetDerived().Plus(rhs);\n    }\n\n    /**\n   * @brief Performs a subtraction operation and returns the result.\n   *\n   * @param &amp;element is the element to subtract from.\n   * @return is the result of the subtraction.\n   */\n    DerivedType Minus(const DerivedType&amp; element) const override = 0;\n\n    /**\n   * @brief Performs a modular multiplication operation for Poly&#x27;s in\n   * EVALUATION format and returns the result. Performs runtime checks\n   * for operand compatibility.\n   *\n   * @param &amp;element is the element to multiply with.\n   * @return is the result of the multiplication.\n   */\n    DerivedType Times(const DerivedType&amp; element) const override = 0;\n\n    /**\n   * @brief Performs a modular multiplication operation for Poly&#x27;s in\n   * any format and returns the result. Performs no runtime checks.\n   *\n   * @param &amp;element is the element to multiply with.\n   * @return is the result of the multiplication.\n   */\n    DerivedType TimesNoCheck(const DerivedType&amp; rhs) const {\n        return this-&gt;GetDerived().Times(rhs);\n    }\n    /**\n   * @brief Scalar addition - add an element to the first index of each tower.\n   *\n   * @param &amp;element is the element to add entry-wise.\n   * @return is the result of the addition operation.\n   */\n    DerivedType Plus(const Integer&amp; element) const override = 0;\n\n    /**\n   * @brief Scalar subtraction - subtract an element to all entries.\n   *\n   * @param &amp;element is the element to subtract entry-wise.\n   * @return is the return value of the minus operation.\n   */\n    DerivedType Minus(const Integer&amp; element) const override = 0;\n\n    /**\n   * @brief Scalar multiplication - multiply all entries.\n   *\n   * @param &amp;element is the element to multiply entry-wise.\n   * @return is the return value of the times operation.\n   */\n    DerivedType Times(const Integer&amp; element) const override = 0;\n\n    /**\n   * @brief Scalar multiplication - multiply by a signed integer\n   *\n   * @param &amp;element is the element to multiply entry-wise.\n   * @return is the return value of the times operation.\n   */\n    DerivedType Times(NativeInteger::SignedNativeInt element) const override = 0;\n\n#if NATIVEINT != 64\n    /**\n   * @brief Scalar multiplication - multiply by a signed integer\n   *\n   * @param &amp;element is the element to multiply entry-wise.\n   * @return is the return value of the times operation.\n   *\n   * @note this is need for 128-bit so that the 64-bit inputs can be used.\n   */\n    DerivedType Times(int64_t rhs) const {\n        return this-&gt;GetDerived().Times(rhs);\n    }\n#endif\n\n    /**\n   * @brief Scalar multiplication followed by division and rounding operation -\n   * operation on all entries.\n   *\n   * @param &amp;p is the element to multiply entry-wise.\n   * @param &amp;q is the element to divide entry-wise.\n   * @return is the return value of the multiply, divide and followed by\n   * rounding operation.\n   *\n   * @warning Will remove, this is only inplace because of BFV\n   */\n    DerivedType MultiplyAndRound(const Integer&amp; p, const Integer&amp; q) const override = 0;\n\n    /**\n   * @brief Scalar division followed by rounding operation - operation on all\n   * entries.\n   *\n   * @param &amp;q is the element to divide entry-wise.\n   * @return is the return value of the divide, followed by rounding operation.\n   *\n   * @warning Will remove, this is only inplace because of BFV\n   */\n    DerivedType DivideAndRound(const Integer&amp; q) const override = 0;\n\n    /**\n   * @brief Performs a negation operation and returns the result.\n   *\n   * @return is the result of the negation.\n   */\n    virtual DerivedType Negate() const = 0;\n\n    /**\n   * @brief Unary minus on a element.\n   * @return additive inverse of the an element.\n   */\n    DerivedType operator-() const override = 0;\n\n    DerivedType&amp; operator+=(const Integer&amp; element) override = 0;\n\n    /**\n   * @brief Performs a subtraction operation and returns the result.\n   *\n   * @param &amp;element is the element to subtract from.\n   * @return is the result of the subtraction.\n   */\n    DerivedType&amp; operator-=(const Integer&amp; element) override = 0;\n\n    /**\n   * @brief Performs a multiplication operation and returns the result.\n   *\n   * @param &amp;element is the element to multiply by.\n   * @return is the result of the multiplication.\n   */\n    DerivedType&amp; operator*=(const Integer&amp; element) override = 0;\n\n    /**\n   * @brief Performs an entry-wise addition over all elements of each tower with\n   * the towers of the element on the right hand side.\n   *\n   * @param &amp;rhs is the element to add with.\n   * @return is the result of the addition.\n   */\n    DerivedType&amp; operator+=(const DerivedType&amp; rhs) override = 0;\n\n    /**\n   * @brief Performs an entry-wise subtraction over all elements of each tower\n   * with the towers of the element on the right hand side.\n   *\n   * @param &amp;rhs is the element to subtract from.\n   * @return is the result of the addition.\n   */\n    DerivedType&amp; operator-=(const DerivedType&amp; rhs) override = 0;\n\n    /**\n   * @brief Performs an multiplication operation and returns the result.\n   *\n   * @param &amp;element is the element to multiply with.\n   * @return is the result of the multiplication.\n   */\n    DerivedType&amp; operator*=(const DerivedType&amp; element) override = 0;\n\n    /**\n   * @brief Equality operator.\n   *\n   * @param &amp;rhs is the specified element to be compared with this element.\n   * @return true if this element represents the same values as the specified\n   * element, false otherwise\n   */\n    bool operator==(const DerivedType&amp; rhs) const override = 0;\n\n    /**\n   * @brief Adds &quot;1&quot; to every entry in every tower.\n   */\n    void AddILElementOne() override = 0;\n\n    /**\n   * @brief Permutes coefficients in a polynomial. Moves the ith index to the\n   * first one, it only supports odd indices.\n   *\n   * @param &amp;i is the element to perform the automorphism transform with.\n   * @return is the result of the automorphism transform.\n   */\n    DerivedType AutomorphismTransform(uint32_t i) const override = 0;\n\n    /**\n   * @brief Performs an automorphism transform operation using precomputed bit\n   * reversal indices.\n   *\n   * @param &amp;i is the element to perform the automorphism transform with.\n   * @param &amp;vec a vector with precomputed indices\n   * @return is the result of the automorphism transform.\n   */\n    DerivedType AutomorphismTransform(uint32_t i, const std::vector&lt;uint32_t&gt;&amp; vec) const override = 0;\n\n    /**\n   * @brief Transpose the ring element using the automorphism operation\n   *\n   * @return is the result of the transposition.\n   */\n    inline DerivedType Transpose() const final {\n        if (this-&gt;GetDerived().GetFormat() == Format::COEFFICIENT) {\n            &quot;hey&quot;; OPENFHE_THROW(not_implemented_error,\n                          &quot;PolyInterface element transposition is currently &quot;\n                          &quot;implemented only in the Evaluation representation.&quot;);\n        }\n        return this-&gt;GetDerived().AutomorphismTransform(this-&gt;GetDerived().GetCyclotomicOrder() - 1);\n    }\n\n    /**\n   * @brief Performs a multiplicative inverse operation and returns the result.\n   *\n   * @return is the result of the multiplicative inverse.\n   */\n    DerivedType MultiplicativeInverse() const override = 0;\n\n    /**\n   * @brief Perform a modulus by 2 operation.  Returns the least significant\n   * bit.\n   *\n   * @return is the resulting value.\n   */\n    DerivedType ModByTwo() const override = 0;\n\n    /**\n   * @brief Modulus - perform a modulus operation. Does proper mapping of\n   * [-modulus/2, modulus/2) to [0, modulus)\n   *\n   * @param modulus is the modulus to use.\n   * @return is the return value of the modulus.\n   */\n    DerivedType Mod(const Integer&amp; modulus) const override = 0;\n\n    /**\n   * @brief Switch modulus and adjust the values\n   *\n   * @param &amp;modulus is the modulus to be set\n   * @param &amp;rootOfUnity is the corresponding root of unity for the modulus\n   * @param &amp;modulusArb is the modulus used for arbitrary cyclotomics CRT\n   * @param &amp;rootOfUnityArb is the corresponding root of unity for the modulus\n   * ASSUMPTION: This method assumes that the caller provides the correct\n   * rootOfUnity for the modulus\n   */\n    void SwitchModulus(const Integer&amp; modulus, const Integer&amp; rootOfUnity, const Integer&amp; modulusArb,\n                       const Integer&amp; rootOfUnityArb) override = 0;\n\n    /**\n   * @brief Convert from Coefficient to CRT or vice versa; calls FFT and inverse FFT\n   *\n   * @warning use @see SetFormat(format) instead\n   */\n    void SwitchFormat() override = 0;\n\n    /**\n   * @brief Sets format to value without calling FFT. Only use if you know what you&#x27;re doing.\n   *\n   */\n    virtual void OverrideFormat(const Format f) = 0;\n\n    /**\n   * @brief Make DCRTPoly Sparse. Sets every index of each tower not equal to\n   * zero mod the wFactor to zero.\n   *\n   * @param &amp;wFactor ratio between the sparse and none-sparse values.\n   *\n   * @warning Only used by RingSwitching, which is no longer supported. Will be removed in future.\n   */\n    void MakeSparse(uint32_t wFactor) override = 0;\n\n    /**\n   * @brief Returns true if ALL the tower(s) are empty.\n   * @return true if all towers are empty\n   */\n    bool IsEmpty() const override = 0;\n\n    /**\n   * @brief Determines if inverse exists\n   *\n   * @return is the Boolean representation of the existence of multiplicative\n   * inverse.\n   */\n    bool InverseExists() const override = 0;\n\n    /**\n   * @brief Returns the infinity norm, basically the largest value in the ring\n   * element.\n   *\n   * @return is the largest value in the ring element.\n   */\n    double Norm() const override = 0;\n\n    /**\n   * @brief Write the element as \\f$ \\sum\\limits{i=0}^{\\lfloor {\\log q/base}\n   * \\rfloor} {(base^i u_i)} \\f$ and return the vector of \\f$ \\left\\{u_0,\n   * u_1,...,u_{\\lfloor {\\log q/base} \\rfloor} \\right\\} \\in R_{{base}^{\\lceil\n   * {\\log q/base} \\rceil}} \\f$; This is used as a subroutine in the\n   * relinearization procedure.\n   *\n   * @param baseBits is the number of bits in the base, i.e., \\f$ base =\n   * 2^{baseBits} \\f$.\n   * @return is the pointer where the base decomposition vector is stored\n   *\n   * @warning not efficient and  not fast, uses multiprecision arithmetic and\n   *          will be removed in future. Use @see DCRTPolyInterface::CRTDecompose instead.\n   */\n\n    std::vector&lt;DerivedType&gt; BaseDecompose(usint baseBits, bool evalModeAnswer) const override = 0;\n\n    /**\n   * @brief Generate a vector of PolyImpl&#x27;s as \\f$ \\left\\{x, {base}*x,\n   * {base}^2*x, ..., {base}^{\\lfloor {\\log q/{base}} \\rfloor} \\right\\}*x \\f$,\n   * where \\f$ x \\f$ is the current PolyImpl object;\n   * used as a subroutine in the relinearization procedure to get powers of a\n   * certain &quot;base&quot; for the secret key element.\n   *\n   * @param baseBits is the number of bits in the base, i.e., \\f$ base =\n   * 2^{baseBits} \\f$.\n   * @return is the pointer where the base decomposition vector is stored\n   *\n   * @warning not efficient and  not fast, uses multiprecision arithmetic and\n   *          will be removed in future. Use @see DCRTPolyInterface::CRTDecompose instead.\n   */\n    std::vector&lt;DerivedType&gt; PowersOfBase(usint baseBits) const override = 0;\n\n    /**\n   * @brief Set method that should not be used, will throw an error.\n   *\n   * @param &amp;values\n   * @param format\n   */\n    virtual void SetValues(const VecType&amp; values, Format format) = 0;\n    virtual void SetValues(VecType&amp;&amp; values, Format format)      = 0;\n\n    /**\n   * @brief Sets all values of element to zero.\n   */\n    virtual void SetValuesToZero() = 0;\n    virtual void SetValuesToMax()  = 0;\n\n    /**\n   * @brief Interpolates the DCRTPoly to an Poly based on the Chinese Remainder\n   * Transform Interpolation. and then returns a Poly with that single element\n   *\n   * @return the interpolated ring element as a Poly object.\n   */\n    DerivedType CRTInterpolate() const {\n        return this-&gt;GetDerived();\n    }\n\n    virtual PolyNative DecryptionCRTInterpolate(PlaintextModulus ptm) const = 0;\n\n    /**\n   * @brief If the values are small enough this is used for efficiency\n   *\n   * @return NativePoly\n   *\n   * @warning This will be replaced with a non-member utility function.\n   */\n    virtual PolyNative ToNativePoly() const = 0;\n\n    DerivedType Clone() const final {\n        return DerivedType(this-&gt;GetDerived());\n    }\n\n    DerivedType CloneEmpty() const final {\n        return DerivedType();\n    }\n\n    DerivedType CloneParametersOnly() const final {\n        return DerivedType(this-&gt;GetDerived().GetParams(), this-&gt;GetDerived().GetFormat());\n    }\n\n    DerivedType CloneWithNoise(const DggType&amp; dgg, Format format) const final {\n        return DerivedType(dgg, this-&gt;GetDerived().GetParams(), this-&gt;GetDerived().GetFormat());\n    }\n\n    const std::string GetElementName() const {\n        return this-&gt;GetDerived().GetElementName();\n    }\n\nprotected:\n    /**\n   * @brief ostream operator\n   * @param os the input preceding output stream\n   * @param vec the element to add to the output stream.\n   * @return a resulting concatenated output stream\n   */\n    friend inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const DerivedType&amp; vec) {\n        os &lt;&lt; (vec.GetFormat() == Format::EVALUATION ? &quot;EVAL: &quot; : &quot;COEF: &quot;) &lt;&lt; vec.GetValues();\n        return os;\n    }\n\n    /**\n   * @brief Element-element addition operator.\n   * @param a first element to add.\n   * @param b second element to add.\n   * @return the result of the addition operation.\n   */\n    friend inline DerivedType operator+(const DerivedType&amp; a, const DerivedType&amp; b) {\n        return a.Plus(b);\n    }\n    /**\n   * @brief Element-integer addition operator.\n   * @param a first element to add.\n   * @param b integer to add.\n   * @return the result of the addition operation.\n   */\n    friend inline DerivedType operator+(const DerivedType&amp; a, const Integer&amp; b) {\n        return a.Plus(b);\n    }\n\n    /**\n   * @brief Integer-element addition operator.\n   * @param a integer to add.\n   * @param b element to add.\n   * @return the result of the addition operation.\n   */\n    friend inline DerivedType operator+(const Integer&amp; a, const DerivedType&amp; b) {\n        return b.Plus(a);\n    }\n\n    /**\n   * @brief Element-element subtraction operator.\n   * @param a element to subtract from.\n   * @param b element to subtract.\n   * @return the result of the subtraction operation.\n   */\n    friend inline DerivedType operator-(const DerivedType&amp; a, const DerivedType&amp; b) {\n        return a.Minus(b);\n    }\n\n    /**\n   * @brief Element-integer subtraction operator.\n   * @param a element to subtract from.\n   * @param b integer to subtract.\n   * @return the result of the subtraction operation.\n   */\n    friend inline DerivedType operator-(const DerivedType&amp; a, const Integer&amp; b) {\n        return a.Minus(b);\n    }\n\n    /**\n   * @brief Element-element multiplication operator.\n   * @param a element to multiply.\n   * @param b element to multiply.\n   * @return the result of the multiplication operation.\n   */\n    friend inline DerivedType operator*(const DerivedType&amp; a, const DerivedType&amp; b) {\n        return a.Times(b);\n    }\n\n    /**\n   * @brief Element-integer multiplication operator.\n   * @param a element to multiply.\n   * @param b integer to multiply.\n   * @return the result of the multiplication operation.\n   */\n    friend inline DerivedType operator*(const DerivedType&amp; a, const Integer&amp; b) {\n        return a.Times(b);\n    }\n\n    /**\n   * @brief Integer-element multiplication operator.\n   * @param a integer to multiply.\n   * @param b element to multiply.\n   * @return the result of the multiplication operation.\n   */\n    friend inline DerivedType operator*(const Integer&amp; a, const DerivedType&amp; b) {\n        return b.Times(a);\n    }\n\n    /**\n   * @brief Element-signed-integer multiplication operator.\n   * @param a element to multiply.\n   * @param b integer to multiply.\n   * @return the result of the multiplication operation.\n   */\n    friend inline DerivedType operator*(const DerivedType&amp; a, int64_t b) {\n        return a.Times((NativeInteger::SignedNativeInt)b);\n    }\n\n    /**\n   * @brief signed-Integer-element multiplication operator.\n   * @param a integer to multiply.\n   * @param b element to multiply.\n   * @return the result of the multiplication operation.\n   */\n    friend inline DerivedType operator*(int64_t a, const DerivedType&amp; b) {\n        return b.Times((NativeInteger::SignedNativeInt)a);\n    }\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Defines an interface that any DCRT Polynomial implmentation must implement in order to work in OpenFHE.\n */\n\n#ifndef LBCRYPTO_INC_LATTICE_HAL_DCRTPOLYINTERFACE_H\n#define LBCRYPTO_INC_LATTICE_HAL_DCRTPOLYINTERFACE_H\n\n#include &quot;lattice/ildcrtparams.h&quot;\n#include &quot;lattice/ilelement.h&quot;\n\n#include &quot;math/math-hal.h&quot;\n#include &quot;math/distrgen.h&quot;\n\n#include &quot;utils/inttypes.h&quot;\n#include &quot;utils/exception.h&quot;\n\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\nnamespace lbcrypto {\n\n/**\n * @brief Ideal lattice for the double-CRT interface representation.\n * The interface contains a methods required for computations on lattices\n * The double-CRT representation of polynomials is a common optimization for\n * lattice encryption operations. Basically, it allows large-modulus polynomials\n * to be represented as multiple smaller-modulus polynomials.  The double-CRT\n * representations are discussed theoretically here:\n *   - Gentry C., Halevi S., Smart N.P. (2012) Homomorphic Evaluation of the AES\n * Circuit. In: Safavi-Naini R., Canetti R. (eds) Advances in Cryptology \u2013\n * CRYPTO 2012. Lecture Notes in Computer Science, vol 7417. Springer, Berlin,\n * Heidelberg\n *\n *\n * @tparam DerivedType Curiously-Recurring-Template-Pattern\n * @tparam BigVecType The Vector type before decomposing the polynomial into CRT\n * @tparam LilVecType The underlaying RNS data structure, a vectors type structure, that will compose the CRT data\n * @tparam RNSContainer The container of LilVecType, a lbcrypto::PolyImpl or vector typically\n *\n * example for the default DerivedType the template types would be...\n *    DerivedType       - DCRTPolyImpl&lt;BigVector&gt;\n *    BigVecType        - BigVector\n *    LilVecType        - NativeVector\n *    RNSContainer&lt;LVT&gt; - PolyImpl\n */\n\n// TODO: CRTP with ILElement to remove virtual overhead\n\ntemplate &lt;typename DerivedType, typename BigVecType, typename LilVecType,\n          template &lt;typename LVT&gt; typename RNSContainerType&gt;\nclass DCRTPolyInterface : public ILElement&lt;DerivedType, BigVecType&gt; {\npublic:\n    using BigIntType    = typename BigVecType::Integer;\n    using Params        = ILDCRTParams&lt;BigIntType&gt;;\n    using LilIntType    = typename LilVecType::Integer;\n    using TowerType     = RNSContainerType&lt;LilVecType&gt;;\n    using PolyLargeType = RNSContainerType&lt;BigVecType&gt;;\n    using DggType       = DiscreteGaussianGeneratorImpl&lt;LilVecType&gt;;\n    using DugType       = DiscreteUniformGeneratorImpl&lt;LilVecType&gt;;\n    using TugType       = TernaryUniformGeneratorImpl&lt;LilVecType&gt;;\n    using BugType       = BinaryUniformGeneratorImpl&lt;LilVecType&gt;;\n\n    /**\n   * @brief Get the Derived object, this is apart of the CRTP software design pattern\n   * it allows the base class (this one) to implement methods that call the derived\n   * objects implementation.\n   *\n   * @ref Chapter 21.2 &quot;C++ Templates The Complete Guide&quot; by David Vandevoorde and Nicolai M. Josuttis\n   * http://www.informit.com/articles/article.asp?p=31473\n   *\n   * @return DerivedType&amp;\n   */\n    DerivedType&amp; GetDerived() {\n        return static_cast&lt;DerivedType&amp;&gt;(*this);\n    }\n\n    const DerivedType&amp; GetDerived() const {\n        return static_cast&lt;DerivedType const&amp;&gt;(*this);\n    }\n\n    /**\n   * @brief Create lambda that allocates a zeroed element for the case when it\n   * is called from a templated class\n   *\n   * @param params the params to use.\n   * @param format - EVALUATION or COEFFICIENT\n   */\n    static std::function&lt;DerivedType()&gt; Allocator(const std::shared_ptr&lt;Params&gt;&amp; params, Format format) {\n        return [=]() {\n            return DerivedType(params, format, true);\n        };\n    }\n\n    /**\n   * @brief Allocator for discrete uniform distribution.\n   *\n   * @param params Params instance that is is passed.\n   * @param resultFormat resultFormat for the polynomials generated.\n   * @param stddev standard deviation for the discrete gaussian generator.\n   * @return the resulting vector.\n   */\n    static std::function&lt;DerivedType()&gt; MakeDiscreteGaussianCoefficientAllocator(const std::shared_ptr&lt;Params&gt;&amp; params,\n                                                                                 Format resultFormat, double stddev) {\n        return [=]() {\n            DggType dgg(stddev);\n            DerivedType ilvec(dgg, params, Format::COEFFICIENT);\n            ilvec.SetFormat(resultFormat);\n            return ilvec;\n        };\n    }\n\n    /**\n   * @brief Allocator for discrete uniform distribution.\n   *\n   * @param params Params instance that is is passed.\n   * @param format format for the polynomials generated.\n   * @return the resulting vector.\n   */\n    static std::function&lt;DerivedType()&gt; MakeDiscreteUniformAllocator(const std::shared_ptr&lt;Params&gt;&amp; params,\n                                                                     Format format) {\n        return [=]() {\n            DugType dug;\n            return DerivedType(dug, params, format);\n        };\n    }\n\n    /**\n   * @brief Makes a copy of the DCRTPoly, but it includes only a sequential\n   * subset of the towers that the original holds.\n   *\n   * @param startTower The index number of the first tower to clone\n   * @param endTower The index number of the last tower to clone\n   * @return new Element\n   */\n    DerivedType CloneTowers(uint32_t startTower, uint32_t endTower) {\n        return this-&gt;GetDerived().CloneTowers(startTower, endTower);\n    }\n\n    DerivedType Clone() const final {\n        return DerivedType(this-&gt;GetDerived());\n    }\n\n    DerivedType CloneEmpty() const final {\n        return DerivedType();\n    }\n\n    DerivedType CloneParametersOnly() const final {\n        return DerivedType(this-&gt;GetDerived().GetParams(), this-&gt;GetDerived().GetFormat());\n    }\n\n    /**\n   * @brief Clone with noise.  This method creates a new DCRTPoly and clones the\n   * params. The tower values will be filled up with noise based on the discrete\n   * gaussian.\n   *\n   * @param &amp;dgg the input discrete Gaussian generator. The dgg will be the seed\n   * to populate the towers of the DCRTPoly with random numbers.\n   * @param format the input format fixed to EVALUATION. Format is a enum type\n   * that indicates if the polynomial is in Evaluation representation or\n   * Coefficient representation. It is defined in inttypes.h.\n   */\n    DerivedType CloneWithNoise(const DiscreteGaussianGeneratorImpl&lt;BigVecType&gt;&amp; dgg, Format format) const override = 0;\n\n    /**\n   * @brief Get method of the format.\n   *\n   * @return the format, either COEFFICIENT or EVALUATION\n   */\n    Format GetFormat() const override = 0;\n    //    return this-&gt;GetDerived().GetFormat();\n\n    /**\n   * @brief returns the parameters of the element.\n   * @return the element parameter set.\n   */\n    const std::shared_ptr&lt;Params&gt;&amp; GetParams() const {\n        return this-&gt;GetDerived().GetParams();\n    }\n\n    /**\n   * @brief returns the element&#x27;s cyclotomic order\n   * @return returns the cyclotomic order of the element.\n   */\n    usint GetCyclotomicOrder() const final {\n        return this-&gt;GetDerived().GetParams()-&gt;GetCyclotomicOrder();\n    }\n\n    /**\n   * @brief returns the element&#x27;s ring dimension\n   * @return returns the ring dimension of the element.\n   */\n    usint GetRingDimension() const {\n        return this-&gt;GetDerived().GetParams()-&gt;GetRingDimension();\n    }\n\n    /**\n   * @brief returns the element&#x27;s modulus\n   * @return returns the modulus of the element.\n   */\n    const BigIntType&amp; GetModulus() const final {\n        return this-&gt;GetDerived().GetParams()-&gt;GetModulus();\n    }\n\n    /**\n   * @brief returns the element&#x27;s original modulus, derived from Poly\n   * @return returns the modulus of the element.\n   */\n    const BigIntType&amp; GetOriginalModulus() const {\n        return this-&gt;GetDerived().GetParams()-&gt;GetOriginalModulus();\n    }\n\n    /**\n   * @brief returns the element&#x27;s root of unity.\n   * @return the element&#x27;s root of unity.\n   */\n    // TODO: this doesn&#x27;t look right\n    const BigIntType GetRootOfUnity() const {\n        return BigIntType(0);\n    }\n\n    /**\n   * @brief Get method for length of each component element.\n   * NOTE assumes all components are the same size. (Ring Dimension)\n   *\n   * @return length of the component element\n   */\n    usint GetLength() const final {\n        return this-&gt;GetDerived().GetParams()-&gt;GetRingDimension();\n    }\n\n    /**\n   * @brief Get interpolated value of elements at all tower index i.\n   * Note this operation is computationally intense. Does bound checking\n   * @return interpolated value at index i.\n   */\n    BigIntType&amp; at(usint i) override             = 0;\n    const BigIntType&amp; at(usint i) const override = 0;\n\n    /**\n   * @brief Get interpolated value of element at index i.\n   * Note this operation is computationally intense. No bound checking\n   * @return interpolated value at index i.\n   */\n    BigIntType&amp; operator[](usint i) override = 0;\n    //    return this-&gt;GetDerived()[i];\n    const BigIntType&amp; operator[](usint i) const override = 0;\n    //    return this-&gt;GetDerived()[i];\n\n    /**\n   * @brief Get method that returns a vector of all component elements.\n   *\n   * @returns a vector of the component elements.\n   */\n    const std::vector&lt;TowerType&gt;&amp; GetAllElements() const {\n        return this-&gt;GetDerived().GetAllElements();\n    }\n    std::vector&lt;TowerType&gt;&amp; GetAllElements() {\n        return this-&gt;GetDerived().GetAllElements();\n    }\n\n    /**\n   * @brief Get method of the number of component elements, also known as the\n   * number of towers.\n   *\n   * @return the number of component elements.\n   */\n    usint GetNumOfElements() const {\n        return this-&gt;GetDerived().GetAllElements().size();\n    }\n\n    /**\n   * @brief Get method of individual tower of elements.\n   * Note this behavior is different than poly\n   * @param i index of tower to be returned.\n   * @returns a reference to the returned tower\n   */\n    const TowerType&amp; GetElementAtIndex(usint i) const {\n        return this-&gt;GetDerived().GetAllElements()[i];\n    }\n\n    /**\n   * @brief Get value of element at index i.\n   *\n   * @return value at index i.\n   *\n   * @warning Should be removed to disable access to the towers, all modifications\n   * in the lattice layer should be done in the lattice layer. This means new functions\n   * will be need in the lattice layer.\n   */\n    TowerType&amp; ElementAtIndex(usint i) {\n        return this-&gt;GetDerived().GetAllElements()[i];\n    }\n\n    /**\n   * @brief Sets element at index\n   *\n   * @param index where the element should be set\n   * @param element The element to store\n   */\n    void SetElementAtIndex(usint index, const TowerType&amp; element) {\n        return this-&gt;GetDerived().SetElementAtIndex(index, element);\n    }\n\n    /**\n   * @brief Sets element at index\n   *\n   * @param index where the element should be set\n   * @param element The element to store\n   */\n    void SetElementAtIndex(usint index, TowerType&amp;&amp; element) {\n        return this-&gt;GetDerived().SetElementAtIndex(index, element);\n    }\n\n    /***********************************************************************\n   * Yuriy and I stopped here!\n   **********************************************************************/\n\n    /**\n   * @brief Write the element as \\f$ \\sum\\limits{i=0}^{\\lfloor {\\log q/base}\n   * \\rfloor} {(base^i u_i)} \\f$ and return the vector of \\f$ \\left\\{u_0,\n   * u_1,...,u_{\\lfloor {\\log q/base} \\rfloor} \\right\\} \\in R_{{base}^{\\lceil\n   * {\\log q/base} \\rceil}} \\f$; This is used as a subroutine in the\n   * relinearization procedure.\n   *\n   * @param baseBits is the number of bits in the base, i.e., \\f$ base =\n   * 2^{baseBits} \\f$.\n   * @return is the pointer where the base decomposition vector is stored\n   *\n   * @warning not efficient and  not fast, uses multiprecision arithmetic and\n   *          will be removed in future. Use @see DCRTPolyInterface::CRTDecompose instead.\n   */\n    std::vector&lt;DerivedType&gt; BaseDecompose(usint baseBits, bool evalModeAnswer) const override = 0;\n\n    /**\n   * @brief Generate a vector of PolyImpl&#x27;s as \\f$ \\left\\{x, {base}*x,\n   * {base}^2*x, ..., {base}^{\\lfloor {\\log q/{base}} \\rfloor} \\right\\}*x \\f$,\n   * where \\f$ x \\f$ is the current PolyImpl object;\n   * used as a subroutine in the relinearization procedure to get powers of a\n   * certain &quot;base&quot; for the secret key element.\n   *\n   * @param baseBits is the number of bits in the base, i.e., \\f$ base =\n   * 2^{baseBits} \\f$.\n   * @return is the pointer where the base decomposition vector is stored\n   *\n   * @warning not efficient and  not fast, uses multiprecision arithmetic and\n   *          will be removed in future. Use @see DCRTPolyInterface::CRTDecompose instead.\n   */\n    std::vector&lt;DerivedType&gt; PowersOfBase(usint baseBits) const override = 0;\n\n    /**\n   * CRT basis decomposition of c as [c qi/q]_qi\n   *\n   * @param &amp;baseBits bits in the base for additional digit decomposition if\n   * base &gt; 0\n   * @return is the pointer where the resulting vector is stored\n   */\n    std::vector&lt;DerivedType&gt; CRTDecompose(uint32_t baseBits) const {\n        return this-&gt;GetDerived().CRTDecompose(baseBits);\n    }\n\n    DerivedType&amp; operator=(const TowerType&amp; rhs) {\n        return this-&gt;GetDerived().operator=(rhs);\n    }\n\n    /**\n   * @brief Assignment Operator.\n   *\n   * @param &amp;rhs the copied element.\n   * @return the resulting element.\n   */\n    DerivedType&amp; operator=(const DerivedType&amp; rhs) override = 0;\n\n    /**\n   * @brief Move Assignment Operator.\n   *\n   * @param &amp;rhs the copied element.\n   * @return the resulting element.\n   */\n    DerivedType&amp; operator=(DerivedType&amp;&amp; rhs) override = 0;\n\n    /**\n   * @brief Initalizer list\n   *\n   * @param &amp;rhs the list to initalized the element.\n   * @return the resulting element.\n   */\n    DerivedType&amp; operator=(std::initializer_list&lt;uint64_t&gt; rhs) override = 0;\n\n    /**\n   * @brief Assignment Operator. The usint val will be set at index zero and all\n   * other indices will be set to zero.\n   *\n   * @param val is the usint to assign to index zero.\n   * @return the resulting vector.\n   */\n    DerivedType&amp; operator=(uint64_t val) {\n        return this-&gt;GetDerived().operator=(val);\n    }\n\n    /**\n   * @brief Creates a Poly from a vector of signed integers (used for trapdoor\n   * sampling)\n   *\n   * @param &amp;rhs the vector to set the PolyImpl to.\n   * @return the resulting PolyImpl.\n    */\n    DerivedType&amp; operator=(const std::vector&lt;int64_t&gt;&amp; rhs) {\n        return this-&gt;GetDerived().operator=(rhs);\n    }\n\n    /**\n   * @brief Creates a Poly from a vector of signed integers (used for trapdoor\n   * sampling)\n   *\n   * @param &amp;rhs the vector to set the PolyImpl to.\n   * @return the resulting PolyImpl.\n   */\n    DerivedType&amp; operator=(const std::vector&lt;int32_t&gt;&amp; rhs) {\n        return this-&gt;GetDerived().operator=(rhs);\n    }\n\n    /**\n   * @brief Initalizer list\n   *\n   * @param &amp;rhs the list to set the PolyImpl to.\n   * @return the resulting PolyImpl.\n   */\n    DerivedType&amp; operator=(std::initializer_list&lt;std::string&gt; rhs) {\n        return this-&gt;GetDerived().operator=(rhs);\n    }\n\n    /**\n   * @brief Unary minus on a element.\n   * @return additive inverse of the an element.\n   */\n    DerivedType operator-() const override = 0;\n\n    /**\n   * @brief Equality operator.\n   *\n   * @param &amp;rhs is the specified element to be compared with this element.\n   * @return true if this element represents the same values as the specified\n   * element, false otherwise.\n   */\n    bool operator==(const DerivedType&amp; rhs) const override = 0;\n\n    /**\n   * @brief Performs an entry-wise addition over all elements of each tower with\n   * the towers of the element on the right hand side.\n   *\n   * @param &amp;rhs is the element to add with.\n   * @return is the result of the addition.\n   */\n    DerivedType&amp; operator+=(const DerivedType&amp; rhs) override = 0;\n\n    /**\n   * @brief Performs an entry-wise subtraction over all elements of each tower\n   * with the towers of the element on the right hand side.\n   *\n   * @param &amp;rhs is the element to subtract from.\n   * @return is the result of the addition.\n   */\n    DerivedType&amp; operator-=(const DerivedType&amp; rhs) override = 0;\n\n    /**\n   * @brief Permutes coefficients in a polynomial. Moves the ith index to the\n   * first one, it only supports odd indices.\n   *\n   * @param &amp;i is the element to perform the automorphism transform with.\n   * @return is the result of the automorphism transform.\n   */\n    DerivedType AutomorphismTransform(uint32_t i) const override = 0;\n\n    /**\n   * @brief Performs an automorphism transform operation using precomputed bit\n   * reversal indices.\n   *\n   * @param &amp;i is the element to perform the automorphism transform with.\n   * @param &amp;vec a vector with precomputed indices\n   * @return is the result of the automorphism transform.\n   */\n    DerivedType AutomorphismTransform(uint32_t i, const std::vector&lt;uint32_t&gt;&amp; vec) const override = 0;\n\n    /**\n   * @brief Transpose the ring element using the automorphism operation\n   *\n   * @return is the result of the transposition.\n   */\n    DerivedType Transpose() const final {\n        if (this-&gt;GetDerived().GetFormat() == Format::COEFFICIENT)\n            &quot;hey&quot;; OPENFHE_THROW(not_implemented_error,\n                          &quot;DCRTPolyInterface element transposition is currently &quot;\n                          &quot;implemented only in the Evaluation representation.&quot;);\n        return this-&gt;GetDerived().AutomorphismTransform(this-&gt;GetDerived().GetCyclotomicOrder() - 1);\n    }\n\n    /**\n   * @brief Performs an addition operation and returns the result.\n   *\n   * @param &amp;element is the element to add with.\n   * @return is the result of the addition.\n   */\n    DerivedType Plus(const DerivedType&amp; rhs) const override = 0;\n    //    return this-&gt;GetDerived().Plus(rhs);\n\n    /**\n   * @brief Performs a multiplication operation and returns the result.\n   *\n   * @param &amp;element is the element to multiply with.\n   * @return is the result of the multiplication.\n   */\n    DerivedType Times(const DerivedType&amp; rhs) const override = 0;\n    //    return this-&gt;GetDerived().Times(rhs);\n\n    /**\n   * @brief Performs a subtraction operation and returns the result.\n   *\n   * @param &amp;element is the element to subtract from.\n   * @return is the result of the subtraction.\n   */\n    DerivedType Minus(const DerivedType&amp; rhs) const override = 0;\n\n    /**\n   * @brief Scalar addition - add an element to the first index of each tower.\n   *\n   * @param &amp;element is the element to add entry-wise.\n   * @return is the result of the addition operation.\n   */\n    DerivedType Plus(const BigIntType&amp; rhs) const override = 0;\n\n    /**\n   * @brief Scalar addition for elements in CRT format.\n   * CRT elements are represented as vector of integer elements which\n   * correspond to the represented number modulo the primes in the\n   * tower chain (in same order).\n   *\n   * @param &amp;element is the element to add entry-wise.\n   * @return is the result of the addition operation.\n   */\n    DerivedType Plus(const std::vector&lt;BigIntType&gt;&amp; rhs) const {\n        return this-&gt;GetDerived().Plus(rhs);\n    }\n\n    /**\n   * @brief Scalar subtraction - subtract an element to all entries.\n   *\n   * @param &amp;element is the element to subtract entry-wise.\n   * @return is the return value of the minus operation.\n   */\n    DerivedType Minus(const BigIntType&amp; rhs) const override = 0;\n\n    /**\n   * @brief Scalar subtraction for elements in CRT format.\n   * CRT elements are represented as vector of integer elements which\n   * correspond to the represented number modulo the primes in the\n   * tower chain (in same order).\n   *\n   * @param &amp;element is the element to subtract entry-wise.\n   * @return is the result of the subtraction operation.\n   */\n    DerivedType Minus(const std::vector&lt;BigIntType&gt;&amp; rhs) const {\n        return this-&gt;GetDerived().Minus(rhs);\n    }\n\n    /**\n   * @brief Scalar multiplication - multiply all entries.\n   *\n   * @param &amp;element is the element to multiply entry-wise.\n   * @return is the return value of the times operation.\n   */\n    DerivedType Times(const BigIntType&amp; rhs) const override = 0;\n\n    /**\n   * @brief Scalar multiplication - multiply by a signed integer\n   *\n   * @param &amp;element is the element to multiply entry-wise.\n   * @return is the return value of the times operation.\n   */\n    DerivedType Times(NativeInteger::SignedNativeInt rhs) const override = 0;\n\n#if NATIVEINT != 64\n    /**\n   * @brief Scalar multiplication - multiply by a signed integer\n   *\n   * @param &amp;element is the element to multiply entry-wise.\n   * @return is the return value of the times operation.\n   *\n   * @note this is need for 128-bit so that the 64-bit inputs can be used.\n   */\n    DerivedType Times(int64_t rhs) const {\n        return this-&gt;GetDerived().Times(rhs);\n    }\n#endif\n\n    /**\n   * @brief Scalar multiplication by an integer represented in CRT Basis.\n   *\n   * @param &amp;element is the element to multiply entry-wise.\n   * @return is the return value of the times operation.\n   */\n    DerivedType Times(const std::vector&lt;NativeInteger&gt;&amp; rhs) const {\n        return this-&gt;GetDerived().Times(rhs);\n    }\n\n    /**\n   * @brief Performs a multiplication operation even when the multiplicands\n   * have a different number of towers.\n   *\n   * @param &amp;element is the element to multiply with.\n   * @return is the result of the multiplication.\n   */\n    DerivedType TimesNoCheck(const std::vector&lt;NativeInteger&gt;&amp; rhs) const {\n        return this-&gt;GetDerived().TimesNoCheck(rhs);\n    }\n\n    /**\n   * @brief Scalar modular multiplication by an integer represented in CRT\n   * Basis.\n   *\n   * @param &amp;element is the element to multiply entry-wise.\n   * @return is the return value of the times operation.\n   *\n   * @warning Should remove this, data is truncated to native-word size.\n   */\n    DerivedType Times(const std::vector&lt;BigIntType&gt;&amp; rhs) const {\n        return this-&gt;GetDerived().Times(rhs);\n    }\n\n    /**\n   * @brief Scalar multiplication followed by division and rounding operation -\n   * operation on all entries.\n   *\n   * @param &amp;p is the element to multiply entry-wise.\n   * @param &amp;q is the element to divide entry-wise.\n   * @return is the return value of the multiply, divide and followed by\n   * rounding operation.\n   *\n   * @warning Will remove, this is only inplace because of BFV\n   */\n    DerivedType MultiplyAndRound(const BigIntType&amp; p, const BigIntType&amp; q) const final {\n        std::string errMsg = &quot;Operation not implemented yet&quot;;\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, errMsg);\n        return this-&gt;GetDerived();\n    }\n\n    /**\n   * @brief Scalar division followed by rounding operation - operation on all\n   * entries.\n   *\n   * @param &amp;q is the element to divide entry-wise.\n   * @return is the return value of the divide, followed by rounding operation.\n   *\n   * @warning Will remove, this is only inplace because of BFV\n   */\n    DerivedType DivideAndRound(const BigIntType&amp; q) const final {\n        std::string errMsg = &quot;Operation not implemented yet&quot;;\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, errMsg);\n        return this-&gt;GetDerived();\n    }\n\n    /**\n   * @brief Performs a negation operation and returns the result.\n   *\n   * @return is the result of the negation.\n   */\n    virtual DerivedType Negate() const = 0;\n\n    DerivedType&amp; operator+=(const BigIntType&amp; rhs) override = 0;\n    virtual DerivedType&amp; operator+=(const LilIntType&amp; rhs)  = 0;\n\n    /**\n   * @brief Performs a subtraction operation and returns the result.\n   *\n   * @param &amp;element is the element to subtract from.\n   * @return is the result of the subtraction.\n   */\n    DerivedType&amp; operator-=(const BigIntType&amp; rhs) override = 0;\n    virtual DerivedType&amp; operator-=(const LilIntType&amp; rhs)  = 0;\n\n    /**\n   * @brief Performs a multiplication operation and returns the result.\n   *\n   * @param &amp;element is the element to multiply by.\n   * @return is the result of the multiplication.\n   */\n    DerivedType&amp; operator*=(const BigIntType&amp; rhs) override = 0;\n    virtual DerivedType&amp; operator*=(const LilIntType&amp; rhs)  = 0;\n\n    /**\n   * @brief Performs an multiplication operation and returns the result.\n   *\n   * @param &amp;element is the element to multiply with.\n   * @return is the result of the multiplication.\n   */\n    DerivedType&amp; operator*=(const DerivedType&amp; rhs) override = 0;\n    //    return this-&gt;GetDerived().operator*=(rhs);\n\n    // multiplicative inverse operation\n    /**\n   * @brief Performs a multiplicative inverse operation and returns the result.\n   *\n   * @return is the result of the multiplicative inverse.\n   */\n    DerivedType MultiplicativeInverse() const override = 0;\n\n    /**\n   * @brief Perform a modulus by 2 operation.  Returns the least significant\n   * bit.\n   *\n   * @return is the resulting value.\n   *\n   * @warning Doesn&#x27;t make sense for DCRT\n   */\n    DerivedType ModByTwo() const final {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;Mod of an BigIntType not implemented on DCRTPoly&quot;);\n    }\n\n    /**\n   * @brief Modulus - perform a modulus operation. Does proper mapping of\n   * [-modulus/2, modulus/2) to [0, modulus)\n   *\n   * @param modulus is the modulus to use.\n   * @return is the return value of the modulus.\n   *\n   * @warning Doesn&#x27;t make sense for DCRT\n   */\n    DerivedType Mod(const BigIntType&amp; modulus) const final {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;Mod of an BigIntType not implemented on DCRTPoly&quot;);\n    }\n\n    /**\n   * @brief Get method that should not be used\n   *\n   * @return will throw an error.\n   *\n   * @warning Doesn&#x27;t make sense for DCRT\n   */\n    const BigVecType&amp; GetValues() const final {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;GetValues not implemented on DCRTPoly&quot;);\n    }\n\n    /**\n   * @brief Set method that should not be used, will throw an error.\n   *\n   * @param &amp;values\n   * @param format\n   *\n   * @warning Doesn&#x27;t make sense for DCRT\n   */\n    void SetValues(const BigVecType&amp; values, Format format) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;SetValues not implemented on DCRTPoly&quot;);\n    }\n\n    /**\n   * @brief Sets all values of element to zero.\n   */\n    virtual void SetValuesToZero() = 0;\n\n    /**\n   * @brief Sets values with a different modulus\n   */\n    virtual void SetValuesModSwitch(const DerivedType&amp; element, const NativeInteger&amp; modulus) = 0;\n\n    /**\n   * @brief Adds &quot;1&quot; to every entry in every tower.\n   */\n    void AddILElementOne() override = 0;\n\n    /**\n   * @brief Add uniformly random values to all components except for the first\n   * one\n   *\n   * @warning Doesn&#x27;t make sense for DCRT\n   */\n    DerivedType AddRandomNoise(const BigIntType&amp; modulus) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;AddRandomNoise is not currently implemented for DCRTPoly&quot;);\n    }\n\n    /**\n   * @brief Make DCRTPoly Sparse. Sets every index of each tower not equal to\n   * zero mod the wFactor to zero.\n   *\n   * @param &amp;wFactor ratio between the sparse and none-sparse values.\n   *\n   * @warning Only used by RingSwitching, which is no longer supported. Will be removed in future.\n   */\n    void MakeSparse(uint32_t wFactor) final {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;MakeSparse is not currently implemented for DCRTPoly&quot;);\n    }\n\n    /**\n   * @brief Returns true if ALL the tower(s) are empty.\n   * @return true if all towers are empty\n   */\n    bool IsEmpty() const override = 0;\n\n    /**\n   * @brief Drops the last element in the double-CRT representation. The\n   * resulting DCRTPoly element will have one less tower.\n   */\n    virtual void DropLastElement() = 0;\n\n    /**\n   * @brief Drops the last i elements in the double-CRT representation.\n   */\n    virtual void DropLastElements(size_t i) = 0;\n\n    /**\n   * @brief Drops the last element in the double-CRT representation and scales\n   * down by the last CRT modulus. The resulting DCRTPoly element will have one\n   * less tower.\n   * @param &amp;QlQlInvModqlDivqlModq precomputed values for\n   * [Q^(l)*[Q^(l)^{-1}]_{q_l}/q_l]_{q_i}\n   * @param &amp;QlQlInvModqlDivqlModqPrecon NTL-specific precomputations\n   * @param &amp;qlInvModq precomputed values for [q_l^{-1}]_{q_i}\n   * @param &amp;qlInvModqPrecon NTL-specific precomputations\n   */\n    virtual void DropLastElementAndScale(const std::vector&lt;NativeInteger&gt;&amp; QlQlInvModqlDivqlModq,\n                                         const std::vector&lt;NativeInteger&gt;&amp; QlQlInvModqlDivqlModqPrecon,\n                                         const std::vector&lt;NativeInteger&gt;&amp; qlInvModq,\n                                         const std::vector&lt;NativeInteger&gt;&amp; qlInvModqPrecon) = 0;\n\n    /**\n   * @brief ModReduces reduces the DCRTPoly element&#x27;s composite modulus by\n   * dropping the last modulus from the chain of moduli as well as dropping the\n   * last tower.\n   *\n   * @param &amp;t is the plaintextModulus used for the DCRTPoly\n   * @param &amp;tModqPrecon NTL-specific precomputations for [t]_{q_i}\n   * @param &amp;negtInvModq precomputed values for [-t^{-1}]_{q_i}\n   * @param &amp;negtInvModqPrecon NTL-specific precomputations for [-t^{-1}]_{q_i}\n   * @param &amp;qlInvModq precomputed values for [q_{l}^{-1}]_{q_i}\n   * @param &amp;qlInvModqPrecon NTL-specific precomputations for [q_{l}^{-1}]_{q_i}\n   */\n    virtual void ModReduce(const NativeInteger&amp; t, const std::vector&lt;NativeInteger&gt;&amp; tModqPrecon,\n                           const NativeInteger&amp; negtInvModq, const NativeInteger&amp; negtInvModqPrecon,\n                           const std::vector&lt;NativeInteger&gt;&amp; qlInvModq,\n                           const std::vector&lt;NativeInteger&gt;&amp; qlInvModqPrecon) = 0;\n\n    /**\n   * @brief Interpolates the DCRTPoly to an Poly based on the Chinese Remainder\n   * Transform Interpolation. and then returns a Poly with that single element\n   *\n   * @return the interpolated ring element as a Poly object.\n   */\n    virtual PolyLargeType CRTInterpolate() const = 0;\n\n    virtual TowerType DecryptionCRTInterpolate(PlaintextModulus ptm) const = 0;\n\n    /**\n   * @brief If the values are small enough this is used for efficiency\n   *\n   * @return NativePoly\n   *\n   * @warning This will be replaced with a non-member utility function.\n   */\n    virtual TowerType ToNativePoly() const = 0;\n\n    /**\n   * @brief Interpolates the DCRTPoly to an Poly based on the Chinese Remainder\n   * Transform Interpolation, only at element index i, all other elements are\n   * zero. and then returns a Poly with that single element\n   *\n   * @return the interpolated ring element as a Poly object.\n   */\n    virtual PolyLargeType CRTInterpolateIndex(usint i) const = 0;\n\n    /**\n   * @brief Computes and returns the product of primes in the current moduli\n   * chain. Compared to GetModulus, which always returns the product of all\n   * primes in the crypto parameters, this method will return a different\n   * modulus, based on the towers/moduli that are currently in the chain (some\n   * towers are dropped along the way).\n   *\n   * @return the product of moduli in the current towers.\n   */\n    virtual BigIntType GetWorkingModulus() const = 0;\n\n    /**\n   * @brief Returns the element parameters for DCRTPoly elements in an extended\n   * CRT basis, which is the concatenation of the towers currently in &quot;this&quot;\n   * DCRTPoly, and the moduli in ParamsP.\n   *\n   * @return element parameters of the extended basis.\n   */\n    virtual std::shared_ptr&lt;Params&gt; GetExtendedCRTBasis(const std::shared_ptr&lt;Params&gt;&amp; paramsP) const = 0;\n\n    virtual void TimesQovert(const std::shared_ptr&lt;Params&gt;&amp; paramsQ, const std::vector&lt;NativeInteger&gt;&amp; tInvModq,\n                             const NativeInteger&amp; t, const NativeInteger&amp; NegQModt,\n                             const NativeInteger&amp; NegQModtPrecon) = 0;\n\n    /**\n   * @brief Performs approximate CRT basis switching:\n   * {X}_{Q} -&gt; {X&#x27;}_{P}\n   * X&#x27; = X + alpha*Q for small alpha\n   * {Q} = {q_1,...,q_l}\n   * {P} = {p_1,...,p_k}\n   *\n   * Brief algorithm:\n   * [X&#x27;]_{p_j} = [\\sum_i([x_i*(Q/q_i)^{-1}]_{q_i}*(Q/q_i)]_{p_j}\n   *\n   * Source: &quot;A full RNS variant of approximate homomorphic encryption&quot; by\n   * Cheon, et. al.\n   *\n   * @param &amp;paramsQ parameters for the CRT basis {q_1,...,q_l}\n   * @param &amp;paramsP parameters for the CRT basis {p_1,...,p_k}\n   * @param &amp;QHatinvModq precomputed values for [(Q/q_i)^{-1}]_{q_i}\n   * @param &amp;QHatinvModqPrecon NTL-specific precomputations\n   * @param &amp;QHatModp precomputed values for [Q/q_i]_{p_j}\n   * @param &amp;modpBarrettMu 128-bit Barrett reduction precomputed values\n   * @return the representation of {X + alpha*Q} in basis {P}.\n   */\n    virtual DerivedType ApproxSwitchCRTBasis(const std::shared_ptr&lt;Params&gt;&amp; paramsQ,\n                                             const std::shared_ptr&lt;Params&gt;&amp; paramsP,\n                                             const std::vector&lt;NativeInteger&gt;&amp; QHatInvModq,\n                                             const std::vector&lt;NativeInteger&gt;&amp; QHatInvModqPrecon,\n                                             const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; QHatModp,\n                                             const std::vector&lt;DoubleNativeInt&gt;&amp; modpBarrettMu) const = 0;\n\n    /**\n   * @brief Performs approximate modulus raising:\n   * {X}_{Q} -&gt; {X&#x27;}_{Q,P}.\n   * X&#x27; = X + alpha*Q for small alpha\n   * {Q} = {q_1,...,q_l}\n   * {P} = {p_1,...,p_k}\n   *\n   * Brief algorithm:\n   * {X}_{Q} -&gt; {X&#x27;}_Q : trivial\n   * {X}_{Q} -&gt; {X&#x27;}_P : use DCRTPoly::ApproxSwitchCRTBasis\n   *\n   * Source: &quot;A full RNS variant of approximate homomorphic encryption&quot; by\n   * Cheon, et. al.\n   *\n   * @param &amp;paramsQ parameters for the CRT basis {q_1,...,q_l}\n   * @param &amp;paramsP parameters for the CRT basis {p_1,...,p_k}\n   * @param &amp;QHatInvModq precomputed values for [(Q/q_i)^{-1}]_{q_i}\n   * @param &amp;QHatInvModqPrecon NTL-specific precomputations\n   * @param &amp;QHatModp precomputed values for [Q/q_i]_{p_j}\n   * @param &amp;modpBarrettMu 128-bit Barrett reduction precomputed values for\n   * p_j\n   * @return the representation of {X + alpha*Q} in basis {Q,P}.\n   */\n    virtual void ApproxModUp(const std::shared_ptr&lt;Params&gt;&amp; paramsQ, const std::shared_ptr&lt;Params&gt;&amp; paramsP,\n                             const std::shared_ptr&lt;Params&gt;&amp; paramsQP, const std::vector&lt;NativeInteger&gt;&amp; QHatInvModq,\n                             const std::vector&lt;NativeInteger&gt;&amp; QHatInvModqPrecon,\n                             const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; QHatModp,\n                             const std::vector&lt;DoubleNativeInt&gt;&amp; modpBarrettMu) = 0;\n\n    /**\n   * @brief Performs approximate modulus reduction:\n   * {X}_{Q,P} -&gt; {\\approx(X/P)}_{Q}.\n   * {Q} = {q_1,...,q_l}\n   * {P} = {p_1,...,p_k}\n   *\n   * Brief algorithm:\n   * 1) use DCRTPoly::ApproxSwitchCRTBasis : {X}_{P} -&gt; {X&#x27;}_{Q}\n   * 2) compute : {(X-X&#x27;) * P^{-1}}_{Q}\n   *\n   * Source: &quot;A full RNS variant of approximate homomorphic encryption&quot; by\n   * Cheon, et. al.\n   *\n   * @param &amp;paramsQ parameters for the CRT basis {q_1,...,q_l}\n   * @param &amp;paramsP parameters for the CRT basis {p_1,...,p_k}\n   * @param &amp;PInvModq precomputed values for (P^{-1} mod q_j)\n   * @param &amp;PInvModqPrecon NTL-specific precomputations\n   * @param &amp;PHatInvModp precomputed values for [(P/p_j)^{-1}]_{p_j}\n   * @param &amp;PHatInvModpPrecon NTL-specific precomputations\n   * @param &amp;PHatModq precomputed values for [P/p_j]_{q_i}\n   * @param &amp;modqBarrettMu 128-bit Barrett reduction precomputed values for\n   * q_i\n   * @param &amp;tInvModp precomputed values for [t^{-1}]_{p_j}\n   * used in BGVrns\n   * @param t often corresponds to the plaintext modulus\n   * used in BGVrns\n   * @return the representation of {\\approx(X/P)}_{Q}\n   */\n    virtual DerivedType ApproxModDown(\n        const std::shared_ptr&lt;Params&gt;&amp; paramsQ, const std::shared_ptr&lt;Params&gt;&amp; paramsP,\n        const std::vector&lt;NativeInteger&gt;&amp; PInvModq, const std::vector&lt;NativeInteger&gt;&amp; PInvModqPrecon,\n        const std::vector&lt;NativeInteger&gt;&amp; PHatInvModp, const std::vector&lt;NativeInteger&gt;&amp; PHatInvModpPrecon,\n        const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; PHatModq, const std::vector&lt;DoubleNativeInt&gt;&amp; modqBarrettMu,\n        const std::vector&lt;NativeInteger&gt;&amp; tInvModp, const std::vector&lt;NativeInteger&gt;&amp; tInvModpPrecon,\n        const NativeInteger&amp; t, const std::vector&lt;NativeInteger&gt;&amp; tModqPrecon) const = 0;\n\n    /**\n   * @brief Performs CRT basis switching:\n   * {X}_{Q} -&gt; {X}_{P}\n   * {Q} = {q_1,...,q_l}\n   * {P} = {p_1,...,p_k}\n   *\n   * Brief algorithm:\n   * 1) X=\\sum_i[x_i*(Q/q_i)^{-1}]_{q_i}*(Q/q_i)-alpha*Q\n   * 2) compute round[[x_i*(Q/q_i)^{-1}]_{q_i} / q_i] to find alpha\n   * 3) [X]_{p_j}=[\\sum_i[x_i*(Q/q_i)^{-1}]_{q_i}*(Q/q_i)]_{p_j}-[alpha*Q]_{p_j}\n   *\n   * Source: Halevi S., Polyakov Y., and Shoup V. An Improved RNS Variant of the\n   * BFV Homomorphic Encryption Scheme. Cryptology ePrint Archive, Report\n   * 2018/117. (https://eprint.iacr.org/2018/117)\n   *\n   * @param &amp;paramsP parameters for the CRT basis {p_1,...,p_k}\n   * @param &amp;QHatInvModq precomputed values for [(Q/q_i)^{-1}]_{q_i}\n   * @param &amp;QHatInvModqPrecon NTL-specific precomputations\n   * @param &amp;QHatModp precomputed values for [Q/q_i]_{p_j}\n   * @param &amp;alphaQModp precomputed values for [alpha*Q]_{p_j}\n   * @param &amp;modpBarrettMu 128-bit Barrett reduction precomputed values for\n   * p_j\n   * @params &amp;qInv precomputed values for 1/q_i\n   * @return the representation of {X}_{P}\n   */\n    virtual DerivedType SwitchCRTBasis(const std::shared_ptr&lt;Params&gt;&amp; paramsP,\n                                       const std::vector&lt;NativeInteger&gt;&amp; QHatInvModq,\n                                       const std::vector&lt;NativeInteger&gt;&amp; QHatInvModqPrecon,\n                                       const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; QHatModp,\n                                       const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; alphaQModp,\n                                       const std::vector&lt;DoubleNativeInt&gt;&amp; modpBarrettMu,\n                                       const std::vector&lt;double&gt;&amp; qInv) const = 0;\n\n    /**\n   * @brief Performs modulus raising:\n   * {X}_{Q} -&gt; {X}_{Q,P}\n   * {Q} = {q_1,...,q_l}\n   * {P} = {p_1,...,p_k}\n   *\n   * Brief algorithm:\n   * {X}_{Q} -&gt; {X}_P : use DCRTPoly::SwitchCRTBasis\n   * combine {X}_{Q} and {X}_{P}\n   * Outputs the resulting polynomial in CRT/RNS\n   *\n   * Source: Halevi S., Polyakov Y., and Shoup V. An Improved RNS Variant of the\n   * BFV Homomorphic Encryption Scheme. Cryptology ePrint Archive, Report\n   * 2018/117. (https://eprint.iacr.org/2018/117)\n   *\n   * @param &amp;paramsQP parameters for the CRT basis {q_1,...,q_l,p_1,...,p_k}\n   * @param &amp;paramsP parameters for the CRT basis {p_1,...,p_k}\n   * @param &amp;QHatInvModq precomputed values for [QInv_i]_{q_i}\n   * @param &amp;QHatInvModqPrecon NTL-specific precomputations\n   * @param &amp;QHatModp precomputed values for [QHat_i]_{p_j}\n   * @param &amp;alphaQModp precomputed values for [alpha*Q]_{p_j}\n   * @param &amp;modpBarrettMu 128-bit Barrett reduction precomputed values for\n   * p_j\n   * @params &amp;qInv precomputed values for 1/q_i\n   * @param resultFormat Specifies the format we want the result to be in\n   *\n   */\n    virtual void ExpandCRTBasis(const std::shared_ptr&lt;Params&gt;&amp; paramsQP, const std::shared_ptr&lt;Params&gt;&amp; paramsP,\n                                const std::vector&lt;NativeInteger&gt;&amp; QHatInvModq,\n                                const std::vector&lt;NativeInteger&gt;&amp; QHatInvModqPrecon,\n                                const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; QHatModp,\n                                const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; alphaQModp,\n                                const std::vector&lt;DoubleNativeInt&gt;&amp; modpBarrettMu, const std::vector&lt;double&gt;&amp; qInv,\n                                Format resultFormat) = 0;\n\n    /**\n   * @brief Performs modulus raising in reverse order:\n   * {X}_{Q} -&gt; {X}_{P,Q}\n   */\n    virtual void ExpandCRTBasisReverseOrder(const std::shared_ptr&lt;Params&gt;&amp; paramsQP,\n                                            const std::shared_ptr&lt;Params&gt;&amp; paramsP,\n                                            const std::vector&lt;NativeInteger&gt;&amp; QHatInvModq,\n                                            const std::vector&lt;NativeInteger&gt;&amp; QHatInvModqPrecon,\n                                            const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; QHatModp,\n                                            const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; alphaQModp,\n                                            const std::vector&lt;DoubleNativeInt&gt;&amp; modpBarrettMu,\n                                            const std::vector&lt;double&gt;&amp; qInv, Format resultFormat) = 0;\n\n    struct CRTBasisExtensionPrecomputations {\n        // TODO (dsuponit) and (pascoec): make the data members private to enforce their constantness and add getters.\n        std::shared_ptr&lt;Params&gt; paramsQlPl;\n        std::shared_ptr&lt;Params&gt; paramsPl;\n        std::shared_ptr&lt;Params&gt; paramsQl;\n        std::vector&lt;NativeInteger&gt; mPlQHatInvModq;\n        std::vector&lt;NativeInteger&gt; mPlQHatInvModqPrecon;\n        std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; qInvModp;\n        std::vector&lt;DoubleNativeInt&gt; modpBarrettMu;\n        std::vector&lt;NativeInteger&gt; PlHatInvModp;\n        std::vector&lt;NativeInteger&gt; PlHatInvModpPrecon;\n        std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; PlHatModq;\n        std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; alphaPlModq;\n        std::vector&lt;DoubleNativeInt&gt; modqBarrettMu;\n        std::vector&lt;double&gt; pInv;\n\n        // clang-format off\n        CRTBasisExtensionPrecomputations(\n            const std::shared_ptr&lt;Params&gt;&amp; paramsQlPl0,\n            const std::shared_ptr&lt;Params&gt;&amp; paramsPl0,\n            const std::shared_ptr&lt;Params&gt;&amp; paramsQl0,\n            const std::vector&lt;NativeInteger&gt;&amp; mPlQHatInvModq0,\n            const std::vector&lt;NativeInteger&gt;&amp; mPlQHatInvModqPrecon0,\n            const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; qInvModp0,\n            const std::vector&lt;DoubleNativeInt&gt;&amp; modpBarrettMu0,\n            const std::vector&lt;NativeInteger&gt;&amp; PlHatInvModp0,\n            const std::vector&lt;NativeInteger&gt;&amp; PlHatInvModpPrecon0,\n            const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; PlHatModq0,\n            const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; alphaPlModq0,\n            const std::vector&lt;DoubleNativeInt&gt;&amp; modqBarrettMu0,\n            const std::vector&lt;double&gt;&amp; pInv0)\n            : paramsQlPl(paramsQlPl0),\n              paramsPl(paramsPl0),\n              paramsQl(paramsQl0),\n              mPlQHatInvModq(mPlQHatInvModq0),\n              mPlQHatInvModqPrecon(mPlQHatInvModqPrecon0),\n              qInvModp(qInvModp0),\n              modpBarrettMu(modpBarrettMu0),\n              PlHatInvModp(PlHatInvModp0),\n              PlHatInvModpPrecon(PlHatInvModpPrecon0),\n              PlHatModq(PlHatModq0),\n              alphaPlModq(alphaPlModq0),\n              modqBarrettMu(modqBarrettMu0),\n              pInv(pInv0) {}\n        // clang-format on\n    };\n    typedef struct CRTBasisExtensionPrecomputations CRTBasisExtensionPrecomputations;\n\n    virtual void FastExpandCRTBasisPloverQ(const CRTBasisExtensionPrecomputations&amp; precomputed) = 0;\n\n    virtual void ExpandCRTBasisQlHat(const std::shared_ptr&lt;Params&gt;&amp; paramsQ,\n                                     const std::vector&lt;NativeInteger&gt;&amp; QlHatModq,\n                                     const std::vector&lt;NativeInteger&gt;&amp; QlHatModqPrecon, const usint sizeQ) = 0;\n\n    /**\n   * @brief Performs scale and round:\n   * {X}_{Q} -&gt; {\\round(t/Q*X)}_t\n   * {Q} = {q_1,...,q_l}\n   * {P} = {p_1,...,p_k}\n   *\n   * Brief algorithm:\n   * [\\sum_i x_i*[t*QHatInv_i/q_i]_t + Round(\\sum_i x_i*{t*QHatInv_i/q_i})]_t\n   *\n   * Source: Halevi S., Polyakov Y., and Shoup V. An Improved RNS Variant of the\n   * BFV Homomorphic Encryption Scheme. Cryptology ePrint Archive, Report\n   * 2018/117. (https://eprint.iacr.org/2018/117)\n   *\n   * @param &amp;t often corresponds to the plaintext modulus\n   * @param &amp;tQHatInvModqDivqModt precomputed values for\n   * [Floor{t*QHatInv_i/q_i}]_t\n   * @param &amp;tQHatInvModqDivqModtPrecon NTL-specific precomputations\n   * @param &amp;tQHatInvModqBDivqModt precomputed values for\n   * [Floor{t*QHatInv_i*B/q_i}]_t used when CRT moduli are 45..60 bits long\n   * @param &amp;tQHatInvBDivqModtPrecon NTL-specific precomputations\n   * used when CRT moduli are 45..60 bits long\n   * @param &amp;tQHatInvModqDivqFrac precomputed values for Frac{t*QHatInv_i/q_i}\n   * @param &amp;tQHatInvBDivqFrac precomputed values for Frac{t*QHatInv_i*B/q_i}\n   * used when CRT moduli are 45..60 bits long\n   * @return the result of computation as a polynomial with native 64-bit\n   * coefficients\n   */\n    virtual TowerType ScaleAndRound(const NativeInteger&amp; t, const std::vector&lt;NativeInteger&gt;&amp; tQHatInvModqDivqModt,\n                                    const std::vector&lt;NativeInteger&gt;&amp; tQHatInvModqDivqModtPrecon,\n                                    const std::vector&lt;NativeInteger&gt;&amp; tQHatInvModqBDivqModt,\n                                    const std::vector&lt;NativeInteger&gt;&amp; tQHatInvModqBDivqModtPrecon,\n                                    const std::vector&lt;double&gt;&amp; tQHatInvModqDivqFrac,\n                                    const std::vector&lt;double&gt;&amp; tQHatInvModqBDivqFrac) const = 0;\n\n    /**\n   * @brief Computes approximate scale and round:\n   * {X}_{Q,P} -&gt; {\\approx{t/Q * X}}_{P}\n   * {Q} = {q_1,...,q_l}\n   * {P} = {p_1,...,p_k}\n   *\n   * Brief algorithm:\n   * Let S = {Q,P}\n   * 1) [\\sum_k x_k * alpha_k]_{p_j}\n   * 2) alpha_k = [Floor[t*P*[[SHatInv_k]_{s_k}/s_k]]_{p_j}\n   *\n   * Source: Halevi S., Polyakov Y., and Shoup V. An Improved RNS Variant of the\n   * BFV Homomorphic Encryption Scheme. Cryptology ePrint Archive, Report\n   * 2018/117. (https://eprint.iacr.org/2018/117)\n   *\n   * @param &amp;paramsP parameters for the CRT basis {p_1,...,p_k}\n   * @param &amp;tPSHatInvModsDivsModp precomputed values for\n   * [\\floor[t*P*[[SHatInv_k]_{s_k}/s_k]]_{p_j}\n   * @param &amp;modpBarretMu 128-bit Barrett reduction precomputed values for\n   * p_j\n   * @return the result {\\approx{t/Q * X}}_{P}\n   */\n    virtual DerivedType ApproxScaleAndRound(const std::shared_ptr&lt;Params&gt;&amp; paramsP,\n                                            const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; tPSHatInvModsDivsModp,\n                                            const std::vector&lt;DoubleNativeInt&gt;&amp; modpBarretMu) const = 0;\n\n    /**\n   * @brief Computes scale and round:\n   * {X}_{I,O} -&gt; {t/I * X}_{O}\n   * {I} = {i_1,...,i_l}\n   * {O} = {o_1,...,o_k}\n   * O, the output modulus can be either P or Q, and I is the other one.\n   *\n   * Brief algorithm:\n   * Let S = {I,O}\n   * 1) [\\sum_k x_k * alpha_k + Round(\\sum_k beta_k * x_k)]_{o_j}\n   * 2) alpha_k = [Floor[t*O*[[SHatInv_k]_{s_k}/s_k]]_{o_j}\n   * 3) beta_k = {t*O*[[SHatInv_k]_{s_k}/s_k}\n   *\n   * Source: Halevi S., Polyakov Y., and Shoup V. An Improved RNS Variant of the\n   * BFV Homomorphic Encryption Scheme. Cryptology ePrint Archive, Report\n   * 2018/117. (https://eprint.iacr.org/2018/117)\n   *\n   * @param &amp;paramsOutput parameters for the CRT basis {o_1,...,o_k}.\n   * @param &amp;tOSHatInvModsDivsModo precomputed values for\n   * [\\floor[t*O*[[SHatInv_k]_{s_k}/s_k]]_{o_j}\n   * @param &amp;tPSHatInvModsDivsFrac precomputed values for\n   * {t*O*[[SHatInv_k]_{s_k}/s_k}\n   * @param &amp;modoBarretMu 128-bit Barrett reduction precomputed values for\n   * o_j\n   * @return the result {t/I * X}_{O}\n   */\n    virtual DerivedType ScaleAndRound(const std::shared_ptr&lt;Params&gt;&amp; paramsOutput,\n                                      const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; tOSHatInvModsDivsModo,\n                                      const std::vector&lt;double&gt;&amp; tOSHatInvModsDivsFrac,\n                                      const std::vector&lt;DoubleNativeInt&gt;&amp; modoBarretMu) const = 0;\n\n    /**\n   * @brief Computes scale and round for fast rounding:\n   * {X}_{Q} -&gt; {\\round(t/Q * X)}_t\n   * {Q} = {q_1,...,q_l}\n   *\n   * Brief algorithm:\n   *\n   * Source: Jean-Claude Bajard and Julien Eynard and Anwar Hasan and Vincent\n   * Zucca. A Full RNS Variant of FV like Somewhat Homomorphic Encryption\n   * Schemes. Cryptology ePrint Archive: Report 2016/510.\n   * (https://eprint.iacr.org/2016/510)\n   *\n   * @param &amp;moduliQ moduli {q_1,...,q_l}\n   * @param &amp;t often corresponds to the plaintext modulus\n   * @param &amp;tgamma t * gamma : t * 2^26 reduction\n   * @param &amp;tgammaQHatModq [t*gamma*(Q/q_i)]_{q_i}\n   * @param &amp;tgammaQHatModqPrecon NTL-specific precomputations\n   * @param &amp;negInvqModtgamma [-q^{-1}]_{t*gamma}\n   * @param &amp;negInvqModtgammaPrecon NTL-specific precomputations\n   * @return\n   */\n    virtual TowerType ScaleAndRound(const std::vector&lt;NativeInteger&gt;&amp; moduliQ, const NativeInteger&amp; t,\n                                    const NativeInteger&amp; tgamma, const std::vector&lt;NativeInteger&gt;&amp; tgammaQHatModq,\n                                    const std::vector&lt;NativeInteger&gt;&amp; tgammaQHatModqPrecon,\n                                    const std::vector&lt;NativeInteger&gt;&amp; negInvqModtgamma,\n                                    const std::vector&lt;NativeInteger&gt;&amp; negInvqModtgammaPrecon) const = 0;\n\n    /**\n   * @brief Computes scale and round for BFV encryption mode EXTENDED:\n   * {X}_{Qp} -&gt; {\\round(1/p * X)}_Q\n   * {Q} = {q_1,...,q_l}\n   *\n   * Source: Andrey Kim and Yuriy Polyakov and Vincent Zucca. Revisiting Homomorphic Encryption\n   * Schemes for Finite Fields. Cryptology ePrint Archive: Report 2021/204.\n   * (https://eprint.iacr.org/2021/204.pdf)\n   *\n   * @param &amp;paramsQ Parameters for moduli {q_1,...,q_l}\n   * @param &amp;pInvModq p^{-1}_{q_i}\n   * @return\n   */\n    virtual void ScaleAndRoundPOverQ(const std::shared_ptr&lt;Params&gt;&amp; paramsQ,\n                                     const std::vector&lt;NativeInteger&gt;&amp; pInvModq) = 0;\n\n    /**\n   * @brief Expands basis:\n   * {X}_{Q} -&gt; {X}_{Q,Bsk,mtilde}\n   * mtilde is a redundant modulus used to remove q overflows generated from\n   * fast conversion. Outputs the resulting polynomial in CRT/RNS\n   * {Q} = {q_1,...,q_l}\n   * {Bsk} = {bsk_1,...,bsk_k}\n   *\n   *\n   * Source: Jean-Claude Bajard and Julien Eynard and Anwar Hasan and Vincent\n   * Zucca. A Full RNS Variant of FV like Somewhat Homomorphic Encryption\n   * Schemes. Cryptology ePrint Archive: Report 2016/510.\n   * (https://eprint.iacr.org/2016/510)\n   *\n   * @param paramsQBsk: container of QBsk moduli and roots on unity\n   * @param &amp;moduliQ: basis {Q} = {q_1,q_2,...,q_l}\n   * @param &amp;moduliBsk: basis {Bsk U mtilde} ...\n   * @param &amp;modbskBarrettMu: 128-bit Barrett reduction precomputed values for\n   * bsk_j\n   * @param &amp;mtildeQHatInvModq: [mtilde*(Q/q_i)^{-1}]_{q_i}\n   * @param &amp;mtildeQHatInvModqPrecon NTL-specific precomputations\n   * @param &amp;QHatModbsk: [Q/q_i]_{bsk_j}\n   * @param &amp;QHatModmtilde: [Q/q_i]_{mtilde}\n   * @param &amp;QModbsk: [Q]_{bsk_j}\n   * @param &amp;QModbskPrecon NTL-specific precomputations\n   * @param &amp;negQInvModmtilde: [-Q^{-1}]_{mtilde}\n   * @param &amp;mtildeInvModbsk: [mtilde^{-1}]_{bsk_j}\n   * @param &amp;mtildeInvModbskPrecon NTL-specific precomputations\n   */\n    virtual void FastBaseConvqToBskMontgomery(\n        const std::shared_ptr&lt;Params&gt;&amp; paramsQBsk, const std::vector&lt;NativeInteger&gt;&amp; moduliQ,\n        const std::vector&lt;NativeInteger&gt;&amp; moduliBsk, const std::vector&lt;DoubleNativeInt&gt;&amp; modbskBarrettMu,\n        const std::vector&lt;NativeInteger&gt;&amp; mtildeQHatInvModq, const std::vector&lt;NativeInteger&gt;&amp; mtildeQHatInvModqPrecon,\n        const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; QHatModbsk, const std::vector&lt;uint64_t&gt;&amp; QHatModmtilde,\n        const std::vector&lt;NativeInteger&gt;&amp; QModbsk, const std::vector&lt;NativeInteger&gt;&amp; QModbskPrecon,\n        const uint64_t&amp; negQInvModmtilde, const std::vector&lt;NativeInteger&gt;&amp; mtildeInvModbsk,\n        const std::vector&lt;NativeInteger&gt;&amp; mtildeInvModbskPrecon) = 0;\n\n    /**\n   * @brief Computes scale and floor:\n   * {X}_{Q,Bsk} -&gt; {\\floor{t/Q * X}}_{Bsk}\n   * {Q} = {q_1,...,q_l}\n   * {Bsk} = {bsk_1,...,bsk_k}\n   * Outputs the resulting polynomial in CRT/RNS\n   *\n   * Source: Jean-Claude Bajard and Julien Eynard and Anwar Hasan and Vincent\n   * Zucca. A Full RNS Variant of FV like Somewhat Homomorphic Encryption\n   * Schemes. Cryptology ePrint Archive: Report 2016/510.\n   * (https://eprint.iacr.org/2016/510)\n   *\n   * @param &amp;t: plaintext modulus\n   * @param &amp;moduliQ: {Q} = {q_1,...,q_l}\n   * @param &amp;moduliBsk: {Bsk} = {bsk_1,...,bsk_k}\n   * @param &amp;modbskBarrettMu: 128-bit Barrett reduction precomputed values for\n   * bsk_j\n   * @param &amp;tQHatInvModq: [(Q/q_i)^{-1}]_{q_i}\n   * @param &amp;tQHatInvModqPrecon: NTL-specific precomputations\n   * @param &amp;QHatModbsk: [Q/q_i]_{bsk_i}\n   * @param &amp;qInvModbsk: [(q_i)^{-1}]_{bsk_j}\n   * @param &amp;tQInvModbsk: [t*Q^{-1}]_{bsk_j}\n   * @param &amp;tQInvModbskPrecon: NTL-specific precomputations\n   */\n    virtual void FastRNSFloorq(\n        const NativeInteger&amp; t, const std::vector&lt;NativeInteger&gt;&amp; moduliQ, const std::vector&lt;NativeInteger&gt;&amp; moduliBsk,\n        const std::vector&lt;DoubleNativeInt&gt;&amp; modbskBarrettMu, const std::vector&lt;NativeInteger&gt;&amp; tQHatInvModq,\n        const std::vector&lt;NativeInteger&gt;&amp; tQHatInvModqPrecon, const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; QHatModbsk,\n        const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; qInvModbsk, const std::vector&lt;NativeInteger&gt;&amp; tQInvModbsk,\n        const std::vector&lt;NativeInteger&gt;&amp; tQInvModbskPrecon) = 0;\n\n    /**\n   * @brief @brief Converts basis:\n   * {X}_{Q,Bsk} -&gt; {X}_{Bsk}\n   * {Q} = {q_1,...,q_l}\n   * {Bsk} = {bsk_1,...,bsk_k}\n   * using Shenoy Kumaresan method.\n   * Outputs the resulting polynomial in CRT/RNS\n   *\n   * Source: Jean-Claude Bajard and Julien Eynard and Anwar Hasan and Vincent\n   * Zucca. A Full RNS Variant of FV like Somewhat Homomorphic Encryption\n   * Schemes. Cryptology ePrint Archive: Report 2016/510.\n   * (https://eprint.iacr.org/2016/510)\n   *\n   * Note in the source paper, B is referred to by M.\n   *\n   * @param &amp;paramsQ: Params for Q\n   * @param &amp;modqBarrettMu precomputed Barrett Mu for q_i\n   * @param &amp;moduliBsk: basis {Bsk} = {bsk_1,...,bsk_k}\n   * @param &amp;modbskBarrettMu: precomputed Barrett Mu for bsk_j\n   * @param &amp;BHatInvModb: [(B/b_j)^{-1}]_{b_j}\n   * @param &amp;BHatInvModbPrecon NTL precomptations for [(B/b_j)^{-1}]_{b_j}\n   * @param &amp;BHatModmsk: [B/b_j]_{msk}\n   * @param &amp;BInvModmsk: [B^{-1}]_{msk}\n   * @param &amp;BInvModmskPrecon NTL precomptation for [B^{-1}]_{msk}\n   * @param &amp;BHatModq: [B/b_j]_{q_i}\n   * @param &amp;BModq: [B]_{q_i}\n   * @param &amp;BModqPrecon NTL precomptations for [B]_{q_i}\n   */\n    virtual void FastBaseConvSK(\n        const std::shared_ptr&lt;Params&gt;&amp; paramsQ, const std::vector&lt;DoubleNativeInt&gt;&amp; modqBarrettMu,\n        const std::vector&lt;NativeInteger&gt;&amp; moduliBsk, const std::vector&lt;DoubleNativeInt&gt;&amp; modbskBarrettMu,\n        const std::vector&lt;NativeInteger&gt;&amp; BHatInvModb, const std::vector&lt;NativeInteger&gt;&amp; BHatInvModbPrecon,\n        const std::vector&lt;NativeInteger&gt;&amp; BHatModmsk, const NativeInteger&amp; BInvModmsk,\n        const NativeInteger&amp; BInvModmskPrecon, const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; BHatModq,\n        const std::vector&lt;NativeInteger&gt;&amp; BModq, const std::vector&lt;NativeInteger&gt;&amp; BModqPrecon) = 0;\n\n    /**\n   * @brief Convert from Coefficient to CRT or vice versa; calls FFT and inverse FFT.\n   *\n   * @warning use @see SetFormat(format) instead\n   */\n    void SwitchFormat() override = 0;\n\n    /**\n   * @brief Sets format to value without calling FFT. Only use if you know what you&#x27;re doing.\n   *\n   */\n    virtual void OverrideFormat(const Format f) = 0;\n\n    /**\n   * @brief Switch modulus and adjust the values\n   *\n   * @param &amp;modulus is the modulus to be set\n   * @param &amp;rootOfUnity is the corresponding root of unity for the modulus\n   * @param &amp;modulusArb is the modulus used for arbitrary cyclotomics CRT\n   * @param &amp;rootOfUnityArb is the corresponding root of unity for the modulus\n   * ASSUMPTION: This method assumes that the caller provides the correct\n   * rootOfUnity for the modulus\n   */\n    void SwitchModulus(const BigIntType&amp; modulus, const BigIntType&amp; rootOfUnity, const BigIntType&amp; modulusArb,\n                       const BigIntType&amp; rootOfUnityArb) final {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;SwitchModulus not implemented on DCRTPoly&quot;);\n    }\n\n    /**\n   * @brief Switch modulus at tower i and adjust the values\n   *\n   * @param index is the index for the tower\n   * @param &amp;modulus is the modulus to be set\n   * @param &amp;rootOfUnity is the corresponding root of unity for the modulus\n   * ASSUMPTION: This method assumes that the caller provides the correct\n   * rootOfUnity for the modulus\n   */\n    virtual void SwitchModulusAtIndex(size_t index, const BigIntType&amp; modulus, const BigIntType&amp; rootOfUnity) = 0;\n\n    /**\n   * @brief Determines if inverse exists\n   *\n   * @return is the Boolean representation of the existence of multiplicative\n   * inverse.\n   */\n    bool InverseExists() const override = 0;\n\n    /**\n   * @brief Returns the infinity norm, basically the largest value in the ring\n   * element.\n   *\n   * @return is the largest value in the ring element.\n   */\n    //    virtual double Norm() const override = 0;\n    double Norm() const final {\n        return PolyLargeType(this-&gt;GetDerived().CRTInterpolate()).Norm();\n    }\n\n    const std::string GetElementName() const {\n        return this-&gt;GetDerived().GetElementName();\n    }\n\nprotected:\n    /**\n   * @brief ostream operator\n   * @param os the input preceding output stream\n   * @param vec the element to add to the output stream.\n   * @return a resulting concatenated output stream\n   */\n    friend inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const DerivedType&amp; vec) {\n        // os &lt;&lt; (vec.m_format == EVALUATION ? &quot;EVAL: &quot; : &quot;COEF: &quot;);\n        for (usint i = 0; i &lt; vec.GetAllElements().size(); i++) {\n            if (i != 0)\n                os &lt;&lt; std::endl;\n            os &lt;&lt; i &lt;&lt; &quot;: &quot;;\n            os &lt;&lt; vec.GetAllElements()[i];\n        }\n        return os;\n    }\n\n    /**\n   * @brief Element-element addition operator.\n   * @param a first element to add.\n   * @param b second element to add.\n   * @return the result of the addition operation.\n   */\n    friend inline DerivedType operator+(const DerivedType&amp; a, const DerivedType&amp; b) {\n        return a.Plus(b);\n    }\n    /**\n   * @brief Element-integer addition operator.\n   * @param a first element to add.\n   * @param b integer to add.\n   * @return the result of the addition operation.\n   */\n    friend inline DerivedType operator+(const DerivedType&amp; a, const BigIntType&amp; b) {\n        return a.Plus(b);\n    }\n\n    /**\n   * @brief BigIntType-element addition operator.\n   * @param a integer to add.\n   * @param b element to add.\n   * @return the result of the addition operation.\n   */\n    friend inline DerivedType operator+(const BigIntType&amp; a, const DerivedType&amp; b) {\n        return b.Plus(a);\n    }\n\n    /**\n   * @brief Element-integer addition operator with CRT integer.\n   * @param a first element to add.\n   * @param b integer to add.\n   * @return the result of the addition operation.\n   */\n    friend inline DerivedType operator+(const DerivedType&amp; a, const std::vector&lt;BigIntType&gt;&amp; b) {\n        return a.Plus(b);\n    }\n\n    /**\n   * @brief BigIntType-element addition operator with CRT integer.\n   * @param a integer to add.\n   * @param b element to add.\n   * @return the result of the addition operation.\n   */\n    friend inline DerivedType operator+(const std::vector&lt;BigIntType&gt;&amp; a, const DerivedType&amp; b) {\n        return b.Plus(a);\n    }\n\n    /**\n   * @brief Element-element subtraction operator.\n   * @param a element to subtract from.\n   * @param b element to subtract.\n   * @return the result of the subtraction operation.\n   */\n    friend inline DerivedType operator-(const DerivedType&amp; a, const DerivedType&amp; b) {\n        return a.Minus(b);\n    }\n\n    /**\n   * @brief Element-integer subtraction operator with CRT integer.\n   * @param a first element to subtract.\n   * @param b integer to subtract.\n   * @return the result of the subtraction operation.\n   */\n    friend inline DerivedType operator-(const DerivedType&amp; a, const std::vector&lt;BigIntType&gt;&amp; b) {\n        return a.Minus(b);\n    }\n\n    /**\n   * @brief BigIntType-element subtraction operator with CRT integer.\n   * @param a integer to subtract.\n   * @param b element to subtract.\n   * @return the result of the subtraction operation.\n   */\n    friend inline DerivedType operator-(const std::vector&lt;BigIntType&gt;&amp; a, const DerivedType&amp; b) {\n        return b.Minus(a);\n    }\n\n    /**\n   * @brief Element-integer subtraction operator.\n   * @param a element to subtract from.\n   * @param b integer to subtract.\n   * @return the result of the subtraction operation.\n   */\n    friend inline DerivedType operator-(const DerivedType&amp; a, const BigIntType&amp; b) {\n        return a.Minus(b);\n    }\n\n    /**\n   * @brief Element-element multiplication operator.\n   * @param a element to multiply.\n   * @param b element to multiply.\n   * @return the result of the multiplication operation.\n   */\n    friend inline DerivedType operator*(const DerivedType&amp; a, const DerivedType&amp; b) {\n        return a.Times(b);\n    }\n\n    /**\n   * @brief Element-integer multiplication operator.\n   * @param a element to multiply.\n   * @param b integer to multiply.\n   * @return the result of the multiplication operation.\n   */\n    friend inline DerivedType operator*(const DerivedType&amp; a, const BigIntType&amp; b) {\n        return a.Times(b);\n    }\n\n    /**\n   * @brief Element-CRT number multiplication operator.\n   * @param a element to multiply.\n   * @param b integer to multiply, in CRT format.\n   * @return the result of the multiplication operation.\n   */\n    friend inline DerivedType operator*(const DerivedType&amp; a, const std::vector&lt;BigIntType&gt;&amp; b) {\n        return a.Times(b);\n    }\n\n    /**\n   * @brief BigIntType-element multiplication operator.\n   * @param a integer to multiply.\n   * @param b element to multiply.\n   * @return the result of the multiplication operation.\n   */\n    friend inline DerivedType operator*(const BigIntType&amp; a, const DerivedType&amp; b) {\n        return b.Times(a);\n    }\n\n    /**\n   * @brief Element-signed-integer multiplication operator.\n   * @param a element to multiply.\n   * @param b integer to multiply.\n   * @return the result of the multiplication operation.\n   */\n    friend inline DerivedType operator*(const DerivedType&amp; a, int64_t b) {\n        return a.Times((NativeInteger::SignedNativeInt)b);\n    }\n\n    /**\n   * @brief signed-BigIntType-element multiplication operator.\n   * @param a integer to multiply.\n   * @param b element to multiply.\n   * @return the result of the multiplication operation.\n   */\n    friend inline DerivedType operator*(int64_t a, const DerivedType&amp; b) {\n        return b.Times((NativeInteger::SignedNativeInt)a);\n    }\n};\n\n}  // namespace lbcrypto\n\n#endif  // LBCRYPTO_LATTICE_HAL_DCRTPOLYINTERFACE_H\n"}, "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/dcrtpoly.h": {"id": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/dcrtpoly.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/dcrtpoly.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2023, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Represents integer lattice elements with double-CRT\n */\n\n#ifndef LBCRYPTO_INC_LATTICE_HAL_DEFAULT_DCRTPOLY_H\n#define LBCRYPTO_INC_LATTICE_HAL_DEFAULT_DCRTPOLY_H\n\n#include &quot;lattice/hal/default/poly.h&quot;\n#include &quot;lattice/hal/dcrtpoly-interface.h&quot;\n#include &quot;lattice/ildcrtparams.h&quot;\n\n#include &quot;math/math-hal.h&quot;\n#include &quot;math/distrgen.h&quot;\n\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/inttypes.h&quot;\n#include &quot;utils/parallel.h&quot;\n\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\nnamespace lbcrypto {\n\ntemplate &lt;typename VecType&gt;\nclass DCRTPolyImpl final : public DCRTPolyInterface&lt;DCRTPolyImpl&lt;VecType&gt;, VecType, NativeVector, PolyImpl&gt; {\npublic:\n    using Vector                = VecType;\n    using Integer               = typename VecType::Integer;\n    using Params                = ILDCRTParams&lt;Integer&gt;;\n    using PolyType              = PolyImpl&lt;NativeVector&gt;;\n    using PolyLargeType         = PolyImpl&lt;VecType&gt;;\n    using DCRTPolyType          = DCRTPolyImpl&lt;VecType&gt;;\n    using DCRTPolyInterfaceType = DCRTPolyInterface&lt;DCRTPolyImpl&lt;VecType&gt;, VecType, NativeVector, PolyImpl&gt;;\n    using Precomputations       = typename DCRTPolyInterfaceType::CRTBasisExtensionPrecomputations;\n    using DggType               = typename DCRTPolyInterfaceType::DggType;\n    using DugType               = typename DCRTPolyInterfaceType::DugType;\n    using TugType               = typename DCRTPolyInterfaceType::TugType;\n    using BugType               = typename DCRTPolyInterfaceType::BugType;\n\n    DCRTPolyImpl() = default;\n\n    DCRTPolyImpl(const DCRTPolyType&amp; e) noexcept : m_params{e.m_params}, m_format{e.m_format}, m_vectors{e.m_vectors} {}\n    DCRTPolyType&amp; operator=(const DCRTPolyType&amp; rhs) noexcept override {\n        m_params  = rhs.m_params;\n        m_format  = rhs.m_format;\n        m_vectors = rhs.m_vectors;\n        return *this;\n    }\n\n    DCRTPolyImpl(const PolyLargeType&amp; e, const std::shared_ptr&lt;Params&gt;&amp; params) noexcept;\n    DCRTPolyType&amp; operator=(const PolyLargeType&amp; rhs) noexcept;\n\n    DCRTPolyImpl(const PolyType&amp; e, const std::shared_ptr&lt;Params&gt;&amp; params) noexcept;\n    DCRTPolyType&amp; operator=(const PolyType&amp; rhs) noexcept;\n\n    DCRTPolyImpl(DCRTPolyType&amp;&amp; e) noexcept\n        : m_params{std::move(e.m_params)}, m_format{e.m_format}, m_vectors{std::move(e.m_vectors)} {}\n    DCRTPolyType&amp; operator=(DCRTPolyType&amp;&amp; rhs) noexcept override {\n        m_params  = std::move(rhs.m_params);\n        m_format  = std::move(rhs.m_format);\n        m_vectors = std::move(rhs.m_vectors);\n        return *this;\n    }\n\n    explicit DCRTPolyImpl(const std::vector&lt;PolyType&gt;&amp; elements);\n\n    DCRTPolyImpl(const std::shared_ptr&lt;Params&gt;&amp; params, Format format = Format::EVALUATION,\n                 bool initializeElementToZero = false) noexcept\n        : m_params{params}, m_format{format} {\n        m_vectors.reserve(m_params-&gt;GetParams().size());\n        for (const auto&amp; p : m_params-&gt;GetParams())\n            m_vectors.emplace_back(p, m_format, initializeElementToZero);\n    }\n\n    DCRTPolyImpl(const DggType&amp; dgg, const std::shared_ptr&lt;Params&gt;&amp; p, Format f = Format::EVALUATION);\n    DCRTPolyImpl(const BugType&amp; bug, const std::shared_ptr&lt;Params&gt;&amp; p, Format f = Format::EVALUATION);\n    DCRTPolyImpl(const TugType&amp; tug, const std::shared_ptr&lt;Params&gt;&amp; p, Format f = Format::EVALUATION, uint32_t h = 0);\n    DCRTPolyImpl(DugType&amp; dug, const std::shared_ptr&lt;Params&gt;&amp; p, Format f = Format::EVALUATION);\n\n    DCRTPolyType&amp; operator=(std::initializer_list&lt;uint64_t&gt; rhs) noexcept override;\n    DCRTPolyType&amp; operator=(uint64_t val) noexcept;\n    DCRTPolyType&amp; operator=(const std::vector&lt;int64_t&gt;&amp; rhs) noexcept;\n    DCRTPolyType&amp; operator=(const std::vector&lt;int32_t&gt;&amp; rhs) noexcept;\n    DCRTPolyType&amp; operator=(std::initializer_list&lt;std::string&gt; rhs) noexcept;\n\n    DCRTPolyType CloneWithNoise(const DiscreteGaussianGeneratorImpl&lt;VecType&gt;&amp; dgg, Format format) const override;\n    DCRTPolyType CloneTowers(uint32_t startTower, uint32_t endTower) const;\n\n    Integer&amp; at(usint i) override;\n    const Integer&amp; at(usint i) const override;\n    Integer&amp; operator[](usint i) override {\n        return DCRTPolyType::CRTInterpolateIndex(i)[i];\n    }\n    const Integer&amp; operator[](usint i) const override {\n        return DCRTPolyType::CRTInterpolateIndex(i)[i];\n    }\n\n    bool operator==(const DCRTPolyType&amp; rhs) const override;\n\n    DCRTPolyType&amp; operator+=(const DCRTPolyType&amp; rhs) override;\n    DCRTPolyType&amp; operator+=(const Integer&amp; rhs) override;\n    DCRTPolyType&amp; operator+=(const NativeInteger&amp; rhs) override;\n    DCRTPolyType&amp; operator-=(const DCRTPolyType&amp; rhs) override;\n    DCRTPolyType&amp; operator-=(const Integer&amp; rhs) override;\n    DCRTPolyType&amp; operator-=(const NativeInteger&amp; rhs) override;\n    DCRTPolyType&amp; operator*=(const DCRTPolyType&amp; rhs) override {\n        size_t size{m_vectors.size()};\n#pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))\n        for (size_t i = 0; i &lt; size; ++i)\n            m_vectors[i] *= rhs.m_vectors[i];\n        return *this;\n    }\n    DCRTPolyType&amp; operator*=(const Integer&amp; rhs) override;\n    DCRTPolyType&amp; operator*=(const NativeInteger&amp; rhs) override;\n\n    DCRTPolyType Negate() const override;\n    DCRTPolyType operator-() const override;\n\n    std::vector&lt;DCRTPolyType&gt; BaseDecompose(usint baseBits, bool evalModeAnswer) const override;\n    std::vector&lt;DCRTPolyType&gt; PowersOfBase(usint baseBits) const override;\n    std::vector&lt;DCRTPolyType&gt; CRTDecompose(uint32_t baseBits) const;\n\n    DCRTPolyType AutomorphismTransform(uint32_t i) const override;\n    DCRTPolyType AutomorphismTransform(uint32_t i, const std::vector&lt;uint32_t&gt;&amp; vec) const override;\n\n    DCRTPolyType Plus(const Integer&amp; rhs) const override;\n    DCRTPolyType Plus(const std::vector&lt;Integer&gt;&amp; rhs) const;\n    DCRTPolyType Plus(const DCRTPolyType&amp; rhs) const override {\n        if (m_params-&gt;GetRingDimension() != rhs.m_params-&gt;GetRingDimension())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;RingDimension missmatch&quot;);\n        if (m_format != rhs.m_format)\n            &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;Format missmatch&quot;);\n        size_t size{m_vectors.size()};\n        if (size != rhs.m_vectors.size())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;tower size mismatch; cannot add&quot;);\n        if (m_vectors[0].GetModulus() != rhs.m_vectors[0].GetModulus())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Modulus missmatch&quot;);\n        DCRTPolyType tmp(m_params, m_format);\n#pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))\n        for (size_t i = 0; i &lt; size; ++i)\n            tmp.m_vectors[i] = m_vectors[i].PlusNoCheck(rhs.m_vectors[i]);\n        return tmp;\n    }\n\n    DCRTPolyType Minus(const DCRTPolyType&amp; rhs) const override;\n    DCRTPolyType Minus(const Integer&amp; rhs) const override;\n    DCRTPolyType Minus(const std::vector&lt;Integer&gt;&amp; rhs) const;\n\n    DCRTPolyType Times(const DCRTPolyType&amp; rhs) const override {\n        if (m_params-&gt;GetRingDimension() != rhs.m_params-&gt;GetRingDimension())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;RingDimension missmatch&quot;);\n        if (m_format != Format::EVALUATION || rhs.m_format != Format::EVALUATION)\n            &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;operator* for DCRTPolyImpl supported only in Format::EVALUATION&quot;);\n        size_t size{m_vectors.size()};\n        if (size != rhs.m_vectors.size())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;tower size mismatch; cannot multiply&quot;);\n        if (m_vectors[0].GetModulus() != rhs.m_vectors[0].GetModulus())\n            &quot;hey&quot;; OPENFHE_THROW(math_error, &quot;Modulus missmatch&quot;);\n        DCRTPolyType tmp(m_params, m_format);\n#pragma omp parallel for num_threads(OpenFHEParallelControls.GetThreadLimit(size))\n        for (size_t i = 0; i &lt; size; ++i)\n            tmp.m_vectors[i] = m_vectors[i].TimesNoCheck(rhs.m_vectors[i]);\n        return tmp;\n    }\n    DCRTPolyType Times(const Integer&amp; rhs) const override;\n    DCRTPolyType Times(const std::vector&lt;Integer&gt;&amp; rhs) const;\n    DCRTPolyType Times(NativeInteger::SignedNativeInt rhs) const override;\n#if NATIVEINT != 64\n    DCRTPolyType Times(int64_t rhs) const {\n        return Times(static_cast&lt;NativeInteger::SignedNativeInt&gt;(rhs));\n    }\n#endif\n    DCRTPolyType Times(const std::vector&lt;NativeInteger&gt;&amp; rhs) const;\n    DCRTPolyType TimesNoCheck(const std::vector&lt;NativeInteger&gt;&amp; rhs) const;\n\n    DCRTPolyType MultiplicativeInverse() const override;\n    bool InverseExists() const override;\n    bool IsEmpty() const override;\n\n    void SetValuesToZero() override;\n    void AddILElementOne() override;\n    void DropLastElement() override;\n    void DropLastElements(size_t i) override;\n    void DropLastElementAndScale(const std::vector&lt;NativeInteger&gt;&amp; QlQlInvModqlDivqlModq,\n                                 const std::vector&lt;NativeInteger&gt;&amp; QlQlInvModqlDivqlModqPrecon,\n                                 const std::vector&lt;NativeInteger&gt;&amp; qlInvModq,\n                                 const std::vector&lt;NativeInteger&gt;&amp; qlInvModqPrecon) override;\n\n    void ModReduce(const NativeInteger&amp; t, const std::vector&lt;NativeInteger&gt;&amp; tModqPrecon,\n                   const NativeInteger&amp; negtInvModq, const NativeInteger&amp; negtInvModqPrecon,\n                   const std::vector&lt;NativeInteger&gt;&amp; qlInvModq,\n                   const std::vector&lt;NativeInteger&gt;&amp; qlInvModqPrecon) override;\n\n    PolyLargeType CRTInterpolate() const override;\n    PolyType DecryptionCRTInterpolate(PlaintextModulus ptm) const override;\n    PolyType ToNativePoly() const override;\n    PolyLargeType CRTInterpolateIndex(usint i) const override;\n    Integer GetWorkingModulus() const override;\n\n    void SetValuesModSwitch(const DCRTPolyType&amp; element, const NativeInteger&amp; modulus) override;\n\n    std::shared_ptr&lt;Params&gt; GetExtendedCRTBasis(const std::shared_ptr&lt;Params&gt;&amp; paramsP) const override;\n\n    void TimesQovert(const std::shared_ptr&lt;Params&gt;&amp; paramsQ, const std::vector&lt;NativeInteger&gt;&amp; tInvModq,\n                     const NativeInteger&amp; t, const NativeInteger&amp; NegQModt,\n                     const NativeInteger&amp; NegQModtPrecon) override;\n\n    DCRTPolyType ApproxSwitchCRTBasis(const std::shared_ptr&lt;Params&gt;&amp; paramsQ, const std::shared_ptr&lt;Params&gt;&amp; paramsP,\n                                      const std::vector&lt;NativeInteger&gt;&amp; QHatInvModq,\n                                      const std::vector&lt;NativeInteger&gt;&amp; QHatInvModqPrecon,\n                                      const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; QHatModp,\n                                      const std::vector&lt;DoubleNativeInt&gt;&amp; modpBarrettMu) const override;\n\n    void ApproxModUp(const std::shared_ptr&lt;Params&gt;&amp; paramsQ, const std::shared_ptr&lt;Params&gt;&amp; paramsP,\n                     const std::shared_ptr&lt;Params&gt;&amp; paramsQP, const std::vector&lt;NativeInteger&gt;&amp; QHatInvModq,\n                     const std::vector&lt;NativeInteger&gt;&amp; QHatInvModqPrecon,\n                     const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; QHatModp,\n                     const std::vector&lt;DoubleNativeInt&gt;&amp; modpBarrettMu) override;\n\n    DCRTPolyType ApproxModDown(\n        const std::shared_ptr&lt;Params&gt;&amp; paramsQ, const std::shared_ptr&lt;Params&gt;&amp; paramsP,\n        const std::vector&lt;NativeInteger&gt;&amp; PInvModq, const std::vector&lt;NativeInteger&gt;&amp; PInvModqPrecon,\n        const std::vector&lt;NativeInteger&gt;&amp; PHatInvModp, const std::vector&lt;NativeInteger&gt;&amp; PHatInvModpPrecon,\n        const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; PHatModq, const std::vector&lt;DoubleNativeInt&gt;&amp; modqBarrettMu,\n        const std::vector&lt;NativeInteger&gt;&amp; tInvModp, const std::vector&lt;NativeInteger&gt;&amp; tInvModpPrecon,\n        const NativeInteger&amp; t, const std::vector&lt;NativeInteger&gt;&amp; tModqPrecon) const override;\n\n    DCRTPolyType SwitchCRTBasis(const std::shared_ptr&lt;Params&gt;&amp; paramsP, const std::vector&lt;NativeInteger&gt;&amp; QHatInvModq,\n                                const std::vector&lt;NativeInteger&gt;&amp; QHatInvModqPrecon,\n                                const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; QHatModp,\n                                const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; alphaQModp,\n                                const std::vector&lt;DoubleNativeInt&gt;&amp; modpBarrettMu,\n                                const std::vector&lt;double&gt;&amp; qInv) const override;\n\n    void ExpandCRTBasis(const std::shared_ptr&lt;Params&gt;&amp; paramsQP, const std::shared_ptr&lt;Params&gt;&amp; paramsP,\n                        const std::vector&lt;NativeInteger&gt;&amp; QHatInvModq,\n                        const std::vector&lt;NativeInteger&gt;&amp; QHatInvModqPrecon,\n                        const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; QHatModp,\n                        const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; alphaQModp,\n                        const std::vector&lt;DoubleNativeInt&gt;&amp; modpBarrettMu, const std::vector&lt;double&gt;&amp; qInv,\n                        Format resultFormat) override;\n\n    void ExpandCRTBasisReverseOrder(const std::shared_ptr&lt;Params&gt;&amp; paramsQP, const std::shared_ptr&lt;Params&gt;&amp; paramsP,\n                                    const std::vector&lt;NativeInteger&gt;&amp; QHatInvModq,\n                                    const std::vector&lt;NativeInteger&gt;&amp; QHatInvModqPrecon,\n                                    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; QHatModp,\n                                    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; alphaQModp,\n                                    const std::vector&lt;DoubleNativeInt&gt;&amp; modpBarrettMu, const std::vector&lt;double&gt;&amp; qInv,\n                                    Format resultFormat) override;\n\n    void FastExpandCRTBasisPloverQ(const Precomputations&amp; precomputed) override;\n\n    void ExpandCRTBasisQlHat(const std::shared_ptr&lt;Params&gt;&amp; paramsQ, const std::vector&lt;NativeInteger&gt;&amp; QlHatModq,\n                             const std::vector&lt;NativeInteger&gt;&amp; QlHatModqPrecon, const usint sizeQ) override;\n\n    PolyType ScaleAndRound(const NativeInteger&amp; t, const std::vector&lt;NativeInteger&gt;&amp; tQHatInvModqDivqModt,\n                           const std::vector&lt;NativeInteger&gt;&amp; tQHatInvModqDivqModtPrecon,\n                           const std::vector&lt;NativeInteger&gt;&amp; tQHatInvModqBDivqModt,\n                           const std::vector&lt;NativeInteger&gt;&amp; tQHatInvModqBDivqModtPrecon,\n                           const std::vector&lt;double&gt;&amp; tQHatInvModqDivqFrac,\n                           const std::vector&lt;double&gt;&amp; tQHatInvModqBDivqFrac) const override;\n\n    DCRTPolyType ApproxScaleAndRound(const std::shared_ptr&lt;Params&gt;&amp; paramsP,\n                                     const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; tPSHatInvModsDivsModp,\n                                     const std::vector&lt;DoubleNativeInt&gt;&amp; modpBarretMu) const override;\n\n    DCRTPolyType ScaleAndRound(const std::shared_ptr&lt;Params&gt;&amp; paramsOutput,\n                               const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; tOSHatInvModsDivsModo,\n                               const std::vector&lt;double&gt;&amp; tOSHatInvModsDivsFrac,\n                               const std::vector&lt;DoubleNativeInt&gt;&amp; modoBarretMu) const override;\n\n    PolyType ScaleAndRound(const std::vector&lt;NativeInteger&gt;&amp; moduliQ, const NativeInteger&amp; t,\n                           const NativeInteger&amp; tgamma, const std::vector&lt;NativeInteger&gt;&amp; tgammaQHatModq,\n                           const std::vector&lt;NativeInteger&gt;&amp; tgammaQHatModqPrecon,\n                           const std::vector&lt;NativeInteger&gt;&amp; negInvqModtgamma,\n                           const std::vector&lt;NativeInteger&gt;&amp; negInvqModtgammaPrecon) const override;\n\n    void ScaleAndRoundPOverQ(const std::shared_ptr&lt;Params&gt;&amp; paramsQ,\n                             const std::vector&lt;NativeInteger&gt;&amp; pInvModq) override;\n\n    void FastBaseConvqToBskMontgomery(\n        const std::shared_ptr&lt;Params&gt;&amp; paramsQBsk, const std::vector&lt;NativeInteger&gt;&amp; moduliQ,\n        const std::vector&lt;NativeInteger&gt;&amp; moduliBsk, const std::vector&lt;DoubleNativeInt&gt;&amp; modbskBarrettMu,\n        const std::vector&lt;NativeInteger&gt;&amp; mtildeQHatInvModq, const std::vector&lt;NativeInteger&gt;&amp; mtildeQHatInvModqPrecon,\n        const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; QHatModbsk, const std::vector&lt;uint64_t&gt;&amp; QHatModmtilde,\n        const std::vector&lt;NativeInteger&gt;&amp; QModbsk, const std::vector&lt;NativeInteger&gt;&amp; QModbskPrecon,\n        const uint64_t&amp; negQInvModmtilde, const std::vector&lt;NativeInteger&gt;&amp; mtildeInvModbsk,\n        const std::vector&lt;NativeInteger&gt;&amp; mtildeInvModbskPrecon) override;\n\n    void FastRNSFloorq(const NativeInteger&amp; t, const std::vector&lt;NativeInteger&gt;&amp; moduliQ,\n                       const std::vector&lt;NativeInteger&gt;&amp; moduliBsk, const std::vector&lt;DoubleNativeInt&gt;&amp; modbskBarrettMu,\n                       const std::vector&lt;NativeInteger&gt;&amp; tQHatInvModq,\n                       const std::vector&lt;NativeInteger&gt;&amp; tQHatInvModqPrecon,\n                       const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; QHatModbsk,\n                       const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; qInvModbsk,\n                       const std::vector&lt;NativeInteger&gt;&amp; tQInvModbsk,\n                       const std::vector&lt;NativeInteger&gt;&amp; tQInvModbskPrecon) override;\n\n    void FastBaseConvSK(const std::shared_ptr&lt;Params&gt;&amp; paramsQ, const std::vector&lt;DoubleNativeInt&gt;&amp; modqBarrettMu,\n                        const std::vector&lt;NativeInteger&gt;&amp; moduliBsk,\n                        const std::vector&lt;DoubleNativeInt&gt;&amp; modbskBarrettMu,\n                        const std::vector&lt;NativeInteger&gt;&amp; BHatInvModb,\n                        const std::vector&lt;NativeInteger&gt;&amp; BHatInvModbPrecon,\n                        const std::vector&lt;NativeInteger&gt;&amp; BHatModmsk, const NativeInteger&amp; BInvModmsk,\n                        const NativeInteger&amp; BInvModmskPrecon, const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; BHatModq,\n                        const std::vector&lt;NativeInteger&gt;&amp; BModq,\n                        const std::vector&lt;NativeInteger&gt;&amp; BModqPrecon) override;\n\n    void SwitchFormat() override;\n\n    void SwitchModulusAtIndex(size_t index, const Integer&amp; modulus, const Integer&amp; rootOfUnity) override;\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::make_nvp(&quot;v&quot;, m_vectors));\n        ar(::cereal::make_nvp(&quot;f&quot;, m_format));\n        ar(::cereal::make_nvp(&quot;p&quot;, m_params));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                 &quot; is from a later version of the library&quot;);\n        }\n        ar(::cereal::make_nvp(&quot;v&quot;, m_vectors));\n        ar(::cereal::make_nvp(&quot;f&quot;, m_format));\n        ar(::cereal::make_nvp(&quot;p&quot;, m_params));\n    }\n\n    static const std::string GetElementName() {\n        return &quot;DCRTPolyImpl&quot;;\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;DCRTPoly&quot;;\n    }\n\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\n    inline Format GetFormat() const final {\n        return m_format;\n    }\n\n    void OverrideFormat(const Format f) final {\n        m_format = f;\n    }\n\n    inline const std::shared_ptr&lt;Params&gt;&amp; GetParams() const {\n        return m_params;\n    }\n\n    const std::vector&lt;PolyType&gt;&amp; GetAllElements() const {\n        return m_vectors;\n    }\n\n    std::vector&lt;PolyType&gt;&amp; GetAllElements() {\n        return m_vectors;\n    }\n\n    void SetElementAtIndex(usint index, const PolyType&amp; element) {\n        m_vectors[index] = element;\n    }\n\n    void SetElementAtIndex(usint index, PolyType&amp;&amp; element) {\n        m_vectors[index] = std::move(element);\n    }\n\nprotected:\n    std::shared_ptr&lt;Params&gt; m_params{std::make_shared&lt;DCRTPolyImpl::Params&gt;(0, 1)};\n    Format m_format{Format::EVALUATION};\n    std::vector&lt;PolyType&gt; m_vectors;\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\n  Represents and defines plaintext objects in OpenFHE\n */\n\n#ifndef LBCRYPTO_UTILS_PLAINTEXT_H\n#define LBCRYPTO_UTILS_PLAINTEXT_H\n\n#include &quot;encoding/plaintext-fwd.h&quot;\n\n#include &quot;encoding/encodingparams.h&quot;\n#include &quot;constants.h&quot;\n#include &quot;scheme/scheme-id.h&quot;\n\n#include &lt;initializer_list&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;utility&gt;\n\nnamespace lbcrypto {\n\n/**\n * @class PlaintextImpl\n * @brief This class represents plaintext in the OpenFHE library.\n *\n * PlaintextImpl is primarily intended to be\n * used as a container and in conjunction with specific encodings which inherit\n * from this class which depend on the application the plaintext is used with.\n * It provides virtual methods for encoding and decoding of data.\n */\nclass PlaintextImpl {\nprotected:\n    enum PtxtPolyType { IsPoly, IsDCRTPoly, IsNativePoly };\n\n    bool isEncoded;\n    PtxtPolyType typeFlag;\n    EncodingParams encodingParams;\n\n    mutable Poly encodedVector;\n    mutable NativePoly encodedNativeVector;\n    mutable DCRTPoly encodedVectorDCRT;\n\n    static constexpr int intCTOR     = 0x01;\n    static constexpr int vecintCTOR  = 0x02;\n    static constexpr int fracCTOR    = 0x04;\n    static constexpr int vecuintCTOR = 0x08;\n\n    double scalingFactor           = 1;\n    NativeInteger scalingFactorInt = 1;\n    size_t level                   = 0;\n    size_t noiseScaleDeg           = 1;\n    usint slots                    = 0;\n    SCHEME schemeID;\n\npublic:\n    PlaintextImpl(const std::shared_ptr&lt;Poly::Params&gt;&amp; vp, EncodingParams ep, SCHEME schemeTag = SCHEME::INVALID_SCHEME,\n                  bool isEncoded = false)\n        : isEncoded(isEncoded),\n          typeFlag(IsPoly),\n          encodingParams(std::move(ep)),\n          encodedVector(vp, Format::COEFFICIENT),\n          schemeID(schemeTag) {}\n\n    PlaintextImpl(const std::shared_ptr&lt;NativePoly::Params&gt;&amp; vp, EncodingParams ep, SCHEME schemeTag = SCHEME::INVALID_SCHEME,\n                  bool isEncoded = false)\n        : isEncoded(isEncoded),\n          typeFlag(IsNativePoly),\n          encodingParams(std::move(ep)),\n          encodedNativeVector(vp, Format::COEFFICIENT),\n          schemeID(schemeTag) {}\n\n    PlaintextImpl(const std::shared_ptr&lt;DCRTPoly::Params&gt;&amp; vp, EncodingParams ep, SCHEME schemeTag = SCHEME::INVALID_SCHEME,\n                  bool isEncoded = false)\n        : isEncoded(isEncoded),\n          typeFlag(IsDCRTPoly),\n          encodingParams(std::move(ep)),\n          encodedVector(vp, Format::COEFFICIENT),\n          encodedVectorDCRT(vp, Format::COEFFICIENT),\n          schemeID(schemeTag) {}\n\n    PlaintextImpl(const PlaintextImpl&amp; rhs)\n        : isEncoded(rhs.isEncoded),\n          typeFlag(rhs.typeFlag),\n          encodingParams(rhs.encodingParams),\n          encodedVector(rhs.encodedVector),\n          encodedVectorDCRT(rhs.encodedVectorDCRT),\n          scalingFactor(rhs.scalingFactor),\n          scalingFactorInt(rhs.scalingFactorInt),\n          level(rhs.level),\n          noiseScaleDeg(rhs.noiseScaleDeg),\n          slots(rhs.slots),\n          schemeID(rhs.schemeID) {}\n\n    PlaintextImpl(PlaintextImpl&amp;&amp; rhs)\n        : isEncoded(rhs.isEncoded),\n          typeFlag(rhs.typeFlag),\n          encodingParams(std::move(rhs.encodingParams)),\n          encodedVector(std::move(rhs.encodedVector)),\n          encodedVectorDCRT(std::move(rhs.encodedVectorDCRT)),\n          scalingFactor(rhs.scalingFactor),\n          scalingFactorInt(rhs.scalingFactorInt),\n          level(rhs.level),\n          noiseScaleDeg(rhs.noiseScaleDeg),\n          slots(rhs.slots),\n          schemeID(rhs.schemeID) {}\n\n    virtual ~PlaintextImpl() {}\n\n    /**\n   * GetEncodingType\n   * @return Encoding type used by this plaintext\n   */\n    virtual PlaintextEncodings GetEncodingType() const = 0;\n\n    /**\n   * Get the scaling factor of the plaintext for CKKS-based plaintexts.\n   */\n    double GetScalingFactor() const {\n        return scalingFactor;\n    }\n\n    /**\n   * Set the scaling factor of the plaintext for CKKS-based plaintexts.\n   */\n    void SetScalingFactor(double sf) {\n        scalingFactor = sf;\n    }\n\n    /**\n   * Get the scaling factor of the plaintext for BGV-based plaintexts.\n   */\n    const NativeInteger GetScalingFactorInt() const {\n        return scalingFactorInt;\n    }\n\n    /**\n   * Set the scaling factor of the plaintext for BGV-based plaintexts.\n   */\n    void SetScalingFactorInt(NativeInteger sf) {\n        scalingFactorInt = sf;\n    }\n\n    /**\n   * Get the encryption technique of the plaintext for BFV-based plaintexts.\n   */\n    SCHEME GetSchemeID() const {\n        return schemeID;\n    }\n\n    /**\n   * IsEncoded\n   * @return true when encoding is done\n   */\n    bool IsEncoded() const {\n        return isEncoded;\n    }\n\n    /**\n   * GetEncodingParams\n   * @return Encoding params used with this plaintext\n   */\n    const EncodingParams GetEncodingParams() const {\n        return encodingParams;\n    }\n\n    /**\n   * Encode the plaintext into a polynomial\n   * @return true on success\n   */\n    virtual bool Encode() = 0;\n\n    /**\n   * Decode the polynomial into the plaintext\n   * @return\n   */\n    virtual bool Decode() = 0;\n\n    /**\n   * Calculate and return lower bound that can be encoded with the plaintext\n   * modulus the number to encode MUST be greater than this value\n   * @return floor(-p/2)\n   */\n    int64_t LowBound() const {\n        uint64_t half = GetEncodingParams()-&gt;GetPlaintextModulus() &gt;&gt; 1;\n        bool odd      = (GetEncodingParams()-&gt;GetPlaintextModulus() &amp; 0x1) == 1;\n        int64_t bound = -1 * half;\n        if (odd)\n            bound--;\n        return bound;\n    }\n\n    /**\n   * Calculate and return upper bound that can be encoded with the plaintext\n   * modulus the number to encode MUST be less than or equal to this value\n   * @return floor(p/2)\n   */\n    int64_t HighBound() const {\n        return GetEncodingParams()-&gt;GetPlaintextModulus() &gt;&gt; 1;\n    }\n\n    /**\n   * SetFormat - allows format to be changed for PlaintextImpl evaluations\n   *\n   * @param fmt\n   */\n    void SetFormat(Format fmt) const {\n        if (typeFlag == IsPoly)\n            encodedVector.SetFormat(fmt);\n        else if (typeFlag == IsNativePoly)\n            encodedNativeVector.SetFormat(fmt);\n        else\n            encodedVectorDCRT.SetFormat(fmt);\n    }\n\n    /**\n   * GetElement\n   * @return the Polynomial that the element was encoded into\n   */\n    template &lt;typename Element&gt;\n    Element&amp; GetElement() {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;Generic GetElement() is not implemented&quot;);\n    }\n\n    template &lt;typename Element&gt;\n    const Element&amp; GetElement() const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;Generic GetElement() is not implemented&quot;);\n    }\n\n    /**\n   * GetElementRingDimension\n   * @return ring dimension on the underlying element\n   */\n    usint GetElementRingDimension() const {\n        return typeFlag == IsPoly ? encodedVector.GetRingDimension() :\n                                    (typeFlag == IsNativePoly ? encodedNativeVector.GetRingDimension() :\n                                                                encodedVectorDCRT.GetRingDimension());\n    }\n\n    /**\n   * GetElementModulus\n   * @return modulus on the underlying elemenbt\n   */\n    const BigInteger GetElementModulus() const {\n        return typeFlag == IsPoly ? encodedVector.GetModulus() :\n                                    (typeFlag == IsNativePoly ? BigInteger(encodedNativeVector.GetModulus()) :\n                                                                encodedVectorDCRT.GetModulus());\n    }\n\n    /**\n   * Get method to return the length of plaintext\n   *\n   * @return the length of the plaintext in terms of the number of bits.\n   */\n    virtual size_t GetLength() const = 0;\n\n    /**\n   * resize the plaintext; only works for plaintexts that support a resizable\n   * vector (coefpacked)\n   * @param newSize\n   */\n    virtual void SetLength(size_t newSize) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;resize not supported&quot;);\n    }\n\n    /*\n   * Method to get the degree of the scaling factor of a plaintext.\n   *\n   * @return the degree of the scaling factor of the plaintext\n   */\n    size_t GetNoiseScaleDeg() const {\n        return noiseScaleDeg;\n    }\n\n    /*\n   * Method to set the degree of the scaling factor of a plaintext.\n   */\n    void SetNoiseScaleDeg(size_t d) {\n        noiseScaleDeg = d;\n    }\n\n    /*\n   * Method to get the level of a plaintext.\n   *\n   * @return the level of the plaintext\n   */\n    size_t GetLevel() const {\n        return level;\n    }\n\n    /*\n   * Method to set the level of a plaintext.\n   */\n    void SetLevel(size_t l) {\n        level = l;\n    }\n\n    /*\n   * Method to get the level of a plaintext.\n   *\n   * @return the level of the plaintext\n   */\n    usint GetSlots() const {\n        return slots;\n    }\n\n    /*\n   * Method to set the level of a plaintext.\n   */\n    void SetSlots(usint l) {\n        slots = l;\n    }\n\n    virtual double GetLogError() const {\n        &quot;hey&quot;; OPENFHE_THROW(not_available_error, &quot;no estimate of noise available for the current scheme&quot;);\n    }\n\n    virtual double GetLogPrecision() const {\n        &quot;hey&quot;; OPENFHE_THROW(not_available_error, &quot;no estimate of precision available for the current scheme&quot;);\n    }\n\n    virtual const std::string&amp; GetStringValue() const {\n        &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;not a string&quot;);\n    }\n    virtual const std::vector&lt;int64_t&gt;&amp; GetCoefPackedValue() const {\n        &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;not a packed coefficient vector&quot;);\n    }\n    virtual const std::vector&lt;int64_t&gt;&amp; GetPackedValue() const {\n        &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;not a packed coefficient vector&quot;);\n    }\n    virtual const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; GetCKKSPackedValue() const {\n        &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;not a packed vector of complex numbers&quot;);\n    }\n    virtual const std::vector&lt;double&gt; GetRealPackedValue() const {\n        &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;not a packed vector of real numbers&quot;);\n    }\n    virtual void SetStringValue(const std::string&amp;) {\n        &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;does not support a string&quot;);\n    }\n    virtual void SetIntVectorValue(const std::vector&lt;int64_t&gt;&amp;) {\n        &quot;hey&quot;; OPENFHE_THROW(type_error, &quot;does not support an int vector&quot;);\n    }\n\n    /**\n   * Method to compare two plaintext to test for equivalence.\n   * This method is called by operator==\n   *\n   * @param other - the other plaintext to compare to.\n   * @return whether the two plaintext are equivalent.\n   */\n    virtual bool CompareTo(const PlaintextImpl&amp; other) const = 0;\n\n    /**\n   * operator== for plaintexts.  This method makes sure the plaintexts are of\n   * the same type.\n   *\n   * @param other - the other plaintext to compare to.\n   * @return whether the two plaintext are the same.\n   */\n    bool operator==(const PlaintextImpl&amp; other) const {\n        return CompareTo(other);\n    }\n\n    bool operator!=(const PlaintextImpl&amp; other) const {\n        return !(*this == other);\n    }\n\n    /**\n   * operator&lt;&lt; for ostream integration - calls PrintValue\n   * @param out\n   * @param item\n   * @return\n   */\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const PlaintextImpl&amp; item);\n\n    /**\n   * PrintValue is called by operator&lt;&lt;\n   * @param out\n   */\n    virtual void PrintValue(std::ostream&amp; out) const = 0;\n};\n\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const PlaintextImpl&amp; item) {\n    item.PrintValue(out);\n    return out;\n}\n\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Plaintext&amp; item) {\n    item-&gt;PrintValue(out);\n    return out;\n}\n\ninline bool operator==(const Plaintext&amp; p1, const Plaintext&amp; p2) {\n    return *p1 == *p2;\n}\n\ninline bool operator!=(const Plaintext&amp; p1, const Plaintext&amp; p2) {\n    return *p1 != *p2;\n}\n\n/**\n * GetElement\n * @return the Polynomial that the element was encoded into\n */\ntemplate &lt;&gt;\ninline const Poly&amp; PlaintextImpl::GetElement&lt;Poly&gt;() const {\n    return encodedVector;\n}\n\ntemplate &lt;&gt;\ninline Poly&amp; PlaintextImpl::GetElement&lt;Poly&gt;() {\n    return encodedVector;\n}\n\n/**\n * GetElement\n * @return the NativePolynomial that the element was encoded into\n */\ntemplate &lt;&gt;\ninline const NativePoly&amp; PlaintextImpl::GetElement&lt;NativePoly&gt;() const {\n    return encodedNativeVector;\n}\n\ntemplate &lt;&gt;\ninline NativePoly&amp; PlaintextImpl::GetElement&lt;NativePoly&gt;() {\n    return encodedNativeVector;\n}\n\n/**\n * GetElement\n * @return the DCRTPolynomial that the element was encoded into\n */\ntemplate &lt;&gt;\ninline const DCRTPoly&amp; PlaintextImpl::GetElement&lt;DCRTPoly&gt;() const {\n    return encodedVectorDCRT;\n}\n\ntemplate &lt;&gt;\ninline DCRTPoly&amp; PlaintextImpl::GetElement&lt;DCRTPoly&gt;() {\n    return encodedVectorDCRT;\n}\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_UTILS_CKKSPACKEDEXTENCODING_H\n#define LBCRYPTO_UTILS_CKKSPACKEDEXTENCODING_H\n\n#include &quot;constants.h&quot;\n\n#include &quot;encoding/encodingparams.h&quot;\n#include &quot;encoding/plaintext.h&quot;\n\n#include &quot;math/hal/basicint.h&quot;\n\n#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n#include &lt;initializer_list&gt;\n#include &lt;memory&gt;\n#include &lt;numeric&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\nnamespace lbcrypto {\n\n/**\n * @class CKKSPackedEncoding\n * @brief Type used for representing IntArray types.\n * Provides conversion functions to encode and decode plaintext data as type\n * vector&lt;uint64_t&gt;. This class uses bit packing techniques to enable efficient\n * computing on vectors of integers. It is NOT supported for DCRTPoly\n */\n\nclass CKKSPackedEncoding : public PlaintextImpl {\npublic:\n    // these two constructors are used inside of Decrypt\n    template &lt;typename T, typename std::enable_if&lt;std::is_same&lt;T, Poly::Params&gt;::value ||\n                                                      std::is_same&lt;T, NativePoly::Params&gt;::value ||\n                                                      std::is_same&lt;T, DCRTPoly::Params&gt;::value,\n                                                  bool&gt;::type = true&gt;\n    CKKSPackedEncoding(std::shared_ptr&lt;T&gt; vp, EncodingParams ep) : PlaintextImpl(vp, ep, CKKSRNS_SCHEME) {\n        this-&gt;slots = GetDefaultSlotSize();\n        if (this-&gt;slots &gt; (GetElementRingDimension() / 2)) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots cannot be larger than half of ring dimension&quot;);\n        }\n    }\n\n    /*\n   * @param noiseScaleDeg degree of the scaling factor of a plaintext\n   * @param level level of plaintext to create.\n   * @param scFact scaling factor of a plaintext of this level at depth 1.\n   *\n   */\n    template &lt;typename T, typename std::enable_if&lt;std::is_same&lt;T, Poly::Params&gt;::value ||\n                                                      std::is_same&lt;T, NativePoly::Params&gt;::value ||\n                                                      std::is_same&lt;T, DCRTPoly::Params&gt;::value,\n                                                  bool&gt;::type = true&gt;\n    CKKSPackedEncoding(std::shared_ptr&lt;T&gt; vp, EncodingParams ep, const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; coeffs,\n                       size_t noiseScaleDeg, uint32_t level, double scFact, size_t slots)\n        : PlaintextImpl(vp, ep, CKKSRNS_SCHEME), value(coeffs) {\n        // validate the number of slots\n        if ((slots &amp; (slots - 1)) != 0) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots should be a power of two&quot;);\n        }\n\n        this-&gt;slots = (slots) ? slots : GetDefaultSlotSize();\n\n        if (this-&gt;slots &lt; coeffs.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots cannot be smaller than value vector size&quot;);\n        }\n        else if (this-&gt;slots &gt; (GetElementRingDimension() / 2)) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots cannot be larger than half of ring dimension&quot;);\n        }\n\n        this-&gt;noiseScaleDeg = noiseScaleDeg;\n        this-&gt;level         = level;\n        this-&gt;scalingFactor = scFact;\n    }\n\n    /**\n   * @brief Constructs a container with a copy of each of the elements in rhs,\n   * in the same order.\n   * @param rhs - The input object to copy.\n   */\n    explicit CKKSPackedEncoding(const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; rhs, size_t slots)\n        : PlaintextImpl(std::shared_ptr&lt;Poly::Params&gt;(0), nullptr, CKKSRNS_SCHEME), value(rhs) {\n        // validate the number of slots\n        if ((slots &amp; (slots - 1)) != 0) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots should be a power of two&quot;);\n        }\n\n        this-&gt;slots = (slots) ? slots : GetDefaultSlotSize();\n\n        if (this-&gt;slots &lt; rhs.size()) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots cannot be smaller than value vector size&quot;);\n        }\n        else if (this-&gt;slots &gt; (GetElementRingDimension() / 2)) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots cannot be larger than half of ring dimension&quot;);\n        }\n    }\n\n    /**\n   * @brief Default empty constructor with empty uninitialized data elements.\n   */\n    CKKSPackedEncoding() : PlaintextImpl(std::shared_ptr&lt;Poly::Params&gt;(0), nullptr, CKKSRNS_SCHEME) {\n        this-&gt;slots = GetDefaultSlotSize();\n        if (this-&gt;slots &gt; (GetElementRingDimension() / 2)) {\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;The number of slots cannot be larger than half of ring dimension&quot;);\n        }\n    }\n\n    CKKSPackedEncoding(const CKKSPackedEncoding&amp; rhs)\n        : PlaintextImpl(rhs), value(rhs.value), m_logError(rhs.m_logError) {}\n\n    CKKSPackedEncoding(CKKSPackedEncoding&amp;&amp; rhs)\n        : PlaintextImpl(std::move(rhs)), value(std::move(rhs.value)), m_logError(rhs.m_logError) {}\n\n    bool Encode();\n\n    bool Decode() {\n        &quot;hey&quot;; OPENFHE_THROW(not_available_error,\n                      &quot;CKKSPackedEncoding::Decode() is not implemented. Use CKKSPackedEncoding::Decode(...) instead.&quot;);\n    }\n\n    bool Decode(size_t depth, double scalingFactor, ScalingTechnique scalTech, ExecutionMode executionMode);\n\n    const std::vector&lt;std::complex&lt;double&gt;&gt;&amp; GetCKKSPackedValue() const {\n        return value;\n    }\n\n    const std::vector&lt;double&gt; GetRealPackedValue() const {\n        std::vector&lt;double&gt; realValue(value.size());\n        std::transform(value.begin(), value.end(), realValue.begin(),\n                       [](std::complex&lt;double&gt; da) { return da.real(); });\n\n        return realValue;\n    }\n\n    /**\n   * Static utility method to multiply two numbers in CRT representation.\n   * CRT representation is stored in a vector of native integers, and each\n   * position corresponds to the remainder of the number against one of\n   * the moduli in mods.\n   *\n   * @param a is the first number in CRT representation.\n   * @param b is the second number in CRT representation.\n   * @return the product of the two numbers in CRT representation.\n   */\n    static std::vector&lt;DCRTPoly::Integer&gt; CRTMult(const std::vector&lt;DCRTPoly::Integer&gt;&amp; a,\n                                                  const std::vector&lt;DCRTPoly::Integer&gt;&amp; b,\n                                                  const std::vector&lt;DCRTPoly::Integer&gt;&amp; mods);\n\n    /**\n   * GetEncodingType\n   * @return CKKS_PACKED_ENCODING\n   */\n    PlaintextEncodings GetEncodingType() const {\n        return CKKS_PACKED_ENCODING;\n    }\n\n    /**\n   * Get method to return the length of plaintext\n   *\n   * @return the length of the plaintext in terms of the number of bits.\n   */\n    size_t GetLength() const {\n        return value.size();\n    }\n\n    /**\n   * Get method to return log2 of estimated standard deviation of approximation\n   * error\n   */\n    double GetLogError() const {\n        return m_logError;\n    }\n\n    /**\n   * Get method to return log2 of estimated precision\n   */\n    double GetLogPrecision() const {\n        return encodingParams-&gt;GetPlaintextModulus() - m_logError;\n    }\n\n    /**\n   * SetLength of the plaintext to the given size\n   * @param siz\n   */\n    void SetLength(size_t siz) {\n        value.resize(siz);\n    }\n\n    /**\n   * Method to compare two plaintext to test for equivalence.  This method does\n   * not test that the plaintext are of the same type.\n   *\n   * @param other - the other plaintext to compare to.\n   * @return whether the two plaintext are equivalent.\n   */\n    bool CompareTo(const PlaintextImpl&amp; other) const {\n        const auto&amp; rv = static_cast&lt;const CKKSPackedEncoding&amp;&gt;(other);\n        return this-&gt;value == rv.value;\n    }\n\n    /**\n   * @brief Destructor method.\n   */\n    static void Destroy();\n\n    void PrintValue(std::ostream&amp; out) const {\n        // for sanity&#x27;s sake, trailing zeros get elided into &quot;...&quot;\n        // out.precision(15);\n        out &lt;&lt; &quot;(&quot;;\n        size_t i = value.size();\n        while (--i &gt; 0)\n            if (value[i] != std::complex&lt;double&gt;(0, 0))\n                break;\n\n        for (size_t j = 0; j &lt;= i; j++) {\n            out &lt;&lt; value[j].real() &lt;&lt; &quot;, &quot;;\n        }\n\n        out &lt;&lt; &quot; ... ); &quot;;\n        out &lt;&lt; &quot;Estimated precision: &quot; &lt;&lt; encodingParams-&gt;GetPlaintextModulus() - m_logError &lt;&lt; &quot; bits&quot; &lt;&lt; std::endl;\n    }\n\nprivate:\n    std::vector&lt;std::complex&lt;double&gt;&gt; value;\n\n    double m_logError = 0;\n\nprotected:\n    usint GetDefaultSlotSize() {\n        auto batchSize = GetEncodingParams()-&gt;GetBatchSize();\n        return (0 == batchSize) ? GetElementRingDimension() / 2 : batchSize;\n    }\n    /**\n   * Set modulus and recalculates the vector values to fit the modulus\n   *\n   * @param &amp;vec input vector\n   * @param &amp;bigValue big bound of the vector values.\n   * @param &amp;modulus modulus to be set for vector.\n   */\n    void FitToNativeVector(const std::vector&lt;int64_t&gt;&amp; vec, int64_t bigBound, NativeVector* nativeVec) const;\n\n#if NATIVEINT == 128 &amp;&amp; !defined(__EMSCRIPTEN__)\n    /**\n   * Set modulus and recalculates the vector values to fit the modulus\n   *\n   * @param &amp;vec input vector\n   * @param &amp;bigValue big bound of the vector values.\n   * @param &amp;modulus modulus to be set for vector.\n   */\n    void FitToNativeVector(const std::vector&lt;int128_t&gt;&amp; vec, int128_t bigBound, NativeVector* nativeVec) const;\n#endif\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-parametergeneration.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-parametergeneration.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-parametergeneration.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_BASE_PARAMETERGENERATION_H\n#define LBCRYPTO_CRYPTO_BASE_PARAMETERGENERATION_H\n\n#include &quot;constants.h&quot;\n#include &quot;schemebase/base-cryptoparameters.h&quot;\n\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\n\n/**\n * @brief Abstract interface for parameter generation algorithm\n * @tparam Element a ring element.\n */\ntemplate &lt;class Element&gt;\nclass ParameterGenerationBase {\n    using ParmType = typename Element::Params;\n    using IntType  = typename Element::Integer;\n    using DugType  = typename Element::DugType;\n    using DggType  = typename Element::DggType;\n    using TugType  = typename Element::TugType;\n\npublic:\n    virtual ~ParameterGenerationBase() {}\n\n    /**\n   * Method for computing all derived parameters based on chosen primitive\n   * parameters\n   *\n   * @param *cryptoParams the crypto parameters object to be populated with\n   * parameters.\n   * @param evalAddCount number of EvalAdds assuming no EvalMult and KeySwitch\n   * operations are performed.\n   * @param multiplicativeDepth number of EvalMults assuming no EvalAdd and\n   * KeySwitch operations are performed.\n   * @param keySwitchCount number of KeySwitch operations assuming no EvalAdd\n   * and EvalMult operations are performed.\n   * @param dcrtBits number of bits in each CRT modulus*\n   * @param n ring dimension in case the user wants to use a custom ring\n   * dimension\n   * @param numPartQ number of partitions of Q for HYBRID key switching\n   */\n    virtual bool ParamsGenBFVRNS(std::shared_ptr&lt;CryptoParametersBase&lt;Element&gt;&gt; cryptoParams, uint32_t evalAddCount,\n                                 uint32_t multiplicativeDepth, uint32_t keySwitchCount, size_t dcrtBits, uint32_t n,\n                                 uint32_t numPartQ) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;This signature for ParamsGen is not supported for this scheme.&quot;);\n    }\n\n    /**\n   * Method for computing all derived parameters based on chosen primitive\n   * parameters.\n   *\n   * @param *cryptoParams the crypto parameters object to be populated with\n   * parameters.\n   * @param cyclOrder the cyclotomic order.\n   * @param numPrimes number of modulus towers to support.\n   * @param scalingModSize the bit-width for plaintexts and DCRTPoly&#x27;s.\n   * @param firstModSize the bit-size of the first modulus\n   * @param numPartQ number of partitions of Q for HYBRID key switching\n   */\n    virtual bool ParamsGenCKKSRNS(std::shared_ptr&lt;CryptoParametersBase&lt;Element&gt;&gt; cryptoParams, usint cyclOrder,\n                                  usint numPrimes, usint scalingModSize, usint firstModSize, uint32_t numPartQ,\n                                  COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;This signature for ParamsGen is not supported for this scheme.&quot;);\n    }\n\n    /**\n   * Method for computing all derived parameters based on chosen primitive\n   * parameters. This is intended for BGVrns\n   * @param *cryptoParams the crypto parameters object to be populated with\n   * parameters.\n   * @param evalAddCount number of EvalAdds per level.\n   * @param keySwitchCount number of KeySwitch operations per level.\n   * @param cyclOrder the cyclotomic order.\n   * @param numPrimes number of modulus towers to support.\n   * @param firstModSize the bit-size of the first modulus\n   * @param dcrtBits the bit-width of moduli\n   * @param numPartQ number of partitions of Q for HYBRID key switching\n   * @param multihopQBound bound for the HRA-secure mode of PRE\n   */\n    virtual bool ParamsGenBGVRNS(std::shared_ptr&lt;CryptoParametersBase&lt;DCRTPoly&gt;&gt; cryptoParams, uint32_t evalAddCount,\n                                 uint32_t keySwitchCount, usint cyclOrder, usint numPrimes, usint firstModSize,\n                                 usint dcrtBits, uint32_t numPartQ, usint multihopQBound) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;This signature for ParamsGen is not supported for this scheme.&quot;);\n    }\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {}\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {}\n\n    std::string SerializedObjectName() const {\n        return &quot;ParameterGenerationBase&quot;;\n    }\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/**\nBase class for key switching algorithms.\n */\n\n#ifndef LBCRYPTO_CRYPTO_KEYSWITCH_BASE_H\n#define LBCRYPTO_CRYPTO_KEYSWITCH_BASE_H\n\n#include &quot;ciphertext-fwd.h&quot;\n#include &quot;key/publickey-fwd.h&quot;\n#include &quot;key/privatekey-fwd.h&quot;\n#include &quot;key/evalkey-fwd.h&quot;\n#include &quot;utils/exception.h&quot;\n#include &quot;schemebase/base-cryptoparameters.h&quot;\n\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\n\n/**\n * @brief Abstract class for LBC keyswitching\n * @tparam Element a secret key type instantiation\n */\ntemplate &lt;class Element&gt;\nclass KeySwitchBase {\n    using ParmType = typename Element::Params;\n\npublic:\n    KeySwitchBase(){};\n\n    virtual ~KeySwitchBase(){};\n\n    /**\n   * Method for KeySwitchGen\n   *\n   * @param &amp;originalPrivateKey Original private key used for encryption.\n   * @param &amp;newPrivateKey New private key to generate the keyswitch hint.\n   * @param *KeySwitchHint is where the resulting keySwitchHint will be\n   * placed.\n   */\n    virtual EvalKey&lt;Element&gt; KeySwitchGenInternal(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                                  const PrivateKey&lt;Element&gt; newPrivateKey) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, std::string(__func__) + &quot; is not supported&quot;);\n    }\n\n    virtual EvalKey&lt;Element&gt; KeySwitchGenInternal(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                                  const PrivateKey&lt;Element&gt; newPrivateKey,\n                                                  const EvalKey&lt;Element&gt; evalKey) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, std::string(__func__) + &quot; is not supported&quot;);\n    }\n\n    virtual EvalKey&lt;Element&gt; KeySwitchGenInternal(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                                  const PublicKey&lt;Element&gt; newPublicKey) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, std::string(__func__) + &quot; is not supported&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; KeySwitch(ConstCiphertext&lt;Element&gt; ciphertext, const EvalKey&lt;Element&gt; evalKey) const;\n\n    virtual void KeySwitchInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const EvalKey&lt;Element&gt; evalKey) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;KeySwitch is not supported&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; KeySwitchExt(ConstCiphertext&lt;Element&gt; ciphertext, bool addFirst) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;KeySwitchExt is not supported&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; KeySwitchDown(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;KeySwitchDown is not supported&quot;);\n    }\n\n    virtual Element KeySwitchDownFirstElement(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;KeySwitchDownFirstElement is not supported&quot;);\n    }\n    /////////////////////////////////////////\n    // CORE OPERATIONS\n    /////////////////////////////////////////\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; KeySwitchCore(const Element&amp; a,\n                                                                const EvalKey&lt;Element&gt; evalKey) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;KeySwitchCore is not supported&quot;);\n    }\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EvalKeySwitchPrecomputeCore(\n        const Element&amp; c, std::shared_ptr&lt;CryptoParametersBase&lt;Element&gt;&gt; cryptoParamsBase) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;EvalKeySwitchPrecomputeCore is not supported&quot;);\n    }\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EvalFastKeySwitchCore(\n        const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits, const EvalKey&lt;Element&gt; evalKey,\n        const std::shared_ptr&lt;ParmType&gt; paramsQl) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;EvalFastKeySwitchCore is not supported&quot;);\n    }\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EvalFastKeySwitchCoreExt(\n        const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits, const EvalKey&lt;Element&gt; evalKey,\n        const std::shared_ptr&lt;ParmType&gt; paramsQl) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;EvalFastKeySwitchCoreExt is not supported&quot;);\n    }\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_BASE_SCHEME_H\n#define LBCRYPTO_CRYPTO_BASE_SCHEME_H\n\n#include &quot;key/evalkey-fwd.h&quot;\n#include &quot;schemebase/base-parametergeneration.h&quot;\n#include &quot;keyswitch/keyswitch-base.h&quot;\n#include &quot;schemebase/base-advancedshe.h&quot;\n#include &quot;schemebase/base-leveledshe.h&quot;\n#include &quot;schemebase/base-multiparty.h&quot;\n#include &quot;schemebase/base-fhe.h&quot;\n#include &quot;schemebase/base-pke.h&quot;\n#include &quot;schemebase/base-pre.h&quot;\n#include &quot;ciphertext.h&quot;\n\n#include &quot;key/keypair.h&quot;\n\n#include &quot;utils/exception.h&quot;\n#include &quot;utils/caller_info.h&quot;\n\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;memory&gt;\n#include &lt;utility&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\n\ntemplate &lt;typename Element&gt;\nclass KeyPair;\n\n// TODO: fix DCRTPoly passed by value\n\n/**\n * @brief Abstract interface for public key encryption schemes\n * @tparam Element a ring element.\n */\ntemplate &lt;typename Element&gt;\nclass SchemeBase {\n    using ParmType = typename Element::Params;\n    using IntType  = typename Element::Integer;\n    using DugType  = typename Element::DugType;\n    using DggType  = typename Element::DggType;\n    using TugType  = typename Element::TugType;\n\nprotected:\n    inline void CheckMultipartyDecryptCompatibility(ConstCiphertext&lt;Element&gt;&amp; ciphertext, CALLER_INFO_ARGS_HDR) const {\n        if (ciphertext-&gt;GetElements().size() &gt; 2) {\n            std::string errorMsg(std::string(&quot;ciphertext&#x27;s number of elements is [&quot;) +\n                                 std::to_string(ciphertext-&gt;GetElements().size()) +\n                                 &quot;]. Must be 2 or less for Multiparty Decryption.&quot; + CALLER_INFO);\n            &quot;hey&quot;; OPENFHE_THROW(openfhe_error, errorMsg);\n        }\n    }\n\npublic:\n    SchemeBase() {}\n\n    virtual ~SchemeBase() {}\n\n    virtual bool operator==(const SchemeBase&amp; sch) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;operator== is not supported&quot;);\n    }\n\n    virtual bool operator!=(const SchemeBase&amp; sch) const {\n        return !(*this == sch);\n    }\n\n    /**\n   * Enable features with a bit mast of PKESchemeFeature codes\n   * @param mask\n   */\n    virtual void Enable(usint mask) {\n        if (mask &amp; PKE)\n            Enable(PKE);\n        if (mask &amp; KEYSWITCH)\n            Enable(KEYSWITCH);\n        if (mask &amp; LEVELEDSHE)\n            Enable(LEVELEDSHE);\n        if (mask &amp; ADVANCEDSHE)\n            Enable(ADVANCEDSHE);\n        if (mask &amp; PRE)\n            Enable(PRE);\n        if (mask &amp; MULTIPARTY)\n            Enable(MULTIPARTY);\n        if (mask &amp; FHE)\n            Enable(FHE);\n        if (mask &amp; SCHEMESWITCH)\n            Enable(SCHEMESWITCH);\n    }\n\n    virtual usint GetEnabled() const {\n        usint flag = 0;\n        if (m_PKE != nullptr)\n            flag |= PKE;\n        if (m_KeySwitch != nullptr)\n            flag |= KEYSWITCH;\n        if (m_LeveledSHE != nullptr)\n            flag |= LEVELEDSHE;\n        if (m_AdvancedSHE != nullptr)\n            flag |= ADVANCEDSHE;\n        if (m_PRE != nullptr)\n            flag |= PRE;\n        if (m_Multiparty != nullptr)\n            flag |= MULTIPARTY;\n        if (m_FHE != nullptr)\n            flag |= FHE;\n        if (m_SchemeSwitch != nullptr)\n            flag |= SCHEMESWITCH;\n        return flag;\n    }\n\n    // instantiated in the scheme implementation class\n    virtual void Enable(PKESchemeFeature feature) {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Enable is not implemented&quot;);\n    }\n\n    //------------------------------------------------------------------------------\n    // PARAMETER GENERATION WRAPPER\n    //------------------------------------------------------------------------------\n\n    virtual bool ParamsGenBFVRNS(std::shared_ptr&lt;CryptoParametersBase&lt;Element&gt;&gt; cryptoParams, uint32_t evalAddCount,\n                                 uint32_t multiplicativeDepth, uint32_t keySwitchCount, size_t dcrtBits, uint32_t n,\n                                 uint32_t numPartQ) const {\n        if (!m_ParamsGen)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;m_ParamsGen is nullptr&quot;);\n        return m_ParamsGen-&gt;ParamsGenBFVRNS(cryptoParams, evalAddCount, multiplicativeDepth, keySwitchCount, dcrtBits,\n                                            n, numPartQ);\n    }\n\n    virtual bool ParamsGenCKKSRNS(std::shared_ptr&lt;CryptoParametersBase&lt;Element&gt;&gt; cryptoParams, usint cyclOrder,\n                                  usint numPrimes, usint scalingModSize, usint firstModSize, uint32_t numPartQ,\n                                  COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel) const {\n        if (!m_ParamsGen)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;m_ParamsGen is nullptr&quot;);\n        return m_ParamsGen-&gt;ParamsGenCKKSRNS(cryptoParams, cyclOrder, numPrimes, scalingModSize, firstModSize, numPartQ,\n                                             mPIntBootCiphertextCompressionLevel);\n    }\n\n    virtual bool ParamsGenBGVRNS(std::shared_ptr&lt;CryptoParametersBase&lt;DCRTPoly&gt;&gt; cryptoParams, uint32_t evalAddCount,\n                                 uint32_t keySwitchCount, usint cyclOrder, usint numPrimes, usint firstModSize,\n                                 usint dcrtBits, uint32_t numPartQ, usint multihopQBound) const {\n        if (!m_ParamsGen)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;m_ParamsGen is nullptr&quot;);\n        return m_ParamsGen-&gt;ParamsGenBGVRNS(cryptoParams, evalAddCount, keySwitchCount, cyclOrder, numPrimes,\n                                            firstModSize, dcrtBits, numPartQ, multihopQBound);\n    }\n\n    /////////////////////////////////////////\n    // PKE WRAPPER\n    /////////////////////////////////////////\n\n    virtual KeyPair&lt;Element&gt; KeyGen(CryptoContext&lt;Element&gt; cc, bool makeSparse) {\n        VerifyPKEEnabled(__func__);\n        return m_PKE-&gt;KeyGenInternal(cc, makeSparse);\n    }\n\n    virtual Ciphertext&lt;Element&gt; Encrypt(const Element&amp; plaintext, const PrivateKey&lt;Element&gt; privateKey) const {\n        VerifyPKEEnabled(__func__);\n        //      if (!plaintext)\n        //        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n\n        return m_PKE-&gt;Encrypt(plaintext, privateKey);\n    }\n\n    virtual Ciphertext&lt;Element&gt; Encrypt(const Element&amp; plaintext, const PublicKey&lt;Element&gt; publicKey) const {\n        VerifyPKEEnabled(__func__);\n        //      if (!plaintext)\n        //        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        if (!publicKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input public key is nullptr&quot;);\n\n        return m_PKE-&gt;Encrypt(plaintext, publicKey);\n    }\n\n    virtual DecryptResult Decrypt(ConstCiphertext&lt;Element&gt; ciphertext, const PrivateKey&lt;Element&gt; privateKey,\n                                  NativePoly* plaintext) const {\n        VerifyPKEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        return m_PKE-&gt;Decrypt(ciphertext, privateKey, plaintext);\n    }\n\n    virtual DecryptResult Decrypt(ConstCiphertext&lt;Element&gt; ciphertext, const PrivateKey&lt;Element&gt; privateKey,\n                                  Poly* plaintext) const {\n        VerifyPKEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        return m_PKE-&gt;Decrypt(ciphertext, privateKey, plaintext);\n    }\n\n    std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EncryptZeroCore(const PrivateKey&lt;Element&gt; privateKey) const {\n        VerifyPKEEnabled(__func__);\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        return m_PKE-&gt;EncryptZeroCore(privateKey, nullptr);\n    }\n\n    std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EncryptZeroCore(const PublicKey&lt;Element&gt; publicKey) const {\n        VerifyPKEEnabled(__func__);\n        if (!publicKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input public key is nullptr&quot;);\n        return m_PKE-&gt;EncryptZeroCore(publicKey, nullptr);\n    }\n\n    Element DecryptCore(ConstCiphertext&lt;Element&gt; ciphertext, const PrivateKey&lt;Element&gt; privateKey) const {\n        VerifyPKEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!privateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input private key is nullptr&quot;);\n        return m_PKE-&gt;DecryptCore(ciphertext-&gt;GetElements(), privateKey);\n    }\n\n    /////////////////////////////////////////\n    // KEY SWITCH WRAPPER\n    /////////////////////////////////////////\n\n    virtual EvalKey&lt;Element&gt; KeySwitchGen(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                          const PrivateKey&lt;Element&gt; newPrivateKey) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!oldPrivateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first private key is nullptr&quot;);\n        if (!newPrivateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second private key is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchGenInternal(oldPrivateKey, newPrivateKey);\n    }\n\n    virtual EvalKey&lt;Element&gt; KeySwitchGen(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                          const PrivateKey&lt;Element&gt; newPrivateKey,\n                                          const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!oldPrivateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first private key is nullptr&quot;);\n        if (!newPrivateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second private key is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input eval key is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchGenInternal(oldPrivateKey, newPrivateKey, evalKey);\n    }\n\n    virtual EvalKey&lt;Element&gt; KeySwitchGen(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                          const PublicKey&lt;Element&gt; newPublicKey) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!oldPrivateKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first private key is nullptr&quot;);\n        if (!newPublicKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second public key is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchGenInternal(oldPrivateKey, newPublicKey);\n    }\n\n    virtual Ciphertext&lt;Element&gt; KeySwitch(ConstCiphertext&lt;Element&gt; ciphertext, const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitch(ciphertext, evalKey);\n    }\n\n    virtual void KeySwitchInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        m_KeySwitch-&gt;KeySwitchInPlace(ciphertext, evalKey);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; KeySwitchDown(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchDown(ciphertext);\n    }\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EvalKeySwitchPrecomputeCore(\n        const Element&amp; c, std::shared_ptr&lt;CryptoParametersBase&lt;Element&gt;&gt; cryptoParamsBase) const {\n        VerifyKeySwitchEnabled(__func__);\n        return m_KeySwitch-&gt;EvalKeySwitchPrecomputeCore(c, cryptoParamsBase);\n    }\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EvalFastKeySwitchCoreExt(\n        const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits, const EvalKey&lt;Element&gt; evalKey,\n        const std::shared_ptr&lt;ParmType&gt; params) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (nullptr == digits)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input digits is nullptr&quot;);\n        if (digits-&gt;size() == 0)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input digits size is 0&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        if (!params)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input params is nullptr&quot;);\n        return m_KeySwitch-&gt;EvalFastKeySwitchCoreExt(digits, evalKey, params);\n    }\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EvalFastKeySwitchCore(\n        const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits, const EvalKey&lt;Element&gt; evalKey,\n        const std::shared_ptr&lt;ParmType&gt; params) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (nullptr == digits)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input digits is nullptr&quot;);\n        if (digits-&gt;size() == 0)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input digits size is 0&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        if (!params)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input params is nullptr&quot;);\n        return m_KeySwitch-&gt;EvalFastKeySwitchCore(digits, evalKey, params);\n    }\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; KeySwitchCore(const Element&amp; a,\n                                                                const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchCore(a, evalKey);\n    }\n\n    /////////////////////////////////////////\n    // PRE WRAPPER\n    /////////////////////////////////////////\n\n    virtual EvalKey&lt;Element&gt; ReKeyGen(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                      const PublicKey&lt;Element&gt; newPublicKey) const;\n\n    virtual Ciphertext&lt;Element&gt; ReEncrypt(ConstCiphertext&lt;Element&gt; ciphertext, const EvalKey&lt;Element&gt; evalKey,\n                                          const PublicKey&lt;Element&gt; publicKey) const;\n\n    /////////////////////////////////////////\n    // SHE NEGATION WRAPPER\n    /////////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalNegate(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalNegate(ciphertext);\n    }\n\n    virtual void EvalNegateInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalNegateInPlace(ciphertext);\n        return;\n    }\n\n    /////////////////////////////////////////\n    // SHE ADDITION Wrapper\n    /////////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                        ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalAdd(ciphertext1, ciphertext2);\n    }\n\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalAddInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalAddMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1,\n                                               Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalAddMutable(ciphertext1, ciphertext2);\n    }\n\n    virtual void EvalAddMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalAddMutableInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalAdd(ciphertext, plaintext);\n    }\n\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, ConstPlaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalAddInPlace(ciphertext, plaintext);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalAddMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalAddMutable(ciphertext, plaintext);\n    }\n\n    // TODO (dsuponit): commented the code below to avoid compiler errors\n    // virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, const NativeInteger &amp;constant) const {\n    //  VerifyLeveledSHEEnabled(__func__);\n    //  if (!ciphertext)\n    //      &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n\n    //  return m_LeveledSHE-&gt;EvalAdd(ciphertext, constant);\n    //}\n\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const NativeInteger&amp; constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalAddInPlace(ciphertext, constant);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalAdd(ciphertext, constant);\n    }\n\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalAddInPlace(ciphertext, constant);\n        return;\n    }\n\n    /////////////////////////////////////////\n    // SHE SUBTRACTION Wrapper\n    /////////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                        ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSub(ciphertext1, ciphertext2);\n    }\n\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalSubInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSubMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1,\n                                               Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSubMutable(ciphertext1, ciphertext2);\n    }\n\n    virtual void EvalSubMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalSubMutableInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSub(ciphertext, plaintext);\n    }\n\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, ConstPlaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalSubInPlace(ciphertext, plaintext);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSubMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSubMutable(ciphertext, plaintext);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, const NativeInteger&amp; constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSub(ciphertext, constant);\n    }\n\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const NativeInteger&amp; constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalSubInPlace(ciphertext, constant);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSub(ciphertext, constant);\n    }\n\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalSubInPlace(ciphertext, constant);\n        return;\n    }\n\n    /////////////////////////////////////////\n    // SHE MULTIPLICATION Wrapper\n    /////////////////////////////////////////\n\n    virtual EvalKey&lt;Element&gt; EvalMultKeyGen(const PrivateKey&lt;Element&gt; privateKey) const;\n\n    virtual std::vector&lt;EvalKey&lt;Element&gt;&gt; EvalMultKeysGen(const PrivateKey&lt;Element&gt; privateKey) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                         ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMult(ciphertext1, ciphertext2);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMultMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1,\n                                                Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMultMutable(ciphertext1, ciphertext2);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSquare(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSquare(ciphertext);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSquareMutable(Ciphertext&lt;Element&gt;&amp; ciphertext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSquareMutable(ciphertext);\n    }\n\n    /////////////////////////////////////////\n    // MULTIPLICATION With Eval Key\n    /////////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2,\n                                         const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMult(ciphertext1, ciphertext2, evalKey);\n    }\n\n    virtual void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2,\n                                 const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalMultInPlace(ciphertext1, ciphertext2, evalKey);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMultMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2,\n                                                const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMultMutable(ciphertext1, ciphertext2, evalKey);\n    }\n\n    virtual void EvalMultMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2,\n                                        const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalMultMutableInPlace(ciphertext1, ciphertext2, evalKey);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSquare(ConstCiphertext&lt;Element&gt; ciphertext, const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSquare(ciphertext, evalKey);\n    }\n\n    virtual void EvalSquareInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalSquareInPlace(ciphertext, evalKey);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSquareMutable(Ciphertext&lt;Element&gt;&amp; ciphertext,\n                                                  const EvalKey&lt;Element&gt; evalKey) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKey)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalSquareMutable(ciphertext, evalKey);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMultAndRelinearize(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                       ConstCiphertext&lt;Element&gt; ciphertext2,\n                                                       const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second ciphertext is nullptr&quot;);\n        if (!evalKeyVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key vector is empty&quot;);\n        return m_LeveledSHE-&gt;EvalMultAndRelinearize(ciphertext1, ciphertext2, evalKeyVec);\n    }\n\n    virtual Ciphertext&lt;Element&gt; Relinearize(ConstCiphertext&lt;Element&gt; ciphertext,\n                                            const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKeyVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key vector is empty&quot;);\n        return m_LeveledSHE-&gt;Relinearize(ciphertext, evalKeyVec);\n    }\n\n    virtual void RelinearizeInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext,\n                                    const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKeyVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key vector is empty&quot;);\n        m_LeveledSHE-&gt;RelinearizeInPlace(ciphertext, evalKeyVec);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMult(ciphertext, plaintext);\n    }\n\n    virtual void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, ConstPlaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalMultInPlace(ciphertext, plaintext);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMultMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMultMutable(ciphertext, plaintext);\n    }\n\n    virtual Ciphertext&lt;Element&gt; MultByMonomial(ConstCiphertext&lt;Element&gt; ciphertext, usint power) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;MultByMonomial(ciphertext, power);\n    }\n\n    virtual void MultByMonomialInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, usint power) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;MultByMonomialInPlace(ciphertext, power);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalMult(ciphertext, constant);\n    }\n\n    virtual void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;EvalMultInPlace(ciphertext, constant);\n        return;\n    }\n\n    virtual Ciphertext&lt;DCRTPoly&gt; MultByInteger(ConstCiphertext&lt;DCRTPoly&gt; ciphertext, uint64_t integer) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;MultByInteger(ciphertext, integer);\n    }\n\n    virtual void MultByIntegerInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, uint64_t integer) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;MultByIntegerInPlace(ciphertext, integer);\n        return;\n    }\n\n    /////////////////////////////////////////\n    // SHE AUTOMORPHISM Wrapper\n    /////////////////////////////////////////\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalAutomorphismKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::vector&lt;usint&gt;&amp; indexList) const;\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalAutomorphismKeyGen(\n        const PublicKey&lt;Element&gt; publicKey, const PrivateKey&lt;Element&gt; privateKey,\n        const std::vector&lt;usint&gt;&amp; indexList) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalAutomorphism(ConstCiphertext&lt;Element&gt; ciphertext, usint i,\n                                                 const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap,\n                                                 CALLER_INFO_ARGS_HDR) const {\n        if (m_LeveledSHE) {\n            if (!ciphertext)\n                &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n            if (!evalKeyMap.size())\n                &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is empty&quot;);\n\n            return m_LeveledSHE-&gt;EvalAutomorphism(ciphertext, i, evalKeyMap);\n        }\n        std::string errorMsg(std::string(&quot;EvalAutomorphism operation has not been enabled&quot;) + CALLER_INFO);\n        &quot;hey&quot;; OPENFHE_THROW(config_error, errorMsg);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalFastRotation(ConstCiphertext&lt;Element&gt; ciphertext, const usint index, const usint m,\n                                                 const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalFastRotation(ciphertext, index, m, digits);\n    }\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EvalFastRotationPrecompute(\n        ConstCiphertext&lt;Element&gt; ciphertext) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalFastRotationPrecompute(ciphertext);\n    }\n\n    /**\n   * Only supported for hybrid key switching.\n   * Performs fast (hoisted) rotation and returns the results\n   * in the extended CRT basis P*Q\n   *\n   * @param ciphertext input ciphertext\n   * @param index the rotation index.\n   * @param precomp the precomputed digits for the ciphertext\n   * @param addFirst if true, the the first element c0 is also computed (otherwise ignored)\n   * @return resulting ciphertext\n   */\n    virtual Ciphertext&lt;Element&gt; EvalFastRotationExt(ConstCiphertext&lt;Element&gt; ciphertext, usint index,\n                                                    const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits, bool addFirst,\n                                                    const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeys) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;EvalFastRotationExt(ciphertext, index, digits, addFirst, evalKeys);\n    }\n\n    /**\n   * Only supported for hybrid key switching.\n   * Scales down the polynomial c0 from extended basis P*Q to Q.\n   *\n   * @param ciphertext input ciphertext in the extended basis\n   * @return resulting polynomial\n   */\n    Element KeySwitchDownFirstElement(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchDownFirstElement(ciphertext);\n    }\n\n    virtual Ciphertext&lt;Element&gt; KeySwitchExt(ConstCiphertext&lt;Element&gt; ciphertext, bool addFirst) const {\n        VerifyKeySwitchEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_KeySwitch-&gt;KeySwitchExt(ciphertext, addFirst);\n    }\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalAtIndexKeyGen(\n        const PublicKey&lt;Element&gt; publicKey, const PrivateKey&lt;Element&gt; privateKey,\n        const std::vector&lt;int32_t&gt;&amp; indexList) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalAtIndex(ConstCiphertext&lt;Element&gt; ciphertext, usint i,\n                                            const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is empty&quot;);\n        return m_LeveledSHE-&gt;EvalAtIndex(ciphertext, i, evalKeyMap);\n    }\n\n    virtual usint FindAutomorphismIndex(usint index, usint m) {\n        VerifyLeveledSHEEnabled(__func__);\n        return m_LeveledSHE-&gt;FindAutomorphismIndex(index, m);\n    }\n\n    /////////////////////////////////////////\n    // SHE Leveled Methods Wrapper\n    /////////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; ComposedEvalMult(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                 ConstCiphertext&lt;Element&gt; ciphertext2,\n                                                 const EvalKey&lt;Element&gt; evalKey) const;\n\n    virtual Ciphertext&lt;Element&gt; ModReduce(ConstCiphertext&lt;Element&gt; ciphertext, size_t levels) const;\n\n    virtual void ModReduceInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;ModReduceInPlace(ciphertext, levels);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; ModReduceInternal(ConstCiphertext&lt;Element&gt; ciphertext, size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;ModReduceInternal(ciphertext, levels);\n    }\n\n    virtual void ModReduceInternalInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (levels == 0)\n            return;\n        m_LeveledSHE-&gt;ModReduceInternalInPlace(ciphertext, levels);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; LevelReduce(ConstCiphertext&lt;Element&gt; ciphertext, const EvalKey&lt;Element&gt; evalKey,\n                                            size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        auto result = m_LeveledSHE-&gt;LevelReduce(ciphertext, evalKey, levels);\n        result-&gt;SetKeyTag(ciphertext-&gt;GetKeyTag());\n        return result;\n    }\n\n    virtual void LevelReduceInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const EvalKey&lt;Element&gt; evalKey,\n                                    size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;LevelReduceInPlace(ciphertext, evalKey, levels);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; LevelReduceInternal(ConstCiphertext&lt;Element&gt; ciphertext, size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;LevelReduceInternal(ciphertext, levels);\n    }\n\n    virtual void LevelReduceInternalInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, size_t levels) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        m_LeveledSHE-&gt;LevelReduceInternalInPlace(ciphertext, levels);\n        return;\n    }\n\n    virtual Ciphertext&lt;Element&gt; Compress(ConstCiphertext&lt;Element&gt; ciphertext, size_t towersLeft) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_LeveledSHE-&gt;Compress(ciphertext, towersLeft);\n    }\n\n    virtual void AdjustLevelsInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1, Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext1 is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext2 is nullptr&quot;);\n        m_LeveledSHE-&gt;AdjustLevelsInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    virtual void AdjustLevelsAndDepthInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1,\n                                             Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext1 is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext2 is nullptr&quot;);\n        m_LeveledSHE-&gt;AdjustLevelsAndDepthInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    virtual void AdjustLevelsAndDepthToOneInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1,\n                                                  Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext2) const {\n        VerifyLeveledSHEEnabled(__func__);\n        if (!ciphertext1)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext1 is nullptr&quot;);\n        if (!ciphertext2)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext2 is nullptr&quot;);\n        m_LeveledSHE-&gt;AdjustLevelsAndDepthToOneInPlace(ciphertext1, ciphertext2);\n        return;\n    }\n\n    /////////////////////////////////////////\n    // Advanced SHE Wrapper\n    /////////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalAddMany(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalAddMany(ciphertextVec);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalAddManyInPlace(std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n\n        return m_AdvancedSHE-&gt;EvalAddManyInPlace(ciphertextVec);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMultMany(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                             const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n        if (!evalKeyVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key vector is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalMultMany(ciphertextVec, evalKeyVec);\n    }\n\n    /////////////////////////////////////\n    // Advanced SHE LINEAR WEIGHTED SUM\n    /////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalLinearWSum(std::vector&lt;ConstCiphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                               const std::vector&lt;double&gt;&amp; constantVec) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalLinearWSum(ciphertextVec, constantVec);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalLinearWSumMutable(std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                                      const std::vector&lt;double&gt;&amp; constantVec) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalLinearWSumMutable(ciphertextVec, constantVec);\n    }\n\n    /////////////////////////////////////\n    // Advanced SHE EVAL POLYNOMIAL\n    /////////////////////////////////////\n\n    Ciphertext&lt;Element&gt; EvalPoly(ConstCiphertext&lt;Element&gt; ciphertext, const std::vector&lt;double&gt;&amp; coefficients) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;EvalPoly(ciphertext, coefficients);\n    }\n\n    Ciphertext&lt;Element&gt; EvalPolyLinear(ConstCiphertext&lt;Element&gt; ciphertext,\n                                       const std::vector&lt;double&gt;&amp; coefficients) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;EvalPolyLinear(ciphertext, coefficients);\n    }\n\n    Ciphertext&lt;Element&gt; EvalPolyPS(ConstCiphertext&lt;Element&gt; ciphertext, const std::vector&lt;double&gt;&amp; coefficients) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;EvalPolyPS(ciphertext, coefficients);\n    }\n\n    /////////////////////////////////////\n    // Advanced SHE EVAL CHEBYSHEV SERIES\n    /////////////////////////////////////\n\n    Ciphertext&lt;Element&gt; EvalChebyshevSeries(ConstCiphertext&lt;Element&gt; ciphertext,\n                                            const std::vector&lt;double&gt;&amp; coefficients, double a, double b) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;EvalChebyshevSeries(ciphertext, coefficients, a, b);\n    }\n\n    Ciphertext&lt;Element&gt; EvalChebyshevSeriesLinear(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                  const std::vector&lt;double&gt;&amp; coefficients, double a, double b) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;EvalChebyshevSeriesLinear(ciphertext, coefficients, a, b);\n    }\n\n    Ciphertext&lt;Element&gt; EvalChebyshevSeriesPS(ConstCiphertext&lt;Element&gt; ciphertext,\n                                              const std::vector&lt;double&gt;&amp; coefficients, double a, double b) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;EvalChebyshevSeriesPS(ciphertext, coefficients, a, b);\n    }\n\n    /////////////////////////////////////\n    // Advanced SHE EVAL SUM\n    /////////////////////////////////////\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSumKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                                                             const PublicKey&lt;Element&gt; publicKey) const;\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSumRowsKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                                                                 const PublicKey&lt;Element&gt; publicKey,\n                                                                                 usint rowSize, usint subringDim) const;\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSumColsKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const PublicKey&lt;Element&gt; publicKey) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalSum(ConstCiphertext&lt;Element&gt; ciphertext, usint batchSize,\n                                        const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalSum(ciphertext, batchSize, evalKeyMap);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSumRows(ConstCiphertext&lt;Element&gt; ciphertext, usint rowSize,\n                                            const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap,\n                                            usint subringDim) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        if (!evalKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalSumRows(ciphertext, rowSize, evalKeyMap, subringDim);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSumCols(ConstCiphertext&lt;Element&gt; ciphertext, usint batchSize,\n                                            const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap,\n                                            const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; rightEvalKeyMap) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!evalKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first evaluation key map is empty&quot;);\n        if (!rightEvalKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input second evaluation key map is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalSumCols(ciphertext, batchSize, evalKeyMap, rightEvalKeyMap);\n    }\n\n    /////////////////////////////////////\n    // Advanced SHE EVAL INNER PRODUCT\n    /////////////////////////////////////\n\n    virtual Ciphertext&lt;Element&gt; EvalInnerProduct(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                 ConstCiphertext&lt;Element&gt; ciphertext2, usint batchSize,\n                                                 const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalSumKeyMap,\n                                                 const EvalKey&lt;Element&gt; evalMultKey) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalInnerProduct(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext,\n                                                 usint batchSize,\n                                                 const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalSumKeyMap) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input first ciphertext is nullptr&quot;);\n        if (!plaintext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input plaintext is nullptr&quot;);\n        if (!evalSumKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalInnerProduct(ciphertext, plaintext, batchSize, evalSumKeyMap);\n    }\n\n    virtual Ciphertext&lt;Element&gt; AddRandomNoise(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertext)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext is nullptr&quot;);\n        return m_AdvancedSHE-&gt;AddRandomNoise(ciphertext);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMerge(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                          const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap) const {\n        VerifyAdvancedSHEEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n        if (!evalKeyMap.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input evaluation key map is empty&quot;);\n        return m_AdvancedSHE-&gt;EvalMerge(ciphertextVec, evalKeyMap);\n    }\n\n    /////////////////////////////////////////\n    // MULTIPARTY WRAPPER\n    /////////////////////////////////////////\n\n    virtual KeyPair&lt;Element&gt; MultipartyKeyGen(CryptoContext&lt;Element&gt; cc,\n                                              const std::vector&lt;PrivateKey&lt;Element&gt;&gt;&amp; privateKeyVec, bool makeSparse);\n\n    virtual KeyPair&lt;Element&gt; MultipartyKeyGen(CryptoContext&lt;Element&gt; cc, const PublicKey&lt;Element&gt; publicKey,\n                                              bool makeSparse, bool PRE);\n\n    virtual Ciphertext&lt;Element&gt; MultipartyDecryptMain(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                      const PrivateKey&lt;Element&gt; privateKey) const;\n\n    virtual Ciphertext&lt;Element&gt; MultipartyDecryptLead(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                      const PrivateKey&lt;Element&gt; privateKey) const;\n\n    virtual DecryptResult MultipartyDecryptFusion(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                                  NativePoly* plaintext) const {\n        VerifyMultipartyEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n\n        return m_Multiparty-&gt;MultipartyDecryptFusion(ciphertextVec, plaintext);\n    }\n\n    virtual DecryptResult MultipartyDecryptFusion(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                                  Poly* plaintext) const {\n        VerifyMultipartyEnabled(__func__);\n        if (!ciphertextVec.size())\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Input ciphertext vector is empty&quot;);\n        return m_Multiparty-&gt;MultipartyDecryptFusion(ciphertextVec, plaintext);\n    }\n\n    virtual EvalKey&lt;Element&gt; MultiKeySwitchGen(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                               const PrivateKey&lt;Element&gt; newPrivateKey,\n                                               const EvalKey&lt;Element&gt; evalKey) const;\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiEvalAutomorphismKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalAutoKeyMap,\n        const std::vector&lt;usint&gt;&amp; indexList, const std::string&amp; keyId);\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiEvalAtIndexKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalAutoKeyMap,\n        const std::vector&lt;int32_t&gt;&amp; indexList, const std::string&amp; keyId);\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiEvalSumKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalSumKeyMap,\n        const std::string&amp; keyId = &quot;&quot;);\n\n    virtual EvalKey&lt;Element&gt; MultiAddEvalKeys(EvalKey&lt;Element&gt; evalKey1, EvalKey&lt;Element&gt; evalKey2,\n                                              const std::string&amp; keyId);\n\n    virtual EvalKey&lt;Element&gt; MultiMultEvalKey(PrivateKey&lt;Element&gt; privateKey, EvalKey&lt;Element&gt; evalKey,\n                                              const std::string&amp; keyId);\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiAddEvalSumKeys(\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalSumKeyMap1,\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalSumKeyMap2, const std::string&amp; keyId);\n\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiAddEvalAutomorphismKeys(\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalSumKeyMap1,\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalSumKeyMap2, const std::string&amp; keyId);\n\n    virtual PublicKey&lt;Element&gt; MultiAddPubKeys(PublicKey&lt;Element&gt; publicKey1, PublicKey&lt;Element&gt; publicKey2,\n                                               const std::string&amp; keyId);\n\n    virtual EvalKey&lt;Element&gt; MultiAddEvalMultKeys(EvalKey&lt;Element&gt; evalKey1, EvalKey&lt;Element&gt; evalKey2,\n                                                  const std::string&amp; keyId);\n\n    virtual Ciphertext&lt;Element&gt; IntMPBootAdjustScale(ConstCiphertext&lt;Element&gt; ciphertext) const {\n        if (m_Multiparty) {\n            return m_Multiparty-&gt;IntMPBootAdjustScale(ciphertext);\n        }\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;IntMPBootAdjustScale operation has not been enabled&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; IntMPBootRandomElementGen(std::shared_ptr&lt;CryptoParametersCKKSRNS&gt; cryptoParameters,\n                                                          const PublicKey&lt;Element&gt; publicKey) const {\n        if (m_Multiparty) {\n            return m_Multiparty-&gt;IntMPBootRandomElementGen(cryptoParameters, publicKey);\n        }\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;IntMPBootRandomElementGen operation has not been enabled&quot;);\n    }\n\n    virtual std::vector&lt;Ciphertext&lt;Element&gt;&gt; IntMPBootDecrypt(const PrivateKey&lt;Element&gt; privateKey,\n                                                              ConstCiphertext&lt;Element&gt; ciphertext,\n                                                              ConstCiphertext&lt;Element&gt; a) const {\n        if (m_Multiparty) {\n            return m_Multiparty-&gt;IntMPBootDecrypt(privateKey, ciphertext, a);\n        }\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;IntMPBootDecrypt operation has not been enabled&quot;);\n    }\n\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; IntMPBootAdd(std::vector&lt;std::vector&lt;Ciphertext&lt;Element&gt;&gt;&gt;&amp; sharesPairVec) const {\n        if (m_Multiparty) {\n            return m_Multiparty-&gt;IntMPBootAdd(sharesPairVec);\n        }\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;IntMPBootAdd operation has not been enabled&quot;);\n    }\n\n    Ciphertext&lt;Element&gt; IntMPBootEncrypt(const PublicKey&lt;Element&gt; publicKey,\n                                         const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; sharesPair, ConstCiphertext&lt;Element&gt; a,\n                                         ConstCiphertext&lt;Element&gt; ciphertext) const {\n        if (m_Multiparty) {\n            return m_Multiparty-&gt;IntMPBootEncrypt(publicKey, sharesPair, a, ciphertext);\n        }\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;IntMPBootEncrypt operation has not been enabled&quot;);\n    }\n\n    // FHE METHODS\n\n    // TODO Andrey: do we need this method?\n    //  const std::shared_ptr&lt;PKEBase&lt;Element&gt;&gt; getAlgorithm() const { return m_PKE; }\n\n    void EvalBootstrapSetup(const CryptoContextImpl&lt;Element&gt;&amp; cc, const std::vector&lt;uint32_t&gt;&amp; levelBudget = {5, 4},\n                            const std::vector&lt;uint32_t&gt;&amp; dim1 = {0, 0}, uint32_t slots = 0,\n                            uint32_t correctionFactor = 0) {\n        VerifyFHEEnabled(__func__);\n        m_FHE-&gt;EvalBootstrapSetup(cc, levelBudget, dim1, slots, correctionFactor);\n        return;\n    }\n\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalBootstrapKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                                                           uint32_t slots) {\n        VerifyFHEEnabled(__func__);\n        return m_FHE-&gt;EvalBootstrapKeyGen(privateKey, slots);\n    }\n\n    Ciphertext&lt;Element&gt; EvalBootstrap(ConstCiphertext&lt;Element&gt; ciphertext, uint32_t numIterations = 1,\n                                      uint32_t precision = 0) const {\n        VerifyFHEEnabled(__func__);\n        return m_FHE-&gt;EvalBootstrap(ciphertext, numIterations, precision);\n    }\n\n    // SCHEMESWITCHING methods\n\n    std::pair&lt;BinFHEContext, LWEPrivateKey&gt; EvalCKKStoFHEWSetup(const CryptoContextImpl&lt;Element&gt;&amp; cc,\n                                                                SecurityLevel sl      = HEStd_128_classic,\n                                                                BINFHE_PARAMSET slBin = STD128, bool arbFunc = false,\n                                                                uint32_t logQ = 29, bool dynamic = false,\n                                                                uint32_t numSlotsCKKS = 0, uint32_t logQswitch = 27) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalCKKStoFHEWSetup(cc, sl, slBin, arbFunc, logQ, dynamic, numSlotsCKKS, logQswitch);\n    }\n\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalCKKStoFHEWKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair,\n                                                                            ConstLWEPrivateKey&amp; lwesk,\n                                                                            uint32_t dim1 = 0, uint32_t L = 1) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalCKKStoFHEWKeyGen(keyPair, lwesk, dim1, L);\n    }\n\n    void EvalCKKStoFHEWPrecompute(const CryptoContextImpl&lt;Element&gt;&amp; cc, double scale = 1.0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalCKKStoFHEWPrecompute(cc, scale);\n    }\n\n    std::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt; EvalCKKStoFHEW(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                   uint32_t numCtxts = 0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalCKKStoFHEW(ciphertext, numCtxts);\n    }\n\n    void EvalFHEWtoCKKSSetup(const CryptoContextImpl&lt;DCRTPoly&gt;&amp; ccCKKS, const BinFHEContext&amp; ccLWE,\n                             uint32_t numSlotsCKKS = 0, uint32_t logQ = 25) {\n        VerifySchemeSwitchEnabled(__func__);\n        m_SchemeSwitch-&gt;EvalFHEWtoCKKSSetup(ccCKKS, ccLWE, numSlotsCKKS, logQ);\n        return;\n    }\n\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalFHEWtoCKKSKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair,\n                                                                            ConstLWEPrivateKey&amp; lwesk,\n                                                                            uint32_t numSlots = 0, uint32_t dim1 = 0,\n                                                                            uint32_t L = 0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalFHEWtoCKKSKeyGen(keyPair, lwesk, numSlots, dim1, L);\n    }\n\n    void EvalCompareSwitchPrecompute(const CryptoContextImpl&lt;Element&gt;&amp; ccCKKS, uint32_t pLWE = 0,\n                                     uint32_t initLevel = 0, double scaleSign = 1.0, bool unit = false) {\n        VerifySchemeSwitchEnabled(__func__);\n        m_SchemeSwitch-&gt;EvalCompareSwitchPrecompute(ccCKKS, pLWE, initLevel, scaleSign, unit);\n        return;\n    }\n\n    Ciphertext&lt;Element&gt; EvalFHEWtoCKKS(std::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt;&amp; LWECiphertexts,\n                                       uint32_t numCtxts = 0, uint32_t numSlots = 0, uint32_t p = 4, double pmin = 0.0,\n                                       double pmax = 2.0) const {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalFHEWtoCKKS(LWECiphertexts, numCtxts, numSlots, p, pmin, pmax);\n    }\n\n    std::pair&lt;BinFHEContext, LWEPrivateKey&gt; EvalSchemeSwitchingSetup(const CryptoContextImpl&lt;DCRTPoly&gt;&amp; cc,\n                                                                     SecurityLevel sl      = HEStd_128_classic,\n                                                                     BINFHE_PARAMSET slBin = STD128,\n                                                                     bool arbFunc = false, uint32_t logQ = 29,\n                                                                     bool dynamic = false, uint32_t numSlotsCKKS = 0,\n                                                                     uint32_t logQswitch = 27) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalSchemeSwitchingSetup(cc, sl, slBin, arbFunc, logQ, dynamic, numSlotsCKKS,\n                                                        logQswitch);\n    }\n\n    std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSchemeSwitchingKeyGen(\n        const KeyPair&lt;Element&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk, uint32_t numValues = 0, bool oneHot = true,\n        bool alt = false, uint32_t dim1CF = 0, uint32_t dim1FC = 0, uint32_t LCF = 1, uint32_t LFC = 0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalSchemeSwitchingKeyGen(keyPair, lwesk, numValues, oneHot, alt, dim1CF, dim1FC, LCF,\n                                                         LFC);\n    }\n\n    Ciphertext&lt;Element&gt; EvalCompareSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                   ConstCiphertext&lt;Element&gt; ciphertext2, uint32_t numCtxts = 0,\n                                                   uint32_t numSlots = 0, uint32_t pLWE = 0, double scaleSign = 1.0,\n                                                   bool unit = false) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalCompareSchemeSwitching(ciphertext1, ciphertext2, numCtxts, numSlots, pLWE, scaleSign,\n                                                          unit);\n    }\n\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMinSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                            PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                            uint32_t numSlots = 0, bool oneHot = true,\n                                                            uint32_t pLWE = 0, double scaleSign = 1.0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalMinSchemeSwitching(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE,\n                                                      scaleSign);\n    }\n\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMinSchemeSwitchingAlt(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                               PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                               uint32_t numSlots = 0, bool oneHot = true,\n                                                               uint32_t pLWE = 0, double scaleSign = 1.0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalMinSchemeSwitchingAlt(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE,\n                                                         scaleSign);\n    }\n\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMaxSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                            PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                            uint32_t numSlots = 0, bool oneHot = true,\n                                                            uint32_t pLWE = 0, double scaleSign = 1.0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalMaxSchemeSwitching(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE,\n                                                      scaleSign);\n    }\n\n    std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMaxSchemeSwitchingAlt(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                               PublicKey&lt;Element&gt; publicKey, uint32_t numValues = 0,\n                                                               uint32_t numSlots = 0, bool oneHot = true,\n                                                               uint32_t pLWE = 0, double scaleSign = 1.0) {\n        VerifySchemeSwitchEnabled(__func__);\n        return m_SchemeSwitch-&gt;EvalMaxSchemeSwitchingAlt(ciphertext, publicKey, numValues, numSlots, oneHot, pLWE,\n                                                         scaleSign);\n    }\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::make_nvp(&quot;enabled&quot;, GetEnabled()));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                 &quot; is from a later version of the library&quot;);\n        }\n\n        usint enabled;\n        ar(::cereal::make_nvp(&quot;enabled&quot;, enabled));\n        Enable(enabled);\n    }\n\n    virtual std::string SerializedObjectName() const {\n        return &quot;SchemeBase&quot;;\n    }\n\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\n    //=================================================================================================================\n    // Functions to check enabled features in the cryptocontext\n    //=================================================================================================================\n    /**\n    * @brief VerifyAdvancedSHEEnabled is to check if Enable(ADVANCEDSHE) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyAdvancedSHEEnabled(const std::string&amp; functionName) const {\n        if (m_AdvancedSHE == nullptr) {\n            std::string errMsg = std::string(functionName) +\n                                 &quot; operation has not been enabled. Enable(ADVANCEDSHE) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n    /**\n    * @brief VerifyMultipartyEnabled is to check if Enable(MULTIPARTY) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyMultipartyEnabled(const std::string&amp; functionName) const {\n        if (m_Multiparty == nullptr) {\n            std::string errMsg = std::string(functionName) +\n                                 &quot; operation has not been enabled. Enable(MULTIPARTY) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n    /**\n    * @brief VerifyLeveledSHEEnabled is to check if Enable(LEVELEDSHE) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyLeveledSHEEnabled(const std::string&amp; functionName) const {\n        if (m_LeveledSHE == nullptr) {\n            std::string errMsg = std::string(functionName) +\n                                 &quot; operation has not been enabled. Enable(LEVELEDSHE) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n    /**\n    * @brief VerifyPKEEnabled is to check if Enable(PKE) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyPKEEnabled(const std::string&amp; functionName) const {\n        if (m_PKE == nullptr) {\n            std::string errMsg =\n                std::string(functionName) + &quot; operation has not been enabled. Enable(PKE) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n    /**\n    * @brief VerifyPREEnabled is to check if Enable(PRE) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyPREEnabled(const std::string&amp; functionName) const {\n        if (m_PRE == nullptr) {\n            std::string errMsg =\n                std::string(functionName) + &quot; operation has not been enabled. Enable(PRE) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n    /**\n    * @brief VerifyKeySwitchEnabled is to check if Enable(KEYSWITCH) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyKeySwitchEnabled(const std::string&amp; functionName) const {\n        if (m_KeySwitch == nullptr) {\n            std::string errMsg = std::string(functionName) +\n                                 &quot; operation has not been enabled. Enable(KEYSWITCH) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n    /**\n    * @brief VerifyFHEEnabled is to check if Enable(FHE) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifyFHEEnabled(const std::string&amp; functionName) const {\n        if (m_FHE == nullptr) {\n            std::string errMsg =\n                std::string(functionName) + &quot; operation has not been enabled. Enable(FHE) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n\n    /**\n    * @brief VerifySchemeSwitchEnabled is to check if Enable(SCHEMESWITCH) has been called and if it has not\n    *        it will thow an exception\n    * @param functionName is the calling function name. __func__ can be used instead\n    */\n    inline void VerifySchemeSwitchEnabled(const std::string&amp; functionName) const {\n        if (m_SchemeSwitch == nullptr) {\n            std::string errMsg = std::string(functionName) +\n                                 &quot; operation has not been enabled. Enable(SCHEMESWITCH) must be called to enable it.&quot;;\n            &quot;hey&quot;; OPENFHE_THROW(config_error, errMsg);\n        }\n    }\n\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const SchemeBase&lt;Element&gt;&amp; s) {\n        out &lt;&lt; typeid(s).name() &lt;&lt; &quot;:&quot;;\n        out &lt;&lt; &quot; ParamsGen &quot; &lt;&lt; (s.m_ParamsGen == 0 ? &quot;none&quot; : typeid(*s.m_ParamsGen).name());\n        out &lt;&lt; &quot;, PKE &quot; &lt;&lt; (s.m_PKE == 0 ? &quot;none&quot; : typeid(*s.m_PKE).name());\n        out &lt;&lt; &quot;, KeySwitch &quot; &lt;&lt; (s.m_KeySwitch == 0 ? &quot;none&quot; : typeid(*s.m_KeySwitch).name());\n        out &lt;&lt; &quot;, PRE &quot; &lt;&lt; (s.m_PRE == 0 ? &quot;none&quot; : typeid(*s.m_PRE).name());\n        out &lt;&lt; &quot;, LeveledSHE &quot; &lt;&lt; (s.m_LeveledSHE == 0 ? &quot;none&quot; : typeid(*s.m_LeveledSHE).name());\n        out &lt;&lt; &quot;, AdvancedSHE &quot; &lt;&lt; (s.m_AdvancedSHE == 0 ? &quot;none&quot; : typeid(*s.m_AdvancedSHE).name());\n        out &lt;&lt; &quot;, Multiparty &quot; &lt;&lt; (s.m_Multiparty == 0 ? &quot;none&quot; : typeid(*s.m_Multiparty).name());\n        out &lt;&lt; &quot;, FHE &quot; &lt;&lt; (s.m_FHE == 0 ? &quot;none&quot; : typeid(*s.m_FHE).name());\n        out &lt;&lt; &quot;, SchemeSwitch &quot; &lt;&lt; (s.m_SchemeSwitch == 0 ? &quot;none&quot; : typeid(*s.m_SchemeSwitch).name());\n\n        return out;\n    }\n\nprotected:\n    std::shared_ptr&lt;ParameterGenerationBase&lt;Element&gt;&gt; m_ParamsGen;\n    std::shared_ptr&lt;PKEBase&lt;Element&gt;&gt; m_PKE;\n    std::shared_ptr&lt;KeySwitchBase&lt;Element&gt;&gt; m_KeySwitch;\n    std::shared_ptr&lt;PREBase&lt;Element&gt;&gt; m_PRE;\n    std::shared_ptr&lt;LeveledSHEBase&lt;Element&gt;&gt; m_LeveledSHE;\n    std::shared_ptr&lt;AdvancedSHEBase&lt;Element&gt;&gt; m_AdvancedSHE;\n    std::shared_ptr&lt;MultipartyBase&lt;Element&gt;&gt; m_Multiparty;\n    std::shared_ptr&lt;FHEBase&lt;Element&gt;&gt; m_FHE;\n    std::shared_ptr&lt;FHEBase&lt;Element&gt;&gt; m_SchemeSwitch;\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-advancedshe.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-advancedshe.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-advancedshe.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_BASE_ADVANCEDSHE_H\n#define LBCRYPTO_CRYPTO_BASE_ADVANCEDSHE_H\n\n#include &quot;key/privatekey-fwd.h&quot;\n#include &quot;key/publickey-fwd.h&quot;\n#include &quot;key/evalkey-fwd.h&quot;\n#include &quot;encoding/plaintext-fwd.h&quot;\n#include &quot;ciphertext-fwd.h&quot;\n#include &quot;utils/inttypes.h&quot;\n#include &quot;utils/exception.h&quot;\n\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;map&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\n\n/**\n * @brief Abstract base class for derived HE algorithms\n * @tparam Element a ring element.\n */\ntemplate &lt;class Element&gt;\nclass AdvancedSHEBase {\n    using ParmType = typename Element::Params;\n    using IntType  = typename Element::Integer;\n    using DugType  = typename Element::DugType;\n    using DggType  = typename Element::DggType;\n    using TugType  = typename Element::TugType;\n\npublic:\n    virtual ~AdvancedSHEBase() {}\n\n    /**\n   * Virtual function for evaluating addition of a list of ciphertexts.\n   *\n   * @param ciphertextVec\n   * @return\n   */\n    virtual Ciphertext&lt;Element&gt; EvalAddMany(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const;\n\n    /**\n   * Virtual function for evaluating addition of a list of ciphertexts.\n   * This version uses no additional space, other than the vector provided.\n   *\n   * @param ciphertextVec  is the ciphertext list.\n   * @param *newCiphertext the new resulting ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalAddManyInPlace(std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec) const;\n\n    /**\n   * Virtual function for evaluating multiplication of a ciphertext list which\n   * each multiplication is followed by relinearization operation.\n   *\n   * @param cipherTextList  is the ciphertext list.\n   * @param evalKeys is the evaluation key to make the newCiphertext\n   *  decryptable by the same secret key as that of ciphertext list.\n   * @param *newCiphertext the new resulting ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalMultMany(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                             const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec) const;\n\n    //------------------------------------------------------------------------------\n    // LINEAR WEIGHTED SUM\n    //------------------------------------------------------------------------------\n\n    /**\n   * Virtual function for computing the linear weighted sum of a\n   * vector of ciphertexts.\n   *\n   * @param ciphertexts vector of input ciphertexts.\n   * @param constants vector containing double weights.\n   * @return A ciphertext containing the linear weighted sum.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalLinearWSum(std::vector&lt;ConstCiphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                               const std::vector&lt;double&gt;&amp; weights) const {\n        std::string errMsg = &quot;EvalLinearWSum is not implemented for this scheme.&quot;;\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, errMsg);\n    }\n\n    /**\n   * Function for computing the linear weighted sum of a\n   * vector of ciphertexts. This is a mutable method,\n   * meaning that the level/depth of input ciphertexts may change.\n   *\n   * @param ciphertexts vector of input ciphertexts.\n   * @param constants vector containing double weights.\n   * @return A ciphertext containing the linear weighted sum.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalLinearWSumMutable(std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                                      const std::vector&lt;double&gt;&amp; weights) const {\n        std::string errMsg = &quot;EvalLinearWSumMutable is not implemented for this scheme.&quot;;\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, errMsg);\n    }\n\n    //------------------------------------------------------------------------------\n    // EVAL POLYNOMIAL\n    //------------------------------------------------------------------------------\n\n    /**\n   * Method for polynomial evaluation for polynomials represented in the power\n   * series. This uses a binary tree computation of\n   * the polynomial powers.\n   *\n   * @param &amp;cipherText input ciphertext\n   * @param &amp;coefficients is the vector of coefficients in the polynomial; the\n   * size of the vector is the degree of the polynomial + 1\n   * @return the result of polynomial evaluation.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalPoly(ConstCiphertext&lt;Element&gt; ciphertext,\n                                         const std::vector&lt;double&gt;&amp; coefficients) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;EvalPoly is not supported for the scheme.&quot;);\n    }\n\n    /**\n   * Method for polynomial evaluation for polynomials represented in the power\n   * series. This uses a binary tree computation of\n   * the polynomial powers.\n   *\n   * @param &amp;cipherText input ciphertext\n   * @param &amp;coefficients is the vector of coefficients in the polynomial; the\n   * size of the vector is the degree of the polynomial + 1\n   * @return the result of polynomial evaluation.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalPolyLinear(ConstCiphertext&lt;Element&gt; ciphertext,\n                                               const std::vector&lt;double&gt;&amp; coefficients) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;EvalPolyLinear is not supported for the scheme.&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalPolyPS(ConstCiphertext&lt;Element&gt; x, const std::vector&lt;double&gt;&amp; coefficients) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;EvalPolyPS is not supported for the scheme.&quot;);\n    }\n\n    //------------------------------------------------------------------------------\n    // EVAL CHEBYSHEV SERIES\n    //------------------------------------------------------------------------------\n\n    /**\n   * Method for evaluating Chebyshev polynomial interpolation;\n   * first the range [a,b] is mapped to [-1,1] using linear transformation 1 + 2\n   * (x-a)/(b-a) If the degree of the polynomial is less than 5, use\n   * EvalChebyshevSeriesLinear, otherwise, use EvalChebyshevSeriesPS.\n   *\n   * @param &amp;cipherText input ciphertext\n   * @param &amp;coefficients is the vector of coefficients in Chebyshev expansion\n   * @param a - lower bound of argument for which the coefficients were found\n   * @param b - upper bound of argument for which the coefficients were found\n   * @return the result of polynomial evaluation.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalChebyshevSeries(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                    const std::vector&lt;double&gt;&amp; coefficients, double a, double b) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;EvalChebyshevSeries is not supported for the scheme.&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalChebyshevSeriesLinear(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                          const std::vector&lt;double&gt;&amp; coefficients, double a,\n                                                          double b) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;EvalChebyshevSeriesLinear is not supported for the scheme.&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalChebyshevSeriesPS(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                      const std::vector&lt;double&gt;&amp; coefficients, double a,\n                                                      double b) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;EvalChebyshevSeriesPS is not supported for the scheme.&quot;);\n    }\n\n    //------------------------------------------------------------------------------\n    // Advanced SHE EVAL SUM\n    //------------------------------------------------------------------------------\n\n    /**\n   * Virtual function to generate the automorphism keys for EvalSum; works\n   * only for packed encoding\n   *\n   * @param privateKey private key.\n   * @return returns the evaluation keys\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSumKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                                                             const PublicKey&lt;Element&gt; publicKey) const;\n\n    /**\n   * Virtual function to generate the automorphism keys for EvalSumRows; works\n   * only for packed encoding\n   *\n   * @param privateKey private key.\n   * @param publicKey public key.\n   * @param rowSize size of rows in the matrix\n   * @param subringDim subring dimension (set to cyclotomic order if set to 0)\n   * @return returns the evaluation keys\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSumRowsKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                                                                 const PublicKey&lt;Element&gt; publicKey,\n                                                                                 usint rowSize, usint subringDim) const;\n\n    /**\n   * Virtual function to generate the automorphism keys for EvalSumCols; works\n   * only for packed encoding\n   *\n   * @param privateKey private key.\n   * @param publicKey public key.\n   * @return returns the evaluation keys\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSumColsKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const PublicKey&lt;Element&gt; publicKey) const;\n\n    /**\n   * Sums all elements in log (batch size) time - works only with packed\n   * encoding\n   *\n   * @param ciphertext the input ciphertext.\n   * @param batchSize size of the batch to be summed up\n   * @param &amp;evalKeys - reference to the map of evaluation keys generated by\n   * EvalAutomorphismKeyGen.\n   * @return resulting ciphertext\n   */\n    virtual Ciphertext&lt;Element&gt; EvalSum(ConstCiphertext&lt;Element&gt; ciphertext, usint batchSize,\n                                        const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalSumKeyMap) const;\n\n    /**\n   * Sums all elements over row-vectors in a matrix - works only with packed\n   * encoding\n   *\n   * @param ciphertext the input ciphertext.\n   * @param rowSize size of rows in the matrix\n   * @param &amp;evalKeys - reference to the map of evaluation keys generated by\n   * @param subringDim the current cyclotomic order/subring dimension. If set to\n   * 0, we use the full cyclotomic order. EvalAutomorphismKeyGen.\n   * @return resulting ciphertext\n   */\n    virtual Ciphertext&lt;Element&gt; EvalSumRows(ConstCiphertext&lt;Element&gt; ciphertext, usint rowSize,\n                                            const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalSumRowsKeyMap,\n                                            usint subringDim) const;\n\n    /**\n   * Sums all elements over column-vectors in a matrix - works only with\n   * packed encoding\n   *\n   * @param ciphertext the input ciphertext.\n   * @param rowSize size of rows in the matrixs\n   * @param &amp;evalKeys - reference to the map of evaluation keys generated by\n   * EvalAutomorphismKeyGen.\n   * @return resulting ciphertext\n   */\n    virtual Ciphertext&lt;Element&gt; EvalSumCols(ConstCiphertext&lt;Element&gt; ciphertext, usint batchSize,\n                                            const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalSumColsKeyMap,\n                                            const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; rightEvalKeys) const;\n\n    //------------------------------------------------------------------------------\n    // Advanced SHE EVAL INNER PRODUCT\n    //------------------------------------------------------------------------------\n\n    /**\n   * Evaluates inner product in batched encoding\n   *\n   * @param ciphertext1 first vector.\n   * @param ciphertext2 second vector.\n   * @param batchSize size of the batch to be summed up\n   * @param &amp;evalSumKeys - reference to the map of evaluation keys generated\n   * by EvalAutomorphismKeyGen.\n   * @param &amp;evalMultKey - reference to the evaluation key generated by\n   * EvalMultKeyGen.\n   * @return resulting ciphertext\n   */\n    virtual Ciphertext&lt;Element&gt; EvalInnerProduct(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                 ConstCiphertext&lt;Element&gt; ciphertext2, usint batchSize,\n                                                 const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap,\n                                                 const EvalKey&lt;Element&gt; evalMultKey) const;\n\n    /**\n   * Evaluates inner product in batched encoding\n   *\n   * @param ciphertext1 first vector.\n   * @param plaintext plaintext.\n   * @param batchSize size of the batch to be summed up\n   * @param &amp;evalSumKeys - reference to the map of evaluation keys generated\n   * by EvalAutomorphismKeyGen.\n   * @param &amp;evalMultKey - reference to the evaluation key generated by\n   * EvalMultKeyGen.\n   * @return resulting ciphertext\n   */\n    virtual Ciphertext&lt;Element&gt; EvalInnerProduct(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext,\n                                                 usint batchSize,\n                                                 const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap) const;\n\n    /**\n   * Function to add random noise to all plaintext slots except for the first\n   * one; used in EvalInnerProduct\n   *\n   * @param &amp;ciphertext the input ciphertext.\n   * @return modified ciphertext\n   */\n    virtual Ciphertext&lt;Element&gt; AddRandomNoise(ConstCiphertext&lt;Element&gt; ciphertext) const;\n\n    /**\n   * Merges multiple ciphertexts with encrypted results in slot 0 into a\n   * single ciphertext The slot assignment is done based on the order of\n   * ciphertexts in the vector\n   *\n   * @param ciphertextVector vector of ciphertexts to be merged.\n   * @param &amp;evalKeys - reference to the map of evaluation keys generated by\n   * EvalAutomorphismKeyGen.\n   * @return resulting ciphertext\n   */\n    virtual Ciphertext&lt;Element&gt; EvalMerge(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVector,\n                                          const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap) const;\n\n    //------------------------------------------------------------------------------\n    // LINEAR TRANSFORMATION\n    //------------------------------------------------------------------------------\n\n    //------------------------------------------------------------------------------\n    // Other Methods for Bootstrap\n    //------------------------------------------------------------------------------\n\nprotected:\n    std::vector&lt;usint&gt; GenerateIndices_2n(usint batchSize, usint m) const;\n\n    std::vector&lt;usint&gt; GenerateIndices2nComplex(usint batchSize, usint m) const;\n\n    std::vector&lt;usint&gt; GenerateIndices2nComplexRows(usint rowSize, usint m) const;\n\n    std::vector&lt;usint&gt; GenerateIndices2nComplexCols(usint batchSize, usint m) const;\n\n    Ciphertext&lt;Element&gt; EvalSum_2n(ConstCiphertext&lt;Element&gt; ciphertext, usint batchSize, usint m,\n                                   const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap) const;\n\n    Ciphertext&lt;Element&gt; EvalSum2nComplex(ConstCiphertext&lt;Element&gt; ciphertext, usint batchSize, usint m,\n                                         const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap) const;\n\n    Ciphertext&lt;Element&gt; EvalSum2nComplexRows(ConstCiphertext&lt;Element&gt; ciphertext, usint rowSize, usint m,\n                                             const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap) const;\n\n    Ciphertext&lt;Element&gt; EvalSum2nComplexCols(ConstCiphertext&lt;Element&gt; ciphertext, usint batchSize, usint m,\n                                             const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap) const;\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_BASE_LEVELEDSHE_H\n#define LBCRYPTO_CRYPTO_BASE_LEVELEDSHE_H\n\n#include &quot;lattice/lat-hal.h&quot;\n#include &quot;key/publickey-fwd.h&quot;\n#include &quot;key/privatekey-fwd.h&quot;\n#include &quot;key/evalkey-fwd.h&quot;\n#include &quot;encoding/plaintext-fwd.h&quot;\n#include &quot;ciphertext-fwd.h&quot;\n#include &quot;utils/caller_info.h&quot;\n#include &quot;utils/inttypes.h&quot;\n#include &quot;utils/exception.h&quot;\n\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\n/**\n * @brief Abstract interface class for LBC SHE algorithms\n * @tparam Element a ring element.\n */\ntemplate &lt;class Element&gt;\nclass LeveledSHEBase {\n    using ParmType = typename Element::Params;\n    using IntType  = typename Element::Integer;\n    using DugType  = typename Element::DugType;\n    using DggType  = typename Element::DggType;\n    using TugType  = typename Element::TugType;\n\npublic:\n    virtual ~LeveledSHEBase() {}\n\n    /////////////////////////////////////////\n    // SHE NEGATION\n    /////////////////////////////////////////\n\n    /**\n   * Virtual function to define the homomorphic negation of\n   * ciphertext.\n   *\n   * @param &amp;ciphertext the input ciphertext.\n   * @return new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalNegate(ConstCiphertext&lt;Element&gt; ciphertext) const;\n\n    /**\n   * Virtual function to define the interface for homomorphic negation of\n   * ciphertext.\n   *\n   * @param &amp;ciphertext the input ciphertext.\n   * @return new ciphertext.\n   */\n    virtual void EvalNegateInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext) const;\n\n    /////////////////////////////////////////\n    // SHE ADDITION\n    /////////////////////////////////////////\n\n    /**\n   * Virtual function to define the interface for homomorphic addition of\n   * ciphertexts.\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                        ConstCiphertext&lt;Element&gt; ciphertext2) const;\n\n    /**\n   * Virtual function to define the interface for in-place homomorphic addition\n   * of ciphertexts.\n   *\n   * @param ciphertext1 the input/output ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   */\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const;\n\n    /**\n   * Virtual function to define the interface for homomorphic addition of\n   * ciphertexts. This is the mutable version - input ciphertexts may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalAddMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1,\n                                               Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalAddMutable is not implemented for this scheme&quot;);\n    }\n\n    virtual void EvalAddMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalAddMutable is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the interface for homomorphic addition of\n   * ciphertexts.\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const;\n\n    /**\n   * Virtual function to define the interface for homomorphic addition of\n   * ciphertexts.\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   */\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, ConstPlaintext plaintext) const;\n\n    /**\n   * Virtual function to define the interface for homomorphic addition of\n   * ciphertexts. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalAddMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalAddMutable is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the interface for homomorphic addition of\n   * ciphertexts. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    virtual void EvalAddMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalAddMutable is not implemented for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, const NativeInteger&amp; constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;integer scalar addition is not implemented for this scheme&quot;);\n    }\n\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const NativeInteger&amp; constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;integer scalar addition is not implemented for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalAdd(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;double scalar addition is not implemented for this scheme&quot;);\n    }\n\n    virtual void EvalAddInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;double scalar addition is not implemented for this scheme&quot;);\n    }\n\n    /////////////////////////////////////////\n    // SHE SUBTRACTION\n    /////////////////////////////////////////\n\n    /**\n   * Virtual function to define the interface for homomorphic subtraction of\n   * ciphertexts.\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                        ConstCiphertext&lt;Element&gt; ciphertext2) const;\n\n    /**\n   * Virtual function to define the interface for homomorphic subtraction of\n   * ciphertexts.\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   */\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const;\n\n    /**\n   * Virtual function to define the interface for homomorphic subtraction of\n   * ciphertexts. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalSubMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1,\n                                               Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalSubMutable is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the interface for homomorphic subtraction of\n   * ciphertexts. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    virtual void EvalSubMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalSubMutable is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the interface for homomorphic subtraction of\n   * ciphertexts.\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const;\n\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, ConstPlaintext plaintext) const;\n\n    /**\n   * Virtual function to define the interface for homomorphic subtraction of\n   * ciphertexts. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalSubMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalSubMutable is not implemented for this scheme&quot;);\n    }\n\n    virtual void EvalSubMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalSubMutable is not implemented for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, const NativeInteger&amp; constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;integer scalar subtraction is not implemented for this scheme&quot;);\n    }\n\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const NativeInteger&amp; constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;integer scalar subtraction is not implemented for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalSub(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;double scalar subtraction is not implemented for this scheme&quot;);\n    }\n\n    virtual void EvalSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;double scalar subtraction is not implemented for this scheme&quot;);\n    }\n\n    //------------------------------------------------------------------------------\n    // SHE MULTIPLICATION\n    //------------------------------------------------------------------------------\n\n    /**\n   * Virtual function to define the interface for generating a evaluation key\n   * which is used after each multiplication.\n   *\n   * @param &amp;ciphertext1 first input ciphertext.\n   * @param &amp;ciphertext2 second input ciphertext.\n   * @param &amp;ek is the evaluation key to make the newCiphertext decryptable by\n   * the same secret key as that of ciphertext1 and ciphertext2.\n   * @param *newCiphertext the new resulting ciphertext.\n   */\n    virtual EvalKey&lt;Element&gt; EvalMultKeyGen(const PrivateKey&lt;Element&gt; privateKey) const;\n\n    /**\n   * Virtual function to define the interface for generating a evaluation key\n   * which is used after each multiplication for depth more than 2.\n   *\n   * @param &amp;originalPrivateKey Original private key used for encryption.\n   * @param *evalMultKeys the resulting evalution key vector list.\n   */\n    virtual std::vector&lt;EvalKey&lt;Element&gt;&gt; EvalMultKeysGen(const PrivateKey&lt;Element&gt; privateKey) const;\n\n    //------------------------------------------------------------------------------\n    // EVAL MULTIPLICATION CIPHERTEXT &amp; CIPHERTEXT\n    //------------------------------------------------------------------------------\n\n    /**\n   * Virtual function to define the interface for multiplicative homomorphic\n   * evaluation of ciphertext.\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                         ConstCiphertext&lt;Element&gt; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalMult is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the interface for multiplicative homomorphic\n   * evaluation of ciphertext. This is the mutable version - input ciphertexts\n   * may change (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalMultMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1,\n                                                Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalMultMutable is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the interface for multiplicative homomorphic\n   * evaluation of ciphertext.\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalSquare(ConstCiphertext&lt;Element&gt; ciphertext1) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalSquare is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the interface for multiplicative homomorphic\n   * evaluation of ciphertext. This is the mutable version - input ciphertexts\n   * may change (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalSquareMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalSquareMutable is not implemented for this scheme&quot;);\n    }\n\n    //------------------------------------------------------------------------------\n    // EVAL MULTIPLICATION CIPHERTEXT &amp; PLAINTEXT\n    //------------------------------------------------------------------------------\n\n    /**\n   * Virtual function to define the interface for multiplication of ciphertext\n   * by plaintext.\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext, ConstPlaintext plaintext) const;\n\n    virtual void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, ConstPlaintext plaintext) const;\n\n    /**\n   * Virtual function to define the interface for multiplication of ciphertext\n   * by plaintext. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalMultMutable(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalMultMutable C,P is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the interface for multiplication of ciphertext\n   * by plaintext. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    virtual void EvalMultMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, Plaintext plaintext) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalMultMutableInPlace C P is not implemented for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; MultByMonomial(ConstCiphertext&lt;Element&gt; ciphertext, usint power) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;MultByMonomial is not implemented for this scheme&quot;);\n    }\n\n    virtual void MultByMonomialInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, usint power) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;MultByMonomialInPlace is not implemented for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext, const NativeInteger&amp; constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;integer scalar multiplication is not implemented for this scheme&quot;);\n    }\n\n    virtual void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const NativeInteger&amp; constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;integer scalar multiplication is not implemented for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext, double constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;double scalar multiplication is not implemented for this scheme&quot;);\n    }\n\n    virtual void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, double constant) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;double scalar multiplication is not implemented for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;DCRTPoly&gt; MultByInteger(ConstCiphertext&lt;DCRTPoly&gt; ciphertext, uint64_t integer) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;MultByInteger is not implemented for this scheme&quot;);\n    }\n\n    virtual void MultByIntegerInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, uint64_t integer) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;MultByIntegerInPlace is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the interface for multiplicative homomorphic\n   * evaluation of ciphertext using the evaluation key.\n   *\n   * @param &amp;ciphertext1 first input ciphertext.\n   * @param &amp;ciphertext2 second input ciphertext.\n   * @param &amp;ek is the evaluation key to make the newCiphertext decryptable by\n   * the same secret key as that of ciphertext1 and ciphertext2.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalMult(ConstCiphertext&lt;Element&gt; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2,\n                                         const EvalKey&lt;Element&gt; evalKey) const;\n\n    virtual void EvalMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2,\n                                 const EvalKey&lt;Element&gt; evalKey) const;\n\n    /**\n   * Virtual function to define the interface for multiplicative homomorphic\n   * evaluation of ciphertext using the evaluation key. This is the mutable\n   * version - input ciphertext may change (automatically rescaled, or towers\n   * dropped).\n   *\n   * @param &amp;ciphertext1 first input ciphertext.\n   * @param &amp;ciphertext2 second input ciphertext.\n   * @param &amp;ek is the evaluation key to make the newCiphertext decryptable by\n   * the same secret key as that of ciphertext1 and ciphertext2.\n   * @return the new ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalMultMutable(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2,\n                                                const EvalKey&lt;Element&gt; evalKey) const;\n\n    /**\n   * Virtual function to define the interface for multiplicative homomorphic\n   * evaluation of ciphertext using the evaluation key. This is the mutable\n   * version - input ciphertext may change (automatically rescaled, or towers\n   * dropped).\n   *\n   * @param &amp;ciphertext1 first input ciphertext.\n   * @param &amp;ciphertext2 second input ciphertext.\n   * @param &amp;ek is the evaluation key to make the newCiphertext decryptable by\n   * the same secret key as that of ciphertext1 and ciphertext2.\n   * @return the new ciphertext.\n   */\n    virtual void EvalMultMutableInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2,\n                                        const EvalKey&lt;Element&gt; evalKey) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalSquare(ConstCiphertext&lt;Element&gt; ciphertext, const EvalKey&lt;Element&gt; evalKey) const;\n\n    virtual void EvalSquareInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, const EvalKey&lt;Element&gt; evalKey) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalSquareMutable(Ciphertext&lt;Element&gt;&amp; ciphertext,\n                                                  const EvalKey&lt;Element&gt; evalKey) const;\n    /**\n   * Virtual function to define the interface for multiplicative homomorphic\n   * evaluation of ciphertext using the evaluation key.\n   *\n   * @param ct1 first input ciphertext.\n   * @param ct2 second input ciphertext.\n   * @param ek is the evaluation key to make the newCiphertext\n   *  decryptable by the same secret key as that of ciphertext1 and\n   * ciphertext2.\n   * @param *newCiphertext the new resulting ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalMultAndRelinearize(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                       ConstCiphertext&lt;Element&gt; ciphertext2,\n                                                       const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec) const;\n\n    /**\n   * Virtual function to do relinearization\n   *\n   * @param ciphertext input ciphertext.\n   * @param ek are the evaluation keys to make the newCiphertext\n   *  decryptable by the same secret key as that of ciphertext1 and\n   * ciphertext2.\n   * @return the new resulting ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; Relinearize(ConstCiphertext&lt;Element&gt; ciphertext,\n                                            const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec) const;\n\n    /**\n   * Virtual function to do relinearization\n   *\n   * @param ciphertext input ciphertext.\n   * @param ek are the evaluation keys to make the newCiphertext\n   *  decryptable by the same secret key as that of ciphertext1 and\n   * ciphertext2.\n   * @return the new resulting ciphertext.\n   */\n    virtual void RelinearizeInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext,\n                                    const std::vector&lt;EvalKey&lt;Element&gt;&gt;&amp; evalKeyVec) const;\n\n    //------------------------------------------------------------------------------\n    // SHE AUTOMORPHISM\n    //------------------------------------------------------------------------------\n\n    /**\n   * Virtual function to generate automophism keys for a given private key;\n   * Uses the private key for encryption\n   *\n   * @param privateKey private key.\n   * @param indexList list of automorphism indices to be computed\n   * @return returns the evaluation keys\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalAutomorphismKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::vector&lt;usint&gt;&amp; indexList) const;\n\n    /**\n   * Virtual function to generate all isomorphism keys for a given private key\n   *\n   * @param publicKey encryption key for the new ciphertext.\n   * @param origPrivateKey original private key used for decryption.\n   * @param indexList list of automorphism indices to be computed\n   * @return returns the evaluation keys\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalAutomorphismKeyGen(\n        const PublicKey&lt;Element&gt; publicKey, const PrivateKey&lt;Element&gt; privateKey,\n        const std::vector&lt;usint&gt;&amp; indexList) const {\n        std::string errMsg = &quot;EvalAutomorphismKeyGen is not implemented for this scheme.&quot;;\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, errMsg);\n    }\n\n    /**\n   * Virtual function for evaluating automorphism of ciphertext at index i\n   *\n   * @param ciphertext the input ciphertext.\n   * @param i automorphism index\n   * @param &amp;evalKeys - reference to the vector of evaluation keys generated\n   * by EvalAutomorphismKeyGen.\n   * @return resulting ciphertext\n   */\n    virtual Ciphertext&lt;Element&gt; EvalAutomorphism(ConstCiphertext&lt;Element&gt; ciphertext, usint i,\n                                                 const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap,\n                                                 CALLER_INFO_ARGS_HDR) const;\n\n    /**\n   * Virtual function for the automorphism and key switching step of\n   * hoisted automorphisms.\n   *\n   * @param ct the input ciphertext to perform the automorphism on\n   * @param index the index of the rotation. Positive indices correspond to\n   * left rotations and negative indices correspond to right rotations.\n   * @param m is the cyclotomic order\n   * @param digits the digit decomposition created by\n   * EvalFastRotationPrecompute at the precomputation step.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalFastRotation(ConstCiphertext&lt;Element&gt; ciphertext, const usint index, const usint m,\n                                                 const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; digits) const;\n\n    /**\n   * Virtual function for the precomputation step of hoisted\n   * automorphisms.\n   *\n   * @param ct the input ciphertext on which to do the precomputation (digit\n   * decomposition)\n   */\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; EvalFastRotationPrecompute(ConstCiphertext&lt;Element&gt; ciphertext) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalFastRotationExt(ConstCiphertext&lt;Element&gt; ciphertext, usint index,\n                                                    const std::shared_ptr&lt;std::vector&lt;Element&gt;&gt; expandedCiphertext,\n                                                    bool addFirst,\n                                                    const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeys) const {\n        std::string errMsg = &quot;EvalFastRotationExt is not implemented for this scheme.&quot;;\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, errMsg);\n    }\n\n    /**\n   * Generates evaluation keys for a list of indices\n   * Currently works only for power-of-two and cyclic-group cyclotomics\n   *\n   * @param publicKey encryption key for the new ciphertext.\n   * @param origPrivateKey original private key used for decryption.\n   * @param indexList list of indices to be computed\n   * @return returns the evaluation keys\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalAtIndexKeyGen(\n        const PublicKey&lt;Element&gt; publicKey, const PrivateKey&lt;Element&gt; privateKey,\n        const std::vector&lt;int32_t&gt;&amp; indexList) const;\n\n    /**\n   * Moves i-th slot to slot 0\n   *\n   * @param ciphertext.\n   * @param i the index.\n   * @param &amp;evalAtIndexKeys - reference to the map of evaluation keys\n   * generated by EvalAtIndexKeyGen.\n   * @return resulting ciphertext\n   */\n    virtual Ciphertext&lt;Element&gt; EvalAtIndex(ConstCiphertext&lt;Element&gt; ciphertext, int32_t index,\n                                            const std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&amp; evalKeyMap) const;\n\n    virtual usint FindAutomorphismIndex(usint index, usint m) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;FindAutomorphismIndex is not supported for this scheme&quot;);\n    }\n\n    /////////////////////////////////////////\n    // SHE LEVELED Mod Reduce\n    /////////////////////////////////////////\n\n    /**\n   * Method for Modulus Reduction.\n   *\n   * @param &amp;cipherText Ciphertext to perform mod reduce on.\n   * @param levels the number of towers to drop.\n   */\n    virtual Ciphertext&lt;Element&gt; ModReduce(ConstCiphertext&lt;Element&gt; ciphertext, size_t levels) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ModReduce is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Method for In-place Modulus Reduction.\n   *\n   * @param &amp;cipherText Ciphertext to perform mod reduce on.\n   * @param levels the number of towers to drop.\n   */\n    virtual void ModReduceInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, size_t levels) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ModReduce is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Method for Composed EvalMult\n   *\n   * @param &amp;cipherText1 ciphertext1, first input ciphertext to perform\n   * multiplication on.\n   * @param &amp;cipherText2 cipherText2, second input ciphertext to perform\n   * multiplication on.\n   * @param &amp;quadKeySwitchHint is for resultant quadratic secret key after\n   * multiplication to the secret key of the particular level.\n   * @param &amp;cipherTextResult is the resulting ciphertext that can be\n   * decrypted with the secret key of the particular level.\n   */\n    virtual Ciphertext&lt;Element&gt; ComposedEvalMult(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                 ConstCiphertext&lt;Element&gt; ciphertext2,\n                                                 const EvalKey&lt;Element&gt; evalKey) const;\n\n    /**\n   * Method for Level Reduction from sk -&gt; sk1. This method peforms a\n   * keyswitch on the ciphertext and then performs a modulus reduction.\n   *\n   * @param &amp;cipherText1 is the original ciphertext to be key switched and mod\n   * reduced.\n   * @param &amp;linearKeySwitchHint is the linear key switch hint to perform the\n   * key switch operation.\n   * @param &amp;cipherTextResult is the resulting ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; LevelReduce(ConstCiphertext&lt;Element&gt; ciphertext1, const EvalKey&lt;Element&gt; evalKey,\n                                            size_t levels) const;\n\n    /**\n   * Method for Level Reduction from sk -&gt; sk1. This method peforms a\n   * keyswitch on the ciphertext and then performs a modulus reduction.\n   *\n   * @param &amp;cipherText1 is the original ciphertext to be key switched and mod\n   * reduced.\n   * @param &amp;linearKeySwitchHint is the linear key switch hint to perform the\n   * key switch operation.\n   * @param &amp;cipherTextResult is the resulting ciphertext.\n   */\n    virtual void LevelReduceInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, const EvalKey&lt;Element&gt; evalKey,\n                                    size_t levels) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;LevelReduceInPlace is not supported for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; Compress(ConstCiphertext&lt;Element&gt; ciphertext, size_t towersLeft) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Compress is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Method for rescaling.\n   *\n   * @param cipherText is the ciphertext to perform modreduce on.\n   * @param levels the number of towers to drop.\n   * @return ciphertext after the modulus reduction performed.\n   */\n    virtual Ciphertext&lt;Element&gt; ModReduceInternal(ConstCiphertext&lt;Element&gt; ciphertext, size_t levels) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ModReduce is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Method for rescaling in-place.\n   *\n   * @param cipherText is the ciphertext to perform modreduce on.\n   * @param levels the number of towers to drop.\n   * @details \\p cipherText will have modulus reduction performed in-place.\n   */\n    virtual void ModReduceInternalInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, size_t levels) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ModReduce is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Method for Level Reduction in the CKKS scheme. It just drops &quot;levels&quot;\n   * number of the towers of the ciphertext without changing the underlying\n   * plaintext.\n   *\n   * @param cipherText1 is the original ciphertext to be level reduced.\n   * @param levels the number of towers to drop.\n   * @return resulting ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; LevelReduceInternal(ConstCiphertext&lt;Element&gt; ciphertext, size_t levels) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;LevelReduce is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Method for in-place Level Reduction in the CKKS scheme. It just drops\n   * &quot;levels&quot; number of the towers of the ciphertext without changing the\n   * underlying plaintext.\n   *\n   * @param cipherText1 is the ciphertext to be level reduced in-place\n   * @param levels the number of towers to drop.\n   */\n    virtual void LevelReduceInternalInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, size_t levels) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;LevelReduce is not supported for this scheme&quot;);\n    }\n\n    virtual void AdjustLevelsInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Leveled Operations are not supported for this scheme&quot;);\n    }\n\n    virtual void AdjustLevelsAndDepthInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Mutable Operations are not supported for this scheme&quot;);\n    }\n\n    virtual void AdjustLevelsAndDepthToOneInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1,\n                                                  Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Mutable Operations are not supported for this scheme&quot;);\n    }\n\n    // TODO (Andrey) : Move these functions to protected or to rns?\n    virtual void AdjustForAddOrSubInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Mutable Operations are not supported for this scheme&quot;);\n    }\n\n    virtual void AdjustForMultInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, Ciphertext&lt;Element&gt;&amp; ciphertext2) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Mutable Operations are not supported for this scheme&quot;);\n    }\n\n    virtual Ciphertext&lt;Element&gt; MorphPlaintext(ConstPlaintext plaintext, ConstCiphertext&lt;Element&gt; ciphertext) const;\n\nprotected:\n    /////////////////////////////////////////\n    // CORE OPERATIONS\n    /////////////////////////////////////////\n\n    /**\n   * Internal function for in-place homomorphic addition of ciphertexts.\n   * This method does not check whether input ciphertexts are\n   * at the same level.\n   *\n   * @param ciphertext1 first input/output ciphertext.\n   * @param ciphertext2 second input ciphertext.\n   * @return \\p ciphertext1 contains the result of the homomorphic addition of\n   * input ciphertexts.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalAddCore(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                            ConstCiphertext&lt;Element&gt; ciphertext2) const;\n\n    /**\n   * Internal function for in-place homomorphic addition of ciphertexts.\n   * This method does not check whether input ciphertexts are\n   * at the same level.\n   *\n   * @param ciphertext1 first input/output ciphertext.\n   * @param ciphertext2 second input ciphertext.\n   * @return \\p ciphertext1 contains the result of the homomorphic addition of\n   * input ciphertexts.\n   */\n    void EvalAddCoreInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalSubCore(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                            ConstCiphertext&lt;Element&gt; ciphertext2) const;\n\n    /**\n   * Internal function for in-place homomorphic addition of ciphertexts.\n   * This method does not check whether input ciphertexts are\n   * at the same level.\n   *\n   * @param ciphertext1 first input/output ciphertext.\n   * @param ciphertext2 second input ciphertext.\n   * @return \\p ciphertext1 contains the result of the homomorphic addition of\n   * input ciphertexts.\n   */\n    void EvalSubCoreInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const;\n\n    /**\n   * Internal function for homomorphic multiplication of ciphertexts.\n   * This method does not check whether input ciphertexts are\n   * at the same level.\n   *\n   * @param ciphertext1 first input ciphertext.\n   * @param ciphertext2 second input ciphertext.\n   * @return result of homomorphic multiplication of input ciphertexts.\n   */\n    Ciphertext&lt;Element&gt; EvalMultCore(ConstCiphertext&lt;Element&gt; ciphertext1, ConstCiphertext&lt;Element&gt; ciphertext2) const;\n\n    Ciphertext&lt;Element&gt; EvalSquareCore(ConstCiphertext&lt;Element&gt; ciphertext) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalAddCore(ConstCiphertext&lt;Element&gt; ciphertext, const Element plaintext) const;\n\n    void EvalAddCoreInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const Element plaintext) const;\n\n    virtual Ciphertext&lt;Element&gt; EvalSubCore(ConstCiphertext&lt;Element&gt; ciphertext1, const Element plaintext) const;\n\n    void EvalSubCoreInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext1, const Element plaintext) const;\n\n    Ciphertext&lt;Element&gt; EvalMultCore(ConstCiphertext&lt;Element&gt; ciphertext, const Element plaintext) const;\n\n    void EvalMultCoreInPlace(Ciphertext&lt;Element&gt;&amp; ciphertext, const Element plaintext) const;\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_RNS_CRYPTOPARAMETERS_H\n#define LBCRYPTO_CRYPTO_RNS_CRYPTOPARAMETERS_H\n\n#include &quot;lattice/lat-hal.h&quot;\n\n#include &quot;schemebase/rlwe-cryptoparameters.h&quot;\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\n\n/**\n * @brief main implementation class to capture essential cryptoparameters of\n * any LBC system.\n * As CryptoParametersRNS is not an abstract class and we don&#x27;t want to\n * instantiate, then we make all its constructors and the destructor protected\n * @tparam Element a ring element.\n */\nclass CryptoParametersRNS : public CryptoParametersRLWE&lt;DCRTPoly&gt; {\n    using ParmType = typename DCRTPoly::Params;\n\nprotected:\n    CryptoParametersRNS()\n        : CryptoParametersRLWE&lt;DCRTPoly&gt;(),\n          m_ksTechnique(BV),\n          m_scalTechnique(FIXEDMANUAL),\n          m_encTechnique(STANDARD),\n          m_multTechnique(HPS),\n          m_MPIntBootCiphertextCompressionLevel(SLACK) {}\n\n    CryptoParametersRNS(const CryptoParametersRNS&amp; rhs)\n        : CryptoParametersRLWE&lt;DCRTPoly&gt;(rhs),\n          m_ksTechnique(rhs.m_ksTechnique),\n          m_scalTechnique(rhs.m_scalTechnique),\n          m_encTechnique(rhs.m_encTechnique),\n          m_multTechnique(rhs.m_multTechnique),\n          m_MPIntBootCiphertextCompressionLevel(rhs.m_MPIntBootCiphertextCompressionLevel) {}\n\n    /**\n   * Constructor that initializes values.  Note that it is possible to set\n   * parameters in a way that is overall infeasible for actual use. There are\n   * fewer degrees of freedom than parameters provided.  Typically one chooses\n   * the basic noise, assurance and security parameters as the typical\n   * community-accepted values, then chooses the plaintext modulus and depth\n   * as needed.  The element parameters should then be choosen to provide\n   * correctness and security.  In some cases we would need to operate over\n   * already encrypted/provided ciphertext and the depth needs to be\n   * pre-computed for initial settings.\n   *\n   * @param params element parameters.\n   * @param &amp;plaintextModulus plaintext modulus.\n   * @param distributionParameter noise distribution parameter.\n   * @param assuranceMeasure assurance level.\n   * @param securityLevel security level.\n   * @param digitSize the size of the relinearization window.\n   * @param secretKeyDist sets the secretKeyDist of operation: GAUSSIAN or UNIFORM_TERNARY\n   * @param maxRelinSkDeg the maximum power of secret key for which the\n   * relinearization key is generated\n   * @param ksTech key switching method\n   * @param scalTech scaling method\n   * @param mPIntBootCiphertextCompressionLevel compression level\n   */\n    CryptoParametersRNS(std::shared_ptr&lt;ParmType&gt; params, const PlaintextModulus&amp; plaintextModulus,\n                        float distributionParameter, float assuranceMeasure, SecurityLevel securityLevel,\n                        usint digitSize, SecretKeyDist secretKeyDist, int maxRelinSkDeg = 2,\n                        KeySwitchTechnique ksTech = BV, ScalingTechnique scalTech = FIXEDMANUAL,\n                        EncryptionTechnique encTech = STANDARD, MultiplicationTechnique multTech = HPS,\n                        MultipartyMode multipartyMode                         = FIXED_NOISE_MULTIPARTY,\n                        ExecutionMode executionMode                           = EXEC_EVALUATION,\n                        DecryptionNoiseMode decryptionNoiseMode               = FIXED_NOISE_DECRYPT,\n                        COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel = COMPRESSION_LEVEL::SLACK)\n        : CryptoParametersRLWE&lt;DCRTPoly&gt;(std::move(params), EncodingParams(std::make_shared&lt;EncodingParamsImpl&gt;(plaintextModulus)),\n                                         distributionParameter, assuranceMeasure, securityLevel, digitSize,\n                                         maxRelinSkDeg, secretKeyDist, INDCPA, multipartyMode, executionMode,\n                                         decryptionNoiseMode) {\n        m_ksTechnique                         = ksTech;\n        m_scalTechnique                       = scalTech;\n        m_encTechnique                        = encTech;\n        m_multTechnique                       = multTech;\n        m_MPIntBootCiphertextCompressionLevel = mPIntBootCiphertextCompressionLevel;\n    }\n\n    CryptoParametersRNS(std::shared_ptr&lt;ParmType&gt; params, EncodingParams encodingParams, float distributionParameter,\n                        float assuranceMeasure, SecurityLevel securityLevel, usint digitSize,\n                        SecretKeyDist secretKeyDist, int maxRelinSkDeg = 2, KeySwitchTechnique ksTech = BV,\n                        ScalingTechnique scalTech = FIXEDMANUAL, EncryptionTechnique encTech = STANDARD,\n                        MultiplicationTechnique multTech = HPS, ProxyReEncryptionMode PREMode = INDCPA,\n                        MultipartyMode multipartyMode           = FIXED_NOISE_MULTIPARTY,\n                        ExecutionMode executionMode             = EXEC_EVALUATION,\n                        DecryptionNoiseMode decryptionNoiseMode = FIXED_NOISE_DECRYPT, PlaintextModulus noiseScale = 1,\n                        uint32_t statisticalSecurity = 30, uint32_t numAdversarialQueries = 1,\n                        uint32_t thresholdNumOfParties                        = 1,\n                        COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel = COMPRESSION_LEVEL::SLACK)\n        : CryptoParametersRLWE&lt;DCRTPoly&gt;(std::move(params), std::move(encodingParams), distributionParameter, assuranceMeasure, securityLevel,\n                                         digitSize, maxRelinSkDeg, secretKeyDist, PREMode, multipartyMode,\n                                         executionMode, decryptionNoiseMode, noiseScale, statisticalSecurity,\n                                         numAdversarialQueries, thresholdNumOfParties) {\n        m_ksTechnique                         = ksTech;\n        m_scalTechnique                       = scalTech;\n        m_encTechnique                        = encTech;\n        m_multTechnique                       = multTech;\n        m_MPIntBootCiphertextCompressionLevel = mPIntBootCiphertextCompressionLevel;\n    }\n\n    virtual ~CryptoParametersRNS() {}\n\npublic:\n    /**\n   * Computes all tables needed for decryption, homomorphic multiplication and key switching.\n   * Even though this is a pure virtual function and must be overriden in all derived classes,\n   * PrecomputeCRTTables() has its own implementation in the source file. It should be called from\n   * derived classes&#x27; PrecomputeCRTTables() only and must not be called from CryptoParametersRNS::load().\n   * @param ksTech the technique to use for key switching (e.g., BV or GHS).\n   * @param scalTech the technique to use for scaling (e.g., FLEXIBLEAUTO or FIXEDMANUAL).\n   */\n    virtual void PrecomputeCRTTables(KeySwitchTechnique ksTech, ScalingTechnique scalTech, EncryptionTechnique encTech,\n                                     MultiplicationTechnique multTech, uint32_t numPartQ, uint32_t auxBits,\n                                     uint32_t extraBits) = 0;\n\n    virtual uint64_t FindAuxPrimeStep() const;\n\n    /**\n   * == operator to compare to this instance of CryptoParametersBase object.\n   *\n   * @param &amp;rhs CryptoParameters to check equality against.\n   */\n    bool operator==(const CryptoParametersBase&lt;DCRTPoly&gt;&amp; rhs) const override {\n        const auto* el = dynamic_cast&lt;const CryptoParametersRNS*&gt;(&amp;rhs);\n\n        if (el == nullptr)\n            return false;\n\n        return CryptoParametersBase&lt;DCRTPoly&gt;::operator==(rhs) &amp;&amp; m_scalTechnique == el-&gt;GetScalingTechnique() &amp;&amp;\n               m_ksTechnique == el-&gt;GetKeySwitchTechnique() &amp;&amp; m_multTechnique == el-&gt;GetMultiplicationTechnique() &amp;&amp;\n               m_encTechnique == el-&gt;GetEncryptionTechnique() &amp;&amp; m_numPartQ == el-&gt;GetNumPartQ() &amp;&amp;\n               m_auxBits == el-&gt;GetAuxBits() &amp;&amp; m_extraBits == el-&gt;GetExtraBits() &amp;&amp; m_PREMode == el-&gt;GetPREMode() &amp;&amp;\n               m_multipartyMode == el-&gt;GetMultipartyMode() &amp;&amp; m_executionMode == el-&gt;GetExecutionMode();\n    }\n\n    void PrintParameters(std::ostream&amp; os) const override {\n        CryptoParametersBase&lt;DCRTPoly&gt;::PrintParameters(os);\n    }\n\n    /////////////////////////////////////\n    // PrecomputeCRTTables\n    /////////////////////////////////////\n\n    /**\n   * Method to retrieve the technique to be used for key switching.\n   *\n   * @return the key switching technique.\n   */\n    enum KeySwitchTechnique GetKeySwitchTechnique() const {\n        return m_ksTechnique;\n    }\n\n    /**\n   * Method to retrieve the technique to be used for scaling.\n   *\n   * @return the scaling technique.\n   */\n    enum ScalingTechnique GetScalingTechnique() const {\n        return m_scalTechnique;\n    }\n\n    /**\n   * Method to retrieve the technique to be used for rescaling.\n   *\n   * @return the rescaling technique.\n   */\n    enum EncryptionTechnique GetEncryptionTechnique() const {\n        return m_encTechnique;\n    }\n\n    /**\n   * Method to retrieve the technique to be used for rescaling.\n   *\n   * @return the rescaling technique.\n   */\n    enum MultiplicationTechnique GetMultiplicationTechnique() const {\n        return m_multTechnique;\n    }\n\n    uint32_t GetAuxBits() const {\n        return m_auxBits;\n    }\n\n    uint32_t GetExtraBits() const {\n        return m_extraBits;\n    }\n\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; GetParamsPK() const override {\n        if ((m_ksTechnique == HYBRID) &amp;&amp; (m_PREMode != NOT_SET))\n            return m_paramsQP;\n        if ((m_encTechnique == EXTENDED) &amp;&amp; (m_paramsQr != nullptr))\n            return m_paramsQr;\n        return m_params;\n    }\n\n    /////////////////////////////////////\n    // BGVrns : ModReduce\n    /////////////////////////////////////\n\n    /**\n   * Method that returns the NTL precomputions for [t]_{q_i}\n   *\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettModqPrecon() const {\n        return m_tModqPrecon;\n    }\n\n    /**\n   * Get the precomputed table of [-t^{-1}]_{q_i}\n   *\n   * @return the pre-computed values.\n   */\n    const NativeInteger&amp; GetNegtInvModq(usint l) const {\n        return m_negtInvModq[l];\n    }\n\n    /**\n   * Method that returns the NTL precomputions for [-t^{-1}]_{q_i}\n   *\n   * @return the pre-computed values.\n   */\n    const NativeInteger&amp; GetNegtInvModqPrecon(usint l) const {\n        return m_negtInvModqPrecon[l];\n    }\n\n    /////////////////////////////////////\n    // CKKSrns : DropLastElementAndScale\n    /////////////////////////////////////\n\n    /**\n   * Q^(l) = \\prod_{j=0}^{l-1}\n   * Gets the precomputed table of [Q^(l)*[Q^(l)^{-1}]_{q_l}/q_l]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetQlQlInvModqlDivqlModq(size_t i) const {\n        return m_QlQlInvModqlDivqlModq[i];\n    }\n\n    /**\n   * Q^(l) = \\prod_{j=0}^{l-1}\n   * Gets the NTL precomputions for [Q^(l)*[Q^(l)^{-1}]_{q_l}/q_l]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetQlQlInvModqlDivqlModqPrecon(size_t i) const {\n        return m_QlQlInvModqlDivqlModqPrecon[i];\n    }\n\n    /**\n   * Gets the precomputed table of [q_i^{-1}]_{q_j}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetqlInvModq(size_t i) const {\n        return m_qlInvModq[i];\n    }\n\n    /**\n   * Gets the NTL precomputions for [q_i^{-1}]_{q_j}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetqlInvModqPrecon(size_t i) const {\n        return m_qlInvModqPrecon[i];\n    }\n\n    /////////////////////////////////////\n    // KeySwitchHybrid : KeyGen\n    /////////////////////////////////////\n\n    /**\n   * Gets Q*P CRT basis\n   * Q*P = {q_1,...,q_l,p_1,...,p_k}\n   * Used in Hybrid key switch generation\n   *\n   * @return the precomputed CRT params\n   */\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; GetParamsQP() const {\n        return m_paramsQP;\n    }\n\n    /**\n   * Method that returns the number of digits.\n   * Used in Hybrid key switch generation\n   * @return the number of digits.\n   */\n    uint32_t GetNumPartQ() const {\n        return m_numPartQ;\n    }\n\n    /**\n   * Gets the precomputed table of [P]_{q_i}\n   * Used in Hybrid key switch generation.\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetPModq() const {\n        return m_PModq;\n    }\n\n    /////////////////////////////////////\n    // KeySwitchHybrid : KeySwitch\n    /////////////////////////////////////\n\n    /**\n   * Gets the Auxiliary CRT basis {P} = {p_1,...,p_k}\n   * Used in Hybrid key switching\n   *\n   * @return the parameters CRT params\n   */\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; GetParamsP() const {\n        return m_paramsP;\n    }\n\n    /**\n   * Method that returns the number of towers within every digit.\n   * This is the alpha parameter from the paper (see documentation\n   * for KeySwitchHHybrid).\n   * Used in Hybrid key switching\n   *\n   * @return the number of towers per digit.\n   */\n    uint32_t GetNumPerPartQ() const {\n        return m_numPerPartQ;\n    }\n\n    /*\n   * Method that returns the number of partitions.\n   * Used in Hybrid key switching\n   *\n   * @return the number of partitions.\n   */\n    uint32_t GetNumberOfQPartitions() const {\n        return m_paramsPartQ.size();\n    }\n\n    /**\n   * Method that returns the element parameters corresponding to\n   * partitions {Q_j} of Q.\n   * Used in Hybrid key switching\n   *\n   * @return the pre-computed values.\n   */\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt;&amp; GetParamsPartQ(uint32_t part) const {\n        return m_paramsPartQ[part];\n    }\n\n    /*\n   * Method that returns the element parameters corresponding to the\n   * complementary basis of a single digit j, i.e., the basis consisting of\n   * all other digits plus the special primes. Note that numTowers should be\n   * up to l (where l is the number of towers).\n   *\n   * @param numTowers is the total number of towers there are in the\n   * ciphertext.\n   * @param digit is the index of the digit we want to get the complementary\n   * partition from.\n   * @return the partitions.\n   */\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt;&amp; GetParamsComplPartQ(uint32_t numTowers, uint32_t digit) const {\n        return m_paramsComplPartQ[numTowers][digit];\n    }\n\n    /**\n   * Method that returns the precomputed values for QHat^-1 mod qj within a\n   * partition of towers, used in HYBRID.\n   *\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetPartQlHatInvModq(uint32_t part, uint32_t sublvl) const {\n        if (part &lt; m_PartQlHatInvModq.size() &amp;&amp; sublvl &lt; m_PartQlHatInvModq[part].size())\n            return m_PartQlHatInvModq[part][sublvl];\n\n        &quot;hey&quot;; OPENFHE_THROW(math_error,\n                      &quot;CryptoParametersCKKS::GetPartitionQHatInvModQTable - &quot;\n                      &quot;index out of bounds.&quot;);\n    }\n\n    /**\n   * Barrett multiplication precomputations getter.\n   *\n   * @param index The number of towers in the ciphertext.\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetPartQlHatInvModqPrecon(uint32_t part, uint32_t sublvl) const {\n        if (part &lt; m_PartQlHatInvModqPrecon.size() &amp;&amp; sublvl &lt; m_PartQlHatInvModqPrecon[part].size())\n            return m_PartQlHatInvModqPrecon[part][sublvl];\n\n        &quot;hey&quot;; OPENFHE_THROW(math_error,\n                      &quot;CryptoParametersCKKS::&quot;\n                      &quot;GetPartitionQHatInvModQPreconTable - index &quot;\n                      &quot;out of bounds.&quot;);\n    }\n\n    /**\n   * Barrett multiplication precomputations getter.\n   *\n   * @param index The table containing [PartQHat]_{p_j}\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GetPartQlHatModp(uint32_t lvl, uint32_t part) const {\n        if (lvl &lt; m_PartQlHatModp.size() &amp;&amp; part &lt; m_PartQlHatModp[lvl].size())\n            return m_PartQlHatModp[lvl][part];\n\n        &quot;hey&quot;; OPENFHE_THROW(math_error,\n                      &quot;CryptoParametersCKKS::GetPartitionQHatModPTable - &quot;\n                      &quot;index out of bounds.&quot;);\n    }\n\n    /**\n   * Barrett multiplication precomputations getter.\n   *\n   * @param index The number of towers in the ciphertext.\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;DoubleNativeInt&gt;&amp; GetmodComplPartqBarrettMu(uint32_t lvl, uint32_t part) const {\n        if (lvl &lt; m_modComplPartqBarrettMu.size() &amp;&amp; part &lt; m_modComplPartqBarrettMu[lvl].size())\n            return m_modComplPartqBarrettMu[lvl][part];\n\n        &quot;hey&quot;; OPENFHE_THROW(math_error,\n                      &quot;CryptoParametersCKKS::GetPartitionPrecon - index out &quot;\n                      &quot;of bounds.&quot;);\n    }\n\n    /**\n   * Gets the precomputed table of [P^{-1}]_{q_i}\n   * Used in GHS key switching\n   *\n   * See more in &quot;A full RNS variant of approximate homomorphic\n   * encryption&quot; by Cheon, et. al. Section 4.\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetPInvModq() const {\n        return m_PInvModq;\n    }\n\n    /**\n   * Gets the NTL precomputions for [P^{-1}]_{q_i}\n   * Used for speeding up GHS key switching.\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetPInvModqPrecon() const {\n        return m_PInvModqPrecon;\n    }\n\n    /**\n   * Get the precomputed table of [(P/p_j)^{-1}]_{p_j}\n   * Used in GHS key switching.\n   *\n   * See more in &quot;A full RNS variant of approximate homomorphic\n   * encryption&quot; by Cheon, et. al. Section 4.\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetPHatInvModp() const {\n        return m_PHatInvModp;\n    }\n\n    /**\n   * Get the NTL precomputions for [(P/p_j)^{-1}]_{p_j}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetPHatInvModpPrecon() const {\n        return m_PHatInvModpPrecon;\n    }\n\n    /**\n   * Gets the precomputed table of [P/p_j]_{q_i}\n   * Used in GHS key switching.\n   *\n   * See more in &quot;A full RNS variant of approximate homomorphic\n   * encryption&quot; by Cheon, et. al. Section 4.\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GetPHatModq() const {\n        return m_PHatModq;\n    }\n\n    /**\n   * Gets the Barrett modulo reduction precomputation for q_i\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;DoubleNativeInt&gt;&amp; GetModqBarrettMu() const {\n        return m_modqBarrettMu;\n    }\n\n    /**\n   * Method that returns the precomputed values for [t^(-1)]_{q_i}\n   * Used in ModulusSwitching.\n   *\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettInvModq() const {\n        return m_tInvModq;\n    }\n\n    /**\n   * Method that returns the NTL precomputions for [t^{-1}]_{q_i}\n   *\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettInvModqPrecon() const {\n        return m_tInvModqPrecon;\n    }\n\n    /**\n   * Method that returns the precomputed values for [t^(-1)]_{p_j}\n   * Used in KeySwitching.\n   *\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettInvModp() const {\n        return m_tInvModp;\n    }\n\n    /**\n   * Method that returns the NTL precomputions for [t^{-1}]_{p_j}\n   *\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettInvModpPrecon() const {\n        return m_tInvModpPrecon;\n    }\n\n    /////////////////////////////////////\n    // CKKSrns Scaling Factor\n    /////////////////////////////////////\n\n    /**\n   * Method to retrieve the scaling factor of level l.\n   * For FIXEDMANUAL scaling technique method always returns 2^p, where p corresponds to plaintext modulus\n   * @param l For FLEXIBLEAUTO scaling technique the level whose scaling factor we want to learn.\n   * Levels start from 0 (no scaling done - all towers) and go up to K-1, where K is the number of towers supported.\n   * @return the scaling factor.\n   */\n    double GetScalingFactorReal(uint32_t l = 0) const {\n        if (m_scalTechnique == FLEXIBLEAUTO || m_scalTechnique == FLEXIBLEAUTOEXT) {\n            if (l &gt;= m_scalingFactorsReal.size()) {\n                // TODO: Return an error here.\n                return m_approxSF;\n            }\n\n            return m_scalingFactorsReal[l];\n        }\n\n        return m_approxSF;\n    }\n\n    double GetScalingFactorRealBig(uint32_t l = 0) const {\n        if (m_scalTechnique == FLEXIBLEAUTO || m_scalTechnique == FLEXIBLEAUTOEXT) {\n            if (l &gt;= m_scalingFactorsRealBig.size()) {\n                // TODO: Return an error here.\n                return m_approxSF;\n            }\n\n            return m_scalingFactorsRealBig[l];\n        }\n\n        return m_approxSF;\n    }\n\n    /**\n   * Method to retrieve the modulus to be dropped of level l.\n   * For FIXEDMANUAL rescaling technique method always returns 2^p, where p corresponds to plaintext modulus\n   * @param l index of modulus to be dropped for FLEXIBLEAUTO scaling technique\n   * @return the precomputed table\n   */\n    double GetModReduceFactor(uint32_t l = 0) const {\n        if (m_scalTechnique == FLEXIBLEAUTO || m_scalTechnique == FLEXIBLEAUTOEXT) {\n            return m_dmoduliQ[l];\n        }\n\n        return m_approxSF;\n    }\n\n    /////////////////////////////////////\n    // BFVrns : Encrypt : POverQ\n    /////////////////////////////////////\n\n    const NativeInteger GetNegQModt() const {\n        return m_negQModt;\n    }\n\n    const NativeInteger GetNegQModtPrecon() const {\n        return m_negQModtPrecon;\n    }\n\n    const NativeInteger GetNegQrModt() const {\n        return m_negQrModt;\n    }\n\n    const NativeInteger GetNegQrModtPrecon() const {\n        return m_negQrModtPrecon;\n    }\n\n    /**\n   * Method that returns the precomputed values for [t^(-1)]_{a} where a is from {q_i} U r\n   * Used in ModulusSwitching.\n   *\n   * @return the pre-computed values.\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettInvModqr() const {\n        return m_tInvModqr;\n    }\n\n    /////////////////////////////////////\n    // BFVrns : Mult : ExpandCRTBasis\n    /////////////////////////////////////\n\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; GetParamsQl(usint l = 0) const {\n        return m_paramsQl[l];\n    }\n\n    const std::vector&lt;double&gt;&amp; GetQlQHatInvModqDivqFrac(usint l) const {\n        return m_QlQHatInvModqDivqFrac[l];\n    }\n\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GetQlQHatInvModqDivqModq(usint l) const {\n        return m_QlQHatInvModqDivqModq[l];\n    }\n\n    /**\n   * Gets the Auxiliary CRT basis {R} = {r_1,...,r_k}\n   * used in homomorphic multiplication\n   *\n   * @return the precomputed CRT params\n   */\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; GetParamsRl(usint l = 0) const {\n        return m_paramsRl[l];\n    }\n\n    /**\n   * Gets the Auxiliary expanded CRT basis {S} = {Q*R} =\n   * {{q_i},{r_k}} used in homomorphic multiplication\n   *\n   * @return the precomputed CRT params\n   */\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; GetParamsQlRl(usint l = 0) const {\n        return m_paramsQlRl[l];\n    }\n\n    /**\n   * Gets the precomputed table of [(Q/q_i)^{-1}]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetQlHatInvModq(usint l = 0) const {\n        return m_QlHatInvModq[l];\n    }\n\n    /**\n   * Gets the NTL precomputations for [(Q/q_i)^{-1}]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetQlHatInvModqPrecon(usint l = 0) const {\n        return m_QlHatInvModqPrecon[l];\n    }\n\n    /**\n   * Gets the precomputed table of [Q/q_i]_{r_k}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GetQlHatModr(usint l = 0) const {\n        return m_QlHatModr[l];\n    }\n\n    /**\n   * Gets the precomputed table of [\\alpha*Q]_{r_k}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GetalphaQlModr(usint l = 0) const {\n        return m_alphaQlModr[l];\n    }\n\n    const std::vector&lt;NativeInteger&gt;&amp; GetmNegRlQHatInvModq(usint l = 0) const {\n        return m_negRlQHatInvModq[l];\n    }\n\n    const std::vector&lt;NativeInteger&gt;&amp; GetmNegRlQHatInvModqPrecon(usint l = 0) const {\n        return m_negRlQHatInvModqPrecon[l];\n    }\n\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GetqInvModr() const {\n        return m_qInvModr;\n    }\n\n    /**\n   * Gets the Barrett modulo reduction precomputations for r_k\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;DoubleNativeInt&gt; const&amp; GetModrBarrettMu() const {\n        return m_modrBarrettMu;\n    }\n\n    /**\n   * Gets the precomputed table of 1./q_i\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;double&gt; const&amp; GetqInv() const {\n        return m_qInv;\n    }\n\n    /////////////////////////////////////\n    // BFVrns : Mult : ScaleAndRound\n    /////////////////////////////////////\n\n    /**\n   * For S = QR\n   * Gets the precomputed table of \\frac{[t*R*(S/s_m)^{-1}]_{s_m}/s_m}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;double&gt;&amp; GettRSHatInvModsDivsFrac() const {\n        return m_tRSHatInvModsDivsFrac;\n    }\n\n    /**\n   * For S = QR\n   * Gets the precomputed table of [\\floor{t*R*(S/s_m)^{-1}/s_m}]_{r_k}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GettRSHatInvModsDivsModr() const {\n        return m_tRSHatInvModsDivsModr;\n    }\n\n    /////////////////////////////////////\n    // BFVrns : Mult : SwitchCRTBasis\n    /////////////////////////////////////\n\n    /**\n   * Gets the precomputed table of [(R/r_k)^{-1}]_{r_k}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetRlHatInvModr(usint l = 0) const {\n        return m_RlHatInvModr[l];\n    }\n\n    /**\n   * Gets the NTL precomputation for [(R/r_k)^{-1}]_{r_k}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GetRlHatInvModrPrecon(usint l = 0) const {\n        return m_RlHatInvModrPrecon[l];\n    }\n\n    /**\n   * Gets the precomputed table of [R/r_k]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GetRlHatModq(usint l = 0) const {\n        return m_RlHatModq[l];\n    }\n\n    /**\n   * Gets the precomputed table of [\\alpha*P]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GetalphaRlModq(usint l = 0) const {\n        return m_alphaRlModq[l];\n    }\n\n    const std::vector&lt;double&gt;&amp; GettQlSlHatInvModsDivsFrac(usint l) const {\n        return m_tQlSlHatInvModsDivsFrac[l];\n    }\n\n    const std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&amp; GettQlSlHatInvModsDivsModq(usint l) const {\n        return m_tQlSlHatInvModsDivsModq[l];\n    }\n\n    const std::vector&lt;NativeInteger&gt;&amp; GetQlHatModq(usint l) const {\n        return m_QlHatModq[l];\n    }\n\n    const std::vector&lt;NativeInteger&gt;&amp; GetQlHatModqPrecon(usint l) const {\n        return m_QlHatModqPrecon[l];\n    }\n\n    /**\n   * Gets the precomputed table of 1./p_j\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;double&gt; const&amp; GetrInv() const {\n        return m_rInv;\n    }\n\n    /////////////////////////////////////\n    // BFVrns : Decrypt : ScaleAndRound\n    /////////////////////////////////////\n\n    /**\n   * Gets the precomputed table of \\frac{t*{Q/q_i}^{-1}/q_i}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;double&gt;&amp; GettQHatInvModqDivqFrac() const {\n        return m_tQHatInvModqDivqFrac;\n    }\n\n    /**\n   * When log2(q_i) &gt;= 45 bits, B = \\floor[2^{\\ceil{log2(q_i)/2}}\n   * Gets the precomputed table of \\frac{t*{Q/q_i}^{-1}*B/q_i}\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;double&gt;&amp; GettQHatInvModqBDivqFrac() const {\n        return m_tQHatInvModqBDivqFrac;\n    }\n\n    /**\n   * Gets the precomputed table of [\\floor{t*{Q/q_i}^{-1}/q_i}]_t\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettQHatInvModqDivqModt() const {\n        return m_tQHatInvModqDivqModt;\n    }\n\n    /**\n   * Gets the NTL precomputations for [\\floor{t*{Q/q_i}^{-1}/q_i}]_t\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettQHatInvModqDivqModtPrecon() const {\n        return m_tQHatInvModqDivqModtPrecon;\n    }\n\n    /**\n   * When log2(q_i) &gt;= 45 bits, B = \\floor[2^{\\ceil{log2(q_i)/2}}\n   * Gets the precomputed table of [\\floor{t*{Q/q_i}^{-1}*B/q_i}]_t\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettQHatInvModqBDivqModt() const {\n        return m_tQHatInvModqBDivqModt;\n    }\n\n    /**\n   * When log2(q_i) &gt;= 45 bits, B = \\floor[2^{\\ceil{log2(q_i)/2}}\n   * Gets the NTL precomputations for [\\floor{t*{Q/q_i}^{-1}*B/q_i}]_t\n   *\n   * @return the precomputed table\n   */\n    const std::vector&lt;NativeInteger&gt;&amp; GettQHatInvModqBDivqModtPrecon() const {\n        return m_tQHatInvModqBDivqModtPrecon;\n    }\n\n    const NativeInteger&amp; GetScalingFactorInt(usint l) const {\n        if (m_scalTechnique == FLEXIBLEAUTO || m_scalTechnique == FLEXIBLEAUTOEXT) {\n            if (l &gt;= m_scalingFactorsInt.size()) {\n                // TODO: Return an error here.\n                return m_fixedSF;\n            }\n            return m_scalingFactorsInt[l];\n        }\n        return m_fixedSF;\n    }\n\n    const NativeInteger&amp; GetScalingFactorIntBig(usint l) const {\n        if (m_scalTechnique == FLEXIBLEAUTO || m_scalTechnique == FLEXIBLEAUTOEXT) {\n            if (l &gt;= m_scalingFactorsIntBig.size()) {\n                // TODO: Return an error here.\n                return m_fixedSF;\n            }\n            return m_scalingFactorsIntBig[l];\n        }\n        return m_fixedSF;\n    }\n\n    const NativeInteger&amp; GetModReduceFactorInt(uint32_t l = 0) const {\n        if (m_scalTechnique == FLEXIBLEAUTO || m_scalTechnique == FLEXIBLEAUTOEXT) {\n            return m_qModt[l];\n        }\n        return m_fixedSF;\n    }\n\n    /////////////////////////////////////\n    // BFVrns : Encrypt\n    /////////////////////////////////////\n\n    /**\n   * Gets the precomputed table of 1./p_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetrInvModq() const {\n        return m_rInvModq;\n    }\n\n    /**\n   * Gets the Auxiliary CRT basis {Qr} = {Q U r}\n   * used in BFV encryption in mode EXTENDED\n   *\n   * @return the precomputed CRT params\n   */\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; GetParamsQr() const {\n        return m_paramsQr;\n    }\n\n    /////////////////////////////////////\n    // BFVrnsB\n    /////////////////////////////////////\n\n    /**\n   * Gets the Auxiliary CRT basis {Bsk} = {B U msk}\n   * used in homomorphic multiplication\n   *\n   * @return the precomputed CRT params\n   */\n    const std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; GetParamsQBsk() const {\n        return m_paramsQBsk;\n    }\n\n    /**\n   * Gets the precomputed table of q_i\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetModuliQ() const {\n        return m_moduliQ;\n    }\n\n    /**\n   * Gets the precomputed table of bsk_j\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetModuliBsk() const {\n        return m_moduliBsk;\n    }\n\n    /**\n   * Gets the Barrett modulo reduction precomputation for bsk_j\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;DoubleNativeInt&gt; const&amp; GetModbskBarrettMu() const {\n        return m_modbskBarrettMu;\n    }\n\n    /**\n   * Gets the precomputed table of [mtilde*(Q/q_i)^{-1}]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetmtildeQHatInvModq() const {\n        return m_mtildeQHatInvModq;\n    }\n\n    /**\n   * Gets the NTL precomputations for [mtilde*(Q/q_i)^{-1}]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetmtildeQHatInvModqPrecon() const {\n        return m_mtildeQHatInvModqPrecon;\n    }\n\n    /**\n   * Gets the precomputed table of [Q/q_i]_{bsk_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; const&amp; GetQHatModbsk() const {\n        return m_QHatModbsk;\n    }\n\n    /**\n   * Gets the precomputed table of [(q_i)^{-1}]_{bsk_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; const&amp; GetqInvModbsk() const {\n        return m_qInvModbsk;\n    }\n\n    /**\n   * Gets the precomputed table of [Q/q_i]_{mtilde}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;uint64_t&gt; const&amp; GetQHatModmtilde() const {\n        return m_QHatModmtilde;\n    }\n\n    /**\n   * Gets the precomputed table of [Q]_{bsk_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetQModbsk() const {\n        return m_QModbsk;\n    }\n\n    /**\n   * Gets the NTL precomputations for [Q]_{bsk_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetQModbskPrecon() const {\n        return m_QModbskPrecon;\n    }\n\n    /**\n   * Gets the precomputed [-Q^{-1}]_{mtilde}\n   *\n   * @return the precomputed value\n   */\n    uint64_t const&amp; GetNegQInvModmtilde() const {\n        return m_negQInvModmtilde;\n    }\n\n    /**\n   * Gets the precomputed table of [mtilde^{-1}]_{bsk_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetmtildeInvModbsk() const {\n        return m_mtildeInvModbsk;\n    }\n\n    /**\n   * Gets the NTL precomputations for [mtilde^{-1}]_{bsk_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetmtildeInvModbskPrecon() const {\n        return m_mtildeInvModbskPrecon;\n    }\n\n    /**\n   * Gets the precomputed table of [t*(Q/q_i)^{-1}]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GettQHatInvModq() const {\n        return m_tQHatInvModq;\n    }\n\n    /**\n   * Gets the NTL precomputations for [t*(Q/q_i)^{-1}]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GettQHatInvModqPrecon() const {\n        return m_tQHatInvModqPrecon;\n    }\n\n    /**\n   * Gets the precomputed table of [t*gamma*(Q/q_i)^(-1)]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GettgammaQHatInvModq() const {\n        return m_tgammaQHatInvModq;\n    }\n\n    /**\n   * Gets the NTL precomputations for [t*gamma*(Q/q_i)^(-1)]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GettgammaQHatInvModqPrecon() const {\n        return m_tgammaQHatInvModqPrecon;\n    }\n\n    /**\n   * Gets the precomputed table of [t/Q]_{bsk_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GettQInvModbsk() const {\n        return m_tQInvModbsk;\n    }\n\n    /**\n   * Gets the NTL precomputations for [t/Q]_{bsk_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GettQInvModbskPrecon() const {\n        return m_tQInvModbskPrecon;\n    }\n\n    /**\n   * Gets the precomputed table of [(B/b_j)^{-1}]_{b_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetBHatInvModb() const {\n        return m_BHatInvModb;\n    }\n\n    /**\n   * Gets the NTL precomputations for [(B/b_j)^{-1}]_{b_j}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetBHatInvModbPrecon() const {\n        return m_BHatInvModbPrecon;\n    }\n\n    /**\n   * Gets the precomputed table of [B/b_j]_{msk}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetBHatModmsk() const {\n        return m_BHatModmsk;\n    }\n\n    /**\n   * Gets the precomputed [B^{-1}]_msk\n   *\n   * @return the precomputed value\n   */\n    NativeInteger const&amp; GetBInvModmsk() const {\n        return m_BInvModmsk;\n    }\n\n    /**\n   * Gets the NTL precomputions for [B^{-1}]_msk\n   *\n   * @return the precomputed value\n   */\n    NativeInteger const&amp; GetBInvModmskPrecon() const {\n        return m_BInvModmskPrecon;\n    }\n\n    /**\n   * Gets the precomputed table of [B/b_j]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; const&amp; GetBHatModq() const {\n        return m_BHatModq;\n    }\n\n    /**\n   * Gets the precomputed table of [B]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetBModq() const {\n        return m_BModq;\n    }\n\n    /**\n   * Gets the NTL precomputions for [B]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetBModqPrecon() const {\n        return m_BModqPrecon;\n    }\n\n    /**\n   * Gets auxiliary modulus gamma\n   *\n   * @return gamma\n   */\n    uint32_t const&amp; Getgamma() const {\n        return m_gamma;\n    }\n\n    // TODO: use 64 bit words in case NativeInteger uses smaller word size\n    /**\n   * Gets t*gamma where t - plaintext modulus, gamma - auxiliary modulus\n   *\n   * @return t*gamma\n   */\n    NativeInteger const&amp; Gettgamma() const {\n        return m_tgamma;\n    }\n\n    /**\n   * Gets the precomputed table of [-(q_i)^{-1}]_{t*gamma}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetNegInvqModtgamma() const {\n        return m_negInvqModtgamma;\n    }\n\n    /**\n   * Gets the NTL precomputations for [-(q_i)^{-1}]_{t*gamma}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetNegInvqModtgammaPrecon() const {\n        return m_negInvqModtgammaPrecon;\n    }\n\n    /**\n   * Gets the precomputed table of [*(Q/q_i/q_0)^{-1}]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetMultipartyQHatInvModqAtIndex(usint l) const {\n        return m_multipartyQHatInvModq[l];\n    }\n\n    /**\n   * Gets the NTL precomputations for [*(Q/q_i/q_0)^{-1}]_{q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;NativeInteger&gt; const&amp; GetMultipartyQHatInvModqPreconAtIndex(usint l) const {\n        return m_multipartyQHatInvModqPrecon[l];\n    }\n\n    /**\n   * Gets the precomputed table of [Q/q_i/q_0]_{q_0}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; const&amp; GetMultipartyQHatModq0AtIndex(usint l) const {\n        return m_multipartyQHatModq0[l];\n    }\n\n    /**\n   * Gets the precomputed table of [\\alpha*Q/q_0]_{q_0} for 0 &lt;= alpha &lt;= 1\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; const&amp; GetMultipartyAlphaQModq0AtIndex(usint l) const {\n        return m_multipartyAlphaQModq0[l];\n    }\n\n    /**\n   * Gets the Barrett modulo reduction precomputation for q_0\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;DoubleNativeInt&gt; const&amp; GetMultipartyModq0BarrettMu() const {\n        return m_multipartyModq0BarrettMu;\n    }\n\n    /**\n   * Gets the precomputed table of \\frac{1/q_i}\n   *\n   * @return the precomputed table\n   */\n    std::vector&lt;double&gt; const&amp; GetMultipartyQInv() const {\n        return m_multipartyQInv;\n    }\n\n    /////////////////////////////////////\n    // CKKS RNS MultiParty Bootstrapping Parameter\n    /////////////////////////////////////\n    /**\n   * Gets the Multi-Party Interactive Bootstrapping Ciphertext Compression Level\n   * @return m_MPIntBootCiphertextCompressionLevel\n   */\n    COMPRESSION_LEVEL GetMPIntBootCiphertextCompressionLevel() const {\n        return m_MPIntBootCiphertextCompressionLevel;\n    }\n\nprotected:\n    /////////////////////////////////////\n    // PrecomputeCRTTables\n    /////////////////////////////////////\n\n    // Stores the technique to use for key switching\n    enum KeySwitchTechnique m_ksTechnique;\n\n    enum ScalingTechnique m_scalTechnique;\n\n    enum EncryptionTechnique m_encTechnique;\n\n    enum MultiplicationTechnique m_multTechnique;\n\n    uint32_t m_auxBits = 0;\n\n    uint32_t m_extraBits = 0;\n\n    /////////////////////////////////////\n    // BGVrns ModReduce\n    /////////////////////////////////////\n\n    // Stores NTL precomputations for [t]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_tModqPrecon;\n\n    // Stores [-t^{-1}]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_negtInvModq;\n\n    // Stores NTL precomputations for [-t^{-1}]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_negtInvModqPrecon;\n\n    /////////////////////////////////////\n    // CKKSrns/BFVrns DropLastElementAndScale\n    /////////////////////////////////////\n\n    // Q^(l) = \\prod_{j=0}^{l-1}\n    // Stores [Q^(l)*[Q^(l)^{-1}]_{q_l}/q_l]_{q_i}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_QlQlInvModqlDivqlModq;\n\n    // Q^(l) = \\prod_{j=0}^{l-1}\n    // Stores NTL precomputations for [Q^(l)*[Q^(l)^{-1}]_{q_l}/q_l]_{q_i}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_QlQlInvModqlDivqlModqPrecon;\n\n    // Stores [q_l^{-1}]_{q_i}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_qlInvModq;\n\n    // Stores NTL precomputations for [q_l^{-1}]_{q_i}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_qlInvModqPrecon;\n\n    /////////////////////////////////////\n    // KeySwitchHybrid KeyGen\n    /////////////////////////////////////\n\n    // Params for Extended CRT basis {QP} = {q_1...q_l,p_1,...,p_k}\n    // used in GHS key switching\n    std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; m_paramsQP;\n\n    // Stores the partition size {PartQ} = {Q_1,...,Q_l}\n    // where each Q_i is the product of q_j\n    uint32_t m_numPartQ = 0;\n\n    // Stores [P]_{q_i}, used in GHS key switching\n    std::vector&lt;NativeInteger&gt; m_PModq;\n\n    /////////////////////////////////////\n    // KeySwitchHybrid KeySwitch\n    /////////////////////////////////////\n\n    // Params for Auxiliary CRT basis {P} = {p_1,...,p_k}\n    // used in GHS key switching\n    std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; m_paramsP;\n\n    // Stores the number of towers per Q_i\n    uint32_t m_numPerPartQ = 0;\n\n    // Stores the parameters for moduli Q_i\n    std::vector&lt;std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt;&gt; m_paramsPartQ;\n\n    // Stores the parameters for complementary {\\bar{Q_i},P}\n    std::vector&lt;std::vector&lt;std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt;&gt;&gt; m_paramsComplPartQ;\n\n    // Stores [{(Q_k)^(l)/q_i}^{-1}]_{q_i} for HYBRID\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_PartQlHatInvModq;\n\n    // Stores NTL precomputations for\n    // [{(Q_k)^(l)/q_i}^{-1}]_{q_i} for HYBRID\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_PartQlHatInvModqPrecon;\n\n    // Stores [QHat_i]_{p_j}\n    std::vector&lt;std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt;&gt; m_PartQlHatModp;\n\n    // Stores the Barrett mu for CompQBar_i\n    std::vector&lt;std::vector&lt;std::vector&lt;DoubleNativeInt&gt;&gt;&gt; m_modComplPartqBarrettMu;\n\n    // Stores [P^{-1}]_{q_i}, required for GHS key switching\n    std::vector&lt;NativeInteger&gt; m_PInvModq;\n\n    // Stores NTL precomputations for [P^{-1}]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_PInvModqPrecon;\n\n    // Stores [(P/p_j)^{-1}]_{p_j}, required for GHS key switching\n    std::vector&lt;NativeInteger&gt; m_PHatInvModp;\n\n    // Stores NTL precomputations for [(P/p_j)^{-1}]_{p_j}\n    std::vector&lt;NativeInteger&gt; m_PHatInvModpPrecon;\n\n    // Stores [P/p_j]_{q_i}, required for GHS key switching\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_PHatModq;\n\n    // Stores the BarrettUint128ModUint64 precomputations for q_j\n    std::vector&lt;DoubleNativeInt&gt; m_modqBarrettMu;\n\n    // Stores [t^{-1}]_{p_j}\n    std::vector&lt;NativeInteger&gt; m_tInvModp;\n\n    // Stores NTL precomputations for [t^{-1}]_{p_j}\n    std::vector&lt;NativeInteger&gt; m_tInvModpPrecon;\n\n    /////////////////////////////////////\n    // CKKS Scaling Factor\n    /////////////////////////////////////\n\n    // A vector holding the doubles that correspond to the exact\n    // scaling factor of each level, when FLEXIBLEAUTO is used.\n    std::vector&lt;double&gt; m_scalingFactorsReal;\n\n    std::vector&lt;double&gt; m_scalingFactorsRealBig;\n\n    // Stores q_i as doubles\n    std::vector&lt;double&gt; m_dmoduliQ;\n\n    // Stores 2^ptm where ptm - plaintext modulus\n    double m_approxSF = 0;\n\n    /////////////////////////////////////\n    // BFVrns : Encrypt\n    /////////////////////////////////////\n\n    std::vector&lt;NativeInteger&gt; m_scalingFactorsInt;\n\n    std::vector&lt;NativeInteger&gt; m_scalingFactorsIntBig;\n\n    std::vector&lt;NativeInteger&gt; m_qModt;\n\n    NativeInteger m_fixedSF = NativeInteger(1);\n\n    /////////////////////////////////////\n    // BFVrns : Encrypt\n    /////////////////////////////////////\n\n    NativeInteger m_negQModt;\n    NativeInteger m_negQModtPrecon;\n    std::vector&lt;NativeInteger&gt; m_tInvModq;\n    std::vector&lt;NativeInteger&gt; m_tInvModqPrecon;\n    std::vector&lt;NativeInteger&gt; m_tInvModqr;\n\n    /////////////////////////////////////\n    // BFVrns : Encrypt\n    /////////////////////////////////////\n\n    std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; m_paramsQr;\n    NativeInteger m_negQrModt;\n    NativeInteger m_negQrModtPrecon;\n    std::vector&lt;NativeInteger&gt; m_rInvModq;\n\n    /////////////////////////////////////\n    // BFVrns : Decrypt : ScaleAndRound\n    /////////////////////////////////////\n\n    // Stores \\frac{t*{Q/q_i}^{-1}/q_i}\n    std::vector&lt;double&gt; m_tQHatInvModqDivqFrac;\n\n    // when log2(q_i) &gt;= 45 bits, B = \\floor[2^{\\ceil{log2(q_i)/2}}\n    // Stores \\frac{t*{Q/q_i}^{-1}*B/q_i}\n    std::vector&lt;double&gt; m_tQHatInvModqBDivqFrac;\n\n    // Stores [\\floor{t*{Q/q_i}^{-1}/q_i}]_t\n    std::vector&lt;NativeInteger&gt; m_tQHatInvModqDivqModt;\n\n    // Stores NTL precomputations for [\\floor{t*{Q/q_i}^{-1}/q_i}]_t\n    std::vector&lt;NativeInteger&gt; m_tQHatInvModqDivqModtPrecon;\n\n    // when log2(q_i) &gt;= 45 bits, B = \\floor[2^{\\ceil{log2(q_i)/2}}\n    // Stores [\\floor{t*{Q/q_i}^{-1}*B/q_i}]_t\n    std::vector&lt;NativeInteger&gt; m_tQHatInvModqBDivqModt;\n\n    // when log2 q_i &gt;= 45 bits, B = \\floor[2^{\\ceil{log2(q_i)/2}}\n    // Stores NTL precomputations for [\\floor{t*{Q/q_i}^{-1}*B/q_i}]_t\n    std::vector&lt;NativeInteger&gt; m_tQHatInvModqBDivqModtPrecon;\n\n    /////////////////////////////////////\n    // BFVrns : Mult : ExpandCRTBasis\n    /////////////////////////////////////\n\n    // Auxiliary CRT basis {Ql} = {q_i}\n    // used in homomorphic multiplication\n    std::vector&lt;std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt;&gt; m_paramsQl;\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; m_QlQHatInvModqDivqFrac;\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_QlQHatInvModqDivqModq;\n\n    // Auxiliary CRT basis {Rl} = {r_k}\n    // used in homomorphic multiplication\n    std::vector&lt;std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt;&gt; m_paramsRl;\n\n    // Auxiliary expanded CRT basis Ql*Rl = {s_m}\n    // used in homomorphic multiplication\n    std::vector&lt;std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt;&gt; m_paramsQlRl;\n\n    // Stores [(Ql/q_i)^{-1}]_{q_i}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_QlHatInvModq;\n\n    // Stores NTL precomputations for [(Ql/q_i)^{-1}]_{q_i}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_QlHatInvModqPrecon;\n\n    // Stores [Q/q_i]_{r_k}\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_QlHatModr;\n\n    // Stores [\\alpha*Ql]_{r_k} for 0 &lt;= alpha &lt;= sizeQl\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_alphaQlModr;\n\n    // Barrett modulo reduction precomputation for r_k\n    std::vector&lt;DoubleNativeInt&gt; m_modrBarrettMu;\n\n    // Stores \\frac{1/q_i}\n    std::vector&lt;double&gt; m_qInv;\n\n    /////////////////////////////////////\n    // BFVrns : Mult : ScaleAndRound\n    /////////////////////////////////////\n\n    // S = QR\n    // Stores \\frac{[t*R*(S/s_m)^{-1}]_{s_m}/s_m}\n    std::vector&lt;double&gt; m_tRSHatInvModsDivsFrac;\n\n    // S = QR\n    // Stores [\\floor{t*R*(S/s_m)^{-1}/s_m}]_{r_k}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_tRSHatInvModsDivsModr;\n\n    /////////////////////////////////////\n    // BFVrns : Mult : SwitchCRTBasis\n    /////////////////////////////////////\n\n    // Stores [(Rl/r_k)^{-1}]_{r_k}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_RlHatInvModr;\n\n    // Stores NTL precomputations for [(Rl/r_k)^{-1}]_{r_k}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_RlHatInvModrPrecon;\n\n    // Stores [Rl/r_k]_{q_i}\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_RlHatModq;\n\n    // Stores [\\alpha*Rl]_{q_i} for 0 &lt;= alpha &lt;= sizeR\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_alphaRlModq;\n\n    // Stores \\frac{1/r_k}\n    std::vector&lt;double&gt; m_rInv;\n\n    /////////////////////////////////////\n    // BFVrns : Mult : FastExpandCRTBasisPloverQ\n    /////////////////////////////////////\n\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_negRlQHatInvModq;\n\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_negRlQHatInvModqPrecon;\n\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_qInvModr;\n\n    /////////////////////////////////////\n    // BFVrns : Mult : ExpandCRTBasisQlHat\n    /////////////////////////////////////\n\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_QlHatModq;\n\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_QlHatModqPrecon;\n\n    /////////////////////////////////////\n    // BFVrns : Mult : ScaleAndRoundP\n    /////////////////////////////////////\n\n    std::vector&lt;std::vector&lt;double&gt;&gt; m_tQlSlHatInvModsDivsFrac;\n\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_tQlSlHatInvModsDivsModq;\n\n    /////////////////////////////////////\n    // BFVrnsB\n    /////////////////////////////////////\n\n    // Auxiliary CRT basis {Bsk} = {B U msk} = {{b_j} U msk}\n    std::shared_ptr&lt;ILDCRTParams&lt;BigInteger&gt;&gt; m_paramsQBsk;\n\n    // number of moduli in the base {Q}\n    uint32_t m_numq = 0;\n\n    // number of moduli in the auxilliary base {B}\n    uint32_t m_numb = 0;\n\n    // mtilde = 2^16\n    NativeInteger m_mtilde = NativeInteger(BasicInteger(1) &lt;&lt; 16);\n\n    // Auxiliary modulus msk\n    NativeInteger m_msk;\n\n    // Stores q_i\n    std::vector&lt;NativeInteger&gt; m_moduliQ;\n\n    // Stores auxilliary base moduli b_j\n    std::vector&lt;NativeInteger&gt; m_moduliB;\n\n    // Stores the roots of unity modulo bsk_j\n    std::vector&lt;NativeInteger&gt; m_rootsBsk;\n\n    // Stores moduli {bsk_i} = {{b_j} U msk}\n    std::vector&lt;NativeInteger&gt; m_moduliBsk;\n\n    // Barrett modulo reduction precomputation for bsk_j\n    std::vector&lt;DoubleNativeInt&gt; m_modbskBarrettMu;\n\n    // Stores [mtilde*(Q/q_i)^{-1}]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_mtildeQHatInvModq;\n\n    // Stores NTL precomputations for [mtilde*(Q/q_i)^{-1}]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_mtildeQHatInvModqPrecon;\n\n    // Stores [Q/q_i]_{bsk_j}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_QHatModbsk;\n\n    // Stores [(q_i)^{-1}]_{bsk_j}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_qInvModbsk;\n\n    // Stores [Q/q_i]_{mtilde}\n    std::vector&lt;uint64_t&gt; m_QHatModmtilde;\n\n    // Stores [Q]_{bsk_j}\n    std::vector&lt;NativeInteger&gt; m_QModbsk;\n    // Stores NTL precomputations for [Q]_{bsk_j}\n    std::vector&lt;NativeInteger&gt; m_QModbskPrecon;\n\n    // Stores [-Q^{-1}]_{mtilde}\n    uint64_t m_negQInvModmtilde = 0;\n\n    // Stores [mtilde^{-1}]_{bsk_j}\n    std::vector&lt;NativeInteger&gt; m_mtildeInvModbsk;\n    // Stores NTL precomputations for [mtilde^{-1}]_{bsk_j}\n    std::vector&lt;NativeInteger&gt; m_mtildeInvModbskPrecon;\n\n    // Stores [t*(Q/q_i)^{-1}]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_tQHatInvModq;\n\n    // Stores NTL precomputations for [t*(Q/q_i)^{-1}]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_tQHatInvModqPrecon;\n\n    // Stores [t*gamma*(Q/q_i)^(-1)]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_tgammaQHatInvModq;\n    // Stores NTL precomputations for [t*gamma*(Q/q_i)^(-1)]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_tgammaQHatInvModqPrecon;\n\n    // Stores [t/Q]_{bsk_j}\n    std::vector&lt;NativeInteger&gt; m_tQInvModbsk;\n    // Stores NTL precomputations for [t/Q]_{bsk_j}\n    std::vector&lt;NativeInteger&gt; m_tQInvModbskPrecon;\n\n    // Stores [(B/b_j)^{-1}]_{b_j}\n    std::vector&lt;NativeInteger&gt; m_BHatInvModb;\n\n    // Stores NTL precomputations for [(B/b_j)^{-1}]_{b_j}\n    std::vector&lt;NativeInteger&gt; m_BHatInvModbPrecon;\n\n    // stores [B/b_j]_{msk}\n    std::vector&lt;NativeInteger&gt; m_BHatModmsk;\n\n    // Stores [B^{-1}]_msk\n    NativeInteger m_BInvModmsk;\n    // Stores NTL precomputations for [B^{-1}]_msk\n    NativeInteger m_BInvModmskPrecon;\n\n    // Stores [B/b_j]_{q_i}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_BHatModq;\n\n    // Stores [B]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_BModq;\n    // Stores NTL precomputations for [B]_{q_i}\n    std::vector&lt;NativeInteger&gt; m_BModqPrecon;\n\n    // Stores gamma = 2^26;\n    uint32_t m_gamma = 1 &lt;&lt; 26;\n\n    // TODO: use 64 bit words in case NativeInteger uses smaller word size\n    // Stores t*gamma on a uint64_t word\n    NativeInteger m_tgamma;\n\n    // Stores [-(q_i)^{-1}]_{t*gamma}\n    std::vector&lt;NativeInteger&gt; m_negInvqModtgamma;\n    // Stores NTL precomputations for [-(q_i)^{-1}]_{t*gamma}\n    std::vector&lt;NativeInteger&gt; m_negInvqModtgammaPrecon;\n\n    /////////////////////////////////////\n    // BFVrns and BGVrns : Multiparty Decryption : ExpandCRTBasis\n    /////////////////////////////////////\n\n    // Stores [*(Q/q_i/q_0)^{-1}]_{q_i}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_multipartyQHatInvModq;\n\n    // Stores NTL precomputations for [*(Q/q_i/q_0)^{-1}]_{q_i}\n    std::vector&lt;std::vector&lt;NativeInteger&gt;&gt; m_multipartyQHatInvModqPrecon;\n\n    // Stores [Q/q_i/q_0]_{q_0}\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_multipartyQHatModq0;\n\n    // Stores [\\alpha*Q/q_0]_{q_0} for 0 &lt;= alpha &lt;= 1\n    std::vector&lt;std::vector&lt;std::vector&lt;NativeInteger&gt;&gt;&gt; m_multipartyAlphaQModq0;\n\n    // Barrett modulo reduction precomputation for q_0\n    std::vector&lt;DoubleNativeInt&gt; m_multipartyModq0BarrettMu;\n\n    // Stores \\frac{1/q_i}\n    std::vector&lt;double&gt; m_multipartyQInv;\n\n    /////////////////////////////////////\n    // CKKS RNS MultiParty Bootstrapping Parameter\n    /////////////////////////////////////\n    COMPRESSION_LEVEL m_MPIntBootCiphertextCompressionLevel;\n\npublic:\n    /////////////////////////////////////\n    // SERIALIZATION\n    /////////////////////////////////////\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(cereal::base_class&lt;CryptoParametersRLWE&lt;DCRTPoly&gt;&gt;(this));\n        ar(cereal::make_nvp(&quot;ks&quot;, m_ksTechnique));\n        ar(cereal::make_nvp(&quot;rs&quot;, m_scalTechnique));\n        ar(cereal::make_nvp(&quot;encs&quot;, m_encTechnique));\n        ar(cereal::make_nvp(&quot;muls&quot;, m_multTechnique));\n        ar(cereal::make_nvp(&quot;dnum&quot;, m_numPartQ));\n        ar(cereal::make_nvp(&quot;ab&quot;, m_auxBits));\n        ar(cereal::make_nvp(&quot;eb&quot;, m_extraBits));\n        ar(cereal::make_nvp(&quot;ccl&quot;, m_MPIntBootCiphertextCompressionLevel));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            std::string errMsg(&quot;serialized object version &quot; + std::to_string(version) +\n                               &quot; is from a later version of the library&quot;);\n            &quot;hey&quot;; OPENFHE_THROW(deserialize_error, errMsg);\n        }\n        ar(cereal::base_class&lt;CryptoParametersRLWE&lt;DCRTPoly&gt;&gt;(this));\n        ar(cereal::make_nvp(&quot;ks&quot;, m_ksTechnique));\n        ar(cereal::make_nvp(&quot;rs&quot;, m_scalTechnique));\n        ar(cereal::make_nvp(&quot;encs&quot;, m_encTechnique));\n        ar(cereal::make_nvp(&quot;muls&quot;, m_multTechnique));\n        ar(cereal::make_nvp(&quot;dnum&quot;, m_numPartQ));\n        ar(cereal::make_nvp(&quot;ab&quot;, m_auxBits));\n        ar(cereal::make_nvp(&quot;eb&quot;, m_extraBits));\n        ar(cereal::make_nvp(&quot;ccl&quot;, m_MPIntBootCiphertextCompressionLevel));\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;SchemeParametersRNS&quot;;\n    }\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-multiparty.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-multiparty.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-multiparty.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_BASE_MULTIPARTY_H\n#define LBCRYPTO_CRYPTO_BASE_MULTIPARTY_H\n\n#include &quot;key/privatekey-fwd.h&quot;\n#include &quot;key/publickey-fwd.h&quot;\n#include &quot;key/evalkey-fwd.h&quot;\n#include &quot;cryptocontext-fwd.h&quot;\n#include &quot;ciphertext-fwd.h&quot;\n#include &quot;decrypt-result.h&quot;\n#include &quot;scheme/ckksrns/ckksrns-cryptoparameters.h&quot;\n\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\ntemplate &lt;class Element&gt;\nclass KeyPair;\n/**\n * @brief Abstract interface class for LBC Multiparty algorithms based on\n * threshold FHE.  A version of this multiparty scheme built on the BGV scheme\n * is seen here:\n *   - Asharov G., Jain A., L\u00f3pez-Alt A., Tromer E., Vaikuntanathan V., Wichs\n * D. (2012) Multiparty Computation with Low Communication, Computation and\n * Interaction via Threshold FHE. In: Pointcheval D., Johansson T. (eds)\n * Advances in Cryptology \u2013 EUROCRYPT 2012. EUROCRYPT 2012. Lecture Notes in\n * Computer Science, vol 7237. Springer, Berlin, Heidelberg\n *\n * During offline key generation, this multiparty scheme relies on the clients\n * coordinating their public key generation.  To do this, a single client\n * generates a public-secret key pair. This public key is shared with other\n * keys which use an element in the public key to generate their own public\n * keys. The clients generate a shared key pair using a scheme-specific\n * approach, then generate re-encryption keys.  Re-encryption keys are\n * uploaded to the server. Clients encrypt data with their public keys and\n * send the encrypted data server. The data is re-encrypted.  Computations are\n * then run on the data. The result is sent to each of the clients. One client\n * runs a &quot;Leader&quot; multiparty decryption operation with its own secret key.\n * All other clients run a regular &quot;Main&quot; multiparty decryption with their own\n * secret key. The resulting partially decrypted ciphertext are then fully\n * decrypted with the decryption fusion algorithms.\n *\n * @tparam Element a ring element.\n */\ntemplate &lt;class Element&gt;\nclass MultipartyBase {\n    using ParmType = typename Element::Params;\n    using IntType  = typename Element::Integer;\n    using DugType  = typename Element::DugType;\n    using DggType  = typename Element::DggType;\n    using TugType  = typename Element::TugType;\n\npublic:\n    virtual ~MultipartyBase() {}\n\n    /**\n   * Threshold FHE: Generates a public key from a vector of secret shares.\n   * ONLY FOR DEBUGGIN PURPOSES. SHOULD NOT BE USED IN PRODUCTION.\n   *\n   * @param cc cryptocontext for the keys to be generated.\n   * @param secretkeys secrete key shares.\n   * @param makeSparse set to true if ring reduce by a factor of 2 is to be\n   * used. NOT SUPPORTED BY ANY SCHEME ANYMORE.\n   * @return key pair including the private for the current party and joined\n   * public key\n   */\n    virtual KeyPair&lt;Element&gt; MultipartyKeyGen(CryptoContext&lt;Element&gt; cc,\n                                              const std::vector&lt;PrivateKey&lt;Element&gt;&gt;&amp; privateKeyVec, bool makeSparse);\n\n    /**\n   * Threshold FHE: Generation of a public key derived\n   * from a previous joined public key (for prior secret shares) and the secret\n   * key share of the current party.\n   *\n   * @param cc cryptocontext for the keys to be generated.\n   * @param pk1 joined public key from prior parties.\n   * @param makeSparse set to true if ring reduce by a factor of 2 is to be\n   * used. NOT SUPPORTED BY ANY SCHEME ANYMORE.\n   * @param fresh set to true if proxy re-encryption is used in the multi-party\n   * protocol or star topology is used\n   * @return key pair including the secret share for the current party and\n   * joined public key\n   */\n    virtual KeyPair&lt;Element&gt; MultipartyKeyGen(CryptoContext&lt;Element&gt; cc, const PublicKey&lt;Element&gt; publicKey,\n                                              bool makeSparse, bool fresh);\n\n    /**\n   * Threshold FHE: Generates a joined evaluation key\n   * from the current secret share and a prior joined\n   * evaluation key\n   *\n   * @param originalPrivateKey secret key transformed from.\n   * @param newPrivateKey secret key transformed to.\n   * @param ek the prior joined evaluation key.\n   * @return the new joined evaluation key.\n   */\n    virtual EvalKey&lt;Element&gt; MultiKeySwitchGen(const PrivateKey&lt;Element&gt; oldPrivateKey,\n                                               const PrivateKey&lt;Element&gt; newPrivateKey,\n                                               const EvalKey&lt;Element&gt; evalKey) const;\n\n    /**\n   * Threshold FHE: Generates joined automorphism keys\n   * from the current secret share and prior joined\n   * automorphism keys\n   *\n   * @param privateKey secret key share.\n   * @param evalKeyMap a dictionary with prior joined automorphism keys.\n   * @param &amp;indexVec a vector of automorphism indices.\n   * @return a dictionary with new joined automorphism keys.\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiEvalAutomorphismKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap,\n        const std::vector&lt;usint&gt;&amp; indexVec) const;\n\n    /**\n   * Threshold FHE: Generates evaluation keys for a list of indices for a\n   * multi-party setting Currently works only for power-of-two and cyclic-group\n   * cyclotomics\n   *\n   * @param privateKey secret share\n   * @param evalKeyMap evaluation key set from other party (parties)\n   * @param indexVec list of indices to be computed\n   * @return returns the joined evaluation keys\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiEvalAtIndexKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey, const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap,\n        const std::vector&lt;int32_t&gt;&amp; indexVec) const;\n\n    /**\n   * Threshold FHE: Generates joined summation evaluation keys\n   * from the current secret share and prior joined\n   * summation keys\n   *\n   * @param privateKey secret key share.\n   * @param evalKeyMap a dictionary with prior joined summation keys.\n   * @return new joined summation keys.\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiEvalSumKeyGen(\n        const PrivateKey&lt;Element&gt; privateKey,\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap) const;\n\n    // MULTIPARTY PKE\n\n    /**\n   * Threshold FHE: &quot;Partial&quot; decryption computed by all parties except for the\n   * lead one\n   *\n   * @param ciphertext ciphertext that is being decrypted.\n   * @param privateKey secret key share used for decryption.\n   */\n    virtual Ciphertext&lt;Element&gt; MultipartyDecryptMain(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                      const PrivateKey&lt;Element&gt; privateKey) const;\n\n    /**\n   * Threshold FHE: Method for decryption operation run by the lead decryption\n   * client\n   *\n   * @param ciphertext ciphertext id decrypted.\n   * @param privateKey secret key share used for decryption.\n   */\n    virtual Ciphertext&lt;Element&gt; MultipartyDecryptLead(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                      const PrivateKey&lt;Element&gt; privateKey) const;\n\n    /**\n   * Threshold FHE: Method for combining the partially decrypted ciphertexts\n   * and getting the final decryption in the clear as a NativePoly.\n   *\n   * @param &amp;ciphertextVec vector of &quot;partial&quot; decryptions.\n   * @param *plaintext the plaintext output as a NativePoly.\n   * @return the decoding result.\n   */\n    virtual DecryptResult MultipartyDecryptFusion(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                                  NativePoly* plaintext) const;\n\n    /**\n   * Threshold FHE: Method for combining the partially decrypted ciphertexts\n   * and getting the final decryption in the clear as a Poly.\n   *\n   * @param &amp;ciphertextVec vector of &quot;partial&quot; decryptions.\n   * @param *plaintext the plaintext output as a Poly.\n   * @return the decoding result.\n   */\n    virtual DecryptResult MultipartyDecryptFusion(const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; ciphertextVec,\n                                                  Poly* plaintext) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Decryption to Poly is not supported&quot;);\n    }\n\n    /**\n   * Threshold FHE: Adds two prior public keys\n   *\n   * @param evalKey1 first public key.\n   * @param evalKey2 second public key.\n   * @return the new joined key.\n   */\n    virtual PublicKey&lt;Element&gt; MultiAddPubKeys(PublicKey&lt;Element&gt; publicKey1, PublicKey&lt;Element&gt; publicKey2) const;\n\n    /**\n   * Threshold FHE: Adds two prior evaluation keys\n   *\n   * @param evalKey1 first evaluation key.\n   * @param evalKey2 second evaluation key.\n   * @return the new joined key.\n   */\n    virtual EvalKey&lt;Element&gt; MultiAddEvalKeys(EvalKey&lt;Element&gt; evalKey1, EvalKey&lt;Element&gt; evalKey2) const;\n\n    /**\n   * Threshold FHE: Adds two partial evaluation keys for multiplication\n   *\n   * @param evalKey1 first evaluation key.\n   * @param evalKey2 second evaluation key.\n   * @return the new joined key.\n   */\n    virtual EvalKey&lt;Element&gt; MultiAddEvalMultKeys(EvalKey&lt;Element&gt; evalKey1, EvalKey&lt;Element&gt; evalKey2) const;\n\n    /**\n    * Threshold FHE: Generates a partial evaluation key for homomorphic\n    * multiplication based on the current secret share and an existing partial\n    * evaluation key\n    *\n    * @param privateKey current secret share.\n    * @param evalKey prior evaluation key.\n    * @return the new joined key.\n    */\n    virtual EvalKey&lt;Element&gt; MultiMultEvalKey(PrivateKey&lt;Element&gt; privateKey, EvalKey&lt;Element&gt; evalKey) const;\n    /**\n    *\n    * Threshold FHE: Adds two prior evaluation key sets for automorphisms\n    *\n    * @param evalKeyMap1 first automorphism key set.\n    * @param evalKeyMap2 second automorphism key set.\n    * @return the new joined key set for summation.\n    */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiAddEvalAutomorphismKeys(\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap1,\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap2) const;\n\n    /**\n    * Threshold FHE: Adds two prior evaluation key sets for summation\n    *\n    * @param evalKeyMap1 first summation key set.\n    * @param evalKeyMap2 second summation key set.\n    * @return the new joined key set for summation.\n    */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; MultiAddEvalSumKeys(\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap1,\n        const std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; evalKeyMap2) const;\n\n    /**\n    * Threshold FHE: Prepare a ciphertext for Multi-Party Interactive Bootstrapping\n    *\n    * @param ciphertext: Input Ciphertext\n    * @return: Resulting Ciphertext\n    */\n    virtual Ciphertext&lt;Element&gt; IntMPBootAdjustScale(ConstCiphertext&lt;Element&gt; ciphertext) const;\n\n    /**\n    * Threshold FHE: Generate a common random polynomial for Multi-Party Interactive Bootstrapping\n    *\n    * @param publicKey: the scheme public key (you can also provide the lead party&#x27;s public-key)\n    * @return: Resulting ring element\n    */\n    virtual Ciphertext&lt;Element&gt; IntMPBootRandomElementGen(std::shared_ptr&lt;CryptoParametersCKKSRNS&gt; params,\n                                                          const PublicKey&lt;Element&gt; publicKey) const;\n\n    /**\n    * Threshold FHE: Does masked decryption as part of Multi-Party Interactive Bootstrapping.\n    * Each party calls this function as part of the protocol\n    *\n    * @param privateKey: secret key share for party i\n    * @param ciphertext: input ciphertext\n    * @param a: input common random polynomial\n    * @return: Resulting masked decryption\n    */\n    virtual std::vector&lt;Ciphertext&lt;Element&gt;&gt; IntMPBootDecrypt(const PrivateKey&lt;Element&gt; privateKey,\n                                                              ConstCiphertext&lt;Element&gt; ciphertext,\n                                                              ConstCiphertext&lt;Element&gt; a) const;\n\n    /**\n    * Threshold FHE: Aggregates a vector of masked decryptions and re-encryotion shares,\n    * which is the second step of the interactive multiparty bootstrapping procedure.\n    *\n    * @param sharesPairVec: vector of pair of ciphertexts, each element of this vector contains\n    * (h_0i, h_1i) - the masked-decryption and encryption shares ofparty i\n    * @return: aggregated pair of shares ((h_0, h_1)\n    */\n    virtual std::vector&lt;Ciphertext&lt;Element&gt;&gt; IntMPBootAdd(\n        std::vector&lt;std::vector&lt;Ciphertext&lt;Element&gt;&gt;&gt;&amp; sharesPairVec) const;\n\n    /**\n    *  Threshold FHE: Does public key encryption of lead party&#x27;s masked decryption\n    * as part of interactive multi-party bootstrapping, which increases\n    * the ciphertext modulus and enables future computations.\n    * This operation is done by the lead party as the final step\n    * of interactive multi-party bootstrapping.\n    *\n    * @param publicKey: the lead party&#x27;s public key\n    * @param sharesPair: aggregated decryption and re-encryption shares\n    * @param a: common random ring element\n    * @param ciphertext: input ciphertext\n    * @return: Resulting encryption\n    */\n    virtual Ciphertext&lt;Element&gt; IntMPBootEncrypt(const PublicKey&lt;Element&gt; publicKey,\n                                                 const std::vector&lt;Ciphertext&lt;Element&gt;&gt;&amp; sharesPair,\n                                                 ConstCiphertext&lt;Element&gt; a, ConstCiphertext&lt;Element&gt; ciphertext) const;\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {}\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {}\n\n    std::string SerializedObjectName() const {\n        return &quot;MultiPartyBase&quot;;\n    }\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/binfhe/include/lwe-cryptoparameters.h": {"id": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/lwe-cryptoparameters.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/lwe-cryptoparameters.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef _LWE_CRYPTOPARAMETERS_H_\n#define _LWE_CRYPTOPARAMETERS_H_\n\n#include &quot;binfhe-constants.h&quot;\n\n#include &quot;math/discretegaussiangenerator.h&quot;\n#include &quot;math/math-hal.h&quot;\n#include &quot;utils/serializable.h&quot;\n\n#include &lt;string&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\n\nnamespace lbcrypto {\n\n/**\n * @brief Class that stores all parameters for the LWE scheme\n */\nclass LWECryptoParams : public Serializable {\npublic:\n    // NativeInteger m_qKS = 1&lt;&lt;20; //PreviousPrime&lt;NativeInteger&gt;(FirstPrime&lt;NativeInteger&gt;(26, 2048), 2048);\n    LWECryptoParams() = default;\n\n    /**\n   * Main constructor for LWECryptoParams\n   *\n   * @param n lattice parameter for additive LWE scheme\n   * @param N ring dimension for RingGSW/RLWE used in bootstrapping\n   * @param q modulus for additive LWE\n   * @param Q modulus for RingGSW/RLWE used in bootstrapping\n   * @param q_KS modulus for key switching\n   * @param std standard deviation\n   * @param baseKS the base used for key switching\n   * @param keyDist the key distribution\n   */\n    explicit LWECryptoParams(uint32_t n, uint32_t N, const NativeInteger&amp; q, const NativeInteger&amp; Q,\n                             const NativeInteger&amp; q_KS, double std, uint32_t baseKS,\n                             SecretKeyDist keyDist = UNIFORM_TERNARY)\n        : m_q(q), m_Q(Q), m_qKS(q_KS), m_n(n), m_N(N), m_baseKS(baseKS), m_keyDist(keyDist) {\n        if(!m_n)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;m_n (lattice parameter) can not be zero&quot;);\n        if(!m_N)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;m_N (ring dimension) can not be zero&quot;);\n        if(!m_q)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;m_q (modulus for additive LWE) can not be zero&quot;);\n        if(!m_Q)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;m_Q (modulus for RingGSW/RLWE) can not be zero&quot;);\n        if(!q_KS)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;q_KS (modulus for key switching) can not be zero&quot;);\n        if(!m_baseKS)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;m_baseKS (the base used for key switching) can not be zero&quot;);\n        \n        if (m_Q.GetMSB() &gt; MAX_MODULUS_SIZE)\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Q.GetMSB() &gt; MAX_MODULUS_SIZE&quot;);\n        m_dgg.SetStd(std);\n        m_ks_dgg.SetStd(std);\n    }\n\n    // TODO: add m_qKS, m_ks_dgg, and m_keyDist to copy/move operations?\n\n    LWECryptoParams(const LWECryptoParams&amp; rhs)\n        : m_q(rhs.m_q),\n          m_Q(rhs.m_Q),\n          // m_qKS(rhs.m_qKS),\n          m_n(rhs.m_n),\n          m_N(rhs.m_N),\n          m_baseKS(rhs.m_baseKS) {\n        this-&gt;m_dgg.SetStd(rhs.m_dgg.GetStd());\n        // this-&gt;m_ks_dgg.SetStd(rhs.m_ks_dgg.GetStd());\n    }\n\n    LWECryptoParams(LWECryptoParams&amp;&amp; rhs) noexcept\n        : m_q(std::move(rhs.m_q)),\n          m_Q(std::move(rhs.m_Q)),\n          // m_qKS(std::move(rhs.m_qKS)),\n          m_n(rhs.m_n),\n          m_N(rhs.m_N),\n          m_baseKS(rhs.m_baseKS) {\n        this-&gt;m_dgg.SetStd(rhs.m_dgg.GetStd());\n        // this-&gt;m_ks_dgg.SetStd(rhs.m_ks_dgg.GetStd());\n    }\n\n    LWECryptoParams&amp; operator=(const LWECryptoParams&amp; rhs) {\n        this-&gt;m_q = rhs.m_q;\n        this-&gt;m_Q = rhs.m_Q;\n        // this-&gt;m_qKS    = rhs.m_qKS;\n        this-&gt;m_n      = rhs.m_n;\n        this-&gt;m_N      = rhs.m_N;\n        this-&gt;m_baseKS = rhs.m_baseKS;\n        this-&gt;m_dgg.SetStd(rhs.m_dgg.GetStd());\n        // this-&gt;m_ks_dgg.SetStd(rhs.m_ks_dgg.GetStd());\n        return *this;\n    }\n\n    LWECryptoParams&amp; operator=(LWECryptoParams&amp;&amp; rhs) noexcept {\n        this-&gt;m_q = std::move(rhs.m_q);\n        this-&gt;m_Q = std::move(rhs.m_Q);\n        // this-&gt;m_qKS    = std::move(rhs.m_qKS);\n        this-&gt;m_n      = rhs.m_n;\n        this-&gt;m_N      = rhs.m_N;\n        this-&gt;m_baseKS = rhs.m_baseKS;\n        this-&gt;m_dgg.SetStd(rhs.m_dgg.GetStd());\n        // this-&gt;m_ks_dgg.SetStd(rhs.m_ks_dgg.GetStd());\n        return *this;\n    }\n\n    uint32_t Getn() const {\n        return m_n;\n    }\n\n    uint32_t GetN() const {\n        return m_N;\n    }\n\n    const NativeInteger&amp; Getq() const {\n        return m_q;\n    }\n\n    const NativeInteger&amp; GetQ() const {\n        return m_Q;\n    }\n\n    const NativeInteger&amp; GetqKS() const {\n        return m_qKS;\n    }\n\n    uint32_t GetBaseKS() const {\n        return m_baseKS;\n    }\n\n    const DiscreteGaussianGeneratorImpl&lt;NativeVector&gt;&amp; GetDgg() const {\n        return m_dgg;\n    }\n\n    const DiscreteGaussianGeneratorImpl&lt;NativeVector&gt;&amp; GetDggKS() const {\n        return m_ks_dgg;\n    }\n\n    SecretKeyDist GetKeyDist() const {\n        return m_keyDist;\n    }\n\n    bool operator==(const LWECryptoParams&amp; other) const {\n        return m_n == other.m_n &amp;&amp; m_N == other.m_N &amp;&amp; m_q == other.m_q &amp;&amp; m_Q == other.m_Q &amp;&amp;\n               m_dgg.GetStd() == other.m_dgg.GetStd() &amp;&amp; m_baseKS == other.m_baseKS;\n    }\n\n    bool operator!=(const LWECryptoParams&amp; other) const {\n        return !(*this == other);\n    }\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(::cereal::make_nvp(&quot;n&quot;, m_n));\n        ar(::cereal::make_nvp(&quot;N&quot;, m_N));\n        ar(::cereal::make_nvp(&quot;q&quot;, m_q));\n        ar(::cereal::make_nvp(&quot;Q&quot;, m_Q));\n        ar(::cereal::make_nvp(&quot;qKS&quot;, m_qKS));\n        ar(::cereal::make_nvp(&quot;sigma&quot;, m_dgg.GetStd()));\n        ar(::cereal::make_nvp(&quot;sigmaKS&quot;, m_ks_dgg.GetStd()));\n        ar(::cereal::make_nvp(&quot;bKS&quot;, m_baseKS));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        if (version &gt; SerializedVersion()) {\n            &quot;hey&quot;; OPENFHE_THROW(deserialize_error, &quot;serialized object version &quot; + std::to_string(version) +\n                                                 &quot; is from a later version of the library&quot;);\n        }\n\n        ar(::cereal::make_nvp(&quot;n&quot;, m_n));\n        ar(::cereal::make_nvp(&quot;N&quot;, m_N));\n        ar(::cereal::make_nvp(&quot;q&quot;, m_q));\n        ar(::cereal::make_nvp(&quot;Q&quot;, m_Q));\n        ar(::cereal::make_nvp(&quot;qKS&quot;, m_qKS));\n        double sigma = 0;\n        ar(::cereal::make_nvp(&quot;sigma&quot;, sigma));\n        double sigmaKS = 0;\n        ar(::cereal::make_nvp(&quot;sigmaKS&quot;, sigmaKS));\n        m_dgg.SetStd(sigma);\n        m_ks_dgg.SetStd(sigmaKS);\n        ar(::cereal::make_nvp(&quot;bKS&quot;, m_baseKS));\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;LWECryptoParams&quot;;\n    }\n    static uint32_t SerializedVersion() {\n        return 1;\n    }\n\nprivate:\n    // modulus for the additive LWE scheme\n    NativeInteger m_q{};\n    // modulus for the RingGSW/RingLWE scheme\n    NativeInteger m_Q{};\n    // modulus for key-switching\n    NativeInteger m_qKS{};\n    // lattice parameter for the additive LWE scheme\n    uint32_t m_n{};\n    // ring dimension for RingGSW/RingLWE scheme\n    uint32_t m_N{};\n    // Base used in key switching\n    uint32_t m_baseKS{};\n    // Secret key distribution: GAUSSIAN, UNIFORM_TERNARY, etc.\n    SecretKeyDist m_keyDist{SecretKeyDist::UNIFORM_TERNARY};\n    // Error distribution generator\n    DiscreteGaussianGeneratorImpl&lt;NativeVector&gt; m_dgg;\n    // Error distribution generator for key switching\n    DiscreteGaussianGeneratorImpl&lt;NativeVector&gt; m_ks_dgg;\n};\n\n}  // namespace lbcrypto\n\n#endif  // _LWE_CRYPTOPARAMETERS_H_\n"}, "/home/zero0000/static-analyze-openfhe/src/binfhe/include/rgsw-acc.h": {"id": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/rgsw-acc.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/rgsw-acc.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef _RGSW_FHE_H_\n#define _RGSW_FHE_H_\n\n#include &quot;rlwe-ciphertext.h&quot;\n#include &quot;rgsw-acckey.h&quot;\n#include &quot;rgsw-cryptoparameters.h&quot;\n\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n\nnamespace lbcrypto {\n\n/**\n * @brief Ring GSW accumulator schemes described in\n * https://eprint.iacr.org/2014/816, https://eprint.iacr.org/2020/086 and https://eprint.iacr.org/2022/198\n */\nclass RingGSWAccumulator {\npublic:\n    RingGSWAccumulator() = default;\n\n    /**\n   * Key generation for internal Ring GSW\n   *\n   * @param params a shared pointer to RingGSW scheme parameters\n   * @param skNTT secret key polynomial in the EVALUATION representation\n   * @param LWEsk the secret key\n   * @return a shared pointer to the resulting keys\n   */\n    virtual RingGSWACCKey KeyGenAcc(const std::shared_ptr&lt;RingGSWCryptoParams&gt;&amp; params, const NativePoly&amp; skNTT,\n                                    ConstLWEPrivateKey&amp; LWEsk) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;KeyGenACC operation not supported&quot;);\n    }\n\n    /**\n   * Main accumulator function used in bootstrapping\n   *\n   * @param params a shared pointer to RingGSW scheme parameters\n   * @param ek the accumulator key\n   * @param acc previous value of the accumulator\n   * @param a value to update the accumulator with\n   */\n    virtual void EvalAcc(const std::shared_ptr&lt;RingGSWCryptoParams&gt;&amp; params, ConstRingGSWACCKey&amp; ek,\n                         RLWECiphertext&amp; acc, const NativeVector&amp; a) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;ACC operation not supported&quot;);\n    }\n\n    /**\n   * The signed digit decomposition which takes an RLWE ciphertext input and outputs a vector of its digits, i.e., an\n   * RLWE&#x27; ciphertext\n   *\n   * @param params a shared pointer to RingGSW scheme parameters\n   * @param input input RLWE ciphertext\n   * @param output output RLWE&#x27; ciphertext\n   */\n    void SignedDigitDecompose(const std::shared_ptr&lt;RingGSWCryptoParams&gt;&amp; params, const std::vector&lt;NativePoly&gt;&amp; input,\n                              std::vector&lt;NativePoly&gt;&amp; output) const;\n\n    /**\n   * The signed digit decomposition which takes a ring element input and outputs a vector of its digits, i.e.,\n   * decompose(a) = (a_0, ..., a_{d-1}) = R^d.\n   * Only for automorphism key switching LMKCDEY\n   *\n   * @param params a shared pointer to RingGSW scheme parameters\n   * @param input input ring element\n   * @param output decomposed value\n   */\n    void SignedDigitDecompose(const std::shared_ptr&lt;RingGSWCryptoParams&gt;&amp; params, const NativePoly&amp; input,\n                              std::vector&lt;NativePoly&gt;&amp; output) const;\n};\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/binfhe/include/binfhe-base-scheme.h": {"id": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/binfhe-base-scheme.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/binfhe-base-scheme.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef BINFHE_FHEW_H\n#define BINFHE_FHEW_H\n\n#include &quot;binfhe-base-params.h&quot;\n#include &quot;lwe-pke.h&quot;\n#include &quot;rlwe-ciphertext.h&quot;\n#include &quot;rgsw-acckey.h&quot;\n#include &quot;rgsw-acc.h&quot;\n#include &quot;rgsw-acc-dm.h&quot;\n#include &quot;rgsw-acc-cggi.h&quot;\n#include &quot;rgsw-acc-lmkcdey.h&quot;\n\n#include &lt;map&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n\nnamespace lbcrypto {\n\n// The struct for storing bootstrapping keys\ntypedef struct {\n    // refreshing key\n    RingGSWACCKey BSkey;\n    // switching key\n    LWESwitchingKey KSkey;\n    // public key\n    LWEPublicKey Pkey;\n} RingGSWBTKey;\n\n/**\n * @brief Ring GSW accumulator schemes described in\n * https://eprint.iacr.org/2014/816, https://eprint.iacr.org/2020/086 and https://eprint.iacr.org/2022/198\n */\nclass BinFHEScheme {\npublic:\n    BinFHEScheme() = default;\n\n    explicit BinFHEScheme(BINFHE_METHOD method) {\n        if (method == AP)\n            ACCscheme = std::make_shared&lt;RingGSWAccumulatorDM&gt;();\n        else if (method == GINX)\n            ACCscheme = std::make_shared&lt;RingGSWAccumulatorCGGI&gt;();\n        else if (method == LMKCDEY)\n            ACCscheme = std::make_shared&lt;RingGSWAccumulatorLMKCDEY&gt;();\n        else\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;method is invalid&quot;);\n    }\n\n    /**\n   * Generates a refresh key\n   *\n   * @param params a shared pointer to RingGSW scheme parameters\n   * @param LWEsk a shared pointer to the secret key of the underlying additive\n   * @param keygenMode enum to indicate generation of secret key only (SYM_ENCRYPT) or\n   * secret key, public key pair (PUB_ENCRYPT)\n   * @return a shared pointer to the refresh key\n   */\n    RingGSWBTKey KeyGen(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params, ConstLWEPrivateKey&amp; LWEsk,\n                        KEYGEN_MODE keygenMode) const;\n\n    /**\n   * Evaluates a binary gate (calls bootstrapping as a subroutine)\n   *\n   * @param params a shared pointer to RingGSW scheme parameters\n   * @param gate the gate; can be AND, OR, NAND, NOR, XOR, or XOR\n   * @param EK a shared pointer to the bootstrapping keys\n   * @param ct1 first ciphertext\n   * @param ct2 second ciphertext\n   * @return a shared pointer to the resulting ciphertext\n   */\n    LWECiphertext EvalBinGate(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params, BINGATE gate, const RingGSWBTKey&amp; EK,\n                              ConstLWECiphertext&amp; ct1, ConstLWECiphertext&amp; ct2) const;\n\n    /**\n   * Evaluates a binary gate on a vector of ciphertexts (calls bootstrapping as a subroutine).\n   * The evaluation of the gates in this function is specific to 3 input and 4 input\n   *\n   * @param params a shared pointer to RingGSW scheme parameters\n   * @param gate the gate; can be for 3-input: AND3, OR3, MAJORITY, CMUX, for 4-input: AND4, OR4\n   * @param EK a shared pointer to the bootstrapping keys\n   * @param ctvector vector of ciphertexts\n   * @return a shared pointer to the resulting ciphertext\n   */\n    LWECiphertext EvalBinGate(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params, BINGATE gate, const RingGSWBTKey&amp; EK,\n                              const std::vector&lt;LWECiphertext&gt;&amp; ctvector) const;\n\n    /**\n   * Evaluates NOT gate\n   *\n   * @param params a shared pointer to RingGSW scheme parameters\n   * @param ct1 the input ciphertext\n   * @return a shared pointer to the resulting ciphertext\n   */\n    LWECiphertext EvalNOT(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params, ConstLWECiphertext&amp; ct) const;\n\n    /**\n   * Bootstraps a fresh ciphertext\n   *\n   * @param params a shared pointer to RingGSW scheme parameters\n   * @param EK a shared pointer to the bootstrapping keys\n   * @param ct1 input ciphertext\n   * @return a shared pointer to the resulting ciphertext\n   */\n    LWECiphertext Bootstrap(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params, const RingGSWBTKey&amp; EK,\n                            ConstLWECiphertext&amp; ct) const;\n\n    /**\n   * Evaluate an arbitrary function\n   *\n   * @param params a shared pointer to RingGSW scheme parameters\n   * @param EK a shared pointer to the bootstrapping keys\n   * @param ct input ciphertext\n   * @param LUT the look-up table of the to-be-evaluated function\n   * @param beta the error bound\n   * @return a shared pointer to the resulting ciphertext\n   */\n    LWECiphertext EvalFunc(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params, const RingGSWBTKey&amp; EK,\n                           ConstLWECiphertext&amp; ct, const std::vector&lt;NativeInteger&gt;&amp; LUT,\n                           const NativeInteger&amp; beta) const;\n\n    /**\n   * Evaluate a round down function\n   *\n   * @param params a shared pointer to RingGSW scheme parameters\n   * @param EK a shared pointer to the bootstrapping keys\n   * @param ct input ciphertext\n   * @param beta the error bound\n   * @param roundbits by how many bits to round down\n   * @return a shared pointer to the resulting ciphertext\n   */\n    LWECiphertext EvalFloor(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params, const RingGSWBTKey&amp; EK,\n                            ConstLWECiphertext&amp; ct, const NativeInteger&amp; beta, uint32_t roundbits = 0) const;\n\n    /**\n   * Evaluate a sign function over large precision\n   *\n   * @param params a shared pointer to RingGSW scheme parameters\n   * @param EK a shared pointer to the bootstrapping keys map\n   * @param ct input ciphertext\n   * @param beta the error bound\n   * @param schemeSwitch flag that indicates if it should be compatible to scheme switching\n   * @return a shared pointer to the resulting ciphertext\n   */\n    LWECiphertext EvalSign(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params,\n                           const std::map&lt;uint32_t, RingGSWBTKey&gt;&amp; EKs, ConstLWECiphertext&amp; ct,\n                           const NativeInteger&amp; beta, bool schemeSwitch = false) const;\n\n    /**\n   * Evaluate digit decomposition over a large precision LWE ciphertext\n   *\n   * @param params a shared pointer to RingGSW scheme parameters\n   * @param EKs a shared pointer to the bootstrapping keys map\n   * @param ct input ciphertext\n   * @param beta the error bound\n   * @return a shared pointer to the resulting ciphertext\n   */\n    std::vector&lt;LWECiphertext&gt; EvalDecomp(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params,\n                                          const std::map&lt;uint32_t, RingGSWBTKey&gt;&amp; EKs, ConstLWECiphertext&amp; ct,\n                                          const NativeInteger&amp; beta) const;\n\nprivate:\n    /**\n   * Core bootstrapping operation\n   *\n   * @param params a shared pointer to RingGSW scheme parameters\n   * @param gate the gate; can be AND, OR, NAND, NOR, XOR, or XOR\n   * @param ek a shared pointer to the bootstrapping keys\n   * @param ct input ciphertext\n   * @return the output RingLWE accumulator\n   */\n    RLWECiphertext BootstrapGateCore(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params, BINGATE gate,\n                                     ConstRingGSWACCKey&amp; ek, ConstLWECiphertext&amp; ct) const;\n\n    // Arbitrary function evaluation purposes\n\n    /**\n   * Core bootstrapping operation\n   *\n   * @param params a shared pointer to RingGSW scheme parameters\n   * @param ek a shared pointer to the bootstrapping keys\n   * @param ct input ciphertext\n   * @param f function to evaluate in the functional bootstrapping\n   * @param fmod modulus over which the function is defined\n   * @return a shared pointer to the resulting ciphertext\n   */\n    template &lt;typename Func&gt;\n    RLWECiphertext BootstrapFuncCore(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params, ConstRingGSWACCKey&amp; ek,\n                                     ConstLWECiphertext&amp; ct, const Func f, const NativeInteger&amp; fmod) const;\n\n    /**\n   * Bootstraps a fresh ciphertext\n   *\n   * @param params a shared pointer to RingGSW scheme parameters\n   * @param EK a shared pointer to the bootstrapping keys\n   * @param ct input ciphertext\n   * @param f function to evaluate in the functional bootstrapping\n   * @param fmod modulus over which the function is defined\n   * @return the output RingLWE accumulator\n   */\n    template &lt;typename Func&gt;\n    LWECiphertext BootstrapFunc(const std::shared_ptr&lt;BinFHECryptoParams&gt;&amp; params, const RingGSWBTKey&amp; EK,\n                                ConstLWECiphertext&amp; ct, const Func f, const NativeInteger&amp; fmod) const;\n\nprotected:\n    std::shared_ptr&lt;LWEEncryptionScheme&gt; LWEscheme{std::make_shared&lt;LWEEncryptionScheme&gt;()};\n    std::shared_ptr&lt;RingGSWAccumulator&gt; ACCscheme{nullptr};\n\n    /**\n   * Checks type of input function\n   *\n   * @param lut look up table for the input function\n   * @param mod modulus over which the function is defined\n   * @return the function type: 0 for negacyclic, 1 for periodic, 2 for arbitrary\n   */\n    static uint32_t checkInputFunction(const std::vector&lt;NativeInteger&gt;&amp; lut, NativeInteger mod) {\n        size_t mid{lut.size() / 2};\n        if (lut[0] == (mod - lut[mid])) {\n            for (size_t i = 1; i &lt; mid; ++i)\n                if (lut[i] != (mod - lut[mid + i]))\n                    return 2;\n            return 0;\n        }\n        if (lut[0] == lut[mid]) {\n            for (size_t i = 1; i &lt; mid; ++i)\n                if (lut[i] != lut[mid + i])\n                    return 2;\n            return 1;\n        }\n        return 2;\n    }\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_BASE_FHE_H\n#define LBCRYPTO_CRYPTO_BASE_FHE_H\n\n#include &quot;key/privatekey-fwd.h&quot;\n#include &quot;key/evalkey-fwd.h&quot;\n#include &quot;ciphertext-fwd.h&quot;\n#include &quot;cryptocontext-fwd.h&quot;\n#include &quot;utils/exception.h&quot;\n\n#include &quot;binfhecontext.h&quot;\n#include &quot;key/keypair.h&quot;\n\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n#include &lt;map&gt;\n#include &lt;utility&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\n\n/**\n * @brief Abstract interface class for LBC PRE algorithms\n * @tparam Element a ring element.\n */\ntemplate &lt;class Element&gt;\nclass FHEBase {\npublic:\n    virtual ~FHEBase() {}\n\n    /**\n   * Bootstrap functionality:\n   * There are three methods that have to be called in this specific order:\n   * 1. EvalBootstrapSetup: computes and encodes the coefficients for encoding and\n   * decoding and stores the necessary parameters\n   * 2. EvalBootstrapKeyGen: computes and stores the keys for rotations and conjugation\n   * 3. EvalBootstrap: refreshes the given ciphertext\n   */\n\n    /**\n   * Sets all parameters for the linear method for the FFT-like method\n   *\n   * @param levelBudget - vector of budgets for the amount of levels in encoding\n   * and decoding\n   * @param dim1 - vector of inner dimension in the baby-step giant-step routine\n   * for encoding and decoding\n   * @param slots - number of slots to be bootstrapped\n   * @param correctionFactor - value to rescale message by to improve precision. If set to 0, we use the default logic. This value is only used when NATIVE_SIZE=64.\n   */\n    virtual void EvalBootstrapSetup(const CryptoContextImpl&lt;Element&gt;&amp; cc, std::vector&lt;uint32_t&gt; levelBudget,\n                                    std::vector&lt;uint32_t&gt; dim1, uint32_t slots, uint32_t correctionFactor) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;Not supported&quot;);\n    }\n\n    /**\n   * Virtual function to define the generation of all automorphism keys for EvalBT (with FFT evaluation).\n   * EvalBTKeyGen uses the baby-step/giant-step strategy.\n   *\n   * @param privateKey private key.\n   * @param slots - number of slots to be bootstrapped\n   * @return the dictionary of evaluation key indices.\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalBootstrapKeyGen(const PrivateKey&lt;Element&gt; privateKey,\n                                                                                   uint32_t slots) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;Not supported&quot;);\n    }\n\n    /**\n   * Defines the bootstrapping evaluation of ciphertext\n   *\n   * The flavor of bootstrapping that uses the numIterations and precision parameters is described\n   * in the Meta-BTS paper.\n   * Source: Bae Y., Cheon J., Cho W., Kim J., and Kim T. META-BTS: Bootstrapping Precision\n   * Beyond the Limit. Cryptology ePrint Archive, Report\n   * 2022/1167. (https://eprint.iacr.org/2022/1167.pdf)\n   *\n   * @param ciphertext the input ciphertext.\n   * @param numIterations number of iterations to run iterative bootstrapping (Meta-BTS). Increasing the iterations increases the precision of bootstrapping.\n   * @param precision precision of initial bootstrapping algorithm. This value is\n   * determined by the user experimentally by first running EvalBootstrap with numIterations = 1 and precision = 0 (unused).\n   * @return the refreshed ciphertext.\n   */\n    virtual Ciphertext&lt;Element&gt; EvalBootstrap(ConstCiphertext&lt;Element&gt; ciphertext, uint32_t numIterations,\n                                              uint32_t precision) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalBootstrap is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Sets all parameters for switching from CKKS to FHEW\n   *\n   * @param cc the CKKS cryptocontext from which to switch\n   * @param sl security level for CKKS cryptocontext\n   * @param slBin security level for FHEW cryptocontext\n   * @param arbFunc whether the binfhecontext should be created for arbitrary function evaluation or not\n   * @param logQ size of ciphertext modulus in FHEW for large-precision evaluation\n   * @param dynamic whether to use dynamic mode for FHEW\n   * @param numSlotsCKKS number of slots in CKKS encryption\n   * @param logQswitch size of ciphertext modulus in intermediate switch for security with the FHEW ring dimension\n   * @return the FHEW cryptocontext and its secret key (if a method from extracting the binfhecontext\n   * from the secret key is created, then we can only return the secret key)\n   */\n    virtual std::pair&lt;BinFHEContext, LWEPrivateKey&gt; EvalCKKStoFHEWSetup(const CryptoContextImpl&lt;Element&gt;&amp; cc,\n                                                                        SecurityLevel sl, BINFHE_PARAMSET slBin,\n                                                                        bool arbFunc, uint32_t logQ, bool dynamic,\n                                                                        uint32_t numSlotsCKKS, uint32_t logQswitch) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalCKKStoFHEWSetup is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Virtual function to define the generation of all keys for scheme switching between CKKS and FHEW:\n   * the rotation keys for the baby-step/giant-step strategy,\n   * conjugation keys, switching key from CKKS to FHEW\n   * @param keypair CKKS key pair\n   * @param lwesk FHEW secret key\n   * @param dim1 baby-step for the linear transform\n   * @param L level on which the hom. decoding matrix should be. We want the hom. decoded ciphertext to be on the last level\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalCKKStoFHEWKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair,\n                                                                                    ConstLWEPrivateKey&amp; lwesk,\n                                                                                    uint32_t dim1, uint32_t L) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalCKKStoFHEWKeyGen is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Performs precomputations for the homomorphic decoding in CKKS. Given as a separate method than EvalCKKStoFHEWSetup\n   * to allow the user to specify a scale that depends on the CKKS and FHEW cryptocontexts\n   *\n   * @param cc the CKKS cryptocontext from which to switch\n   * @param scale factor with which to scale the matrix in the linear transform\n   * @param dim1 baby-step for the linear transform\n   * @param L level on which the hom. decoding matrix should be. We want the hom. decoded ciphertext to be on the last level\n   */\n    virtual void EvalCKKStoFHEWPrecompute(const CryptoContextImpl&lt;Element&gt;&amp; cc, double scale) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalCKKStoFHEWPrecompute is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Performs the scheme switching on a CKKS ciphertext\n   * @param ciphertext CKKS ciphertext to switch\n   * @param numCtxts number of coefficients to extract from the CKKS ciphertext. If it is zero, it defaults to number of slots\n   * @return a vector of LWE ciphertexts of length the numCtxts\n   */\n    virtual std::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt; EvalCKKStoFHEW(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                           uint32_t numCtxts) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalCKKStoFHEW is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Sets all parameters for switching from FHEW to CKKS. The CKKS cryptocontext to switch to is\n   * already generated.\n   *\n   * @param ccCKKS the CKKS cryptocontext to switch to\n   * @param ccLWE the FHEW cryptocontext from which to switch\n   * @param numSlotsCKKS number of FHEW ciphertexts that becomes the number of slots in CKKS encryption\n   * @param logQ the logarithm of a ciphertext modulus in FHEW\n   */\n    virtual void EvalFHEWtoCKKSSetup(const CryptoContextImpl&lt;Element&gt;&amp; ccCKKS, const BinFHEContext&amp; ccLWE,\n                                     uint32_t numSlotsCKKS, uint32_t logQ) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalFHEWtoCKKSSetup is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Generates all keys for scheme switching: the rotation keys for the baby-step/giant-step strategy\n   * in the linear transform for the partial decryption, the switching key from FHEW to CKKS\n   *\n   * @param keypair CKKS key pair\n   * @param lwesk FHEW secret key\n   * @param numSlots number of slots for the CKKS encryption of the FHEW secret key\n   * @param dim1 baby-step for the linear transform\n   * @param L level on which the hom. decoding matrix should be. We want the hom. decoded ciphertext to be on the last level\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalFHEWtoCKKSKeyGen(const KeyPair&lt;Element&gt;&amp; keyPair,\n                                                                                    ConstLWEPrivateKey&amp; lwesk,\n                                                                                    uint32_t numSlots,\n                                                                                    uint32_t dim1 = 0, uint32_t L = 0) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalFHEWtoCKKSKeyGen is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Performs precomputations for the homomorphic decoding in CKKS. Given as a separate method than EvalSchemeSwitchingSetup\n   * to allow the user to specify a scale that depends on the CKKS and FHEW cryptocontexts\n   *\n   * @param cc the CKKS cryptocontext from which to switch\n   * @param pLWE the desired plaintext modulus for the new FHEW ciphertexts\n   * @param initLevel the level of the ciphertext that will be switched\n   * @param scaleSign factor to multiply the CKKS ciphertext when switching to FHEW in case the messages are too small;\n   * the resulting FHEW ciphertexts will encrypt values modulo pLWE, so scaleSign should account for this\n   * @param unit whether the input messages are normalized to the unit circle\n   */\n    virtual void EvalCompareSwitchPrecompute(const CryptoContextImpl&lt;Element&gt;&amp; ccCKKS, uint32_t pLWE,\n                                             uint32_t initLevel, double scaleSign, bool unit) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalCompareSwitchPrecompute is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Performs the scheme switching on a vector of FHEW ciphertexts\n   *\n   * @param LWECiphertexts FHEW/LWE ciphertexts to switch\n   * @param numCtxts number of values to encrypt from the LWE ciphertexts in the new CKKS ciphertext\n   * @param numSlots number of slots to encode in the new CKKS/RLWE ciphertext\n   * @param p plaintext modulus to use to decide postscaling, by default p = 4\n   * @param pmin, pmax plaintext space of the resulting messages (by default [0,2] assuming\n   * the LWE ciphertext had plaintext modulus p = 4 and only bits were encrypted)\n   * @return a CKKS ciphertext encrypting in its slots the messages in the LWE ciphertexts\n   */\n    virtual Ciphertext&lt;Element&gt; EvalFHEWtoCKKS(std::vector&lt;std::shared_ptr&lt;LWECiphertextImpl&gt;&gt;&amp; LWECiphertexts,\n                                               uint32_t numCtxts, uint32_t numSlots, uint32_t p, double pmin,\n                                               double pmax) const {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalFHEWtoCKKS is not implemented for this scheme&quot;);\n    }\n\n    /**\n   * Sets all parameters for switching from CKKS to FHEW and back\n   *\n   * @param sl security level for CKKS cryptocontext\n   * @param slBin security level for FHEW cryptocontext\n   * @param arbFunc whether the binfhecontext should be created for arbitrary function evaluation or not\n   * @param logQ size of ciphertext modulus in FHEW for large-precision evaluation\n   * @param dynamic whether to use dynamic mode for FHEW\n   * @param numSlotsCKKS number of slots in CKKS encryption\n   * @param logQswitch size of ciphertext modulus in intermediate switch for security with the FHEW ring dimension\n   * @return the FHEW cryptocontext and its secret key (if a method from extracting the binfhecontext\n   * from the secret key is created, then we can only return the secret key)\n   * TODO: add an overload for when BinFHEContext is already generated and fed as a parameter\n   */\n    virtual std::pair&lt;BinFHEContext, LWEPrivateKey&gt; EvalSchemeSwitchingSetup(const CryptoContextImpl&lt;DCRTPoly&gt;&amp; ccCKKS,\n                                                                             SecurityLevel sl, BINFHE_PARAMSET slBin,\n                                                                             bool arbFunc, uint32_t logQ, bool dynamic,\n                                                                             uint32_t numSlotsCKKS,\n                                                                             uint32_t logQswitch) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalSchemeSwitchingSetup is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Generates all keys for scheme switching: the rotation keys for the baby-step/giant-step strategy\n   * in the linear transform for the homomorphic encoding and partial decryption, the switching key from\n   * FHEW to CKKS\n   *\n   * @param keypair CKKS key pair\n   * @param lwesk FHEW secret key\n   * @param numValues parameter of argmin computation, set to zero if not needed\n   * @param oneHot flag that indicates if the argmin encoding should be one hot\n   * @param alt flag that indicates whether to use the alternative version of argmin which requires fewer automorphism keys\n   * @param dim1CF baby-step for the linear transform in CKKS to FHEW\n   * @param dim1FC baby-step for the linear transform in FHEW to CKKS\n   * @param LCF level on which to do the linear transform in CKKS to FHEW\n   * @param LFC level on which to do the linear transform in FHEW to CKKS\n   */\n    virtual std::shared_ptr&lt;std::map&lt;usint, EvalKey&lt;Element&gt;&gt;&gt; EvalSchemeSwitchingKeyGen(\n        const KeyPair&lt;Element&gt;&amp; keyPair, ConstLWEPrivateKey&amp; lwesk, uint32_t numValues, bool oneHot, bool alt,\n        uint32_t dim1CF, uint32_t dim1FC, uint32_t LCF, uint32_t LFC) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalSchemeSwitchingKeyGen is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Performs the scheme switching on the difference of two CKKS ciphertexts to compare, evaluates the sign function\n   * over the resulting FHEW ciphertexts, then performs the scheme switching back to a CKKS ciphertext\n   *\n   * @param ciphertext1, ciphertext2 CKKS ciphertexts of messages that need to be compared\n   * @param numCtxts number of coefficients to extract from the CKKS ciphertext. If it is zero, it defaults to number of slots\n   * @param numSlots number of slots to encode the new CKKS ciphertext with\n   * @param pLWE the desired plaintext modulus for the new FHEW ciphertexts. If it is zero, it defaults to the large precision\n   * plaintext modulus Q/2beta\n   * @param scaleSign factor to multiply the CKKS ciphertext when switching to FHEW in case the messages are too small;\n   * the resulting FHEW ciphertexts will encrypt values modulo pLWE, so scaleSign should account for this\n   * @param unit whether the input messages are normalized to the unit circle\n   * @return a CKKS ciphertext encrypting in its slots the sign of  messages in the LWE ciphertexts\n   */\n    virtual Ciphertext&lt;Element&gt; EvalCompareSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext1,\n                                                           ConstCiphertext&lt;Element&gt; ciphertext2, uint32_t numCtxts,\n                                                           uint32_t numSlots, uint32_t pLWE, double scaleSign,\n                                                           bool unit) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalCompareSchemeSwitching is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Computes the minimum and argument of the first numValues packed in a CKKS ciphertext via repeated\n   * scheme switchings to FHEW and back.\n   *\n   * @param ciphertext CKKS ciphertexts of values that need to be compared\n   * @param publicKey public key of the CKKS cryptocontext\n   * @param numValues number of values to extract from the CKKS ciphertext. We always assume for the moment numValues is a power of two\n   * @param numSlots number of slots to encode the new CKKS ciphertext with\n   * @param oneHot whether the argmin result is given as a one hot/elementary vector or as the index\n   * @param pLWE the desired plaintext modulus for the new FHEW ciphertexts\n   * @param scaleSign factor to multiply the CKKS ciphertext when switching to FHEW in case the messages are too small;\n   * the resulting FHEW ciphertexts will encrypt values modulo pLWE, so scaleSign should account for this\n   * pLWE and scaleSign are given here only if the homomorphic decoding matrix is not scaled with the desired values\n   * @return a vector of two CKKS ciphertexts where the first encrypts the minimum value and the second encrypts the\n   * index (in the representation specified by oneHot). The ciphertexts have junk after the first slot in the first ciphertext\n   * and after numValues in the second ciphertext if oneHot=true and after the first slot if oneHot=false.\n   */\n    virtual std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMinSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                    PublicKey&lt;Element&gt; publicKey, uint32_t numValues,\n                                                                    uint32_t numSlots, bool oneHot, uint32_t pLWE,\n                                                                    double scaleSign) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalMinSchemeSwitching is not supported for this scheme&quot;);\n    }\n\n    /**\n     * Performs more operations in FHEW than in CKKS. Slightly better precision but slower.\n    */\n    virtual std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMinSchemeSwitchingAlt(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                       PublicKey&lt;Element&gt; publicKey, uint32_t numValues,\n                                                                       uint32_t numSlots, bool oneHot, uint32_t pLWE,\n                                                                       double scaleSign) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalMinSchemeSwitchingAlt is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Computes the maximum and argument of the first numValues packed in a CKKS ciphertext via repeated\n   * scheme switchings to FHEW and back.\n   *\n   * @param ciphertext CKKS ciphertexts of values that need to be compared\n   * @param publicKey public key of the CKKS cryptocontext\n   * @param numValues number of values to extract from the CKKS ciphertext. We always assume for the moment numValues is a power of two\n   * @param numSlots number of slots to encode the new CKKS ciphertext with\n   * @param oneHot whether the argmax result is given as a one hot/elementary vector or as the index\n   * @param pLWE the desired plaintext modulus for the new FHEW ciphertexts\n   * @param scaleSign factor to multiply the CKKS ciphertext when switching to FHEW in case the messages are too small;\n   * the resulting FHEW ciphertexts will encrypt values modulo pLWE, so scaleSign should account for this\n   * pLWE and scaleSign are given here only if the homomorphic decoding matrix is not scaled with the desired values\n   * @return a vector of two CKKS ciphertexts where the first encrypts the maximum value and the second encrypts the\n   * index (in the representation specified by oneHot). The ciphertexts have junk after the first slot in the first ciphertext\n   * and after numValues in the second ciphertext if oneHot=true and after the first slot if oneHot=false.\n   */\n    virtual std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMaxSchemeSwitching(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                    PublicKey&lt;Element&gt; publicKey, uint32_t numValues,\n                                                                    uint32_t numSlots, bool oneHot, uint32_t pLWE,\n                                                                    double scaleSign) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalMaxSchemeSwitching is not supported for this scheme&quot;);\n    }\n\n    /**\n     * Performs more operations in FHEW than in CKKS. Slightly better precision but slower.\n    */\n    virtual std::vector&lt;Ciphertext&lt;Element&gt;&gt; EvalMaxSchemeSwitchingAlt(ConstCiphertext&lt;Element&gt; ciphertext,\n                                                                       PublicKey&lt;Element&gt; publicKey, uint32_t numValues,\n                                                                       uint32_t numSlots, bool oneHot, uint32_t pLWE,\n                                                                       double scaleSign) {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;EvalMaxSchemeSwitchingAlt is not supported for this scheme&quot;);\n    }\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-pke.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-pke.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-pke.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_BASE_PKE_H\n#define LBCRYPTO_CRYPTO_BASE_PKE_H\n\n#include &quot;ciphertext-fwd.h&quot;\n#include &quot;cryptocontext-fwd.h&quot;\n#include &quot;key/privatekey-fwd.h&quot;\n#include &quot;key/publickey-fwd.h&quot;\n#include &quot;decrypt-result.h&quot;\n\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\ntemplate &lt;class Element&gt;\nclass KeyPair;\n\n/**\n * @brief Abstract interface for encryption algorithm\n * @tparam Element a ring element.\n */\ntemplate &lt;class Element&gt;\nclass PKEBase {\n    using ParmType = typename Element::Params;\n    using IntType  = typename Element::Integer;\n    using DugType  = typename Element::DugType;\n    using DggType  = typename Element::DggType;\n    using TugType  = typename Element::TugType;\n\npublic:\n    virtual ~PKEBase() {}\n\n    /**\n   * Function to generate public and private keys\n   *\n   * @param &amp;publicKey private key used for decryption.\n   * @param &amp;privateKey private key used for decryption.\n   * @return function ran correctly.\n   */\n    virtual KeyPair&lt;Element&gt; KeyGenInternal(CryptoContext&lt;Element&gt; cc, bool makeSparse);\n\n    //  virtual KeyPair&lt;Element&gt; KeyGen(CryptoContext&lt;Element&gt; cc,\n    //                                    bool makeSparse,\n    //                                    PublicKey&lt;Element&gt;\n    // publicKey);\n\n    /**\n   * Method for encrypting plaintex using LBC\n   *\n   * @param privateKey private key used for encryption.\n   * @param plaintext copy of the plaintext input. NOTE a copy is passed! That\n   * is NOT an error!\n   * @param doEncryption encrypts if true, embeds (encodes) the plaintext into\n   * cryptocontext if false\n   * @param *ciphertext ciphertext which results from encryption.\n   */\n    virtual Ciphertext&lt;Element&gt; Encrypt(Element plaintext, const PrivateKey&lt;Element&gt; privateKey) const;\n\n    /**\n   * Method for encrypting plaintext using LBC\n   *\n   * @param&amp;publicKey public key used for encryption.\n   * @param plaintext copy of the plaintext element. NOTE a copy is passed!\n   * That is NOT an error!\n   * @param doEncryption encrypts if true, embeds (encodes) the plaintext into\n   * cryptocontext if false\n   * @param *ciphertext ciphertext which results from encryption.\n   */\n    virtual Ciphertext&lt;Element&gt; Encrypt(Element plaintext, const PublicKey&lt;Element&gt; publicKey) const;\n\n    /**\n   * Method for decrypting plaintext using LBC\n   *\n   * @param &amp;privateKey private key used for decryption.\n   * @param &amp;ciphertext ciphertext id decrypted.\n   * @param *plaintext the plaintext output.\n   * @return the decoding result.\n   */\n    virtual DecryptResult Decrypt(ConstCiphertext&lt;Element&gt; ciphertext, const PrivateKey&lt;Element&gt; privateKey,\n                                  NativePoly* plaintext) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Decryption to NativePoly is not supported&quot;);\n    }\n\n    /**\n   * Method for decrypting plaintext using LBC\n   *\n   * @param &amp;privateKey private key used for decryption.\n   * @param &amp;ciphertext ciphertext id decrypted.\n   * @param *plaintext the plaintext output.\n   * @return the decoding result.\n   */\n    virtual DecryptResult Decrypt(ConstCiphertext&lt;Element&gt; ciphertext, const PrivateKey&lt;Element&gt; privateKey,\n                                  Poly* plaintext) const {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;Decryption to Poly is not supported&quot;);\n    }\n\n    /////////////////////////////////////////\n    // CORE OPERATIONS\n    /////////////////////////////////////////\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt; &gt; EncryptZeroCore(const PrivateKey&lt;Element&gt; privateKey,\n                                                                   const std::shared_ptr&lt;ParmType&gt; params) const;\n\n    virtual std::shared_ptr&lt;std::vector&lt;Element&gt; &gt; EncryptZeroCore(const PublicKey&lt;Element&gt; publicKey,\n                                                                   const std::shared_ptr&lt;ParmType&gt; params) const;\n\n    virtual Element DecryptCore(const std::vector&lt;Element&gt;&amp; cv, const PrivateKey&lt;Element&gt; privateKey) const;\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-parametergeneration.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-parametergeneration.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-parametergeneration.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_RNS_PARAMETERGENERATION_H\n#define LBCRYPTO_CRYPTO_RNS_PARAMETERGENERATION_H\n\n#include &quot;lattice/lat-hal.h&quot;\n\n#include &quot;schemebase/base-parametergeneration.h&quot;\n\n#include &lt;string&gt;\n#include &lt;memory&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\n\n/**\n * @brief Abstract interface for parameter generation algorithm\n * @tparam Element a ring element.\n */\nclass ParameterGenerationRNS : public ParameterGenerationBase&lt;DCRTPoly&gt; {\npublic:\n    virtual ~ParameterGenerationRNS() {}\n\n    /**\n   * Method for computing all derived parameters based on chosen primitive\n   * parameters\n   *\n   * @param *cryptoParams the crypto parameters object to be populated with\n   * parameters.\n   * @param evalAddCount number of EvalAdds assuming no EvalMult and KeySwitch\n   * operations are performed.\n   * @param multiplicativeDepth number of EvalMults assuming no EvalAdd and\n   * KeySwitch operations are performed.\n   * @param keySwitchCount number of KeySwitch operations assuming no EvalAdd\n   * and EvalMult operations are performed.\n   * @param dcrtBits number of bits in each CRT modulus*\n   * @param n ring dimension in case the user wants to use a custom ring\n   * dimension\n   */\n    bool ParamsGenBFVRNS(std::shared_ptr&lt;CryptoParametersBase&lt;DCRTPoly&gt;&gt; cryptoParams, uint32_t evalAddCount,\n                         uint32_t multiplicativeDepth, uint32_t keySwitchCount, size_t dcrtBits, uint32_t numPartQ,\n                         uint32_t n) const override {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;This signature for ParamsGen is not supported for this scheme.&quot;);\n    }\n\n    /**\n   * Method for computing all derived parameters based on chosen primitive\n   * parameters.\n   *\n   * @param cryptoParams the crypto parameters object to be populated with parameters.\n   * @param cyclOrder the cyclotomic order.\n   * @param numPrimes number of modulus towers to support.\n   * @param scalingModSize the bit-width for plaintexts and DCRTPoly&#x27;s.\n   * @param firstModSize the bit-size of the first modulus\n   * @param numPartQ number of partitions of Q for HYBRID key switching\n   *\n   */\n    bool ParamsGenCKKSRNS(std::shared_ptr&lt;CryptoParametersBase&lt;DCRTPoly&gt;&gt; cryptoParams, usint cyclOrder,\n                          usint numPrimes, usint scalingModSize, usint firstModSize, uint32_t mulPartQ,\n                          COMPRESSION_LEVEL mPIntBootCiphertextCompressionLevel) const override {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;This signature for ParamsGen is not supported for this scheme.&quot;);\n    }\n\n    /**\n   * Method for computing all derived parameters based on chosen primitive\n   * parameters. This is intended for BGVrns\n   * @param *cryptoParams the crypto parameters object to be populated with\n   * parameters.\n   * @param evalAddCount number of EvalAdds per level.\n   * @param keySwitchCount number of KeySwitch operations per level.\n   * @param cyclOrder the cyclotomic order.\n   * @param numPrimes number of modulus towers to support.\n   * @param digitSize the digit size\n   * @param secretKeyDist\n   * @param ksTech the key switching technique used (e.g., BV or GHS)\n   * @param firstModSize the bit-size of the first modulus\n   * @param dcrtBits the bit-width of moduli.\n   */\n    bool ParamsGenBGVRNS(std::shared_ptr&lt;CryptoParametersBase&lt;DCRTPoly&gt;&gt; cryptoParams, uint32_t evalAddCount,\n                         uint32_t keySwitchCount, usint cyclOrder, usint numPrimes, usint firstModSize, usint dcrtBits,\n                         uint32_t numPartQ, usint multihopQBound) const override {\n        &quot;hey&quot;; OPENFHE_THROW(not_implemented_error, &quot;This signature for ParamsGen is not supported for this scheme.&quot;);\n    }\n\n    /////////////////////////////////////\n    // SERIALIZATION\n    /////////////////////////////////////\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {}\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {}\n\n    std::string SerializedObjectName() const {\n        return &quot;ParameterGenerationRNS&quot;;\n    }\n\nprotected:\n    enum DCRT_MODULUS {\n        DEFAULT_EXTRA_MOD_SIZE = 20,\n        MIN_SIZE               = 30,\n        MAX_SIZE               = 60,\n    };\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-leveledshe.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-leveledshe.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-leveledshe.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_RNS_LEVELEDSHE_H\n#define LBCRYPTO_CRYPTO_RNS_LEVELEDSHE_H\n\n#include &quot;lattice/lat-hal.h&quot;\n\n#include &quot;schemebase/base-leveledshe.h&quot;\n\n#include &lt;string&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\n\n/**\n * @brief Abstract interface class for LBC SHE algorithms\n * @tparam Element a ring element.\n */\nclass LeveledSHERNS : public LeveledSHEBase&lt;DCRTPoly&gt; {\npublic:\n    virtual ~LeveledSHERNS() {}\n\n    /////////////////////////////////////////\n    // SHE NEGATION\n    /////////////////////////////////////////\n\n    /////////////////////////////////////////\n    // SHE ADDITION\n    /////////////////////////////////////////\n\n    using LeveledSHEBase&lt;DCRTPoly&gt;::EvalAdd;\n    using LeveledSHEBase&lt;DCRTPoly&gt;::EvalAddInPlace;\n    using LeveledSHEBase&lt;DCRTPoly&gt;::EvalAddMutable;\n    using LeveledSHEBase&lt;DCRTPoly&gt;::EvalAddMutableInPlace;\n\n    /**\n   * Virtual function to define the interface for homomorphic addition of\n   * ciphertexts.\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    Ciphertext&lt;DCRTPoly&gt; EvalAdd(ConstCiphertext&lt;DCRTPoly&gt; ciphertext1,\n                                 ConstCiphertext&lt;DCRTPoly&gt; ciphertext2) const override;\n\n    /**\n   * Virtual function to define the interface for in-place homomorphic addition\n   * of ciphertexts.\n   *\n   * @param ciphertext1 the input/output ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   */\n    void EvalAddInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1, ConstCiphertext&lt;DCRTPoly&gt; ciphertext2) const override;\n\n    /**\n   * Virtual function to define the interface for homomorphic addition of\n   * ciphertexts. This is the mutable version - input ciphertexts may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    Ciphertext&lt;DCRTPoly&gt; EvalAddMutable(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1,\n                                        Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext2) const override;\n\n    void EvalAddMutableInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1, Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext2) const override;\n\n    /**\n   * Virtual function to define the interface for homomorphic addition of\n   * ciphertexts.\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    Ciphertext&lt;DCRTPoly&gt; EvalAdd(ConstCiphertext&lt;DCRTPoly&gt; ciphertext, ConstPlaintext plaintext) const override;\n\n    /**\n   * Virtual function to define the interface for homomorphic addition of\n   * ciphertexts.\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   */\n    void EvalAddInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, ConstPlaintext plaintext) const override;\n\n    /**\n   * Virtual function to define the interface for homomorphic addition of\n   * ciphertexts. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    Ciphertext&lt;DCRTPoly&gt; EvalAddMutable(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, Plaintext plaintext) const override;\n\n    /**\n   * Virtual function to define the interface for homomorphic addition of\n   * ciphertexts. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    void EvalAddMutableInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, Plaintext plaintext) const override;\n\n    /////////////////////////////////////////\n    // SHE SUBTRACTION\n    /////////////////////////////////////////\n\n    using LeveledSHEBase&lt;DCRTPoly&gt;::EvalSub;\n    using LeveledSHEBase&lt;DCRTPoly&gt;::EvalSubInPlace;\n    using LeveledSHEBase&lt;DCRTPoly&gt;::EvalSubMutable;\n    using LeveledSHEBase&lt;DCRTPoly&gt;::EvalSubMutableInPlace;\n\n    /**\n   * Virtual function to define the interface for homomorphic subtraction of\n   * ciphertexts.\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    Ciphertext&lt;DCRTPoly&gt; EvalSub(ConstCiphertext&lt;DCRTPoly&gt; ciphertext1,\n                                 ConstCiphertext&lt;DCRTPoly&gt; ciphertext2) const override;\n\n    /**\n   * Virtual function to define the interface for homomorphic subtraction of\n   * ciphertexts.\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   */\n    void EvalSubInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1, ConstCiphertext&lt;DCRTPoly&gt; ciphertext2) const override;\n\n    /**\n   * Virtual function to define the interface for homomorphic subtraction of\n   * ciphertexts. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    Ciphertext&lt;DCRTPoly&gt; EvalSubMutable(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1,\n                                        Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext2) const override;\n\n    /**\n   * Virtual function to define the interface for homomorphic subtraction of\n   * ciphertexts. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext1 the input ciphertext.\n   * @param ciphertext2 the input ciphertext.\n   * @return the new ciphertext.\n   */\n    void EvalSubMutableInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1, Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext2) const override;\n\n    /**\n   * Virtual function to define the interface for homomorphic subtraction of\n   * ciphertexts.\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    Ciphertext&lt;DCRTPoly&gt; EvalSub(ConstCiphertext&lt;DCRTPoly&gt; ciphertext, ConstPlaintext plaintext) const override;\n\n    void EvalSubInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, ConstPlaintext plaintext) const override;\n\n    /**\n   * Virtual function to define the interface for homomorphic subtraction of\n   * ciphertexts. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    Ciphertext&lt;DCRTPoly&gt; EvalSubMutable(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, Plaintext plaintext) const override;\n\n    /**\n   * Virtual function to define the interface for homomorphic subtraction of\n   * ciphertexts. This is the mutable version - input ciphertext may change\n   * (automatically rescaled, or towers dropped).\n   *\n   * @param ciphertext the input ciphertext.\n   * @param plaintext the input plaintext.\n   * @return the new ciphertext.\n   */\n    void EvalSubMutableInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, Plaintext plaintext) const override;\n\n    /////////////////////////////////////////\n    // SHE MULTIPLICATION\n    /////////////////////////////////////////\n\n    using LeveledSHEBase&lt;DCRTPoly&gt;::EvalMult;\n    using LeveledSHEBase&lt;DCRTPoly&gt;::EvalMultInPlace;\n    using LeveledSHEBase&lt;DCRTPoly&gt;::EvalMultMutable;\n    using LeveledSHEBase&lt;DCRTPoly&gt;::EvalMultMutableInPlace;\n\n    Ciphertext&lt;DCRTPoly&gt; EvalMult(ConstCiphertext&lt;DCRTPoly&gt; ciphertext1,\n                                  ConstCiphertext&lt;DCRTPoly&gt; ciphertext2) const override;\n\n    Ciphertext&lt;DCRTPoly&gt; EvalMultMutable(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1,\n                                         Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext2) const override;\n\n    Ciphertext&lt;DCRTPoly&gt; EvalSquare(ConstCiphertext&lt;DCRTPoly&gt; ciphertext) const override;\n\n    Ciphertext&lt;DCRTPoly&gt; EvalSquareMutable(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext) const override;\n\n    Ciphertext&lt;DCRTPoly&gt; EvalMult(ConstCiphertext&lt;DCRTPoly&gt; ciphertext, ConstPlaintext plaintext) const override;\n\n    void EvalMultInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, ConstPlaintext plaintext) const override;\n\n    Ciphertext&lt;DCRTPoly&gt; EvalMultMutable(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, Plaintext plaintext) const override;\n\n    void EvalMultMutableInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, Plaintext plaintext) const override;\n\n    Ciphertext&lt;DCRTPoly&gt; MultByMonomial(ConstCiphertext&lt;DCRTPoly&gt; ciphertext, usint power) const override;\n\n    void MultByMonomialInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, usint power) const override;\n\n    /////////////////////////////////////////\n    // SHE AUTOMORPHISM\n    /////////////////////////////////////////\n\n    /////////////////////////////////////////\n    // SHE LEVELED Mod Reduce\n    /////////////////////////////////////////\n\n    Ciphertext&lt;DCRTPoly&gt; ModReduce(ConstCiphertext&lt;DCRTPoly&gt; ciphertext, size_t levels) const override;\n\n    /**\n   * Method for In-place Modulus Reduction.\n   *\n   * @param &amp;cipherText Ciphertext to perform mod reduce on.\n   * @param levels the number of towers to drop.\n   */\n    void ModReduceInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, size_t levels) const override;\n\n    /////////////////////////////////////////\n    // SHE LEVELED Level Reduce\n    /////////////////////////////////////////\n\n    Ciphertext&lt;DCRTPoly&gt; LevelReduce(ConstCiphertext&lt;DCRTPoly&gt; ciphertext, const EvalKey&lt;DCRTPoly&gt; evalKey,\n                                     size_t levels) const override;\n\n    void LevelReduceInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, const EvalKey&lt;DCRTPoly&gt; evalKey,\n                            size_t levels) const override;\n\n    /////////////////////////////////////////\n    // SHE LEVELED Compress\n    /////////////////////////////////////////\n\n    Ciphertext&lt;DCRTPoly&gt; Compress(ConstCiphertext&lt;DCRTPoly&gt; ciphertext, size_t towersLeft) const override;\n\nprotected:\n    /////////////////////////////////////\n    // RNS Core\n    /////////////////////////////////////\n\n    /**\n   * Method for rescaling.\n   *\n   * @param cipherText is the ciphertext to perform modreduce on.\n   * @param levels the number of towers to drop.\n   * @return ciphertext after the modulus reduction performed.\n   */\n    Ciphertext&lt;DCRTPoly&gt; ModReduceInternal(ConstCiphertext&lt;DCRTPoly&gt; ciphertext, size_t levels) const override;\n\n    /**\n   * Method for rescaling in-place.\n   *\n   * @param cipherText is the ciphertext to perform modreduce on.\n   * @param levels the number of towers to drop.\n   * @details \\p cipherText will have modulus reduction performed in-place.\n   */\n    void ModReduceInternalInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, size_t levels) const override {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ModReduceInternalInPlace is not supported for this scheme&quot;);\n    }\n\n    /**\n   * Method for Level Reduction in the CKKS scheme. It just drops &quot;levels&quot;\n   * number of the towers of the ciphertext without changing the underlying\n   * plaintext.\n   *\n   * @param cipherText1 is the original ciphertext to be level reduced.\n   * @param levels the number of towers to drop.\n   * @return resulting ciphertext.\n   */\n    Ciphertext&lt;DCRTPoly&gt; LevelReduceInternal(ConstCiphertext&lt;DCRTPoly&gt; ciphertext, size_t levels) const override;\n\n    /**\n   * Method for in-place Level Reduction in the CKKS scheme. It just drops\n   * &quot;levels&quot; number of the towers of the ciphertext without changing the\n   * underlying plaintext.\n   *\n   * @param cipherText1 is the ciphertext to be level reduced in-place\n   * @param linearKeySwitchHint not used in the CKKS scheme.\n   * @param levels the number of towers to drop.\n   */\n    void LevelReduceInternalInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext, size_t levels) const override {\n        &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;LevelReduceInternalInPlace is not supported for this scheme&quot;);\n    }\n\n    void AdjustLevelsInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1, Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext2) const override;\n\n    void AdjustForAddOrSubInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1, Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext2) const override;\n\n    void AdjustForMultInPlace(Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext1, Ciphertext&lt;DCRTPoly&gt;&amp; ciphertext2) const override;\n\n    /////////////////////////////////////\n    // SERIALIZATION\n    /////////////////////////////////////\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar) const {\n        ar(cereal::base_class&lt;LeveledSHEBase&lt;DCRTPoly&gt;&gt;(this));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar) {\n        ar(cereal::base_class&lt;LeveledSHEBase&lt;DCRTPoly&gt;&gt;(this));\n    }\n\n    std::string SerializedObjectName() const {\n        return &quot;LeveledSHERNS&quot;;\n    }\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_RNS_SCHEME_H\n#define LBCRYPTO_CRYPTO_RNS_SCHEME_H\n\n#include &quot;lattice/lat-hal.h&quot;\n\n#include &quot;schemebase/base-scheme.h&quot;\n\n#include &quot;schemerns/rns-cryptoparameters.h&quot;\n#include &quot;schemerns/rns-parametergeneration.h&quot;\n#include &quot;schemerns/rns-pke.h&quot;\n#include &quot;schemerns/rns-pre.h&quot;\n#include &quot;schemerns/rns-leveledshe.h&quot;\n#include &quot;schemerns/rns-advancedshe.h&quot;\n#include &quot;schemerns/rns-multiparty.h&quot;\n\n#include &quot;keyswitch/keyswitch-hybrid.h&quot;\n#include &quot;keyswitch/keyswitch-bv.h&quot;\n#include &quot;constants.h&quot;\n#include &quot;utils/exception.h&quot;\n\n#include &lt;string&gt;\n#include &lt;memory&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\n\n/**\n * @brief Abstract interface class for LBC PRE algorithms\n * @tparam Element a ring element.\n */\nclass SchemeRNS : public SchemeBase&lt;DCRTPoly&gt; {\npublic:\n    SchemeRNS() {}\n\n    virtual ~SchemeRNS() {}\n\n    void SetKeySwitchingTechnique(KeySwitchTechnique ksTech) {\n        if (ksTech == BV) {\n            m_KeySwitch = std::make_shared&lt;KeySwitchBV&gt;();\n        }\n        else if (ksTech == HYBRID) {\n            m_KeySwitch = std::make_shared&lt;KeySwitchHYBRID&gt;();\n        }\n        else\n            &quot;hey&quot;; OPENFHE_THROW(config_error, &quot;ksTech is invalid&quot;);\n    }\n\n    /////////////////////////////////////\n    // SERIALIZATION\n    /////////////////////////////////////\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar, std::uint32_t const version) const {\n        ar(cereal::base_class&lt;SchemeBase&lt;DCRTPoly&gt;&gt;(this));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar, std::uint32_t const version) {\n        ar(cereal::base_class&lt;SchemeBase&lt;DCRTPoly&gt;&gt;(this));\n    }\n\n    std::string SerializedObjectName() const override {\n        return &quot;SchemeRNS&quot;;\n    }\n};\n\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/bgvrns/bgvrns-pke.h": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/bgvrns/bgvrns-pke.h", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/bgvrns/bgvrns-pke.h", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n#ifndef LBCRYPTO_CRYPTO_BGVRNS_PKE_H\n#define LBCRYPTO_CRYPTO_BGVRNS_PKE_H\n\n#include &quot;schemerns/rns-pke.h&quot;\n\n#include &lt;string&gt;\n\n/**\n * @namespace lbcrypto\n * The namespace of lbcrypto\n */\nnamespace lbcrypto {\n\nclass PKEBGVRNS : public PKERNS {\n    using ParmType = typename DCRTPoly::Params;\n    using IntType  = typename DCRTPoly::Integer;\n    using DugType  = typename DCRTPoly::DugType;\n    using DggType  = typename DCRTPoly::DggType;\n    using TugType  = typename DCRTPoly::TugType;\n\npublic:\n    virtual ~PKEBGVRNS() {}\n\n    /**\n   * Method for decrypting plaintext using LBC\n   *\n   * @param &amp;privateKey private key used for decryption.\n   * @param &amp;ciphertext ciphertext id decrypted.\n   * @param *plaintext the plaintext output.\n   * @return the decoding result.\n   */\n    DecryptResult Decrypt(ConstCiphertext&lt;DCRTPoly&gt; ciphertext, const PrivateKey&lt;DCRTPoly&gt; privateKey,\n                          NativePoly* plaintext) const override;\n\n    /**\n   * Method for decrypting plaintext using LBC\n   *\n   * @param &amp;privateKey private key used for decryption.\n   * @param &amp;ciphertext ciphertext id decrypted.\n   * @param *plaintext the plaintext output.\n   * @return the decoding result.\n   */\n    DecryptResult Decrypt(ConstCiphertext&lt;DCRTPoly&gt; ciphertext, const PrivateKey&lt;DCRTPoly&gt; privateKey,\n                          Poly* plaintext) const override {\n        std::string errMsg =\n            &quot;PKEBGVRNS: Decryption to Poly from DCRTPoly is not supported as it &quot;\n            &quot;may &quot;\n            &quot;lead to incorrect results.&quot;;\n        &quot;hey&quot;; OPENFHE_THROW(not_available_error, errMsg);\n    }\n\n    /////////////////////////////////////\n    // SERIALIZATION\n    /////////////////////////////////////\n\n    template &lt;class Archive&gt;\n    void save(Archive&amp; ar) const {\n        ar(cereal::base_class&lt;PKERNS&gt;(this));\n    }\n\n    template &lt;class Archive&gt;\n    void load(Archive&amp; ar) {\n        ar(cereal::base_class&lt;PKERNS&gt;(this));\n    }\n\n    std::string SerializedObjectName() const {\n        return &quot;PKEBGVRNS&quot;;\n    }\n};\n}  // namespace lbcrypto\n\n#endif\n"}, "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/bgvrns/bgvrns-scheme.cpp": {"id": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/bgvrns/bgvrns-scheme.cpp", "filePath": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/bgvrns/bgvrns-scheme.cpp", "content": "//==================================================================================\n// BSD 2-Clause License\n//\n// Copyright (c) 2014-2022, NJIT, Duality Technologies Inc. and other contributors\n//\n// All rights reserved.\n//\n// Author TPOC: contact@openfhe.org\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice, this\n//    list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n// OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//==================================================================================\n\n/*\nBGV implementation. See https://eprint.iacr.org/2021/204 for details.\n */\n\n#define PROFILE\n\n#include &quot;scheme/bgvrns/bgvrns-scheme.h&quot;\n\n#include &quot;scheme/bgvrns/bgvrns-advancedshe.h&quot;\n#include &quot;scheme/bgvrns/bgvrns-leveledshe.h&quot;\n#include &quot;scheme/bgvrns/bgvrns-multiparty.h&quot;\n#include &quot;scheme/bgvrns/bgvrns-fhe.h&quot;\n#include &quot;scheme/bgvrns/bgvrns-pke.h&quot;\n#include &quot;scheme/bgvrns/bgvrns-pre.h&quot;\n\n#include &lt;iosfwd&gt;\n\nnamespace lbcrypto {\n\nvoid SchemeBGVRNS::Enable(PKESchemeFeature feature) {\n    switch (feature) {\n        case PKE:\n            if (m_PKE == nullptr)\n                m_PKE = std::make_shared&lt;PKEBGVRNS&gt;();\n            break;\n        case KEYSWITCH:\n            // m_KeySwitch must be initialized later by calling SetKeySwitchingTechnique() with the value of key switching technique from cryptoparams\n            break;\n        case PRE:\n            if (m_PRE == nullptr)\n                m_PRE = std::make_shared&lt;PREBGVRNS&gt;();\n            break;\n        case LEVELEDSHE:\n            if (m_LeveledSHE == nullptr)\n                m_LeveledSHE = std::make_shared&lt;LeveledSHEBGVRNS&gt;();\n            break;\n        case MULTIPARTY:\n            if (m_Multiparty == nullptr)\n                m_Multiparty = std::make_shared&lt;MultipartyBGVRNS&gt;();\n            break;\n        case ADVANCEDSHE:\n            if (m_AdvancedSHE == nullptr)\n                m_AdvancedSHE = std::make_shared&lt;AdvancedSHEBGVRNS&gt;();\n            break;\n        case FHE:\n            if (m_FHE == nullptr)\n                m_FHE = std::make_shared&lt;FHEBGVRNS&gt;();\n            break;\n        default:\n            std::stringstream ss;\n            ss &lt;&lt; feature;\n            &quot;hey&quot;; OPENFHE_THROW(not_implemented_error,\n                          std::string(&quot;This feature [&quot;) + ss.str() + &quot;] is not supported for BGVRNS scheme&quot;);\n    }\n}\n\n}  // namespace lbcrypto\n"}}, "reports": [{"fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "reportHash": "4fe49240553edfa6f5d54f695abc41ca", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 273, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'mubintvec::ModMulEq'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "line": 282, "column": 9}, {"message": "Entered call from 'PolyImpl::operator*='", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "line": 348, "column": 1}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "line": 350, "column": 9}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "line": 353, "column": 24}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "line": 353, "column": 24}, {"message": "Calling 'ubint::ModMulFastEq'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "line": 354, "column": 9}, {"message": "Entered call from 'mubintvec::ModMulEq'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/bigintdyn/ubintdyn.h", "line": 628, "column": 5}, {"message": "Calling 'ubint::ModMulFast'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/bigintdyn/ubintdyn.h", "line": 629, "column": 24}, {"message": "Entered call from 'ubint::ModMulFastEq'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 383, "column": 1}, {"message": "Assuming field 'm_MSB' is not equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 384, "column": 9}, {"message": "Assuming field 'm_MSB' is not equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 384, "column": 23}, {"message": "Assuming field 'm_MSB' is not equal to 1", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 386, "column": 9}, {"message": "Assuming field 'm_MSB' is not equal to 1", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 388, "column": 9}, {"message": "Assuming 'aSize' is >= 'bSize'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 395, "column": 9}, {"message": "Assuming 'i' is >= 'bSize'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 401, "column": 24}, {"message": "Loop body executed 0 times", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 401, "column": 24}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 411, "column": 9}, {"message": "Calling 'ubint::Mod'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 412, "column": 16}, {"message": "Entered call from 'ubint::ModMulFast'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 271, "column": 1}, {"message": "Assuming field 'm_MSB' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 272, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 273, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "reportHash": "1d9298f60b99f28bd9a0e6db37c1126f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 286, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'mubintvec::ModMulEq'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "line": 282, "column": 9}, {"message": "Entered call from 'PolyImpl::operator*='", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "line": 348, "column": 1}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "line": 350, "column": 9}, {"message": "Calling 'ubint::ModEq'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/mubintvecdyn.cpp", "line": 351, "column": 9}, {"message": "Entered call from 'mubintvec::ModMulEq'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 284, "column": 1}, {"message": "Assuming field 'm_MSB' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 285, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/lib/math/hal/bigintdyn/ubintdyn.cpp", "line": 286, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/bigintdyn/mubintvecdyn.h", "reportHash": "ee063d58823218c55ae3960712cb824d", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 241, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/bigintdyn/mubintvecdyn.h", "line": 241, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/bigintdyn/mubintvecdyn.h", "reportHash": "7c0e275bb7924d64aa4838bc92be33fb", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 326, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "line": 302, "column": 18}, {"message": "Calling 'operator=='", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "line": 303, "column": 18}, {"message": "Entered call from 'PolyImpl::operator=='", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/vector.h", "line": 107, "column": 5}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/vector.h", "line": 108, "column": 14}, {"message": "Calling 'mubintvec::GetModulus'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/vector.h", "line": 108, "column": 50}, {"message": "Entered call from 'operator=='", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/bigintdyn/mubintvecdyn.h", "line": 324, "column": 5}, {"message": "Assuming field 'm_modulus_state' is not equal to INITIALIZED", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/bigintdyn/mubintvecdyn.h", "line": 325, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/bigintdyn/mubintvecdyn.h", "line": 326, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/openfhebase64.h", "reportHash": "ae7f02ebfb29b406870b50eeb171bde5", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 67, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'index' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/openfhebase64.h", "line": 66, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/openfhebase64.h", "line": 67, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "reportHash": "feca8fb314f6ef85d2a9dbf1d7b058cd", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 288, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'r' is < field 'm_value'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 287, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 288, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "reportHash": "0be968ee17316a14556c684019d617ce", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 322, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 321, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 322, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "reportHash": "723efb9c1b673ca487b1266eb104bc69", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 484, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'make_shared<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>, unsigned int, intnat::NativeIntegerT<unsigned long> &>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/rgsw-cryptoparameters.h", "line": 85, "column": 24}, {"message": "Entered call from constructor for 'RingGSWCryptoParams'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 874, "column": 5}, {"message": "Calling 'allocate_shared<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>, std::allocator<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>>, unsigned int, intnat::NativeIntegerT<unsigned long> &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 878, "column": 14}, {"message": "Entered call from 'make_shared<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>, unsigned int, intnat::NativeIntegerT<unsigned long> &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 857, "column": 5}, {"message": "Calling constructor for 'shared_ptr<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 862, "column": 14}, {"message": "Entered call from 'allocate_shared<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>, std::allocator<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>>, unsigned int, intnat::NativeIntegerT<unsigned long> &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 408, "column": 2}, {"message": "Calling constructor for '__shared_ptr<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 409, "column": 4}, {"message": "Entered call from constructor for 'shared_ptr<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1341, "column": 2}, {"message": "Calling constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1342, "column": 14}, {"message": "Entered call from constructor for '__shared_ptr<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 643, "column": 2}, {"message": "Calling constructor for '_Sp_counted_ptr_inplace<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>, std::allocator<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 651, "column": 6}, {"message": "Entered call from constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 514, "column": 2}, {"message": "Calling 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 519, "column": 4}, {"message": "Entered call from constructor for '_Sp_counted_ptr_inplace<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>, std::allocator<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 510, "column": 2}, {"message": "Calling 'new_allocator::construct'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 516, "column": 4}, {"message": "Entered call from 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 159, "column": 2}, {"message": "Calling constructor for 'ILParamsImpl<intnat::NativeIntegerT<unsigned long>>'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 162, "column": 23}, {"message": "Entered call from 'new_allocator::construct'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ilparams.h", "line": 90, "column": 5}, {"message": "Calling 'RootOfUnity<intnat::NativeIntegerT<unsigned long>>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ilparams.h", "line": 91, "column": 47}, {"message": "Entered call from constructor for 'ILParamsImpl<intnat::NativeIntegerT<unsigned long>>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "line": 183, "column": 1}, {"message": "Calling 'NativeIntegerT::DividedBy'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "line": 195, "column": 33}, {"message": "Entered call from 'RootOfUnity<intnat::NativeIntegerT<unsigned long>>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 482, "column": 5}, {"message": "Assuming field 'm_value' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 483, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 484, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "reportHash": "5d72e61bb6fbee802b7fdb2565d5d085", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 652, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'NativeIntegerT::ComputeMu'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/mubintvecnat.h", "line": 490, "column": 17}, {"message": "Entered call from 'NativeVectorT::ModMulNoCheckEq'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 650, "column": 5}, {"message": "Assuming field 'm_value' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 651, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/ubintnat.h", "line": 652, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/mubintvecnat.h", "reportHash": "de94591996865f8ee02e854f56d78f0f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 281, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/mubintvecnat.h", "line": 281, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/mubintvecnat.h", "reportHash": "75192edf6b10dd1ab55adde589125e0f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 312, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'NativeVectorT::SetModulus'", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/lwe-ciphertext.h", "line": 118, "column": 9}, {"message": "Entered call from 'LWECiphertextImpl::SetModulus'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/mubintvecnat.h", "line": 310, "column": 5}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/mubintvecnat.h", "line": 311, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/hal/intnat/mubintvecnat.h", "line": 312, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "reportHash": "eb17d1cd839bbaf2a30f5c40524269dc", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 148, "column": 7, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'Blake2Engine::operator()'", "fileId": "/usr/include/c++/11/bits/uniform_int_dist.h", "line": 258, "column": 24}, {"message": "Entered call from 'uniform_int_distribution::_S_nd'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "line": 107, "column": 3}, {"message": "Assuming 'PRNG_BUFFER_SIZE' is not equal to field 'm_bufferIndex'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "line": 110, "column": 9}, {"message": "Assuming field 'm_bufferIndex' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "line": 115, "column": 9}, {"message": "Calling 'Blake2Engine::Generate'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "line": 115, "column": 29}, {"message": "Entered call from 'Blake2Engine::operator()'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "line": 142, "column": 3}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "line": 145, "column": 9}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/utils/prng/blake2engine.h", "line": 148, "column": 7}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "reportHash": "efda2b59acbf740358d06a3f87856d78", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 191, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'make_shared<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>, unsigned int, intnat::NativeIntegerT<unsigned long> &>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/rgsw-cryptoparameters.h", "line": 85, "column": 24}, {"message": "Entered call from constructor for 'RingGSWCryptoParams'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 874, "column": 5}, {"message": "Calling 'allocate_shared<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>, std::allocator<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>>, unsigned int, intnat::NativeIntegerT<unsigned long> &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 878, "column": 14}, {"message": "Entered call from 'make_shared<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>, unsigned int, intnat::NativeIntegerT<unsigned long> &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 857, "column": 5}, {"message": "Calling constructor for 'shared_ptr<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 862, "column": 14}, {"message": "Entered call from 'allocate_shared<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>, std::allocator<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>>, unsigned int, intnat::NativeIntegerT<unsigned long> &>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 408, "column": 2}, {"message": "Calling constructor for '__shared_ptr<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 409, "column": 4}, {"message": "Entered call from constructor for 'shared_ptr<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1341, "column": 2}, {"message": "Calling constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1342, "column": 14}, {"message": "Entered call from constructor for '__shared_ptr<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 643, "column": 2}, {"message": "Calling constructor for '_Sp_counted_ptr_inplace<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>, std::allocator<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 651, "column": 6}, {"message": "Entered call from constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 514, "column": 2}, {"message": "Calling 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 519, "column": 4}, {"message": "Entered call from constructor for '_Sp_counted_ptr_inplace<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>, std::allocator<lbcrypto::ILParamsImpl<intnat::NativeIntegerT<unsigned long>>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 510, "column": 2}, {"message": "Calling 'new_allocator::construct'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 516, "column": 4}, {"message": "Entered call from 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 159, "column": 2}, {"message": "Calling constructor for 'ILParamsImpl<intnat::NativeIntegerT<unsigned long>>'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 162, "column": 23}, {"message": "Entered call from 'new_allocator::construct'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ilparams.h", "line": 90, "column": 5}, {"message": "Calling 'RootOfUnity<intnat::NativeIntegerT<unsigned long>>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ilparams.h", "line": 91, "column": 47}, {"message": "Entered call from constructor for 'ILParamsImpl<intnat::NativeIntegerT<unsigned long>>'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "line": 183, "column": 1}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "line": 191, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "reportHash": "3991ac136730caf05321ac85dab543b9", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 337, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'nBits' is > MAX_MODULUS_SIZE", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "line": 336, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "line": 337, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "reportHash": "1af897edd0c784ec5574d2757bd6fdd4", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 366, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "line": 364, "column": 12}, {"message": "Entering loop body", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "line": 364, "column": 12}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/math/nbtheory-impl.h", "line": 366, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "reportHash": "a4c1006ddae3de6ae88cbe7e6ceed48e", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 87, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'allocate_shared<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, std::allocator<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>>, int, int>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 878, "column": 14}, {"message": "Entered call from 'make_shared<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, int, int>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 857, "column": 5}, {"message": "Calling constructor for 'shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 862, "column": 14}, {"message": "Entered call from 'allocate_shared<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, std::allocator<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>>, int, int>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 408, "column": 2}, {"message": "Calling constructor for '__shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr.h", "line": 409, "column": 4}, {"message": "Entered call from constructor for 'shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1341, "column": 2}, {"message": "Calling constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 1342, "column": 14}, {"message": "Entered call from constructor for '__shared_ptr<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 643, "column": 2}, {"message": "Calling constructor for '_Sp_counted_ptr_inplace<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, std::allocator<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 651, "column": 6}, {"message": "Entered call from constructor for '__shared_count<__gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 514, "column": 2}, {"message": "Calling 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/bits/shared_ptr_base.h", "line": 519, "column": 4}, {"message": "Entered call from constructor for '_Sp_counted_ptr_inplace<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>, std::allocator<lbcrypto::ILDCRTParams<bigintdyn::ubint<unsigned long>>>, __gnu_cxx::_S_atomic>'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 510, "column": 2}, {"message": "Calling 'new_allocator::construct'", "fileId": "/usr/include/c++/11/bits/alloc_traits.h", "line": 516, "column": 4}, {"message": "Entered call from 'allocator_traits::construct'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 159, "column": 2}, {"message": "Calling default constructor for 'ILDCRTParams<bigintdyn::ubint<unsigned long>>'", "fileId": "/usr/include/c++/11/ext/new_allocator.h", "line": 162, "column": 23}, {"message": "Entered call from 'new_allocator::construct'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "line": 82, "column": 5}, {"message": "Assuming 'order' is not equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "line": 84, "column": 13}, {"message": "Assuming 'depth' is equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "line": 86, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ildcrtparams.h", "line": 87, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ilelement.h", "reportHash": "2da22a6eb346cbebec93f4872d1d106c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 157, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ilelement.h", "line": 157, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ilelement.h", "reportHash": "a5a32c115a88bec1989f0b76a59e1541", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 160, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ilelement.h", "line": 160, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ilelement.h", "reportHash": "ff2d3b36da5fc501a5695bfeda52d4e3", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 163, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ilelement.h", "line": 163, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ilelement.h", "reportHash": "62151fcf9191d625f47d009a9b48fb0f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 166, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/ilelement.h", "line": 166, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/poly-interface.h", "reportHash": "4a645a4e44916eda26dad23255001f87", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 445, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/poly-interface.h", "line": 444, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/poly-interface.h", "line": 445, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "reportHash": "f65ca742918ad69f561d67354509a1a0", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 189, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "line": 302, "column": 18}, {"message": "Calling 'PolyImpl::GetValues'", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "line": 303, "column": 18}, {"message": "Entered call from 'PolyImpl::operator=='", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "line": 187, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "line": 189, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "reportHash": "2d13838ae6661e239fe6c4c27defb9f4", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 199, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "line": 199, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "reportHash": "f4ab09d466b85b1890237833b4fa26a9", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 205, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "line": 205, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "reportHash": "b6a7e7626068c1f305fc281c8cff8049", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 219, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "line": 218, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "line": 219, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "reportHash": "456ca819e6fdda01b28aa154b3fb2f9f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 251, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "line": 250, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "line": 251, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "reportHash": "f4376b912babc72bc0ec566c2b940429", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 267, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "line": 266, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/poly.h", "line": 267, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h", "reportHash": "6bb6e2a8e4085fc74369a719efec9a57", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 525, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h", "line": 524, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h", "line": 525, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h", "reportHash": "833f6a1e366853943408155e7b46dc7e", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 676, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h", "line": 676, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h", "reportHash": "7f81868ff377bfba9e0720792f7eaaea", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 691, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h", "line": 691, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h", "reportHash": "81fb9753409d9cee7e5bbda183cd1919", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 749, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h", "line": 749, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h", "reportHash": "4ccbb959a8d298d47310a0d9bf54bd7a", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 762, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h", "line": 762, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h", "reportHash": "d6bd890a2aad98ad6f4dae04d0bda76c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 773, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h", "line": 773, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h", "reportHash": "b444293a503db077aaf84a626b2520c0", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 822, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h", "line": 822, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h", "reportHash": "4a7a1d1c92fcaee9da156f2985a736ff", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1418, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/dcrtpoly-interface.h", "line": 1418, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/dcrtpoly.h", "reportHash": "8f34705a6e7851212b60baec32f4b112", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 164, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/dcrtpoly.h", "line": 163, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/dcrtpoly.h", "line": 164, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/dcrtpoly.h", "reportHash": "38cb84febc5c3fdfc0403f828f3ee753", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 185, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/dcrtpoly.h", "line": 184, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/core/include/lattice/hal/default/dcrtpoly.h", "line": 185, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "reportHash": "cd7f3ac0fd63f887b2f22a818e8d8c0d", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 295, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "line": 295, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "reportHash": "e6da1a49e2f59dadd1970b70012ac2c5", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 347, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "line": 347, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "reportHash": "0ccca471ad7567a9daec4c029c834743", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 351, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "line": 351, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "reportHash": "22a7b70cf377fd13e8920302c57f808d", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 355, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "line": 355, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "reportHash": "5252dd0e0ddf28f28b6f2016c7c70127", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 358, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "line": 358, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "reportHash": "765fe526763b61621998242b6c778950", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 361, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "line": 361, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "reportHash": "3653aed3f873c25ab73ff5f340842895", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 364, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "line": 364, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "reportHash": "ba7ad519edc5c578ce03c24aef1a6e39", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 367, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "line": 367, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "reportHash": "5c5921032359c5b9752964b98c944221", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 370, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "line": 370, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "reportHash": "4222817fae84824a774d6b88632abfbe", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 373, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/plaintext.h", "line": 373, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "reportHash": "7f1ce1ab0d5a25b37631a533a90d5010", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 115, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 114, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 115, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "reportHash": "ae3b4484fa5975fa2dc0acbc12047167", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 121, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 114, "column": 13}, {"message": "Assuming 'slots' is not equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 118, "column": 23}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 120, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 121, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "reportHash": "aa0884c4110ebc85b5773d9c8b2235eb", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 124, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 114, "column": 13}, {"message": "Assuming 'slots' is not equal to 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 118, "column": 23}, {"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 120, "column": 13}, {"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 123, "column": 18}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 124, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "reportHash": "570866ced80db9d0fd8fa6ec7b8998dd", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 134, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 133, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 134, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "reportHash": "f9a6c64a666734f37bfcf1bba2995c94", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 147, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/encoding/ckkspackedencoding.h", "line": 147, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-parametergeneration.h", "reportHash": "c3e2f72ef308a6e1ff46e8c26591ad94", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 83, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-parametergeneration.h", "line": 83, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-parametergeneration.h", "reportHash": "b62b43106795bec9cacc5c66b538516f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 101, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-parametergeneration.h", "line": 101, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-parametergeneration.h", "reportHash": "56d02210e7d7943237f09ed23bfaef0c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 121, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-parametergeneration.h", "line": 121, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "reportHash": "114620bf9baf9590ae70889f77b9476a", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 79, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "line": 79, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "reportHash": "0f52b939a693c2a5cf4b6836c6ff8346", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 85, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "line": 85, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "reportHash": "fd232316f9e86a6775b8e04ada8a4924", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 90, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "line": 90, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "reportHash": "3deeea385873b076b9adf1890ceca575", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 96, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "line": 96, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "reportHash": "2243039e24d021f3cd3795503e22de05", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 100, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "line": 100, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "reportHash": "7195678c05ef6cdf8555a8d5941011eb", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 104, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "line": 104, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "reportHash": "7d2f4fe37b51f753af49ce9c43c3e544", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 108, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "line": 108, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "reportHash": "5285ed8bb874b9fed1571dd5d9ccc96c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 116, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "line": 116, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "reportHash": "fe47be9a852c7b87788478a6734623d5", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 121, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'KeySwitchBase::EvalKeySwitchPrecomputeCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 321, "column": 16}, {"message": "Entered call from 'SchemeBase::EvalKeySwitchPrecomputeCore'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "line": 119, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "line": 121, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "reportHash": "3ff609da59178f65d1f761d22c86da46", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 127, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "line": 127, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "reportHash": "cbf79c397c85c55bc7004ad9c49cf2bb", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 133, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/keyswitch/keyswitch-base.h", "line": 133, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-advancedshe.h", "reportHash": "b517523f050efc6fc0d2274c881c965c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 113, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-advancedshe.h", "line": 113, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-advancedshe.h", "reportHash": "5dd8017b9e024e750b1c65404f6a0d9c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 128, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-advancedshe.h", "line": 128, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-advancedshe.h", "reportHash": "1913ff34d4a44a406133f1c647acc7f7", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 147, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-advancedshe.h", "line": 147, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-advancedshe.h", "reportHash": "90bfba3f59ee9ee60b8d5b8a36928785", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 162, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-advancedshe.h", "line": 162, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-advancedshe.h", "reportHash": "75d5a856d5a6a67a97a05bca76f446d8", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 166, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-advancedshe.h", "line": 166, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-advancedshe.h", "reportHash": "266887c85fe884bed036b8a4784b9ea4", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 187, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-advancedshe.h", "line": 187, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-advancedshe.h", "reportHash": "edba726b3b260029652b636324864d1d", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 193, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-advancedshe.h", "line": 193, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-advancedshe.h", "reportHash": "276b2b73c49b51af6736378c69d79723", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 199, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-advancedshe.h", "line": 199, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "f3877cb2537c7b30e3789c9b2b77ed44", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 127, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 127, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "205ba371ea1777c4c8cc1cf9adca8fae", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 131, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 131, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "f401e609992c3df1894e777a93973fe0", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 163, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 163, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "eaae3571566a6cff77c452aab5c569ff", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 176, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 176, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "4c72e4d3f0d6e992198058db82d0ccd9", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 180, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 180, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "947bb06a1cbe22dc8e5e0a972b017cda", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 184, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 184, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "3233dd53a1089bfa876a9ddce45df888", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 188, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 188, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "8890bc2147df34fb209cacac167a868a", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 192, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 192, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "4966867c9a723e28043052906e5eaa3d", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 230, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 230, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "5319cae3d55cd3c409eb25aad370b3aa", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 243, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 243, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "8e426f9a3f9f7e1ebc35b2340bb37c00", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 268, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 268, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "6e1d151105c3e7fe15b7de5b47e00e0e", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 272, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 272, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "9528933b366ff991e7dec2edbd2cdaec", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 276, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 276, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "3ba8753c58d6bd6c907daddf76beb603", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 280, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 280, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "3effacfdab93295777d8ccaed6f3f210", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 284, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 284, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "7effbc17b3bb87750e3f70713203a346", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 288, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 288, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "7061a3e551fc45def852fe4115eefab9", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 330, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 330, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "f60d8f2991a26f0c2515c790ce2a6ebf", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 344, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 344, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "9ef2f441f0389097c0c2aa7685bc5a69", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 356, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 356, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "59ce750ef58fd1dfcc991cd423e6c089", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 369, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 369, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "fb61de3a173f94b09f991114abb5c5b0", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 398, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 398, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "0948e9c1fcc763a0fcb254d7c4ce1d71", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 411, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 411, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "df03ff1d628c1924f7ff7b941ae8e08a", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 415, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 415, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "105e4d6c6538f5d7b6d068374fcc943c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 419, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 419, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "10c300d448bbe09e62a569353b7a8fda", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 423, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 423, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "04c36a71b2d9ae638aa4be0fd532d2c8", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 427, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 427, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "1681ed8342c721f14ffea9a7ff396540", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 431, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 431, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "ca0bad33c662767d6b8b27f2f75e82a3", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 435, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 435, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "ff2dc108584dbe27edf7e7bf11fd6bd6", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 439, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 439, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "3d5fa1fc344b8b5b1a88e98a6b3cccf2", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 443, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 443, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "19739ba26a67a2e9393a3e843685060f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 564, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 564, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "e229297daf6ac3c418e76dfe19992871", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 608, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 608, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "275e9ec1dc3c71046a31536004f6fff7", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 637, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'LeveledSHEBase::FindAutomorphismIndex'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 928, "column": 16}, {"message": "Entered call from 'SchemeBase::FindAutomorphismIndex'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 636, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 637, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "75929ad152f34e38c5f3c66bbbd9865e", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 651, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 651, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "c0ec1b628d2ffc44dc07a210a3605be4", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 661, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 661, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "f81cfdd849e29d6a21ae91d3eac311a7", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 705, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 705, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "4c0c62d89e620adc4fda982c16a4a88d", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 709, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 709, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "150dbe8cfd5ab6db97b49c16cf5e24cc", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 720, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 720, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "2a871eb8d3f9a3c0d0d58f009caf4db0", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 731, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 731, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "ce733e181f77c0000837355810c361e2", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 744, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 744, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "913eda935da8447aa2cb1434bfc32116", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 756, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 756, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "16d5de21853978b55b5b3a0f27ef5b04", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 760, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 760, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "e2d31573aab6682f30a4a490e62b00cd", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 764, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 764, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "fc23d7f0bf1b070e484bd0815a8d9bed", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 769, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 769, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "418d8b0c0231e04195f94508cbb44b8f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 774, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 774, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "reportHash": "70e5fce6371194bf3f7b6068d0fbcb37", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 778, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-leveledshe.h", "line": 778, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "reportHash": "91264b75115e428b6c03790562d20c23", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 416, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 413, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 416, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "reportHash": "7acd6a905b30f0cd53b4299dd4847aa2", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 431, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 428, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 431, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "reportHash": "f4192b21a0a2df1c97449e2c11c158fa", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 447, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 444, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 447, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "reportHash": "9535836242d2d52bf265e98a8506c4a1", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 462, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is false", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 459, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-cryptoparameters.h", "line": 462, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-multiparty.h", "reportHash": "26ec34e511937eb09754c3c272fb6986", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 221, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-multiparty.h", "line": 221, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/lwe-cryptoparameters.h", "reportHash": "0450ad12240578bbea98730f56772f25", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 72, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming field 'm_n' is 0", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/lwe-cryptoparameters.h", "line": 71, "column": 12}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/lwe-cryptoparameters.h", "line": 72, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/rgsw-acc.h", "reportHash": "4a91219e827b465a1b98ec4dccad8cfe", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 62, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/rgsw-acc.h", "line": 62, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/rgsw-acc.h", "reportHash": "c48aa1e2b9a9e2ba54777c50ed0e6b56", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 75, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/rgsw-acc.h", "line": 75, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/binfhe-base-scheme.h", "reportHash": "6c08065cb9103ca3123daf12f1ad757f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 76, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'method' is not equal to AP", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/binfhe-base-scheme.h", "line": 69, "column": 13}, {"message": "Assuming 'method' is not equal to GINX", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/binfhe-base-scheme.h", "line": 71, "column": 18}, {"message": "Assuming 'method' is not equal to LMKCDEY", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/binfhe-base-scheme.h", "line": 73, "column": 18}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/binfhe/include/binfhe-base-scheme.h", "line": 76, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "6d66744ab8e5e2ece73fb50e5619489f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 85, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 85, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "fc5b1fedecd1f1af0be399130c86d35a", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 98, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 98, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "7ae2150978eaff40b26f1c5058a21443", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 118, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 118, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "3e98184b8f2ce36403916ee0674b65c9", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 139, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 139, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "e648248da220fef766c9f27a4f4a5852", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 154, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 154, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "a90b98144f64780be3046fab7deeb243", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 167, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 167, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "46834949930b6f6cdeeaa48cbdfdb810", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 178, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 178, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "ccd42fb10855baa29420c8221b012a37", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 192, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 192, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "683853662d77d87cc4e2a1efcafc98a0", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 209, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 209, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "181f854ddd592ce0bb0e773a3146cef9", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 225, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 225, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "e36581caa25a4f4b1bdf7f2666193b3a", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 242, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 242, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "1df389f451bba93d61e8b450744de424", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 264, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 264, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "c87d115d89cd409505fb7f30c2c8f0c4", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 285, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 285, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "db7dba503ea52ddfeaf06819b628032a", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 306, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 306, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "aff23752cfd086767129017e8f6299ca", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 330, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 330, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "4c67a294ae3e9f0c7bb16596c4cd3457", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 340, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 340, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "e36311646bce01c79be3799410783487", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 364, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 364, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "reportHash": "99c4cafd1901f10212465ce9883fab89", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 374, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-fhe.h", "line": 374, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-pke.h", "reportHash": "77e83f698af638b8d5cffc51a9e013ad", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 115, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-pke.h", "line": 115, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-pke.h", "reportHash": "4f137c81f780b53bf21f5252429f43b2", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 128, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-pke.h", "line": 128, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "e2af9a136569a87cf1d7b5128a34cd06", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 96, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::operator=='", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 100, "column": 18}, {"message": "Entered call from 'SchemeBase::operator!='", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 95, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 96, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "fb262a8993243911d30a6c86f5843b09", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 149, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 108, "column": 13}, {"message": "Calling 'SchemeBase::Enable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 109, "column": 13}, {"message": "Entered call from 'SchemeBase::Enable'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 148, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 149, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "f2576dec3ac5710b0b257a3f808dce20", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 160, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 160, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "e6e96698a403086c6732f9452e288fe1", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 169, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 169, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "9cdf8b0cdb281d3ddcdb027ded1d30bc", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 178, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 178, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "a203d2be1ecc52088d9c219ce2bddc2a", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 197, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 197, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "b2128a806536a50cca52c2a88979659d", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 207, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 207, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "79aecef9de535dbcfb3fe1c603be2943", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 216, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 216, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "b7fc2d692efc60b0e8971bc4de64185f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 226, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 226, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "b5986e6340717a78ab37aacd2a9b0cb6", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 263, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 263, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "73f0060cef7d1cc8361e2c175f809e26", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 274, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 274, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "5503c526096af0544a324b71fee5e9bf", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 286, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 286, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "e3180c94a0bd30ff87d8c0be76ba3c43", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 295, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 295, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "0076d686029b063a14b7f4bbca1c9841", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 304, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 304, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "ef99d8af6174376e7021dd17044d6dc7", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 314, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 314, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "1b1aea8b5157e7a74b36b0d3bf7c97c8", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 329, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 329, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "31ccbf0574b8f5ae7f305b95d30d345a", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 344, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 344, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "85535af17def65d3f1073cb1f26b5b4d", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 358, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 358, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "2dc48c2944f13a4debc425637a410e7c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 379, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 379, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "2321f4739fdbf45f4479ed3c7565573f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 386, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 386, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "3701fa13e3b63895b6e0e6e1879522d7", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 399, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 399, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "89adc7e979a1e8176a429792ce3e76ff", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 408, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 408, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "7b541f5b86ec4521ff3ba09c8a583e0c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 419, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 419, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "7c01258d393940a8a057edcebdc62ed0", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 428, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 428, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "772a9788a1962bd7a55b29a591688774", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 438, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 438, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "c40c11b6e7c49bf6deaf21760b6bfc6c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 447, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 447, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "a9462fc6c621d06a947ca48db4991bbc", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 457, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 457, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "3c6e77a0be4d1151e6e273f9e7f38894", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 475, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 475, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "86823814785301027efec58c8ab666e9", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 483, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 483, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "f86d9e830ee67d6d5ed9fb90b20de7bc", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 490, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 490, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "6f55dc591239299ff797ea62b01d72a9", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 503, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 503, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "0d3e0f8bcde152823a6eb553353e4c32", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 512, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 512, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "8e34def1e5eec390ff941c06646f3fa9", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 523, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 523, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "9e14330c50ce15daea7799316d935e15", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 532, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 532, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "c104d38a2729befdabade41a410a9963", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 542, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 542, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "40c669a644e6392b8d4eaca2ceba1afe", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 551, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 551, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "b5d0be4517c750262055197e9830e43e", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 561, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 561, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "865355aa20179d743bee3409ac208476", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 570, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 570, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "ad138ef506398a1516b23aec54d82a7e", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 577, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 577, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "36127874f4014cdd409944c54caed26c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 585, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 585, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "38ab2c5221e90b6f7f2d07d4d222c949", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 592, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 592, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "335177602eff53e7d8b756859dd6812c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 609, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 609, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "00ffc114383995ed6708585498942c39", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 619, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 619, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "cf1aab940c7936f1dfa1a88fc2915967", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 628, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 628, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "78134068e5db788467595aca05474a14", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 635, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 635, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "0b23aa2bb2cd0cc52a85fefa5acf31b3", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 647, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 647, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "062346976fef02a18b54e7c00834ca92", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 659, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 659, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "55c29a0e988144bbce883498a9446f4f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 672, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 672, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "31401befddd0fbd885abd4fa7da88602", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 684, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 684, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "999cc0471f786746c61cdb7daca5dfd0", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 696, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 696, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "23855bbdacbfbbae3ed9c15a7f94381c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 705, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 705, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "77ef8bdcca78634e307b34924311406b", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 716, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 716, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "430b4caaf1c9be1df34a838c4ecfe85d", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 727, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 727, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "70de3e369ae6da886c0c4a940eec077c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 739, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 739, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "1c145dee88bb7b8dcda825186da7a25b", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 749, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 749, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "a9d0768d1bfa647ab72b4ceb2cbcb7b5", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 759, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 759, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "3f91a8a3a392cb190b0ab9729d0d860e", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 768, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 768, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "0aac3c0f4abe01f5c96b3a821dbb5520", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 778, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 778, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "80c299a796009535de2903ddca99068d", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 787, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 787, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "9f29cf188cba43fa3f2c70137ab89885", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 794, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 794, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "f3e664434609b6b96fb0ad2d04e96529", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 802, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 802, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "51f7718cb9e7b58abc2b08e5b605289b", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 809, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 809, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "76bace5b361d2790d4d5c235d82c1158", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 817, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 817, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "c999a0fde9074903caeb908bde33fba0", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 824, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 824, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "85c01d96aa0a1f48efb961c5c8f89cc0", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 845, "column": 17, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 845, "column": 17}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "ec82fb74d6108e7a395d45be962ac7b5", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 852, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 852, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "a1f2901a47eec8d859e79c10b4f452a4", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 859, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 859, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "8d645bd7d2b0b8bf0033666e5ef644d7", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 867, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 867, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "928a0d2bfbad7e9199803f326381bd2f", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 887, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 887, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "5bdb5fe77f1b478c665e9d9c60f1a7c6", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 908, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 908, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "5966364d4c28446ae08c31688556f2de", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 920, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 920, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "4da6a19dc47cd952af60b6c480f70480", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 944, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 944, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "466a508d28acc705950d413c12a81cb3", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 952, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 952, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "91ed3f621546483063e7bfb63626e4fb", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 959, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 959, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "75346a88b5bc371959f5d36424945200", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 970, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 970, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "f08b998e7206001de784d14727725ef1", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 980, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 980, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "71c59bf58df9fa254d1e6b5d6218f1ab", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 988, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 988, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "0b8c4a8dc561f0ac51de8a3b3bd3db9a", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 995, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 995, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "5292f182ca60a03bd0f8e9b3ddcfd3f8", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1003, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1003, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "f3e57b4db9b5b48ef949284593bbe996", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1010, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1010, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "a3164e50ce09f2764e052c75430c7f56", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1021, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1021, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "4493eead90d0f7fc49f19fcd2cdcfe14", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1032, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1032, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "139aff6ed47e6c42e32f7147523f8abb", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1046, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1045, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1046, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "290bc91a53aaf582b8197ef434999824", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1053, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1052, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1053, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "98f4d3be3b49fcb7ccb931669edd3426", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1062, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1061, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1062, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "5ad496c87f1aff93200fa4a8eca72237", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1076, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1075, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1076, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "98a3399dab5678231e869c15af8f31f1", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1084, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1083, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1084, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "11efb39d7b1a48c496c6b744564d845a", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1160, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1160, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "b2d61e9336ef24cc8bd3089b3764de3c", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1171, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1171, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "b48f10b8ccab424e73be14a9c21558aa", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1182, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1181, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1182, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "8d21b5b0b492f8950492833b1873f2f8", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1202, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1202, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "e35038eee6dad5433bc554cfabb108a4", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1213, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1213, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "9a8898e529d2e643a7eb287da48eb1fc", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1221, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1220, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1221, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "e94cda049ce4b519e61fa531f9bfeb9b", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1247, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1246, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1247, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "606415135c6927426e293cb9c3ca3a20", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1256, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming the condition is true", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1255, "column": 13}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1256, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "506b7e248d77c52034d270e39cfa03ca", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1300, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1300, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "3feb5e8b01b68add5c1f53ef238e1ff4", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1308, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1308, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "76c7658792ecf0fd00220bc060bcc965", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1317, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1317, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "c5439632c04166dae34a4863f2217634", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1520, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::VerifyAdvancedSHEEnabled'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1219, "column": 9}, {"message": "Entered call from 'SchemeBase::EvalMerge'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1516, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1520, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "e6959785843513c9fc446b0fc904bd77", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1532, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::VerifyMultipartyEnabled'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1254, "column": 9}, {"message": "Entered call from 'SchemeBase::MultipartyDecryptFusion'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1528, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1532, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "037d7e5cbb5a2e775a4f3e46e6b40b8d", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1544, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::VerifyLeveledSHEEnabled'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1030, "column": 9}, {"message": "Entered call from 'SchemeBase::AdjustLevelsAndDepthToOneInPlace'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1540, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1544, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "eec7f68783ee90f657178293ed87d1c1", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1556, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::VerifyPKEEnabled'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 224, "column": 9}, {"message": "Entered call from 'SchemeBase::Decrypt'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1552, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1556, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "reportHash": "67160562a727516bb1183df549898981", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 1580, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Calling 'SchemeBase::VerifyKeySwitchEnabled'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 906, "column": 9}, {"message": "Entered call from 'SchemeBase::KeySwitchExt'", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1576, "column": 5}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemebase/base-scheme.h", "line": 1580, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-parametergeneration.h", "reportHash": "30d623285e00df149d7799b15d5df141", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 75, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-parametergeneration.h", "line": 75, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-parametergeneration.h", "reportHash": "e4f1ca46c94e339679ccc7f7f62212f0", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 93, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-parametergeneration.h", "line": 93, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-parametergeneration.h", "reportHash": "6cadaa2dae34f9b607a449b1d3fdc19d", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 114, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-parametergeneration.h", "line": 114, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-leveledshe.h", "reportHash": "05e4f0c2a555b01504a76ec9bac09f18", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 316, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-leveledshe.h", "line": 316, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-leveledshe.h", "reportHash": "ce14c5b6963da3093833f4a927104213", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 340, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-leveledshe.h", "line": 340, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "reportHash": "d132ed6a836949e6521bc9548e13fbdf", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 79, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "Assuming 'ksTech' is not equal to BV", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "line": 72, "column": 13}, {"message": "Assuming 'ksTech' is not equal to HYBRID", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "line": 75, "column": 18}, {"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/schemerns/rns-scheme.h", "line": 79, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/bgvrns/bgvrns-pke.h", "reportHash": "db1c9f2f6bb5fefdabdbe48aaebac9cd", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 80, "column": 9, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/include/scheme/bgvrns/bgvrns-pke.h", "line": 80, "column": 9}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}, {"fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/bgvrns/bgvrns-scheme.cpp", "reportHash": "4b3828e11be1d08f3440acf771a3eb73", "checker": {"name": "alpha.unix.OpenFHEThrow", "url": null}, "analyzerName": "clangsa", "line": 83, "column": 13, "message": "alpha.unix.OpenFHEThrow", "events": [{"message": "alpha.unix.OpenFHEThrow", "fileId": "/home/zero0000/static-analyze-openfhe/src/pke/lib/scheme/bgvrns/bgvrns-scheme.cpp", "line": 83, "column": 13}], "macros": [], "notes": [], "reviewStatus": "unreviewed", "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
